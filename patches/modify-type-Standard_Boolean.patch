Index: oce/inc/ChFi3d_Builder.hxx
===================================================================
--- oce.orig/inc/ChFi3d_Builder.hxx
+++ oce/inc/ChFi3d_Builder.hxx
@@ -234,7 +234,7 @@ Standard_EXPORT virtual ~ChFi3d_Builder(
 //!          chamfer). <br>
   Standard_EXPORT     Standard_Boolean SplitKPart(const Handle(ChFiDS_SurfData)& Data,ChFiDS_SequenceOfSurfData& SetData,const Handle(ChFiDS_Spine)& Spine,const Standard_Integer Iedge,const Handle(Adaptor3d_HSurface)& S1,const Handle(Adaptor3d_TopolTool)& I1,const Handle(Adaptor3d_HSurface)& S2,const Handle(Adaptor3d_TopolTool)& I2,Standard_Boolean& Intf,Standard_Boolean& Intl) ;
   
-  Standard_EXPORT     Standard_Integer PerformTwoCornerbyInter(const Standard_Integer Index) ;
+  Standard_EXPORT     Standard_Boolean PerformTwoCornerbyInter(const Standard_Integer Index) ;
 
 
 
@@ -247,7 +247,7 @@ protected:
   
   Standard_EXPORT   virtual  void SimulKPart(const Handle(ChFiDS_SurfData)& SD) const = 0;
   
-  Standard_EXPORT   virtual  Standard_Boolean SimulSurf(Handle(ChFiDS_SurfData)& Data,const Handle(ChFiDS_HElSpine)& Guide,const Handle(ChFiDS_Spine)& Spine,const Standard_Integer Choix,const Handle(BRepAdaptor_HSurface)& S1,const Handle(Adaptor3d_TopolTool)& I1,const Handle(BRepAdaptor_HSurface)& S2,const Handle(Adaptor3d_TopolTool)& I2,const Standard_Real TolGuide,Standard_Real& First,Standard_Real& Last,const Standard_Boolean Inside,const Standard_Boolean Appro,const Standard_Boolean Forward,const Standard_Boolean RecOnS1,const Standard_Boolean RecOnS2,const math_Vector& Soldep,Standard_Boolean& Intf,Standard_Boolean& Intl)  = 0;
+  Standard_EXPORT   virtual  Standard_Boolean SimulSurf(Handle(ChFiDS_SurfData)& Data,const Handle(ChFiDS_HElSpine)& Guide,const Handle(ChFiDS_Spine)& Spine,const Standard_Integer Choix,const Handle(BRepAdaptor_HSurface)& S1,const Handle(Adaptor3d_TopolTool)& I1,const Handle(BRepAdaptor_HSurface)& S2,const Handle(Adaptor3d_TopolTool)& I2,const Standard_Real TolGuide,Standard_Real& First,Standard_Real& Last,const Standard_Boolean Inside,const Standard_Boolean Appro,const Standard_Boolean Forward,const Standard_Boolean RecOnS1,const Standard_Boolean RecOnS2,const math_Vector& Soldep,Standard_Integer& Intf,Standard_Integer& Intl)  = 0;
   
   Standard_EXPORT   virtual  void SimulSurf(Handle(ChFiDS_SurfData)& Data,const Handle(ChFiDS_HElSpine)& Guide,const Handle(ChFiDS_Spine)& Spine,const Standard_Integer Choix,const Handle(BRepAdaptor_HSurface)& S1,const Handle(Adaptor3d_TopolTool)& I1,const Handle(BRepAdaptor_HCurve2d)& PC1,const Handle(BRepAdaptor_HSurface)& Sref1,const Handle(BRepAdaptor_HCurve2d)& PCref1,Standard_Boolean& Decroch1,const Handle(BRepAdaptor_HSurface)& S2,const Handle(Adaptor3d_TopolTool)& I2,const TopAbs_Orientation Or2,const Standard_Real Fleche,const Standard_Real TolGuide,Standard_Real& First,Standard_Real& Last,const Standard_Boolean Inside,const Standard_Boolean Appro,const Standard_Boolean Forward,const Standard_Boolean RecP,const Standard_Boolean RecS,const Standard_Boolean RecRst,const math_Vector& Soldep) ;
   
@@ -275,11 +275,11 @@ protected:
   
   Standard_EXPORT     void Trunc(const Handle(ChFiDS_SurfData)& SD,const Handle(ChFiDS_Spine)& Spine,const Handle(Adaptor3d_HSurface)& S1,const Handle(Adaptor3d_HSurface)& S2,const Standard_Integer iedge,const Standard_Boolean isfirst,const Standard_Integer cntlFiOnS) ;
   
-  Standard_EXPORT     void CallPerformSurf(Handle(ChFiDS_Stripe)& Stripe,const Standard_Boolean Simul,ChFiDS_SequenceOfSurfData& SeqSD,Handle(ChFiDS_SurfData)& SD,const Handle(ChFiDS_HElSpine)& Guide,const Handle(ChFiDS_Spine)& Spine,const Handle(BRepAdaptor_HSurface)& HS1,const Handle(BRepAdaptor_HSurface)& HS3,const gp_Pnt2d& P1,const gp_Pnt2d& P3,Handle(Adaptor3d_TopolTool)& I1,const Handle(BRepAdaptor_HSurface)& HS2,const Handle(BRepAdaptor_HSurface)& HS4,const gp_Pnt2d& P2,const gp_Pnt2d& P4,Handle(Adaptor3d_TopolTool)& I2,const Standard_Real MaxStep,const Standard_Real Fleche,const Standard_Real TolGuide,Standard_Real& First,Standard_Real& Last,const Standard_Boolean Inside,const Standard_Boolean Appro,const Standard_Boolean Forward,const Standard_Boolean RecOnS1,const Standard_Boolean RecOnS2,math_Vector& Soldep,Standard_Boolean& Intf,Standard_Boolean& Intl,Handle(BRepAdaptor_HSurface)& Surf1,Handle(BRepAdaptor_HSurface)& Surf2) ;
+  Standard_EXPORT     void CallPerformSurf(Handle(ChFiDS_Stripe)& Stripe,const Standard_Boolean Simul,ChFiDS_SequenceOfSurfData& SeqSD,Handle(ChFiDS_SurfData)& SD,const Handle(ChFiDS_HElSpine)& Guide,const Handle(ChFiDS_Spine)& Spine,const Handle(BRepAdaptor_HSurface)& HS1,const Handle(BRepAdaptor_HSurface)& HS3,const gp_Pnt2d& P1,const gp_Pnt2d& P3,Handle(Adaptor3d_TopolTool)& I1,const Handle(BRepAdaptor_HSurface)& HS2,const Handle(BRepAdaptor_HSurface)& HS4,const gp_Pnt2d& P2,const gp_Pnt2d& P4,Handle(Adaptor3d_TopolTool)& I2,const Standard_Real MaxStep,const Standard_Real Fleche,const Standard_Real TolGuide,Standard_Real& First,Standard_Real& Last,const Standard_Boolean Inside,const Standard_Boolean Appro,const Standard_Boolean Forward,const Standard_Boolean RecOnS1,const Standard_Boolean RecOnS2,math_Vector& Soldep,Standard_Integer& Intf,Standard_Integer& Intl,Handle(BRepAdaptor_HSurface)& Surf1,Handle(BRepAdaptor_HSurface)& Surf2) ;
   //! Method, implemented in the inheritants, calculating <br>
 //!          elements of construction of the surface (fillet or <br>
 //!          chamfer). <br>
-  Standard_EXPORT   virtual  Standard_Boolean PerformSurf(ChFiDS_SequenceOfSurfData& Data,const Handle(ChFiDS_HElSpine)& Guide,const Handle(ChFiDS_Spine)& Spine,const Standard_Integer Choix,const Handle(BRepAdaptor_HSurface)& S1,const Handle(Adaptor3d_TopolTool)& I1,const Handle(BRepAdaptor_HSurface)& S2,const Handle(Adaptor3d_TopolTool)& I2,const Standard_Real MaxStep,const Standard_Real Fleche,const Standard_Real TolGuide,Standard_Real& First,Standard_Real& Last,const Standard_Boolean Inside,const Standard_Boolean Appro,const Standard_Boolean Forward,const Standard_Boolean RecOnS1,const Standard_Boolean RecOnS2,const math_Vector& Soldep,Standard_Boolean& Intf,Standard_Boolean& Intl)  = 0;
+  Standard_EXPORT   virtual  Standard_Boolean PerformSurf(ChFiDS_SequenceOfSurfData& Data,const Handle(ChFiDS_HElSpine)& Guide,const Handle(ChFiDS_Spine)& Spine,const Standard_Integer Choix,const Handle(BRepAdaptor_HSurface)& S1,const Handle(Adaptor3d_TopolTool)& I1,const Handle(BRepAdaptor_HSurface)& S2,const Handle(Adaptor3d_TopolTool)& I2,const Standard_Real MaxStep,const Standard_Real Fleche,const Standard_Real TolGuide,Standard_Real& First,Standard_Real& Last,const Standard_Boolean Inside,const Standard_Boolean Appro,const Standard_Boolean Forward,const Standard_Boolean RecOnS1,const Standard_Boolean RecOnS2,const math_Vector& Soldep,Standard_Integer& Intf,Standard_Integer& Intl)  = 0;
   //! Method, implemented  in inheritants, calculates <br>
 //!          the elements of construction of  the surface (fillet <br>
 //!          or chamfer) contact edge/face. <br>
@@ -311,7 +311,7 @@ protected:
   
   Standard_EXPORT     Standard_Boolean StripeOrientations(const Handle(ChFiDS_Spine)& Sp,TopAbs_Orientation& Or1,TopAbs_Orientation& Or2,Standard_Integer& ChoixConge) const;
   //! Calculates  a Line of contact face/face. <br>
-  Standard_EXPORT     Standard_Boolean ComputeData(Handle(ChFiDS_SurfData)& Data,const Handle(ChFiDS_HElSpine)& Guide,const Handle(ChFiDS_Spine)& Spine,Handle(BRepBlend_Line)& Lin,const Handle(Adaptor3d_HSurface)& S1,const Handle(Adaptor3d_TopolTool)& I1,const Handle(Adaptor3d_HSurface)& S2,const Handle(Adaptor3d_TopolTool)& I2,Blend_Function& Func,Blend_FuncInv& FInv,const Standard_Real PFirst,const Standard_Real MaxStep,const Standard_Real Fleche,const Standard_Real TolGuide,Standard_Real& First,Standard_Real& Last,const Standard_Boolean Inside,const Standard_Boolean Appro,const Standard_Boolean Forward,const math_Vector& Soldep,Standard_Boolean& Intf,Standard_Boolean& Intl,Standard_Boolean& Gd1,Standard_Boolean& Gd2,Standard_Boolean& Gf1,Standard_Boolean& Gf2,const Standard_Boolean RecOnS1 = Standard_False,const Standard_Boolean RecOnS2 = Standard_False) ;
+  Standard_EXPORT     Standard_Boolean ComputeData(Handle(ChFiDS_SurfData)& Data,const Handle(ChFiDS_HElSpine)& Guide,const Handle(ChFiDS_Spine)& Spine,Handle(BRepBlend_Line)& Lin,const Handle(Adaptor3d_HSurface)& S1,const Handle(Adaptor3d_TopolTool)& I1,const Handle(Adaptor3d_HSurface)& S2,const Handle(Adaptor3d_TopolTool)& I2,Blend_Function& Func,Blend_FuncInv& FInv,const Standard_Real PFirst,const Standard_Real MaxStep,const Standard_Real Fleche,const Standard_Real TolGuide,Standard_Real& First,Standard_Real& Last,const Standard_Boolean Inside,const Standard_Boolean Appro,const Standard_Boolean Forward,const math_Vector& Soldep,Standard_Integer& Intf,Standard_Integer& Intl,Standard_Boolean& Gd1,Standard_Boolean& Gd2,Standard_Boolean& Gf1,Standard_Boolean& Gf2,const Standard_Boolean RecOnS1 = Standard_False,const Standard_Boolean RecOnS2 = Standard_False) ;
   //! Calculates a Line of contact edge/face. <br>
   Standard_EXPORT     Standard_Boolean ComputeData(Handle(ChFiDS_SurfData)& Data,const Handle(ChFiDS_HElSpine)& HGuide,Handle(BRepBlend_Line)& Lin,const Handle(Adaptor3d_HSurface)& S1,const Handle(Adaptor3d_TopolTool)& I1,const Handle(Adaptor3d_HSurface)& S2,const Handle(Adaptor2d_HCurve2d)& PC2,const Handle(Adaptor3d_TopolTool)& I2,Standard_Boolean& Decroch,Blend_SurfRstFunction& Func,Blend_FuncInv& FInv,Blend_SurfPointFuncInv& FInvP,Blend_SurfCurvFuncInv& FInvC,const Standard_Real PFirst,const Standard_Real MaxStep,const Standard_Real Fleche,const Standard_Real TolGuide,Standard_Real& First,Standard_Real& Last,const math_Vector& Soldep,const Standard_Boolean Inside,const Standard_Boolean Appro,const Standard_Boolean Forward,const Standard_Boolean RecP,const Standard_Boolean RecS,const Standard_Boolean RecRst) ;
   //! Calculates a Line of contact edge/edge. <br>
Index: oce/inc/ChFi3d_ChBuilder.hxx
===================================================================
--- oce.orig/inc/ChFi3d_ChBuilder.hxx
+++ oce/inc/ChFi3d_ChBuilder.hxx
@@ -148,7 +148,7 @@ public:
   //! Methode, implemented in inheritants, calculates <br>
 //!          the elements of construction of  the surface (fillet <br>
 //!          or chamfer). <br>
-  Standard_EXPORT   virtual  Standard_Boolean PerformSurf(ChFiDS_SequenceOfSurfData& Data,const Handle(ChFiDS_HElSpine)& Guide,const Handle(ChFiDS_Spine)& Spine,const Standard_Integer Choix,const Handle(BRepAdaptor_HSurface)& S1,const Handle(Adaptor3d_TopolTool)& I1,const Handle(BRepAdaptor_HSurface)& S2,const Handle(Adaptor3d_TopolTool)& I2,const Standard_Real MaxStep,const Standard_Real Fleche,const Standard_Real TolGuide,Standard_Real& First,Standard_Real& Last,const Standard_Boolean Inside,const Standard_Boolean Appro,const Standard_Boolean Forward,const Standard_Boolean RecOnS1,const Standard_Boolean RecOnS2,const math_Vector& Soldep,Standard_Boolean& Intf,Standard_Boolean& Intl) ;
+  Standard_EXPORT   virtual  Standard_Boolean PerformSurf(ChFiDS_SequenceOfSurfData& Data,const Handle(ChFiDS_HElSpine)& Guide,const Handle(ChFiDS_Spine)& Spine,const Standard_Integer Choix,const Handle(BRepAdaptor_HSurface)& S1,const Handle(Adaptor3d_TopolTool)& I1,const Handle(BRepAdaptor_HSurface)& S2,const Handle(Adaptor3d_TopolTool)& I2,const Standard_Real MaxStep,const Standard_Real Fleche,const Standard_Real TolGuide,Standard_Real& First,Standard_Real& Last,const Standard_Boolean Inside,const Standard_Boolean Appro,const Standard_Boolean Forward,const Standard_Boolean RecOnS1,const Standard_Boolean RecOnS2,const math_Vector& Soldep,Standard_Integer& Intf,Standard_Integer& Intl) ;
   //! Method, implemented in  the inheritants, calculates <br>
 //!          the elements of construction of  the surface (fillet <br>
 //!          or chamfer) contact edge/face. <br>
@@ -173,7 +173,7 @@ protected:
   
   Standard_EXPORT     void SimulKPart(const Handle(ChFiDS_SurfData)& SD) const;
   
-  Standard_EXPORT     Standard_Boolean SimulSurf(Handle(ChFiDS_SurfData)& Data,const Handle(ChFiDS_HElSpine)& Guide,const Handle(ChFiDS_Spine)& Spine,const Standard_Integer Choix,const Handle(BRepAdaptor_HSurface)& S1,const Handle(Adaptor3d_TopolTool)& I1,const Handle(BRepAdaptor_HSurface)& S2,const Handle(Adaptor3d_TopolTool)& I2,const Standard_Real TolGuide,Standard_Real& First,Standard_Real& Last,const Standard_Boolean Inside,const Standard_Boolean Appro,const Standard_Boolean Forward,const Standard_Boolean RecOnS1,const Standard_Boolean RecOnS2,const math_Vector& Soldep,Standard_Boolean& Intf,Standard_Boolean& Intl) ;
+  Standard_EXPORT     Standard_Boolean SimulSurf(Handle(ChFiDS_SurfData)& Data,const Handle(ChFiDS_HElSpine)& Guide,const Handle(ChFiDS_Spine)& Spine,const Standard_Integer Choix,const Handle(BRepAdaptor_HSurface)& S1,const Handle(Adaptor3d_TopolTool)& I1,const Handle(BRepAdaptor_HSurface)& S2,const Handle(Adaptor3d_TopolTool)& I2,const Standard_Real TolGuide,Standard_Real& First,Standard_Real& Last,const Standard_Boolean Inside,const Standard_Boolean Appro,const Standard_Boolean Forward,const Standard_Boolean RecOnS1,const Standard_Boolean RecOnS2,const math_Vector& Soldep,Standard_Integer& Intf,Standard_Integer& Intl) ;
   
   Standard_EXPORT     Standard_Boolean PerformFirstSection(const Handle(ChFiDS_Spine)& S,const Handle(ChFiDS_HElSpine)& HGuide,const Standard_Integer Choix,Handle(BRepAdaptor_HSurface)& S1,Handle(BRepAdaptor_HSurface)& S2,const Handle(Adaptor3d_TopolTool)& I1,const Handle(Adaptor3d_TopolTool)& I2,const Standard_Real Par,math_Vector& SolDep,TopAbs_State& Pos1,TopAbs_State& Pos2) const;
   //! computes  the  intersection of two chamfers on <br>
Index: oce/inc/ChFi3d_FilBuilder.hxx
===================================================================
--- oce.orig/inc/ChFi3d_FilBuilder.hxx
+++ oce/inc/ChFi3d_FilBuilder.hxx
@@ -163,7 +163,7 @@ protected:
   
   Standard_EXPORT     void SimulKPart(const Handle(ChFiDS_SurfData)& SD) const;
   
-  Standard_EXPORT     Standard_Boolean SimulSurf(Handle(ChFiDS_SurfData)& Data,const Handle(ChFiDS_HElSpine)& Guide,const Handle(ChFiDS_Spine)& Spine,const Standard_Integer Choix,const Handle(BRepAdaptor_HSurface)& S1,const Handle(Adaptor3d_TopolTool)& I1,const Handle(BRepAdaptor_HSurface)& S2,const Handle(Adaptor3d_TopolTool)& I2,const Standard_Real TolGuide,Standard_Real& First,Standard_Real& Last,const Standard_Boolean Inside,const Standard_Boolean Appro,const Standard_Boolean Forward,const Standard_Boolean RecOnS1,const Standard_Boolean RecOnS2,const math_Vector& Soldep,Standard_Boolean& Intf,Standard_Boolean& Intl) ;
+  Standard_EXPORT     Standard_Boolean SimulSurf(Handle(ChFiDS_SurfData)& Data,const Handle(ChFiDS_HElSpine)& Guide,const Handle(ChFiDS_Spine)& Spine,const Standard_Integer Choix,const Handle(BRepAdaptor_HSurface)& S1,const Handle(Adaptor3d_TopolTool)& I1,const Handle(BRepAdaptor_HSurface)& S2,const Handle(Adaptor3d_TopolTool)& I2,const Standard_Real TolGuide,Standard_Real& First,Standard_Real& Last,const Standard_Boolean Inside,const Standard_Boolean Appro,const Standard_Boolean Forward,const Standard_Boolean RecOnS1,const Standard_Boolean RecOnS2,const math_Vector& Soldep,Standard_Integer& Intf,Standard_Integer& Intl) ;
   
   Standard_EXPORT   virtual  void SimulSurf(Handle(ChFiDS_SurfData)& Data,const Handle(ChFiDS_HElSpine)& Guide,const Handle(ChFiDS_Spine)& Spine,const Standard_Integer Choix,const Handle(BRepAdaptor_HSurface)& S1,const Handle(Adaptor3d_TopolTool)& I1,const Handle(BRepAdaptor_HCurve2d)& PC1,const Handle(BRepAdaptor_HSurface)& Sref1,const Handle(BRepAdaptor_HCurve2d)& PCref1,Standard_Boolean& Decroch1,const Handle(BRepAdaptor_HSurface)& S2,const Handle(Adaptor3d_TopolTool)& I2,const TopAbs_Orientation Or2,const Standard_Real Fleche,const Standard_Real TolGuide,Standard_Real& First,Standard_Real& Last,const Standard_Boolean Inside,const Standard_Boolean Appro,const Standard_Boolean Forward,const Standard_Boolean RecP,const Standard_Boolean RecS,const Standard_Boolean RecRst,const math_Vector& Soldep) ;
   
@@ -174,7 +174,7 @@ protected:
   Standard_EXPORT     Standard_Boolean PerformFirstSection(const Handle(ChFiDS_Spine)& S,const Handle(ChFiDS_HElSpine)& HGuide,const Standard_Integer Choix,Handle(BRepAdaptor_HSurface)& S1,Handle(BRepAdaptor_HSurface)& S2,const Handle(Adaptor3d_TopolTool)& I1,const Handle(Adaptor3d_TopolTool)& I2,const Standard_Real Par,math_Vector& SolDep,TopAbs_State& Pos1,TopAbs_State& Pos2) const;
   //! Method calculates the elements of construction of  the <br>
 //!          fillet (constant or evolutive). <br>
-  Standard_EXPORT     Standard_Boolean PerformSurf(ChFiDS_SequenceOfSurfData& SeqData,const Handle(ChFiDS_HElSpine)& Guide,const Handle(ChFiDS_Spine)& Spine,const Standard_Integer Choix,const Handle(BRepAdaptor_HSurface)& S1,const Handle(Adaptor3d_TopolTool)& I1,const Handle(BRepAdaptor_HSurface)& S2,const Handle(Adaptor3d_TopolTool)& I2,const Standard_Real MaxStep,const Standard_Real Fleche,const Standard_Real TolGuide,Standard_Real& First,Standard_Real& Last,const Standard_Boolean Inside,const Standard_Boolean Appro,const Standard_Boolean Forward,const Standard_Boolean RecOnS1,const Standard_Boolean RecOnS2,const math_Vector& Soldep,Standard_Boolean& Intf,Standard_Boolean& Intl) ;
+  Standard_EXPORT     Standard_Boolean PerformSurf(ChFiDS_SequenceOfSurfData& SeqData,const Handle(ChFiDS_HElSpine)& Guide,const Handle(ChFiDS_Spine)& Spine,const Standard_Integer Choix,const Handle(BRepAdaptor_HSurface)& S1,const Handle(Adaptor3d_TopolTool)& I1,const Handle(BRepAdaptor_HSurface)& S2,const Handle(Adaptor3d_TopolTool)& I2,const Standard_Real MaxStep,const Standard_Real Fleche,const Standard_Real TolGuide,Standard_Real& First,Standard_Real& Last,const Standard_Boolean Inside,const Standard_Boolean Appro,const Standard_Boolean Forward,const Standard_Boolean RecOnS1,const Standard_Boolean RecOnS2,const math_Vector& Soldep,Standard_Integer& Intf,Standard_Integer& Intl) ;
   
   Standard_EXPORT   virtual  void PerformSurf(ChFiDS_SequenceOfSurfData& SeqData,const Handle(ChFiDS_HElSpine)& Guide,const Handle(ChFiDS_Spine)& Spine,const Standard_Integer Choix,const Handle(BRepAdaptor_HSurface)& S1,const Handle(Adaptor3d_TopolTool)& I1,const Handle(BRepAdaptor_HCurve2d)& PC1,const Handle(BRepAdaptor_HSurface)& Sref1,const Handle(BRepAdaptor_HCurve2d)& PCref1,Standard_Boolean& Decroch1,const Handle(BRepAdaptor_HSurface)& S2,const Handle(Adaptor3d_TopolTool)& I2,const TopAbs_Orientation Or2,const Standard_Real MaxStep,const Standard_Real Fleche,const Standard_Real TolGuide,Standard_Real& First,Standard_Real& Last,const Standard_Boolean Inside,const Standard_Boolean Appro,const Standard_Boolean Forward,const Standard_Boolean RecP,const Standard_Boolean RecS,const Standard_Boolean RecRst,const math_Vector& Soldep) ;
   
Index: oce/inc/FilletSurf_InternalBuilder.hxx
===================================================================
--- oce.orig/inc/FilletSurf_InternalBuilder.hxx
+++ oce/inc/FilletSurf_InternalBuilder.hxx
@@ -154,7 +154,7 @@ protected:
   //! This  method calculates the elements of construction of the <br>
 //!          fillet (constant or evolutive). <br>
 //! <br>
-  Standard_EXPORT   virtual  Standard_Boolean PerformSurf(ChFiDS_SequenceOfSurfData& SeqData,const Handle(ChFiDS_HElSpine)& Guide,const Handle(ChFiDS_Spine)& Spine,const Standard_Integer Choix,const Handle(BRepAdaptor_HSurface)& S1,const Handle(Adaptor3d_TopolTool)& I1,const Handle(BRepAdaptor_HSurface)& S2,const Handle(Adaptor3d_TopolTool)& I2,const Standard_Real MaxStep,const Standard_Real Fleche,const Standard_Real TolGuide,Standard_Real& First,Standard_Real& Last,const Standard_Boolean Inside,const Standard_Boolean Appro,const Standard_Boolean Forward,const Standard_Boolean RecOnS1,const Standard_Boolean RecOnS2,const math_Vector& Soldep,Standard_Boolean& Intf,Standard_Boolean& Intl) ;
+  Standard_EXPORT   virtual  Standard_Boolean PerformSurf(ChFiDS_SequenceOfSurfData& SeqData,const Handle(ChFiDS_HElSpine)& Guide,const Handle(ChFiDS_Spine)& Spine,const Standard_Integer Choix,const Handle(BRepAdaptor_HSurface)& S1,const Handle(Adaptor3d_TopolTool)& I1,const Handle(BRepAdaptor_HSurface)& S2,const Handle(Adaptor3d_TopolTool)& I2,const Standard_Real MaxStep,const Standard_Real Fleche,const Standard_Real TolGuide,Standard_Real& First,Standard_Real& Last,const Standard_Boolean Inside,const Standard_Boolean Appro,const Standard_Boolean Forward,const Standard_Boolean RecOnS1,const Standard_Boolean RecOnS2,const math_Vector& Soldep,Standard_Integer& Intf,Standard_Integer& Intl) ;
   
   Standard_EXPORT   virtual  void PerformSurf(ChFiDS_SequenceOfSurfData& SeqData,const Handle(ChFiDS_HElSpine)& Guide,const Handle(ChFiDS_Spine)& Spine,const Standard_Integer Choix,const Handle(BRepAdaptor_HSurface)& S1,const Handle(Adaptor3d_TopolTool)& I1,const Handle(BRepAdaptor_HCurve2d)& PC1,const Handle(BRepAdaptor_HSurface)& Sref1,const Handle(BRepAdaptor_HCurve2d)& PCref1,Standard_Boolean& Decroch1,const Handle(BRepAdaptor_HSurface)& S2,const Handle(Adaptor3d_TopolTool)& I2,const TopAbs_Orientation Or2,const Standard_Real MaxStep,const Standard_Real Fleche,const Standard_Real TolGuide,Standard_Real& First,Standard_Real& Last,const Standard_Boolean Inside,const Standard_Boolean Appro,const Standard_Boolean Forward,const Standard_Boolean RecP,const Standard_Boolean RecS,const Standard_Boolean RecRst,const math_Vector& Soldep) ;
   
Index: oce/inc/HLRAlgo_BiPoint.hxx
===================================================================
--- oce.orig/inc/HLRAlgo_BiPoint.hxx
+++ oce/inc/HLRAlgo_BiPoint.hxx
@@ -41,15 +41,15 @@ public:
   
   Standard_EXPORT   HLRAlgo_BiPoint(const Standard_Real X1,const Standard_Real Y1,const Standard_Real Z1,const Standard_Real X2,const Standard_Real Y2,const Standard_Real Z2,const Standard_Real XT1,const Standard_Real YT1,const Standard_Real ZT1,const Standard_Real XT2,const Standard_Real YT2,const Standard_Real ZT2,const Standard_Integer Index,const Standard_Boolean reg1,const Standard_Boolean regn,const Standard_Boolean outl,const Standard_Boolean intl);
   
-  Standard_EXPORT   HLRAlgo_BiPoint(const Standard_Real X1,const Standard_Real Y1,const Standard_Real Z1,const Standard_Real X2,const Standard_Real Y2,const Standard_Real Z2,const Standard_Real XT1,const Standard_Real YT1,const Standard_Real ZT1,const Standard_Real XT2,const Standard_Real YT2,const Standard_Real ZT2,const Standard_Integer Index,const Standard_Boolean flag);
+  Standard_EXPORT   HLRAlgo_BiPoint(const Standard_Real X1,const Standard_Real Y1,const Standard_Real Z1,const Standard_Real X2,const Standard_Real Y2,const Standard_Real Z2,const Standard_Real XT1,const Standard_Real YT1,const Standard_Real ZT1,const Standard_Real XT2,const Standard_Real YT2,const Standard_Real ZT2,const Standard_Integer Index,const Standard_Integer flag);
   
   Standard_EXPORT   HLRAlgo_BiPoint(const Standard_Real X1,const Standard_Real Y1,const Standard_Real Z1,const Standard_Real X2,const Standard_Real Y2,const Standard_Real Z2,const Standard_Real XT1,const Standard_Real YT1,const Standard_Real ZT1,const Standard_Real XT2,const Standard_Real YT2,const Standard_Real ZT2,const Standard_Integer Index,const Standard_Integer i1,const Standard_Integer i1p1,const Standard_Integer i1p2,const Standard_Boolean reg1,const Standard_Boolean regn,const Standard_Boolean outl,const Standard_Boolean intl);
   
-  Standard_EXPORT   HLRAlgo_BiPoint(const Standard_Real X1,const Standard_Real Y1,const Standard_Real Z1,const Standard_Real X2,const Standard_Real Y2,const Standard_Real Z2,const Standard_Real XT1,const Standard_Real YT1,const Standard_Real ZT1,const Standard_Real XT2,const Standard_Real YT2,const Standard_Real ZT2,const Standard_Integer Index,const Standard_Integer i1,const Standard_Integer i1p1,const Standard_Integer i1p2,const Standard_Boolean flag);
+  Standard_EXPORT   HLRAlgo_BiPoint(const Standard_Real X1,const Standard_Real Y1,const Standard_Real Z1,const Standard_Real X2,const Standard_Real Y2,const Standard_Real Z2,const Standard_Real XT1,const Standard_Real YT1,const Standard_Real ZT1,const Standard_Real XT2,const Standard_Real YT2,const Standard_Real ZT2,const Standard_Integer Index,const Standard_Integer i1,const Standard_Integer i1p1,const Standard_Integer i1p2,const Standard_Integer flag);
   
   Standard_EXPORT   HLRAlgo_BiPoint(const Standard_Real X1,const Standard_Real Y1,const Standard_Real Z1,const Standard_Real X2,const Standard_Real Y2,const Standard_Real Z2,const Standard_Real XT1,const Standard_Real YT1,const Standard_Real ZT1,const Standard_Real XT2,const Standard_Real YT2,const Standard_Real ZT2,const Standard_Integer Index,const Standard_Integer i1,const Standard_Integer i1p1,const Standard_Integer i1p2,const Standard_Integer i2,const Standard_Integer i2p1,const Standard_Integer i2p2,const Standard_Boolean reg1,const Standard_Boolean regn,const Standard_Boolean outl,const Standard_Boolean intl);
   
-  Standard_EXPORT   HLRAlgo_BiPoint(const Standard_Real X1,const Standard_Real Y1,const Standard_Real Z1,const Standard_Real X2,const Standard_Real Y2,const Standard_Real Z2,const Standard_Real XT1,const Standard_Real YT1,const Standard_Real ZT1,const Standard_Real XT2,const Standard_Real YT2,const Standard_Real ZT2,const Standard_Integer Index,const Standard_Integer i1,const Standard_Integer i1p1,const Standard_Integer i1p2,const Standard_Integer i2,const Standard_Integer i2p1,const Standard_Integer i2p2,const Standard_Boolean flag);
+  Standard_EXPORT   HLRAlgo_BiPoint(const Standard_Real X1,const Standard_Real Y1,const Standard_Real Z1,const Standard_Real X2,const Standard_Real Y2,const Standard_Real Z2,const Standard_Real XT1,const Standard_Real YT1,const Standard_Real ZT1,const Standard_Real XT2,const Standard_Real YT2,const Standard_Real ZT2,const Standard_Integer Index,const Standard_Integer i1,const Standard_Integer i1p1,const Standard_Integer i1p2,const Standard_Integer i2,const Standard_Integer i2p1,const Standard_Integer i2p2,const Standard_Integer flag);
   
         Standard_Boolean Rg1Line() const;
   
Index: oce/inc/HLRAlgo_EdgeStatus.hxx
===================================================================
--- oce.orig/inc/HLRAlgo_EdgeStatus.hxx
+++ oce/inc/HLRAlgo_EdgeStatus.hxx
@@ -103,7 +103,7 @@ Standard_Real myStart;
 Standard_Real myEnd;
 Standard_ShortReal myTolStart;
 Standard_ShortReal myTolEnd;
-Standard_Boolean myFlags;
+Standard_Integer myFlags;
 Intrv_Intervals myVisibles;
 
 
Index: oce/inc/HLRAlgo_EdgesBlock.hxx
===================================================================
--- oce.orig/inc/HLRAlgo_EdgesBlock.hxx
+++ oce/inc/HLRAlgo_EdgesBlock.hxx
@@ -102,7 +102,7 @@ private:
 
 
 TColStd_Array1OfInteger myEdges;
-TColStd_Array1OfBoolean myFlags;
+TColStd_Array1OfInteger myFlags;
 Standard_Integer myMinMax[16];
 
 
Index: oce/inc/HLRAlgo_PolyData.hxx
===================================================================
--- oce.orig/inc/HLRAlgo_PolyData.hxx
+++ oce/inc/HLRAlgo_PolyData.hxx
@@ -91,7 +91,7 @@ protected:
 private: 
 
   //! evident. <br>
-  Standard_EXPORT     void HideByOneTriangle(const Standard_Address Coordinates,const Standard_Address RealPtr,const Standard_Address BooleanPtr,const Standard_Address PlanPtr,HLRAlgo_EdgeStatus& status) ;
+  Standard_EXPORT     void HideByOneTriangle(const Standard_Address Coordinates,const Standard_Address RealPtr,const Standard_Boolean Crossing,const Standard_Boolean HideBefore,const Standard_Integer TrFlags,HLRAlgo_EdgeStatus& status) ;
 
 Standard_Integer myIndices[3];
 Handle_TColgp_HArray1OfXYZ myHNodes;
Index: oce/inc/HLRBRep_BiPnt2D.hxx
===================================================================
--- oce.orig/inc/HLRBRep_BiPnt2D.hxx
+++ oce/inc/HLRBRep_BiPnt2D.hxx
@@ -84,7 +84,7 @@ private:
 gp_Pnt2d myP1;
 gp_Pnt2d myP2;
 TopoDS_Shape myShape;
-Standard_Boolean myFlags;
+Standard_Integer myFlags;
 
 
 };
Index: oce/inc/HLRBRep_BiPoint.hxx
===================================================================
--- oce.orig/inc/HLRBRep_BiPoint.hxx
+++ oce/inc/HLRBRep_BiPoint.hxx
@@ -84,7 +84,7 @@ private:
 gp_Pnt myP1;
 gp_Pnt myP2;
 TopoDS_Shape myShape;
-Standard_Boolean myFlags;
+Standard_Integer myFlags;
 
 
 };
Index: oce/inc/HLRBRep_EdgeData.hxx
===================================================================
--- oce.orig/inc/HLRBRep_EdgeData.hxx
+++ oce/inc/HLRBRep_EdgeData.hxx
@@ -145,7 +145,7 @@ private:
 
 
 
-Standard_Boolean myFlags;
+Standard_Integer myFlags;
 Standard_Integer myHideCount;
 Standard_Integer myVSta;
 Standard_Integer myVEnd;
Index: oce/inc/HLRBRep_FaceData.hxx
===================================================================
--- oce.orig/inc/HLRBRep_FaceData.hxx
+++ oce/inc/HLRBRep_FaceData.hxx
@@ -141,7 +141,7 @@ private:
 
 
 
-Standard_Boolean myFlags;
+Standard_Integer myFlags;
 Handle_HLRAlgo_WiresBlock myWires;
 HLRBRep_Surface myGeometry;
 Standard_Real mySize;
Index: oce/inc/HLRBRep_PolyAlgo.hxx
===================================================================
--- oce.orig/inc/HLRBRep_PolyAlgo.hxx
+++ oce/inc/HLRBRep_PolyAlgo.hxx
@@ -232,11 +232,11 @@ private:
   
   Standard_EXPORT     Standard_Boolean Interpolation(const Standard_Real U1,const Standard_Real U2,const Standard_Address Nod1RValues,const Standard_Address Nod2RValues,Standard_Real& X3,Standard_Real& Y3,Standard_Real& Z3,Standard_Real& XT3,Standard_Real& YT3,Standard_Real& ZT3,Standard_Real& coef3,Standard_Real& U3,Standard_Boolean& mP3P1) const;
   
-  Standard_EXPORT     void MoveOrInsertPoint(HLRAlgo_ListOfBPoint& List,Standard_Real& X1,Standard_Real& Y1,Standard_Real& Z1,Standard_Real& X2,Standard_Real& Y2,Standard_Real& Z2,Standard_Real& XTI1,Standard_Real& YTI1,Standard_Real& ZTI1,Standard_Real& XTI2,Standard_Real& YTI2,Standard_Real& ZTI2,const Standard_Integer e,Standard_Real& U1,Standard_Real& U2,Standard_Address& Nod11Indices,Standard_Address& Nod11RValues,Standard_Address& Nod12Indices,Standard_Address& Nod12RValues,const Standard_Integer i1p1,const Standard_Integer i1p2,const Standard_Integer i1,const Handle(HLRAlgo_PolyInternalData)& pid1,Standard_Address& TData1,Standard_Address& PISeg1,Standard_Address& PINod1,const Standard_Real X3,const Standard_Real Y3,const Standard_Real Z3,const Standard_Real XT3,const Standard_Real YT3,const Standard_Real ZT3,const Standard_Real coef3,const Standard_Real U3,const Standard_Boolean insP3,const Standard_Boolean mP3P1,const Standard_Boolean flag) const;
+  Standard_EXPORT     void MoveOrInsertPoint(HLRAlgo_ListOfBPoint& List,Standard_Real& X1,Standard_Real& Y1,Standard_Real& Z1,Standard_Real& X2,Standard_Real& Y2,Standard_Real& Z2,Standard_Real& XTI1,Standard_Real& YTI1,Standard_Real& ZTI1,Standard_Real& XTI2,Standard_Real& YTI2,Standard_Real& ZTI2,const Standard_Integer e,Standard_Real& U1,Standard_Real& U2,Standard_Address& Nod11Indices,Standard_Address& Nod11RValues,Standard_Address& Nod12Indices,Standard_Address& Nod12RValues,const Standard_Integer i1p1,const Standard_Integer i1p2,const Standard_Integer i1,const Handle(HLRAlgo_PolyInternalData)& pid1,Standard_Address& TData1,Standard_Address& PISeg1,Standard_Address& PINod1,const Standard_Real X3,const Standard_Real Y3,const Standard_Real Z3,const Standard_Real XT3,const Standard_Real YT3,const Standard_Real ZT3,const Standard_Real coef3,const Standard_Real U3,const Standard_Boolean insP3,const Standard_Boolean mP3P1,const Standard_Integer flag) const;
   
-  Standard_EXPORT     void MoveOrInsertPoint(HLRAlgo_ListOfBPoint& List,Standard_Real& X1,Standard_Real& Y1,Standard_Real& Z1,Standard_Real& X2,Standard_Real& Y2,Standard_Real& Z2,Standard_Real& XTI1,Standard_Real& YTI1,Standard_Real& ZTI1,Standard_Real& XTI2,Standard_Real& YTI2,Standard_Real& ZTI2,const Standard_Integer e,Standard_Real& U1,Standard_Real& U2,Standard_Address& Nod11Indices,Standard_Address& Nod11RValues,Standard_Address& Nod12Indices,Standard_Address& Nod12RValues,const Standard_Integer i1p1,const Standard_Integer i1p2,const Standard_Integer i1,const Handle(HLRAlgo_PolyInternalData)& pid1,Standard_Address& TData1,Standard_Address& PISeg1,Standard_Address& PINod1,Standard_Address& Nod21Indices,Standard_Address& Nod21RValues,Standard_Address& Nod22Indices,Standard_Address& Nod22RValues,const Standard_Integer i2p1,const Standard_Integer i2p2,const Standard_Integer i2,const Handle(HLRAlgo_PolyInternalData)& pid2,Standard_Address& TData2,Standard_Address& PISeg2,Standard_Address& PINod2,const Standard_Real X3,const Standard_Real Y3,const Standard_Real Z3,const Standard_Real XT3,const Standard_Real YT3,const Standard_Real ZT3,const Standard_Real coef3,const Standard_Real U3,const Standard_Boolean insP3,const Standard_Boolean mP3P1,const Standard_Boolean flag) const;
+  Standard_EXPORT     void MoveOrInsertPoint(HLRAlgo_ListOfBPoint& List,Standard_Real& X1,Standard_Real& Y1,Standard_Real& Z1,Standard_Real& X2,Standard_Real& Y2,Standard_Real& Z2,Standard_Real& XTI1,Standard_Real& YTI1,Standard_Real& ZTI1,Standard_Real& XTI2,Standard_Real& YTI2,Standard_Real& ZTI2,const Standard_Integer e,Standard_Real& U1,Standard_Real& U2,Standard_Address& Nod11Indices,Standard_Address& Nod11RValues,Standard_Address& Nod12Indices,Standard_Address& Nod12RValues,const Standard_Integer i1p1,const Standard_Integer i1p2,const Standard_Integer i1,const Handle(HLRAlgo_PolyInternalData)& pid1,Standard_Address& TData1,Standard_Address& PISeg1,Standard_Address& PINod1,Standard_Address& Nod21Indices,Standard_Address& Nod21RValues,Standard_Address& Nod22Indices,Standard_Address& Nod22RValues,const Standard_Integer i2p1,const Standard_Integer i2p2,const Standard_Integer i2,const Handle(HLRAlgo_PolyInternalData)& pid2,Standard_Address& TData2,Standard_Address& PISeg2,Standard_Address& PINod2,const Standard_Real X3,const Standard_Real Y3,const Standard_Real Z3,const Standard_Real XT3,const Standard_Real YT3,const Standard_Real ZT3,const Standard_Real coef3,const Standard_Real U3,const Standard_Boolean insP3,const Standard_Boolean mP3P1,const Standard_Integer flag) const;
   
-  Standard_EXPORT     void MoveOrInsertPoint(HLRAlgo_ListOfBPoint& List,Standard_Real& X1,Standard_Real& Y1,Standard_Real& Z1,Standard_Real& X2,Standard_Real& Y2,Standard_Real& Z2,Standard_Real& XTI1,Standard_Real& YTI1,Standard_Real& ZTI1,Standard_Real& XTI2,Standard_Real& YTI2,Standard_Real& ZTI2,const Standard_Integer e,Standard_Real& U1,Standard_Real& U2,Standard_Address& Nod11Indices,Standard_Address& Nod11RValues,Standard_Address& Nod12Indices,Standard_Address& Nod12RValues,const Standard_Integer i1p1,const Standard_Integer i1p2,const Standard_Integer i1,const Handle(HLRAlgo_PolyInternalData)& pid1,Standard_Address& TData1,Standard_Address& PISeg1,Standard_Address& PINod1,Standard_Address& Nod21Indices,Standard_Address& Nod21RValues,Standard_Address& Nod22Indices,Standard_Address& Nod22RValues,const Standard_Integer i2p1,const Standard_Integer i2p2,const Standard_Integer i2,const Handle(HLRAlgo_PolyInternalData)& pid2,Standard_Address& TData2,Standard_Address& PISeg2,Standard_Address& PINod2,const Standard_Real X3,const Standard_Real Y3,const Standard_Real Z3,const Standard_Real XT3,const Standard_Real YT3,const Standard_Real ZT3,const Standard_Real coef3,const Standard_Real U3,const Standard_Boolean insP3,const Standard_Boolean mP3P1,const Standard_Real X4,const Standard_Real Y4,const Standard_Real Z4,const Standard_Real XT4,const Standard_Real YT4,const Standard_Real ZT4,const Standard_Real coef4,const Standard_Real U4,const Standard_Boolean insP4,const Standard_Boolean mP4P1,const Standard_Boolean flag) const;
+  Standard_EXPORT     void MoveOrInsertPoint(HLRAlgo_ListOfBPoint& List,Standard_Real& X1,Standard_Real& Y1,Standard_Real& Z1,Standard_Real& X2,Standard_Real& Y2,Standard_Real& Z2,Standard_Real& XTI1,Standard_Real& YTI1,Standard_Real& ZTI1,Standard_Real& XTI2,Standard_Real& YTI2,Standard_Real& ZTI2,const Standard_Integer e,Standard_Real& U1,Standard_Real& U2,Standard_Address& Nod11Indices,Standard_Address& Nod11RValues,Standard_Address& Nod12Indices,Standard_Address& Nod12RValues,const Standard_Integer i1p1,const Standard_Integer i1p2,const Standard_Integer i1,const Handle(HLRAlgo_PolyInternalData)& pid1,Standard_Address& TData1,Standard_Address& PISeg1,Standard_Address& PINod1,Standard_Address& Nod21Indices,Standard_Address& Nod21RValues,Standard_Address& Nod22Indices,Standard_Address& Nod22RValues,const Standard_Integer i2p1,const Standard_Integer i2p2,const Standard_Integer i2,const Handle(HLRAlgo_PolyInternalData)& pid2,Standard_Address& TData2,Standard_Address& PISeg2,Standard_Address& PINod2,const Standard_Real X3,const Standard_Real Y3,const Standard_Real Z3,const Standard_Real XT3,const Standard_Real YT3,const Standard_Real ZT3,const Standard_Real coef3,const Standard_Real U3,const Standard_Boolean insP3,const Standard_Boolean mP3P1,const Standard_Real X4,const Standard_Real Y4,const Standard_Real Z4,const Standard_Real XT4,const Standard_Real YT4,const Standard_Real ZT4,const Standard_Real coef4,const Standard_Real U4,const Standard_Boolean insP4,const Standard_Boolean mP4P1,const Standard_Integer flag) const;
   
   Standard_EXPORT     void InsertOnOutLine(TColStd_Array1OfTransient& PID) ;
   
Index: oce/inc/IFSelect_DispGlobal.hxx
===================================================================
--- oce.orig/inc/IFSelect_DispGlobal.hxx
+++ oce/inc/IFSelect_DispGlobal.hxx
@@ -43,7 +43,7 @@ public:
   //! Returns True : maximum equates 1 <br>
   Standard_EXPORT   virtual  Standard_Boolean LimitedMax(const Standard_Integer nbent,Standard_Integer& max) const;
   //! Returns True (count of packets is well known) and count is 1 <br>
-  Standard_EXPORT   virtual  Standard_Boolean PacketsCount(const Interface_Graph& G,Standard_Integer& count) const;
+  Standard_EXPORT   virtual  Standard_Integer PacketsCount(const Interface_Graph& G,Standard_Integer& count) const;
   //! Computes the list of produced Packets. It is made of only ONE <br>
 //!           Packet, which gets the RootResult from the Final Selection. <br>
 //!           Remark : the inherited exception raising is never activated. <br>
Index: oce/inc/IFSelect_DispPerCount.hxx
===================================================================
--- oce.orig/inc/IFSelect_DispPerCount.hxx
+++ oce/inc/IFSelect_DispPerCount.hxx
@@ -58,7 +58,7 @@ public:
   Standard_EXPORT   virtual  Standard_Boolean LimitedMax(const Standard_Integer nbent,Standard_Integer& max) const;
   //! Returns True (count is easy to know) and count is computed <br>
 //!           from length of input list (RootResult from Final Selection) <br>
-  Standard_EXPORT   virtual  Standard_Boolean PacketsCount(const Interface_Graph& G,Standard_Integer& count) const;
+  Standard_EXPORT   virtual  Standard_Integer PacketsCount(const Interface_Graph& G,Standard_Integer& count) const;
   //! Computes the list of produced Packets. It defines Packets in <br>
 //!           order to have at most <Count> Entities per Packet, Entities <br>
 //!           are given by RootResult from the Final Selection. <br>
Index: oce/inc/IFSelect_DispPerFiles.hxx
===================================================================
--- oce.orig/inc/IFSelect_DispPerFiles.hxx
+++ oce/inc/IFSelect_DispPerFiles.hxx
@@ -61,7 +61,7 @@ public:
   Standard_EXPORT   virtual  Standard_Boolean LimitedMax(const Standard_Integer nbent,Standard_Integer& max) const;
   //! Returns True (count is easy to know) and count is the minimum <br>
 //!           value between  length of input list and CountValue <br>
-  Standard_EXPORT   virtual  Standard_Boolean PacketsCount(const Interface_Graph& G,Standard_Integer& count) const;
+  Standard_EXPORT   virtual  Standard_Integer PacketsCount(const Interface_Graph& G,Standard_Integer& count) const;
   //! Computes the list of produced Packets. It defines Packets in <br>
 //!           order to have <Count> Packets, except if the input count of <br>
 //!           Entities is lower. Entities are given by RootResult from the <br>
Index: oce/inc/IFSelect_DispPerOne.hxx
===================================================================
--- oce.orig/inc/IFSelect_DispPerOne.hxx
+++ oce/inc/IFSelect_DispPerOne.hxx
@@ -45,7 +45,7 @@ public:
   Standard_EXPORT   virtual  Standard_Boolean LimitedMax(const Standard_Integer nbent,Standard_Integer& max) const;
   //! Returns True (count is easy to know) and count is the length <br>
 //!           of the input list (RootResult from FinalSelection) <br>
-  Standard_EXPORT   virtual  Standard_Boolean PacketsCount(const Interface_Graph& G,Standard_Integer& count) const;
+  Standard_EXPORT   virtual  Standard_Integer PacketsCount(const Interface_Graph& G,Standard_Integer& count) const;
   //! Returns the list of produced Packets. It defines one Packet <br>
 //!           per Entity given by RootResult from the Final Selection. <br>
   Standard_EXPORT     void Packets(const Interface_Graph& G,IFGraph_SubPartsIterator& packs) const;
Index: oce/inc/IFSelect_Dispatch.hxx
===================================================================
--- oce.orig/inc/IFSelect_Dispatch.hxx
+++ oce/inc/IFSelect_Dispatch.hxx
@@ -107,7 +107,7 @@ public:
 //!           of complete evaluation made by method Packets), it is <br>
 //!           preferable to answer "unknown" by returning False <br>
 //!           Default answer if False. Can be redefined. <br>
-  Standard_EXPORT   virtual  Standard_Boolean PacketsCount(const Interface_Graph& G,Standard_Integer& count) const;
+  Standard_EXPORT   virtual  Standard_Integer PacketsCount(const Interface_Graph& G,Standard_Integer& count) const;
   //! Returns the list of produced Packets into argument <pack>. <br>
 //!           Each Packet corresponds to a Part, the Entities listed are the <br>
 //!           Roots given by the Selection. Input is given as a Graph. <br>
Index: oce/inc/OSD_DirectoryIterator.hxx
===================================================================
--- oce.orig/inc/OSD_DirectoryIterator.hxx
+++ oce/inc/OSD_DirectoryIterator.hxx
@@ -95,7 +95,7 @@ private:
 
 
 OSD_Directory TheIterator;
-Standard_Integer myFlag;
+Standard_Boolean myFlag;
 TCollection_AsciiString myMask;
 TCollection_AsciiString myPlace;
 Standard_Address myDescr;
Index: oce/inc/OSD_FileIterator.hxx
===================================================================
--- oce.orig/inc/OSD_FileIterator.hxx
+++ oce/inc/OSD_FileIterator.hxx
@@ -95,7 +95,7 @@ private:
 
 
 OSD_File TheIterator;
-Standard_Integer myFlag;
+Standard_Boolean myFlag;
 TCollection_AsciiString myMask;
 TCollection_AsciiString myPlace;
 Standard_Address myDescr;
Index: oce/inc/ShapeAnalysis_Surface.hxx
===================================================================
--- oce.orig/inc/ShapeAnalysis_Surface.hxx
+++ oce/inc/ShapeAnalysis_Surface.hxx
@@ -340,7 +340,7 @@ private:
   
   Standard_EXPORT     void ComputeBoxes() ;
   
-  Standard_EXPORT     Standard_Boolean SurfaceNewton(const gp_Pnt2d& p2dPrev,const gp_Pnt& P3D,const Standard_Real preci,gp_Pnt2d& sol) ;
+  Standard_EXPORT     Standard_Integer SurfaceNewton(const gp_Pnt2d& p2dPrev,const gp_Pnt& P3D,const Standard_Real preci,gp_Pnt2d& sol) ;
   
   Standard_EXPORT     void SortSingularities() ;
 
Index: oce/inc/ShapeFix_Solid.hxx
===================================================================
--- oce.orig/inc/ShapeFix_Solid.hxx
+++ oce/inc/ShapeFix_Solid.hxx
@@ -71,7 +71,7 @@ public:
   //! Calls MakeSolid and orients the solid to be "not infinite" <br>
   Standard_EXPORT     TopoDS_Solid SolidFromShell(const TopoDS_Shell& shell) ;
   //! Returns the status of the last Fix. <br>
-  Standard_EXPORT     Standard_Boolean Status(const ShapeExtend_Status status) const;
+  Standard_EXPORT     Standard_Integer Status(const ShapeExtend_Status status) const;
   //! Returns resulting solid. <br>
   Standard_EXPORT     TopoDS_Shape Solid() const;
   //! Returns tool for fixing shells. <br>
Index: oce/inc/TopOpeBRep_FacesFiller.hxx
===================================================================
--- oce.orig/inc/TopOpeBRep_FacesFiller.hxx
+++ oce/inc/TopOpeBRep_FacesFiller.hxx
@@ -279,7 +279,7 @@ Standard_Boolean myLineIsonEdge;
 TopTools_ListOfShape myERL;
 TopTools_DataMapOfShapeListOfShape myDataforDegenEd;
 Standard_Boolean myLastVPison0;
-Standard_Boolean mykeptVPnbr;
+Standard_Integer mykeptVPnbr;
 Standard_Integer myDSCIndex;
 TopOpeBRepDS_ListOfInterference myDSCIL;
 TopOpeBRep_PointClassifier myPointClassifier;
Index: oce/src/Adaptor3d/Adaptor3d_IsoCurve.cxx
===================================================================
--- oce.orig/src/Adaptor3d/Adaptor3d_IsoCurve.cxx
+++ oce/src/Adaptor3d/Adaptor3d_IsoCurve.cxx
@@ -896,7 +896,7 @@ Standard_Integer Adaptor3d_IsoCurve::Deg
 
 Standard_Boolean Adaptor3d_IsoCurve::IsRational() const 
 {
-  Standard_Integer is_rational = Standard_False ;
+  Standard_Boolean is_rational = Standard_False ;
   GeomAbs_SurfaceType type = mySurface->GetType() ;
   switch(type) {
   case GeomAbs_BezierSurface:
Index: oce/src/BOPDS/BOPDS_IndexRange.lxx
===================================================================
--- oce.orig/src/BOPDS/BOPDS_IndexRange.lxx
+++ oce/src/BOPDS/BOPDS_IndexRange.lxx
@@ -88,5 +88,5 @@
 //=======================================================================
   inline Standard_Boolean BOPDS_IndexRange::Contains(const Standard_Integer aIndex)const
 {
-  return (Standard_Boolean)(aIndex>=myFirst && aIndex<=myLast);
+  return (aIndex>=myFirst && aIndex<=myLast);
 }
Index: oce/src/BRep/BRep_TEdge.cxx
===================================================================
--- oce.orig/src/BRep/BRep_TEdge.cxx
+++ oce/src/BRep/BRep_TEdge.cxx
@@ -70,7 +70,7 @@ BRep_TEdge::BRep_TEdge() :
 
  Standard_Boolean  BRep_TEdge::SameRange()const 
 {
-  return myFlags & RangeMask;
+  return 0 != (myFlags & RangeMask);
 }
 
 
@@ -93,7 +93,7 @@ BRep_TEdge::BRep_TEdge() :
 
  Standard_Boolean  BRep_TEdge::Degenerated()const 
 {
-  return myFlags & DegeneratedMask;
+  return 0 != (myFlags & DegeneratedMask);
 }
 
 
Index: oce/src/BRepBuilderAPI/BRepBuilderAPI_Sewing.cxx
===================================================================
--- oce.orig/src/BRepBuilderAPI/BRepBuilderAPI_Sewing.cxx
+++ oce/src/BRepBuilderAPI/BRepBuilderAPI_Sewing.cxx
@@ -398,8 +398,8 @@ TopoDS_Edge BRepBuilderAPI_Sewing::SameP
       if (locReShape != myReShape) Edge2 = TopoDS::Edge(aTmpShape);
 
       // Calculate relative orientation
-      Standard_Integer Orientation = seqForward(i);
-      if (!isForward) Orientation = (Orientation? 0 : 1);
+      Standard_Boolean Orientation = (0 != seqForward(i));
+      if (!isForward) Orientation = !Orientation;
 
       // Retrieve faces information for the second edge
       TopoDS_Shape bnd2 = oedge2;
@@ -3229,7 +3229,7 @@ void BRepBuilderAPI_Sewing::Merging(cons
         if (!nbMerged) MergedWithBound.UnBind(bound);
       }
     }
-    Standard_Boolean isMerged = MergedWithBound.Extent();
+    Standard_Boolean isMerged = !MergedWithBound.IsEmpty();
 
     // Merge with cutting sections
     Handle(BRepTools_ReShape) SectionsReShape = new BRepTools_ReShape;
@@ -3330,7 +3330,7 @@ void BRepBuilderAPI_Sewing::Merging(cons
         }
       }
     }
-    Standard_Boolean isMergedSplit = MergedWithSections.Extent();
+    Standard_Boolean isMergedSplit = !MergedWithSections.IsEmpty();
 
     if (!isMerged && !isMergedSplit) {
       // Nothing was merged in this iteration
@@ -3562,7 +3562,7 @@ Standard_Boolean BRepBuilderAPI_Sewing::
         SeqMergedOri.Append(ori);
         if (!myNonmanifold) break;
       }
-      success = nbCandidates;
+      success = (0 != nbCandidates);
     }
   }
 
Index: oce/src/BRepFill/BRepFill_Sweep.cxx
===================================================================
--- oce.orig/src/BRepFill/BRepFill_Sweep.cxx
+++ oce/src/BRepFill/BRepFill_Sweep.cxx
@@ -2167,13 +2167,13 @@ BRepFill_Sweep::BRepFill_Sweep(const Han
     // Return data
     if (isec >NbLaw) {
       S = TabS(NbLaw, 1);
-      ureverse = UReverse(NbLaw, 1);
-      exuv = ExchUV(NbLaw, 1);
+      ureverse = (0 != UReverse(NbLaw, 1));
+      exuv = (0 != ExchUV(NbLaw, 1));
     }
     else {
       S = TabS(isec, 1);
-      ureverse = UReverse(isec, 1);
-      exuv = ExchUV(isec, 1);
+      ureverse = (0 != UReverse(isec, 1));
+      exuv = (0 != ExchUV(isec, 1));
     }
     S->Bounds(UFirst, ULast, VFirst, VLast);
     
@@ -2249,13 +2249,13 @@ BRepFill_Sweep::BRepFill_Sweep(const Han
     // Return data
     if (isec >NbLaw) {
         S = TabS(NbLaw, NbPath);
-        ureverse = UReverse(NbLaw, NbPath);
-        exuv = ExchUV(NbLaw, NbPath);
+        ureverse = (0 != UReverse(NbLaw, NbPath));
+        exuv = (0 != ExchUV(NbLaw, NbPath));
     }
     else {
       S = TabS(isec, NbPath);
-      ureverse = UReverse(isec, NbPath);
-      exuv = ExchUV(isec, NbPath);
+      ureverse = (0 != UReverse(isec, NbPath));
+      exuv = (0 != ExchUV(isec, NbPath));
     }
     S->Bounds(UFirst, ULast, VFirst, VLast);
     
@@ -2308,7 +2308,7 @@ BRepFill_Sweep::BRepFill_Sweep(const Han
         continue;
       
       S = TabS(isec, ipath);
-      exuv = ExchUV(isec, ipath);
+      exuv = (0 != ExchUV(isec, ipath));
       S->Bounds(UFirst, ULast, VFirst, VLast);
       if (UReverse(isec, ipath)) {
 	Standard_Real aux;
@@ -2572,8 +2572,8 @@ BRepFill_Sweep::BRepFill_Sweep(const Han
 		  TopoDS::Edge(UEdge(isec+1, ipath)),
 		  TopoDS::Edge(VEdge(isec, ipath+1)),
 		  myVEdgesModified,
-		  ExchUV(isec, ipath),
-		  UReverse(isec, ipath),
+		  0 != ExchUV(isec, ipath),
+		  0 != UReverse(isec, ipath),
 		  face);
 	myFaces->SetValue(isec, IPath, face);
       }
Index: oce/src/BRepFill/BRepFill_TrimShellCorner.cxx
===================================================================
--- oce.orig/src/BRepFill/BRepFill_TrimShellCorner.cxx
+++ oce/src/BRepFill/BRepFill_TrimShellCorner.cxx
@@ -438,7 +438,7 @@ Standard_Boolean MakeFacesNonSec(const S
 
   // search common vertices between uedges. begin
   TopTools_ListOfShape aCommonVertices;
-  Standard_Boolean acommonflag = 0; // 0 - no, 1 - first pair, 2 - second pair, 3 - both
+  Standard_Integer acommonflag = 0; // 0 - no, 1 - first pair, 2 - second pair, 3 - both
   Standard_Integer ueit = 0, eindex = 0;
 
   for(ueit = 1, eindex = theIndex; ueit <= 2; ueit++, eindex++) {
Index: oce/src/BRepMesh/BRepMesh_Delaun.cxx
===================================================================
--- oce.orig/src/BRepMesh/BRepMesh_Delaun.cxx
+++ oce/src/BRepMesh/BRepMesh_Delaun.cxx
@@ -306,7 +306,7 @@ void BRepMesh_Delaun::createTriangles(co
     Standard_Integer     anEdgeId = anEdges.Key();
     const BRepMesh_Edge& anEdge   = GetEdge( anEdgeId );
 
-    Standard_Boolean isPositive = (Standard_Boolean)thePoly( anEdgeId );
+    Standard_Boolean isPositive = (0 != thePoly( anEdgeId ));
 
     Standard_Integer aNodes[3];
     if ( isPositive )
@@ -1938,7 +1938,7 @@ void BRepMesh_Delaun::RemoveVertex( cons
     Standard_Integer aPivotNode = anEdge.LastNode();
     Standard_Integer anEdgeId   = aLoopEdgesIt.Key();
     
-    Standard_Boolean isPositive = (Standard_Boolean)aLoopEdges( anEdgeId );
+    Standard_Boolean isPositive = (0 != aLoopEdges( anEdgeId ));
     if ( !isPositive )
     {
       Standard_Integer aTmp;
Index: oce/src/BRepMesh/BRepMesh_FastDiscretFace.cxx
===================================================================
--- oce.orig/src/BRepMesh/BRepMesh_FastDiscretFace.cxx
+++ oce/src/BRepMesh/BRepMesh_FastDiscretFace.cxx
@@ -844,8 +844,8 @@ void BRepMesh_FastDiscretFace::insertInt
           }
 
           gp_Dir N1(0, 0, 1), N2(0, 0, 1);
-          Standard_Boolean aSt1 = GeomLib::NormEstim(aBSpline, aStPnt1, aPrecision, N1);
-          Standard_Boolean aSt2 = GeomLib::NormEstim(aBSpline, aStPnt2, aPrecision, N2);
+          Standard_Integer aSt1 = GeomLib::NormEstim(aBSpline, aStPnt1, aPrecision, N1);
+          Standard_Integer aSt2 = GeomLib::NormEstim(aBSpline, aStPnt2, aPrecision, N2);
 
           Standard_Real aAngle = N2.Angle(N1);
           if (aSt1 < 1 && aSt2 < 1 && aAngle > myAngle)
Index: oce/src/BRepTest/BRepTest_CheckCommands.cxx
===================================================================
--- oce.orig/src/BRepTest/BRepTest_CheckCommands.cxx
+++ oce/src/BRepTest/BRepTest_CheckCommands.cxx
@@ -355,7 +355,7 @@ static Standard_Integer checkdiff(Draw_I
       di << syntaxe << "\n";
       return 1;
     }
-    closedSolid=Draw::Atoi(a[narg-1]);
+    closedSolid = (0 != Draw::Atoi(a[narg-1]));
     resu = DBRep::Get(a[narg-2]);
     lastArg=narg-3;
     if (resu.IsNull()) {
@@ -365,7 +365,7 @@ static Standard_Integer checkdiff(Draw_I
 	return 1;
       }
       geomCtrl=closedSolid;
-      closedSolid=Draw::Atoi(a[narg-2]);
+      closedSolid = (0 != Draw::Atoi(a[narg-2]));
       resu = DBRep::Get(a[narg-3]);
       lastArg=narg-4;
       if (resu.IsNull()) {
Index: oce/src/BRepTest/BRepTest_CurveCommands.cxx
===================================================================
--- oce.orig/src/BRepTest/BRepTest_CurveCommands.cxx
+++ oce/src/BRepTest/BRepTest_CurveCommands.cxx
@@ -1040,7 +1040,7 @@ static Standard_Integer bsplineprof(Draw
   not_done = 1 ;
   while (not_done) {
 
-    dout.Select(id,X,Y,b,wait);
+    dout.Select(id,X,Y,b,0 != wait);
     Standard_Real z = dout.Zoom(id);
     a_point.SetCoord(1,(Standard_Real)X /z) ;
     a_point.SetCoord(2,(Standard_Real)Y /z) ;
Index: oce/src/BRepTest/BRepTest_DraftAngleCommands.cxx
===================================================================
--- oce.orig/src/BRepTest/BRepTest_DraftAngleCommands.cxx
+++ oce/src/BRepTest/BRepTest_DraftAngleCommands.cxx
@@ -130,7 +130,7 @@ static Standard_Integer NDEP(Draw_Interp
 //#ifdef DEB
 //    Flag = Draw::Atof(a[9*ii+7]); // BUG?? Real -> Boolean ???
 //#else
-    Flag = (Standard_Boolean ) Draw::Atof(a[9*ii+7]);
+    Flag = (0.0 != Draw::Atof(a[9*ii+7]));
 //#endif
     Angle = Draw::Atof(a[9*ii+8])*M_PI/180.;
     Pax.SetCoord(Draw::Atof(a[9*ii+9]),Draw::Atof(a[9*ii+10]),Draw::Atof(a[9*ii+11]));
Index: oce/src/BRepTest/BRepTest_FeatureCommands.cxx
===================================================================
--- oce.orig/src/BRepTest/BRepTest_FeatureCommands.cxx
+++ oce/src/BRepTest/BRepTest_FeatureCommands.cxx
@@ -330,7 +330,7 @@ static Standard_Integer CONTROL(Draw_Int
 				Standard_Integer narg, const char** a)
 {
   if (narg >= 2) {
-    WithControl = strcmp("0",a[1]);
+    WithControl = (0 != strcmp("0",a[1]));
   }
   if (WithControl) {
     theCommands << "Mode avec controle";
@@ -947,7 +947,7 @@ Standard_Integer offsetparameter(Draw_In
   if ( n < 4 ) return 1;
   
   TheTolerance = Draw::Atof(a[1]);
-  TheInter     = strcmp(a[2],"p");
+  TheInter     = (0 != strcmp(a[2],"p"));
   
   if      ( !strcmp(a[3],"a")) TheJoin = GeomAbs_Arc;
   else if ( !strcmp(a[3],"i")) TheJoin = GeomAbs_Intersection;
Index: oce/src/BRepTest/BRepTest_FillingCommands.cxx
===================================================================
--- oce.orig/src/BRepTest/BRepTest_FillingCommands.cxx
+++ oce/src/BRepTest/BRepTest_FillingCommands.cxx
@@ -668,7 +668,7 @@ static Standard_Integer fillingparam( Dr
 	  Degree      = Draw::Atoi( a[2] );
 	  NbPtsOnCur  = Draw::Atoi( a[3] );
 	  NbIter      = Draw::Atoi( a[4] );
-	  Anisotropie = Draw::Atoi( a[5] );
+	  Anisotropie = (0 != Draw::Atoi( a[5] ));
 	}
       else if (strcmp( flag, "-c" ) == 0 && n == 6)
 	{
Index: oce/src/BRepTest/BRepTest_SweepCommands.cxx
===================================================================
--- oce.orig/src/BRepTest/BRepTest_SweepCommands.cxx
+++ oce/src/BRepTest/BRepTest_SweepCommands.cxx
@@ -531,7 +531,7 @@ static Standard_Integer setsweep(Draw_In
           Standard_Integer CurvilinearEquivalence = Draw::Atoi(a[3]);
           Standard_Integer KeepContact = Draw::Atoi(a[4]);
           Sweep->SetMode(TopoDS::Wire(Guide),
-                         CurvilinearEquivalence,
+                         0 != CurvilinearEquivalence,
                          (BRepFill_TypeOfContact)KeepContact);
 	}
     }
Index: oce/src/BRepToIGES/BRepToIGES_BREntity.cxx
===================================================================
--- oce.orig/src/BRepToIGES/BRepToIGES_BREntity.cxx
+++ oce/src/BRepToIGES/BRepToIGES_BREntity.cxx
@@ -76,8 +76,8 @@ void BRepToIGES_BREntity::Init()
 {  
   TheMap = new Transfer_FinderProcess();
   TheUnitFactor = 1.;
-  myConvSurface = Interface_Static::IVal("write.convertsurface.mode");
-  myPCurveMode = Interface_Static::IVal("write.surfacecurve.mode");
+  myConvSurface = (0 != Interface_Static::IVal("write.convertsurface.mode"));
+  myPCurveMode = (0 != Interface_Static::IVal("write.surfacecurve.mode"));
 }
 
 //=======================================================================
Index: oce/src/BRepToIGESBRep/BRepToIGESBRep_Entity.cxx
===================================================================
--- oce.orig/src/BRepToIGESBRep/BRepToIGESBRep_Entity.cxx
+++ oce/src/BRepToIGESBRep/BRepToIGESBRep_Entity.cxx
@@ -747,10 +747,10 @@ Handle(IGESSolid_ManifoldSolid) BRepToIG
     FirstShell = GetCasted(IGESSolid_Shell, Seq->Value(1));
     ShellFlag = SeqFlag.Value(1);
     Tab.Nullify();  TabFlag.Nullify();
-    mysol->Init(FirstShell, ShellFlag, Tab, TabFlag);
+    mysol->Init(FirstShell, 0 != ShellFlag, Tab, TabFlag);
   }
   else if (nbshells >=2 ) {
-    mysol->Init(FirstShell, ShellFlag, Tab, TabFlag);
+    mysol->Init(FirstShell, 0 != ShellFlag, Tab, TabFlag);
   }
   else
     AddWarning (start, " no Result ");
Index: oce/src/BinLDrivers/BinLDrivers_DocumentSection.cxx
===================================================================
--- oce.orig/src/BinLDrivers/BinLDrivers_DocumentSection.cxx
+++ oce/src/BinLDrivers/BinLDrivers_DocumentSection.cxx
@@ -204,6 +204,6 @@ void BinLDrivers_DocumentSection::ReadTO
 #endif
     theSection.myValue[0] = (Standard_Size)aValue[0];
     theSection.myValue[1] = (Standard_Size)aValue[1];
-    theSection.myIsPostRead = (Standard_Boolean)aValue[2];
+    theSection.myIsPostRead = (0 != aValue[2]);
   }
 }
Index: oce/src/BinMDataStd/BinMDataStd_ByteArrayDriver.cxx
===================================================================
--- oce.orig/src/BinMDataStd/BinMDataStd_ByteArrayDriver.cxx
+++ oce/src/BinMDataStd/BinMDataStd_ByteArrayDriver.cxx
@@ -73,7 +73,7 @@ Standard_Boolean BinMDataStd_ByteArrayDr
     if (! (theSource >> aDeltaValue))
       return Standard_False;
     else
-      aDelta = (Standard_Boolean)aDeltaValue;
+      aDelta = (0 != aDeltaValue);
   }
   anAtt->SetDelta(aDelta);
   return Standard_True;
Index: oce/src/BinMDataStd/BinMDataStd_ExtStringArrayDriver.cxx
===================================================================
--- oce.orig/src/BinMDataStd/BinMDataStd_ExtStringArrayDriver.cxx
+++ oce/src/BinMDataStd/BinMDataStd_ExtStringArrayDriver.cxx
@@ -87,7 +87,7 @@ Standard_Boolean BinMDataStd_ExtStringAr
 	    return Standard_False;
 	  }
       else
-	aDelta = (Standard_Boolean)aDeltaValue;
+	aDelta = (0 != aDeltaValue);
 	}
     anAtt->SetDelta(aDelta);
   }
Index: oce/src/BinMDataStd/BinMDataStd_IntPackedMapDriver.cxx
===================================================================
--- oce.orig/src/BinMDataStd/BinMDataStd_IntPackedMapDriver.cxx
+++ oce/src/BinMDataStd/BinMDataStd_IntPackedMapDriver.cxx
@@ -90,7 +90,7 @@ Standard_Boolean BinMDataStd_IntPackedMa
     if (! (Source >> aDeltaValue))
       return Standard_False;
     else
-      aDelta = (Standard_Boolean)aDeltaValue;
+      aDelta = (0 != aDeltaValue);
   }
   aTagAtt->SetDelta(aDelta);
   return Standard_True;
Index: oce/src/BinMDataStd/BinMDataStd_IntegerArrayDriver.cxx
===================================================================
--- oce.orig/src/BinMDataStd/BinMDataStd_IntegerArrayDriver.cxx
+++ oce/src/BinMDataStd/BinMDataStd_IntegerArrayDriver.cxx
@@ -71,7 +71,7 @@ Standard_Boolean BinMDataStd_IntegerArra
     if (! (theSource >> aDeltaValue))
       return Standard_False;
     else
-      aDelta = (Standard_Boolean)aDeltaValue;
+      aDelta = (0 != aDeltaValue);
   }
 #ifdef DEB
   else if(BinMDataStd::DocumentVersion() == -1)
Index: oce/src/BinMDataStd/BinMDataStd_RealArrayDriver.cxx
===================================================================
--- oce.orig/src/BinMDataStd/BinMDataStd_RealArrayDriver.cxx
+++ oce/src/BinMDataStd/BinMDataStd_RealArrayDriver.cxx
@@ -71,7 +71,7 @@ Standard_Boolean BinMDataStd_RealArrayDr
     if (! (theSource >> aDeltaValue))
       return Standard_False;
     else
-      aDelta = (Standard_Boolean)aDeltaValue;
+      aDelta = (0 != aDeltaValue);
   }
   anAtt->SetDelta(aDelta);
   return Standard_True; 
Index: oce/src/BinMDataXtd/BinMDataXtd_ConstraintDriver.cxx
===================================================================
--- oce.orig/src/BinMDataXtd/BinMDataXtd_ConstraintDriver.cxx
+++ oce/src/BinMDataXtd/BinMDataXtd_ConstraintDriver.cxx
@@ -120,8 +120,8 @@ Standard_Boolean BinMDataXtd_ConstraintD
   if (! (theSource >> flags))
     return Standard_False;
   aC->Verified( flags & 1);
-  aC->Inverted( flags & 2);
-  aC->Reversed( flags & 4);
+  aC->Inverted( 0 != (flags & 2));
+  aC->Reversed( 0 != (flags & 4));
 
   return Standard_True;
 }
Index: oce/src/BinMDataXtd/BinMDataXtd_PatternStdDriver.cxx
===================================================================
--- oce.orig/src/BinMDataXtd/BinMDataXtd_PatternStdDriver.cxx
+++ oce/src/BinMDataXtd/BinMDataXtd_PatternStdDriver.cxx
@@ -65,7 +65,7 @@ Standard_Boolean BinMDataXtd_PatternStdD
   if (! (theSource >> revFlags))
     return Standard_False;
   aP->Axis1Reversed( revFlags & 1 );
-  aP->Axis2Reversed( revFlags & 2 );
+  aP->Axis2Reversed( 0 != (revFlags & 2) );
 
   Handle(TNaming_NamedShape) TNS;
   Standard_Integer aNb;
Index: oce/src/BinMPrsStd/BinMPrsStd_AISPresentationDriver.cxx
===================================================================
--- oce.orig/src/BinMPrsStd/BinMPrsStd_AISPresentationDriver.cxx
+++ oce/src/BinMPrsStd/BinMPrsStd_AISPresentationDriver.cxx
@@ -54,7 +54,7 @@ Standard_Boolean BinMPrsStd_AISPresentat
 //Display status
   Standard_Boolean ok = theSource >> aValue;
   if (!ok) return ok;
-  anAtt->SetDisplayed((Standard_Boolean)aValue);
+  anAtt->SetDisplayed(0 != aValue);
 
 //GUID
   Standard_GUID aGUID;
Index: oce/src/BinObjMgt/BinObjMgt_Persistent.lxx
===================================================================
--- oce.orig/src/BinObjMgt/BinObjMgt_Persistent.lxx
+++ oce/src/BinObjMgt/BinObjMgt_Persistent.lxx
@@ -227,6 +227,6 @@ inline const BinObjMgt_Persistent& BinOb
 //  Standard_Integer anIntVal = (Standard_Integer) theValue;
   Standard_Integer anIntVal;
   GetInteger (anIntVal);
-  theValue = (Standard_Boolean) anIntVal;
+  theValue = (0 != anIntVal);
   return *this;
 }
Index: oce/src/BinTools/BinTools.cxx
===================================================================
--- oce.orig/src/BinTools/BinTools.cxx
+++ oce/src/BinTools/BinTools.cxx
@@ -126,6 +126,6 @@ Standard_IStream& BinTools::GetExtChar(S
 
 Standard_IStream& BinTools::GetBool(Standard_IStream& IS, Standard_Boolean& aValue)
 {
-  aValue = (Standard_Boolean)IS.get();
+  aValue = (0 != IS.get());
   return IS;
 }
Index: oce/src/Bnd/Bnd_Box.cxx
===================================================================
--- oce.orig/src/Bnd/Bnd_Box.cxx
+++ oce/src/Bnd/Bnd_Box.cxx
@@ -291,7 +291,7 @@ void Bnd_Box::OpenZmax ()
 
 Standard_Boolean Bnd_Box::IsOpenXmin () const
 {
-  return XminFlag();
+  return 0 != XminFlag();
 }
 
 //=======================================================================
@@ -301,7 +301,7 @@ Standard_Boolean Bnd_Box::IsOpenXmin ()
 
 Standard_Boolean Bnd_Box::IsOpenXmax () const
 {
-  return XmaxFlag();
+  return 0 != XmaxFlag();
 }
 
 //=======================================================================
@@ -311,7 +311,7 @@ Standard_Boolean Bnd_Box::IsOpenXmax ()
 
 Standard_Boolean Bnd_Box::IsOpenYmin () const
 {
-  return YminFlag();
+  return 0 != YminFlag();
 }
 
 //=======================================================================
@@ -321,7 +321,7 @@ Standard_Boolean Bnd_Box::IsOpenYmin ()
 
 Standard_Boolean Bnd_Box::IsOpenYmax () const
 {
-  return YmaxFlag();
+  return 0 != YmaxFlag();
 }
 
 //=======================================================================
@@ -331,7 +331,7 @@ Standard_Boolean Bnd_Box::IsOpenYmax ()
 
 Standard_Boolean Bnd_Box::IsOpenZmin () const
 {
-  return ZminFlag();
+  return 0 != ZminFlag();
 }
 
 //=======================================================================
@@ -341,7 +341,7 @@ Standard_Boolean Bnd_Box::IsOpenZmin ()
 
 Standard_Boolean Bnd_Box::IsOpenZmax () const
 {
-  return ZmaxFlag();
+  return 0 != ZmaxFlag();
 }
 
 //=======================================================================
Index: oce/src/Bnd/Bnd_Box2d.lxx
===================================================================
--- oce.orig/src/Bnd/Bnd_Box2d.lxx
+++ oce/src/Bnd/Bnd_Box2d.lxx
@@ -151,7 +151,7 @@ inline void Bnd_Box2d::OpenYmax ()
 //=======================================================================
 
 inline Standard_Boolean Bnd_Box2d::IsOpenXmin () const
-{ return Flags & XminMask; }
+{ return 0 != (Flags & XminMask); }
 
 //=======================================================================
 //function : IsOpenXmax
@@ -159,7 +159,7 @@ inline Standard_Boolean Bnd_Box2d::IsOpe
 //=======================================================================
 
 inline Standard_Boolean Bnd_Box2d::IsOpenXmax () const
-{ return Flags & XmaxMask; }
+{ return 0 != (Flags & XmaxMask); }
 
 //=======================================================================
 //function : IsOpenYmin
@@ -167,7 +167,7 @@ inline Standard_Boolean Bnd_Box2d::IsOpe
 //=======================================================================
 
 inline Standard_Boolean Bnd_Box2d::IsOpenYmin () const
-{ return Flags & YminMask; }
+{ return 0 != (Flags & YminMask); }
 
 //=======================================================================
 //function : IsOpenYmax
@@ -175,7 +175,7 @@ inline Standard_Boolean Bnd_Box2d::IsOpe
 //=======================================================================
 
 inline Standard_Boolean Bnd_Box2d::IsOpenYmax () const
-{ return Flags & YmaxMask; }
+{ return 0 != (Flags & YmaxMask); }
 
 //=======================================================================
 //function : IsWhole
Index: oce/src/ChFi3d/ChFi3d_Builder.cdl
===================================================================
--- oce.orig/src/ChFi3d/ChFi3d_Builder.cdl
+++ oce/src/ChFi3d/ChFi3d_Builder.cdl
@@ -272,7 +272,7 @@ is
 	      Forward         : Boolean from Standard;
               RecOnS1,RecOnS2 : Boolean from Standard;
               Soldep          : Vector from math;
-              Intf,Intl       : in out Boolean from Standard)
+              Intf,Intl       : in out Integer from Standard)
     returns  Boolean
     is deferred protected;	
 
@@ -518,7 +518,7 @@ is
                 Forward         : Boolean from Standard;
                 RecOnS1,RecOnS2 : Boolean from Standard;
                 Soldep          : in  out  Vector from math;
-                Intf,Intl       : in out Boolean from Standard; 
+                Intf,Intl       : in out Integer from Standard;
                 Surf1,Surf2     : in  out  HSurface from BRepAdaptor)
     is protected;
      
@@ -539,7 +539,7 @@ is
                 Forward         : Boolean from Standard;
                 RecOnS1,RecOnS2 : Boolean from Standard;
                 Soldep          : Vector from math;
-                Intf,Intl       : in out Boolean from Standard)
+                Intf,Intl       : in out Integer from Standard)
     returns  Boolean
     is deferred protected;	
     ---Purpose: Method, implemented in the inheritants, calculating
@@ -656,7 +656,7 @@ is
     
     PerformTwoCornerbyInter(me    : in out ; 
                             Index : Integer from Standard)
-    returns Integer	    
+    returns Boolean
     is static;
 
     PerformTwoCorner(me    : in out ; 
@@ -798,7 +798,7 @@ is
                 Inside,Appro    : Boolean from Standard;
                 Forward         : Boolean from Standard;
                 Soldep          : Vector from math;
-                Intf,Intl       : in out Boolean from Standard;
+                Intf,Intl       : in out Integer from Standard;
                 Gd1,Gd2,Gf1,Gf2 : out Boolean from Standard;
                 RecOnS1         : Boolean from Standard = Standard_False; 
                 RecOnS2         : Boolean from Standard = Standard_False)
Index: oce/src/ChFi3d/ChFi3d_Builder_2.cxx
===================================================================
--- oce.orig/src/ChFi3d/ChFi3d_Builder_2.cxx
+++ oce/src/ChFi3d/ChFi3d_Builder_2.cxx
@@ -603,8 +603,8 @@ CallPerformSurf(Handle(ChFiDS_Stripe)&
 		const Standard_Boolean              RecOnS1,
 		const Standard_Boolean              RecOnS2,
 		math_Vector&                        Soldep,
-		Standard_Boolean&                   intf,
-		Standard_Boolean&                   intl,
+		Standard_Integer&                   intf,
+		Standard_Integer&                   intl,
                 Handle(BRepAdaptor_HSurface)&       Surf1,
 		Handle(BRepAdaptor_HSurface)&       Surf2) 
 {
@@ -1736,8 +1736,8 @@ static void ChFi3d_Purge (Handle(ChFiDS_
 			  const ChFiDS_CommonPoint& VRef,
 			  const Standard_Boolean    isfirst,
 			  const Standard_Integer    ons,
-			  Standard_Boolean&         intf,
-			  Standard_Boolean&         intl)
+			  Standard_Integer&         intf,
+			  Standard_Integer&         intl)
 {
   if (isfirst) intf = 1; else intl = 1; // End.
   Standard_Integer opp = 3-ons;
@@ -1984,7 +1984,7 @@ void ChFi3d_Builder::PerformSetOfSurfOnE
   }
   Standard_Real         MaxStep  = (bidl-bidf)*0.05/nbed;
   Standard_Real         Firstsov = 0.;
-  Standard_Boolean      intf = 0, intl = 0;
+  Standard_Integer      intf = 0, intl = 0;
   while(!fini){
     // are these the ends (no extension on periodic).
     Ok1 = 1,Ok2 = 1;
Index: oce/src/ChFi3d/ChFi3d_Builder_6.cxx
===================================================================
--- oce.orig/src/ChFi3d/ChFi3d_Builder_6.cxx
+++ oce/src/ChFi3d/ChFi3d_Builder_6.cxx
@@ -1450,8 +1450,8 @@ Standard_Boolean ChFi3d_Builder::Compute
  const Standard_Boolean Appro,
  const Standard_Boolean Forward,
  const math_Vector& Soldep,
- Standard_Boolean& intf,
- Standard_Boolean& intl,
+ Standard_Integer& intf,
+ Standard_Integer& intl,
  Standard_Boolean& Gd1,
  Standard_Boolean& Gd2,
  Standard_Boolean& Gf1,
Index: oce/src/ChFi3d/ChFi3d_Builder_C1.cxx
===================================================================
--- oce.orig/src/ChFi3d/ChFi3d_Builder_C1.cxx
+++ oce/src/ChFi3d/ChFi3d_Builder_C1.cxx
@@ -2637,7 +2637,7 @@ void ChFi3d_Builder::PerformIntersection
               Pl=C1->Value(C1->LastParameter());
               //Standard_Boolean sens;
               sens=Pl.Distance(pext)<tolpt;
-              GeomLib::ExtendCurveToPoint(C1,CV1.Point(),1,sens);
+              GeomLib::ExtendCurveToPoint(C1,CV1.Point(),1,0!=sens);
               csau=C1;
             }
           }
@@ -2647,7 +2647,7 @@ void ChFi3d_Builder::PerformIntersection
               Pl=C1->Value(C1->LastParameter());
               //Standard_Boolean sens;
               sens=Pl.Distance(pext)<tolpt;
-              GeomLib::ExtendCurveToPoint(C1,CV2.Point(),1,sens);
+              GeomLib::ExtendCurveToPoint(C1,CV2.Point(),1,0!=sens);
               csau=C1;
             }
           }
Index: oce/src/ChFi3d/ChFi3d_Builder_C2.cxx
===================================================================
--- oce.orig/src/ChFi3d/ChFi3d_Builder_C2.cxx
+++ oce/src/ChFi3d/ChFi3d_Builder_C2.cxx
@@ -131,7 +131,7 @@ static void Reduce(const Standard_Real&
 //           path is used; 3D curve and 2 pcurves are approximated.
 //=======================================================================
 
-Standard_Integer ChFi3d_Builder::PerformTwoCornerbyInter(const Standard_Integer Index)
+Standard_Boolean ChFi3d_Builder::PerformTwoCornerbyInter(const Standard_Integer Index)
 
 {
   done = 0;
Index: oce/src/ChFi3d/ChFi3d_ChBuilder.cdl
===================================================================
--- oce.orig/src/ChFi3d/ChFi3d_ChBuilder.cdl
+++ oce/src/ChFi3d/ChFi3d_ChBuilder.cdl
@@ -199,7 +199,7 @@ is
 		  Forward         : Boolean from Standard;
 	          RecOnS1,RecOnS2 : Boolean from Standard;
 		  Soldep          : Vector from math;
-    	    	  Intf,Intl       : in out Boolean from Standard) 
+    	    	  Intf,Intl       : in out Integer from Standard)
 	returns  Boolean
     	is protected;
 
@@ -309,7 +309,7 @@ is
                 Forward         : Boolean from Standard;
                 RecOnS1,RecOnS2 : Boolean from Standard;
                 Soldep          : Vector from math;
-                Intf,Intl       : in out Boolean from Standard)
+                Intf,Intl       : in out Integer from Standard)
     returns  Boolean
     is redefined;	
     ---Purpose: Methode, implemented in inheritants, calculates
Index: oce/src/ChFi3d/ChFi3d_ChBuilder.cxx
===================================================================
--- oce.orig/src/ChFi3d/ChFi3d_ChBuilder.cxx
+++ oce/src/ChFi3d/ChFi3d_ChBuilder.cxx
@@ -796,8 +796,8 @@ ChFi3d_ChBuilder::SimulSurf(Handle(ChFiD
 			    const Standard_Boolean              RecOnS1,
 			    const Standard_Boolean              RecOnS2,
 			    const math_Vector&                  Soldep,
-			    Standard_Boolean&                   intf,
-			    Standard_Boolean&                   intl)
+			    Standard_Integer&                   intf,
+			    Standard_Integer&                   intl)
      
 {
   Handle(ChFiDS_ChamfSpine) 
@@ -888,7 +888,7 @@ ChFi3d_ChBuilder::SimulSurf(Handle(ChFiD
       if(cp1.IsOnArc()){
 	TopoDS_Face F1 = S1->ChangeSurface().Face();
 	TopoDS_Face bid;
-	ok = intf = !SearchFace(Spine,cp1,F1,bid);
+	intf = ok = !SearchFace(Spine,cp1,F1,bid);
       }
       const ChFiDS_CommonPoint& cp2 = Data->VertexFirstOnS2();
       if(cp2.IsOnArc() && !ok){
@@ -903,7 +903,7 @@ ChFi3d_ChBuilder::SimulSurf(Handle(ChFiD
       if(cp1.IsOnArc()){
 	TopoDS_Face F1 = S1->ChangeSurface().Face();
 	TopoDS_Face bid;
-	ok = intl = !SearchFace(Spine,cp1,F1,bid);
+	intl = ok = !SearchFace(Spine,cp1,F1,bid);
       }
       const ChFiDS_CommonPoint& cp2 = Data->VertexLastOnS2();
       if(cp2.IsOnArc() && !ok){
@@ -968,7 +968,7 @@ ChFi3d_ChBuilder::SimulSurf(Handle(ChFiD
       if(cp1.IsOnArc()){
 	TopoDS_Face F1 = S1->ChangeSurface().Face();
 	TopoDS_Face bid;
-	ok = intf = !SearchFace(Spine,cp1,F1,bid);
+	intf = ok = !SearchFace(Spine,cp1,F1,bid);
       }
       const ChFiDS_CommonPoint& cp2 = Data->VertexFirstOnS2();
       if(cp2.IsOnArc() && !ok){
@@ -983,7 +983,7 @@ ChFi3d_ChBuilder::SimulSurf(Handle(ChFiD
       if(cp1.IsOnArc()){
 	TopoDS_Face F1 = S1->ChangeSurface().Face();
 	TopoDS_Face bid;
-	ok = intl = !SearchFace(Spine,cp1,F1,bid);
+	intl = ok = !SearchFace(Spine,cp1,F1,bid);
       }
       const ChFiDS_CommonPoint& cp2 = Data->VertexLastOnS2();
       if(cp2.IsOnArc() && !ok){
@@ -1053,7 +1053,7 @@ ChFi3d_ChBuilder::SimulSurf(Handle(ChFiD
 	if(cp1.IsOnArc()){
 	  TopoDS_Face F1 = S1->ChangeSurface().Face();
 	  TopoDS_Face bid;
-	  ok = intf = !SearchFace(Spine,cp1,F1,bid);
+	  intf = ok = !SearchFace(Spine,cp1,F1,bid);
 	}
 	const ChFiDS_CommonPoint& cp2 = Data->VertexFirstOnS2();
 	if(cp2.IsOnArc() && !ok){
@@ -1069,7 +1069,7 @@ ChFi3d_ChBuilder::SimulSurf(Handle(ChFiD
 	if(cp1.IsOnArc()){
 	  TopoDS_Face F1 = S1->ChangeSurface().Face();
 	  TopoDS_Face bid;
-	  ok = intl = !SearchFace(Spine,cp1,F1,bid);
+	  intl = ok = !SearchFace(Spine,cp1,F1,bid);
 	}
 	const ChFiDS_CommonPoint& cp2 = Data->VertexLastOnS2();
 	if(cp2.IsOnArc() && !ok){
@@ -1137,7 +1137,7 @@ ChFi3d_ChBuilder::SimulSurf(Handle(ChFiD
 	if(cp1.IsOnArc()){
 	  TopoDS_Face F1 = S1->ChangeSurface().Face();
 	  TopoDS_Face bid;
-	  ok = intf = !SearchFace(Spine,cp1,F1,bid);
+	  intf = ok = !SearchFace(Spine,cp1,F1,bid);
 	}
 	const ChFiDS_CommonPoint& cp2 = Data->VertexFirstOnS2();
 	if(cp2.IsOnArc() && !ok){
@@ -1153,7 +1153,7 @@ ChFi3d_ChBuilder::SimulSurf(Handle(ChFiD
 	if(cp1.IsOnArc()){
 	  TopoDS_Face F1 = S1->ChangeSurface().Face();
 	  TopoDS_Face bid;
-	  ok = intl = !SearchFace(Spine,cp1,F1,bid);
+	  intl = ok = !SearchFace(Spine,cp1,F1,bid);
 	}
 	const ChFiDS_CommonPoint& cp2 = Data->VertexLastOnS2();
 	if(cp2.IsOnArc() && !ok){
@@ -1570,8 +1570,8 @@ ChFi3d_ChBuilder::PerformSurf(ChFiDS_Seq
 			      const Standard_Boolean              RecOnS1,
 			      const Standard_Boolean              RecOnS2,
 			      const math_Vector&                  Soldep,
-			      Standard_Boolean&                   intf,
-			      Standard_Boolean&                   intl)
+			      Standard_Integer&                   intf,
+			      Standard_Integer&                   intl)
      
 {
   Handle(ChFiDS_SurfData) Data = SeqData(1);
Index: oce/src/ChFi3d/ChFi3d_ChBuilder_C3.cxx
===================================================================
--- oce.orig/src/ChFi3d/ChFi3d_ChBuilder_C3.cxx
+++ oce/src/ChFi3d/ChFi3d_ChBuilder_C3.cxx
@@ -89,7 +89,7 @@
 //           points PntA, PntB, PntC
 //=======================================================================
 
-static int CoPlanar(const gp_Pnt  PntA,
+static Standard_Boolean CoPlanar(const gp_Pnt  PntA,
 	            const gp_Pnt  PntB,
 		    const gp_Pnt  PntC,
 		    const gp_Pnt  PntD)
Index: oce/src/ChFi3d/ChFi3d_FilBuilder.cdl
===================================================================
--- oce.orig/src/ChFi3d/ChFi3d_FilBuilder.cdl
+++ oce/src/ChFi3d/ChFi3d_FilBuilder.cdl
@@ -248,7 +248,7 @@ is
 		  Forward         : Boolean from Standard;
 	          RecOnS1,RecOnS2 : Boolean from Standard;
 		  Soldep          : Vector from math;
-    	    	  Intf,Intl       : in out Boolean from Standard)
+    	    	  Intf,Intl       : in out Integer from Standard)
         returns  Boolean  is protected;
 
         SimulSurf(me                   : in out; 
@@ -355,7 +355,7 @@ is
                     Forward         : Boolean from Standard;
 	            RecOnS1,RecOnS2 : Boolean from Standard;
 		    Soldep          : Vector from math;
-    	    	    Intf,Intl       : in out Boolean from Standard) 
+    	    	    Intf,Intl       : in out Integer from Standard)
 	returns  Boolean
     	is protected;
     	---Purpose: Method calculates the elements of construction of  the
Index: oce/src/ChFi3d/ChFi3d_FilBuilder.cxx
===================================================================
--- oce.orig/src/ChFi3d/ChFi3d_FilBuilder.cxx
+++ oce/src/ChFi3d/ChFi3d_FilBuilder.cxx
@@ -608,8 +608,8 @@ ChFi3d_FilBuilder::SimulSurf(Handle(ChFi
 			     const Standard_Boolean              RecOnS1,
 			     const Standard_Boolean              RecOnS2,
 			     const math_Vector&                  Soldep,
-			     Standard_Boolean&                   intf,
-			     Standard_Boolean&                   intl)
+			     Standard_Integer&                   intf,
+			     Standard_Integer&                   intl)
 {
   Handle(ChFiDS_FilSpine) fsp = Handle(ChFiDS_FilSpine)::DownCast(Spine);
   if(fsp.IsNull()) Standard_ConstructionError::Raise
@@ -698,7 +698,7 @@ ChFi3d_FilBuilder::SimulSurf(Handle(ChFi
     if(cp1.IsOnArc()){
       TopoDS_Face F1 = S1->ChangeSurface().Face();
       TopoDS_Face bid;
-      ok = intf = !SearchFace(Spine,cp1,F1,bid);
+      intf = ok = !SearchFace(Spine,cp1,F1,bid);
     }
     const ChFiDS_CommonPoint& cp2 = Data->VertexFirstOnS2();
     if(cp2.IsOnArc() && !ok){
@@ -713,7 +713,7 @@ ChFi3d_FilBuilder::SimulSurf(Handle(ChFi
     if(cp1.IsOnArc()){
       TopoDS_Face F1 = S1->ChangeSurface().Face();
       TopoDS_Face bid;
-      ok = intl = !SearchFace(Spine,cp1,F1,bid);
+      intl = ok = !SearchFace(Spine,cp1,F1,bid);
     }
     const ChFiDS_CommonPoint& cp2 = Data->VertexLastOnS2();
     if(cp2.IsOnArc() && !ok){
@@ -1237,8 +1237,8 @@ ChFi3d_FilBuilder::PerformSurf(ChFiDS_Se
 			       const Standard_Boolean              RecOnS1,
 			       const Standard_Boolean              RecOnS2,
 			       const math_Vector&                  Soldep,
-			       Standard_Boolean&                   intf,
-			       Standard_Boolean&                   intl)
+			       Standard_Integer&                   intf,
+			       Standard_Integer&                   intl)
 {
 #ifdef DEB
   OSD_Chronometer ch;
Index: oce/src/ChFi3d/ChFi3d_FilBuilder_C3.cxx
===================================================================
--- oce.orig/src/ChFi3d/ChFi3d_FilBuilder_C3.cxx
+++ oce/src/ChFi3d/ChFi3d_FilBuilder_C3.cxx
@@ -590,7 +590,7 @@ void ChFi3d_FilBuilder::PerformThreeCorn
 	finv.Set(Rdeb,choix);
 	Standard_Real TolGuide = cornerspine->Resolution(tolesp); 
 	
-	Standard_Boolean intf = 3, intl = 3;
+	Standard_Integer intf = 3, intl = 3;
 	done = ComputeData(coin,cornerspine,NullSpine,lin,Fac,IFac,Surf,ISurf,
 			   func,finv,ffi,pasmax,locfleche,TolGuide,ffi,lla,
 			   0,0,1,Soldep,intf,intl,Gd1,Gd2,Gf1,Gf2,0,1);
@@ -612,7 +612,7 @@ void ChFi3d_FilBuilder::PerformThreeCorn
 	func.Set(myShape);
 	finv.Set(choix);
 	Standard_Real TolGuide = cornerspine->Resolution(tolesp);
-	Standard_Boolean intf = 3, intl = 3;
+	Standard_Integer intf = 3, intl = 3;
 	done = ComputeData(coin,cornerspine,NullSpine,lin,Fac,IFac,Surf,ISurf,
 			   func,finv,ffi,pasmax,locfleche,TolGuide,ffi,lla,
 			   0,0,1,Soldep,intf,intl,Gd1,Gd2,Gf1,Gf2,0,1);
Index: oce/src/ChFiDS/ChFiDS_SurfData.lxx
===================================================================
--- oce.orig/src/ChFiDS/ChFiDS_SurfData.lxx
+++ oce/src/ChFiDS/ChFiDS_SurfData.lxx
@@ -52,7 +52,8 @@ inline Standard_Integer  ChFiDS_SurfData
 
 inline void ChFiDS_SurfData::SetIndexOfC1(const Standard_Integer Index)
 {
-  indexOfC1 = isoncurv1 = Index;
+  indexOfC1 = Index;
+  isoncurv1 = (0 != Index);
 }
 
 //=======================================================================
@@ -93,7 +94,8 @@ inline Standard_Integer  ChFiDS_SurfData
 
 inline void ChFiDS_SurfData::SetIndexOfC2(const Standard_Integer Index)
 {
-  indexOfC2 = isoncurv2 = Index;
+  indexOfC2 = Index;
+  isoncurv2 = (0 != Index);
 }
 
 //=======================================================================
Index: oce/src/DDataStd/DDataStd_BasicCommands.cxx
===================================================================
--- oce.orig/src/DDataStd/DDataStd_BasicCommands.cxx
+++ oce/src/DDataStd/DDataStd_BasicCommands.cxx
@@ -438,7 +438,7 @@ static Standard_Integer DDataStd_SetIntA
   Standard_Integer isDelta = Draw::Atoi(arg[3]);
   Standard_Integer From = Draw::Atoi(arg[4]), To = Draw::Atoi( arg[5] ), j;
   di << "Array of Standard_Integer with bounds from = " << From  << " to = " << To  << "\n";
-  Handle(TDataStd_IntegerArray) A = TDataStd_IntegerArray::Set(label, From, To, isDelta);
+  Handle(TDataStd_IntegerArray) A = TDataStd_IntegerArray::Set(label, From, To, 0 != isDelta);
   
   j = 6;
   for(Standard_Integer i = From; i<=To; i++) {
@@ -556,7 +556,7 @@ static Standard_Integer DDataStd_SetIntA
   Standard_Integer isDelta = Draw::Atoi(arg[3]);
   Standard_Integer From = Draw::Atoi(arg[4]), To = Draw::Atoi( arg[5] ), j;
   di << "Array of Standard_Integer with bounds from = " << From  << " to = " << To  << "\n";
-  Handle(TDataStd_IntegerArray) A = TDataStd_IntegerArray::Set(label, From, To, isDelta);
+  Handle(TDataStd_IntegerArray) A = TDataStd_IntegerArray::Set(label, From, To, 0 != isDelta);
   
   j = 6;
   Standard_Integer k = 100;
@@ -585,7 +585,7 @@ static Standard_Integer DDataStd_SetReal
  
   Standard_Integer From = Draw::Atoi(arg[4]), To = Draw::Atoi( arg[5] ), j;
   di << " Array of Standard_Real with bounds from = " << From  << " to = " << To  << "\n";
-  Handle(TDataStd_RealArray) A = TDataStd_RealArray::Set(label, From, To, isDelta);
+  Handle(TDataStd_RealArray) A = TDataStd_RealArray::Set(label, From, To, 0 != isDelta);
   
   j = 6;
   for(Standard_Integer i = From; i<=To; i++) { 
@@ -706,7 +706,7 @@ static Standard_Integer DDataStd_SetVari
     const char* aUnits = arg[4];
     aV->Unit(Standard_CString(aUnits));
 
-    aV->Constant(Standard_Boolean(Draw::Atoi(arg[3])));
+    aV->Constant(0 != Draw::Atoi(arg[3]));
     return 0; 
   }
 
@@ -912,7 +912,7 @@ static Standard_Integer DDataStd_SetExtS
 
   Standard_Integer From = Draw::Atoi(arg[4]), To = Draw::Atoi( arg[5] ), j;
   di << "Array of ExtString with bounds from = " << From  << " to = " << To  << "\n";
-  Handle(TDataStd_ExtStringArray) A = TDataStd_ExtStringArray::Set(label, From, To, isDelta);
+  Handle(TDataStd_ExtStringArray) A = TDataStd_ExtStringArray::Set(label, From, To, 0 != isDelta);
   
   j = 6;
   for(Standard_Integer i = From; i<=To; i++) {
@@ -1141,7 +1141,7 @@ static Standard_Integer DDataStd_SetByte
     Standard_Integer isDelta = Draw::Atoi(arg[3]);
     Standard_Integer From = Draw::Atoi(arg[4]), To = Draw::Atoi( arg[5] ), j;
     di << "Array of Standard_Integer with bounds from = " << From  << " to = " << To  << "\n";
-    Handle(TDataStd_ByteArray) A = TDataStd_ByteArray::Set(label, From, To, isDelta);
+    Handle(TDataStd_ByteArray) A = TDataStd_ByteArray::Set(label, From, To, 0 != isDelta);
     
     j = 6;
     for(Standard_Integer i = From; i<=To; ++i) {
@@ -1534,7 +1534,7 @@ static Standard_Integer DDataStd_SetIntP
     Standard_Integer aNum = nb - 4;
     Handle(TDataStd_IntPackedMap) anAtt;
     if(!aLabel.FindAttribute(TDataStd_IntPackedMap::GetID(), anAtt))
-      anAtt = TDataStd_IntPackedMap::Set(aLabel, isDelta);
+      anAtt = TDataStd_IntPackedMap::Set(aLabel, 0 != isDelta);
     if(anAtt.IsNull()) {
       di << "IntPackedMap attribute is not found or not set"  << "\n";
       return 1;}
@@ -1734,7 +1734,7 @@ static Standard_Integer DDataStd_SetIntP
     Standard_Integer aNum = Draw::Atoi(arg[4]);
     Handle(TDataStd_IntPackedMap) anAtt;
     if(!aLabel.FindAttribute(TDataStd_IntPackedMap::GetID(), anAtt))
-      anAtt = TDataStd_IntPackedMap::Set(aLabel, isDelta);
+      anAtt = TDataStd_IntPackedMap::Set(aLabel, 0 != isDelta);
     if(anAtt.IsNull()) {
       di << "IntPackedMap attribute is not found or not set"  << "\n";
       return 1;}
Index: oce/src/DDataStd/DDataStd_TreeCommands.cxx
===================================================================
--- oce.orig/src/DDataStd/DDataStd_TreeCommands.cxx
+++ oce/src/DDataStd/DDataStd_TreeCommands.cxx
@@ -381,7 +381,7 @@ static Standard_Integer DDataStd_ChildNo
   if (n >= 4) {
     Handle(TDF_Data) DF;
     if (!DDF::GetDF(a[1],DF)) return 1;
-    const Standard_Boolean AllLevels(Draw::Atoi(a[3]));
+    const Standard_Boolean AllLevels(0 != Draw::Atoi(a[3]));
     Handle(TDataStd_TreeNode) TN, Value;
 
     Standard_GUID ID;
@@ -444,7 +444,7 @@ static Standard_Integer DDataStd_InitChi
     }
 
     if (!DDF::Find(DF, a[2], ID, TN)) return 1; 
-    const Standard_Boolean AllLevels(Draw::Atoi(a[3]));
+    const Standard_Boolean AllLevels(0 != Draw::Atoi(a[3]));
     cni.Initialize(TN, AllLevels);
     return 0;
   }
Index: oce/src/DNaming/DNaming.cxx
===================================================================
--- oce.orig/src/DNaming/DNaming.cxx
+++ oce/src/DNaming/DNaming.cxx
@@ -326,7 +326,7 @@ static Standard_Boolean GetDangleShapes(
     const TopTools_ListOfShape& ancestors = subShapeAndAncestors.FindFromIndex(i);
     if (ancestors.Extent() == 1) Dangles.Bind(ancestors.First(), mayBeDangle);
   }
-  return Dangles.Extent();
+  return !Dangles.IsEmpty();
 }
 
 //=======================================================================
Index: oce/src/DNaming/DNaming_BasicCommands.cxx
===================================================================
--- oce.orig/src/DNaming/DNaming_BasicCommands.cxx
+++ oce/src/DNaming/DNaming_BasicCommands.cxx
@@ -383,7 +383,7 @@ static Standard_Integer Collect (Draw_In
     if (!DDF::GetDF(arg[1],DF)) return 1;
     if (!DDF::Find(DF,arg[2],TNaming_NamedShape::GetID(),A)) return 1;
     if (nb >= 4) {
-      OnlyModif = Draw::Atoi(arg[3]);
+      OnlyModif = (0 != Draw::Atoi(arg[3]));
     }
     TNaming_Tool::Collect(A,MNS,OnlyModif);
     for (TNaming_MapIteratorOfMapOfNamedShape it(MNS); it.More(); it.Next()) {
Index: oce/src/DNaming/DNaming_Line3DDriver.cxx
===================================================================
--- oce.orig/src/DNaming/DNaming_Line3DDriver.cxx
+++ oce/src/DNaming/DNaming_Line3DDriver.cxx
@@ -113,7 +113,7 @@ Standard_Integer DNaming_Line3DDriver::E
   }
 
   const Standard_Integer aType = DNaming::GetInteger(aFunction, LINE3D_TYPE)->Get();
-  Standard_Boolean isClosed(aType);
+  Standard_Boolean isClosed(0 != aType);
   Standard_Integer aCounter(0), aLength  = DNaming::GetInteger(aFunction, LINE3D_PNTNB)->Get();
   if(aLength < 2) {
     aFunction->SetFailure(WRONG_ARGUMENT);
Index: oce/src/DNaming/DNaming_ModelingCommands.cxx
===================================================================
--- oce.orig/src/DNaming/DNaming_ModelingCommands.cxx
+++ oce/src/DNaming/DNaming_ModelingCommands.cxx
@@ -681,10 +681,10 @@ static Standard_Integer DNaming_AttachSh
 	  aResultLabel.ForgetAllAttributes(Standard_True);
 	  Standard_Boolean aKeepOrientation(Standard_False);
 	  if (nb >= 6) 
-	    aKeepOrientation = (Standard_Boolean) Draw::Atoi(a[5]);
+	    aKeepOrientation = (0 != Draw::Atoi(a[5]));
 	  Standard_Boolean aGeometry(Standard_False);
 	  if (nb == 7) 
-	    aGeometry = (Standard_Boolean) Draw::Atoi(a[6]);
+	    aGeometry = (0 != Draw::Atoi(a[6]));
 	  Handle(TNaming_NamedShape) aCont =  DNaming::GetObjectValue(aContext);
 #ifdef DEBUG
 	  if(aCont.IsNull() || aCont->IsEmpty())
@@ -757,10 +757,10 @@ static Standard_Integer DNaming_XAttachS
 	  aResultLabel.ForgetAllAttributes(Standard_True);
 	  Standard_Boolean aKeepOrientation(Standard_False);
 	  if (nb >= 5) 
-	    aKeepOrientation = (Standard_Boolean) Draw::Atoi(a[4]);
+	    aKeepOrientation = (0 != Draw::Atoi(a[4]));
 	  Standard_Boolean aGeometry(Standard_False);
 	  if (nb == 6) 
-	    aGeometry = (Standard_Boolean) Draw::Atoi(a[5]);
+	    aGeometry = (0 != Draw::Atoi(a[5]));
 	  Handle(TNaming_NamedShape) aCont =  DNaming::GetObjectValue(aContext);
 
 	  if(aCont.IsNull() || aCont->IsEmpty())
@@ -1533,17 +1533,17 @@ static Standard_Integer DNaming_PntOffse
     Handle(TFunction_Function) aFun = GetFunction(objLabel,funGUID);
     if(!aFun.IsNull()) {
       Standard_Real value(0.0);
-      Standard_Boolean isDX = (strcmp(theArg[3],"skip"));
+      Standard_Boolean isDX = (0 != strcmp(theArg[3],"skip"));
       if(isDX) {
 	value = Draw::Atof(theArg[3]);
 	DNaming::GetReal(aFun,PNT_DX)->Set(value);
       }
-      Standard_Boolean isDY = (strcmp(theArg[4],"skip"));
+      Standard_Boolean isDY = (0 != strcmp(theArg[4],"skip"));
       if(isDY) {
 	value = Draw::Atof(theArg[4]);
 	DNaming::GetReal(aFun,PNT_DY)->Set(value);
       }
-      Standard_Boolean isDZ = (strcmp(theArg[5],"skip"));
+      Standard_Boolean isDZ = (0 != strcmp(theArg[5],"skip"));
       if(isDZ) {
 	value = Draw::Atof(theArg[5]);
 	DNaming::GetReal(aFun,PNT_DZ)->Set(value);
@@ -1900,11 +1900,11 @@ static Standard_Integer DNaming_TestSing
     Standard_Boolean XSelection(Standard_False);
     Standard_Boolean Geometry(Standard_False);
     if(theNb == 4)
-      Orientation = (Standard_Boolean)Draw::Atoi(theArg[3]);
+      Orientation = (0 != Draw::Atoi(theArg[3]));
     if(theNb == 5)
-      XSelection = (Standard_Boolean)Draw::Atoi(theArg[4]);
+      XSelection = (0 != Draw::Atoi(theArg[4]));
     if (theNb == 6) 
-      Geometry = (Standard_Boolean) Draw::Atoi(theArg[5]);
+      Geometry = (0 != Draw::Atoi(theArg[5]));
     Handle(TNaming_NamedShape) aNS = DNaming::GetObjectValue( aCntObj);
 
     if(!aNS.IsNull() && !aNS->IsEmpty()) {
@@ -2039,11 +2039,11 @@ static Standard_Integer DNaming_Multiple
     Standard_Boolean XSelection(Standard_False);
     Standard_Boolean Geometry(Standard_False);
     if(theNb == 4)
-      Orientation = (Standard_Boolean)Draw::Atoi(theArg[3]);
+      Orientation = (0 != Draw::Atoi(theArg[3]));
     if(theNb == 5)
-      XSelection = (Standard_Boolean)Draw::Atoi(theArg[4]);
+      XSelection = (0 != Draw::Atoi(theArg[4]));
     if (theNb == 6) 
-      Geometry = (Standard_Boolean) Draw::Atoi(theArg[5]);
+      Geometry = (0 != Draw::Atoi(theArg[5]));
     Handle(TNaming_NamedShape) aNS = DNaming::GetObjectValue( aCntObj);
 
     if(!aNS.IsNull() && !aNS->IsEmpty()) {
Index: oce/src/DNaming/DNaming_SelectionCommands.cxx
===================================================================
--- oce.orig/src/DNaming/DNaming_SelectionCommands.cxx
+++ oce/src/DNaming/DNaming_SelectionCommands.cxx
@@ -123,7 +123,7 @@ static Standard_Integer DNaming_Select (
     }
     if (n > 4) {  
       Standard_Boolean Orient(Standard_False);
-      if(n == 6) Orient = (Standard_Boolean)Draw::Atoi(a[5]);
+      if(n == 6) Orient = (0 != Draw::Atoi(a[5]));
       TopoDS_Shape S = DBRep::Get(a[3], TopAbs_SHAPE);
       TopoDS_Shape C = DBRep::Get(a[4], TopAbs_SHAPE);
       SL.Select (S, C, geometry, Orient);       
Index: oce/src/Draw/Draw_Interpretor.cxx
===================================================================
--- oce.orig/src/Draw/Draw_Interpretor.cxx
+++ oce/src/Draw/Draw_Interpretor.cxx
@@ -544,7 +544,7 @@ Standard_Boolean Draw_Interpretor::Compl
   Standard_PCharacter pLine;
   //
   pLine=(Standard_PCharacter)line;
-  return Tcl_CommandComplete(pLine);
+  return 0 != Tcl_CommandComplete(pLine);
 }
 
 //=======================================================================
Index: oce/src/Draw/Draw_Viewer.cxx
===================================================================
--- oce.orig/src/Draw/Draw_Viewer.cxx
+++ oce/src/Draw/Draw_Viewer.cxx
@@ -965,7 +965,7 @@ void Draw_Viewer::PostScriptView (const
     if (n == 0) return;
     CurrentMode = POSTSCRIPT;
     Draw_Display DF = MakeDisplay(id);
-    Standard_Boolean view2d = myViews[id]->Flag2d;
+    Standard_Boolean view2d = (0 != myViews[id]->Flag2d);
     for (Standard_Integer i = 1; i <= n; i++)
       if (myDrawables(i)->Is3D()) {
 	if (!view2d) myDrawables(i)->DrawOn(DF);
@@ -1157,7 +1157,7 @@ void Draw_Viewer::DrawOnView(const Stand
     xmin = ymin = DRAWINFINITE;
     xmax = ymax = -DRAWINFINITE;
 
-    Standard_Boolean view2d = myViews[id]->Flag2d;
+    Standard_Boolean view2d = (0 != myViews[id]->Flag2d);
     myViews[id]->ResetFrame();
     if ((D->Is3D() && !view2d) ||
 	(!D->Is3D() && view2d)) {
Index: oce/src/Extrema/Extrema_Curve2dTool.lxx
===================================================================
--- oce.orig/src/Extrema/Extrema_Curve2dTool.lxx
+++ oce/src/Extrema/Extrema_Curve2dTool.lxx
@@ -281,7 +281,7 @@ inline void Extrema_Curve2dTool::D2(cons
 
  inline Standard_Boolean Extrema_Curve2dTool::IsRational(const Adaptor2d_Curve2d& C)
 {
-  return C.Degree();
+  return 0 != C.Degree();
 }
 
 
Index: oce/src/FSD/FSD_BinaryFile.cxx
===================================================================
--- oce.orig/src/FSD/FSD_BinaryFile.cxx
+++ oce/src/FSD/FSD_BinaryFile.cxx
@@ -257,12 +257,14 @@ Storage_BaseDriver& FSD_BinaryFile::PutI
 
 Storage_BaseDriver& FSD_BinaryFile::PutBoolean(const Standard_Boolean aValue)
 {
+  // In OCCT, Standard_Boolean is an unsigned int
+  Standard_Integer iValue = aValue;
 #if DO_INVERSE
-  Standard_Integer t = InverseInt ((Standard_Integer) aValue);
+  Standard_Integer t = InverseInt (iValue);
   
   if (!fwrite(&t,sizeof(Standard_Integer),1,myStream)) Storage_StreamWriteError::Raise();
 #else
-  if (!fwrite(&aValue,sizeof(Standard_Boolean),1,myStream)) Storage_StreamWriteError::Raise();
+  if (!fwrite(&iValue,sizeof(Standard_Integer),1,myStream)) Storage_StreamWriteError::Raise();
 #endif
   return *this;
 }
@@ -365,11 +367,14 @@ Storage_BaseDriver& FSD_BinaryFile::GetI
 
 Storage_BaseDriver& FSD_BinaryFile::GetBoolean(Standard_Boolean& aValue)
 {
-  if (!fread(&aValue,sizeof(Standard_Boolean),1,myStream))
+  // In OCCT, Standard_Boolean is an unsigned int
+  Standard_Integer iValue;
+  if (!fread(&iValue,sizeof(Standard_Integer),1,myStream))
     Storage_StreamTypeMismatchError::Raise();
 #if DO_INVERSE
-  aValue = InverseInt ((Standard_Integer) aValue);
+  iValue = InverseInt (iValue);
 #endif
+  aValue = (0 != iValue);
   return *this;
 }
 
Index: oce/src/FilletSurf/FilletSurf_InternalBuilder.cdl
===================================================================
--- oce.orig/src/FilletSurf/FilletSurf_InternalBuilder.cdl
+++ oce/src/FilletSurf/FilletSurf_InternalBuilder.cdl
@@ -88,7 +88,7 @@ is
                 Forward         : Boolean from Standard;
 	        RecOnS1,RecOnS2 : Boolean from Standard;
 		Soldep          : Vector from math;
-    	    	Intf,Intl       : in out Boolean from Standard) 
+    	    	Intf,Intl       : in out Integer from Standard) 
     returns  Boolean
     is redefined protected;
     ---Purpose: This  method calculates the elements of construction of the
Index: oce/src/FilletSurf/FilletSurf_InternalBuilder.cxx
===================================================================
--- oce.orig/src/FilletSurf/FilletSurf_InternalBuilder.cxx
+++ oce/src/FilletSurf/FilletSurf_InternalBuilder.cxx
@@ -324,8 +324,8 @@ Standard_Boolean
 					 const Standard_Boolean RecOnS1, 
 					 const Standard_Boolean RecOnS2, 
 					 const math_Vector& Soldep, 
-					 Standard_Boolean& Intf, 
-					 Standard_Boolean& Intl)
+					 Standard_Integer& Intf, 
+					 Standard_Integer& Intl)
 {
   Handle(ChFiDS_SurfData) Data = SeqData(1);
   Handle(ChFiDS_FilSpine) fsp = Handle(ChFiDS_FilSpine)::DownCast(Spine);
@@ -383,7 +383,7 @@ Standard_Boolean
     if(cpf1.IsOnArc()){
       TopoDS_Face F1 = S1->ChangeSurface().Face();
       TopoDS_Face bid;
-      ok = Intf = !SearchFace(Spine,cpf1,F1,bid);
+      Intf = ok = !SearchFace(Spine,cpf1,F1,bid);
     }
     const ChFiDS_CommonPoint& cpf2 = Data->VertexFirstOnS2();
     if(cpf2.IsOnArc() && !ok){
@@ -398,7 +398,7 @@ Standard_Boolean
   if(cpl1.IsOnArc()){
     TopoDS_Face F1 = S1->ChangeSurface().Face();
     TopoDS_Face bid;
-    ok = Intl = !SearchFace(Spine,cpl1,F1,bid);
+    Intl = ok = !SearchFace(Spine,cpl1,F1,bid);
   }
   const ChFiDS_CommonPoint& cpl2 = Data->VertexLastOnS2();
   if(cpl2.IsOnArc() && !ok){
@@ -414,17 +414,17 @@ Standard_Boolean
   return Standard_True;
 }
 
-void FilletSurf_InternalBuilder::PerformSurf(ChFiDS_SequenceOfSurfData&, const Handle(ChFiDS_HElSpine)&, const Handle(ChFiDS_Spine)&, const int, const Handle(BRepAdaptor_HSurface)&, const Handle(Adaptor3d_TopolTool)&, const Handle(BRepAdaptor_HCurve2d)&, const Handle(BRepAdaptor_HSurface)&, const Handle(BRepAdaptor_HCurve2d)&, unsigned int&, const Handle(BRepAdaptor_HSurface)&, const Handle(Adaptor3d_TopolTool)&, const TopAbs_Orientation, const double, const double, const double, double&, double&, const unsigned int, const unsigned int, const unsigned int, const unsigned int, const unsigned int, const unsigned int, const math_Vector&)
+void FilletSurf_InternalBuilder::PerformSurf(ChFiDS_SequenceOfSurfData&, const Handle(ChFiDS_HElSpine)&, const Handle(ChFiDS_Spine)&, const Standard_Integer, const Handle(BRepAdaptor_HSurface)&, const Handle(Adaptor3d_TopolTool)&, const Handle(BRepAdaptor_HCurve2d)&, const Handle(BRepAdaptor_HSurface)&, const Handle(BRepAdaptor_HCurve2d)&, Standard_Boolean&, const Handle(BRepAdaptor_HSurface)&, const Handle(Adaptor3d_TopolTool)&, const TopAbs_Orientation, const Standard_Real, const Standard_Real, const Standard_Real, Standard_Real&, Standard_Real&, const Standard_Boolean, const Standard_Boolean, const Standard_Boolean, const Standard_Boolean, const Standard_Boolean, const Standard_Boolean, const math_Vector&)
 {
  Standard_DomainError::Raise("BlendFunc_CSConstRad::Section : Not implemented");
 }
 
-void FilletSurf_InternalBuilder::PerformSurf(ChFiDS_SequenceOfSurfData&, const Handle(ChFiDS_HElSpine)&, const Handle(ChFiDS_Spine)&, const int, const Handle(BRepAdaptor_HSurface)&, const Handle(Adaptor3d_TopolTool)&, const Handle(BRepAdaptor_HCurve2d)&, const Handle(BRepAdaptor_HSurface)&, const Handle(BRepAdaptor_HCurve2d)&, unsigned int&, const TopAbs_Orientation, const Handle(BRepAdaptor_HSurface)&, const Handle(Adaptor3d_TopolTool)&, const Handle(BRepAdaptor_HCurve2d)&, const Handle(BRepAdaptor_HSurface)&, const Handle(BRepAdaptor_HCurve2d)&, unsigned int&, const TopAbs_Orientation, const double, const double, const double, double&, double&, const unsigned int, const unsigned int, const unsigned int, const unsigned int, const unsigned int, const unsigned int, const unsigned int, const math_Vector&)
+void FilletSurf_InternalBuilder::PerformSurf(ChFiDS_SequenceOfSurfData&, const Handle(ChFiDS_HElSpine)&, const Handle(ChFiDS_Spine)&, const Standard_Integer, const Handle(BRepAdaptor_HSurface)&, const Handle(Adaptor3d_TopolTool)&, const TopAbs_Orientation, const Handle(BRepAdaptor_HSurface)&, const Handle(Adaptor3d_TopolTool)&, const Handle(BRepAdaptor_HCurve2d)&, const Handle(BRepAdaptor_HSurface)&, const Handle(BRepAdaptor_HCurve2d)&, Standard_Boolean&, const Standard_Real, const Standard_Real, const Standard_Real, Standard_Real&, Standard_Real&, const Standard_Boolean, const Standard_Boolean, const Standard_Boolean, const Standard_Boolean, const Standard_Boolean, const Standard_Boolean, const math_Vector&)
 {
  Standard_DomainError::Raise("BlendFunc_CSConstRad::Section : Not implemented");
 }
 
-void FilletSurf_InternalBuilder::PerformSurf(ChFiDS_SequenceOfSurfData&, const Handle(ChFiDS_HElSpine)&, const Handle(ChFiDS_Spine)&, const int, const Handle(BRepAdaptor_HSurface)&, const Handle(Adaptor3d_TopolTool)&, const TopAbs_Orientation, const Handle(BRepAdaptor_HSurface)&, const Handle(Adaptor3d_TopolTool)&, const Handle(BRepAdaptor_HCurve2d)&, const Handle(BRepAdaptor_HSurface)&, const Handle(BRepAdaptor_HCurve2d)&, unsigned int&, const double, const double, const double, double&, double&, const unsigned int, const unsigned int, const unsigned int, const unsigned int, const unsigned int, const unsigned int, const math_Vector&)
+void FilletSurf_InternalBuilder::PerformSurf(ChFiDS_SequenceOfSurfData&, const Handle(ChFiDS_HElSpine)&, const Handle(ChFiDS_Spine)&, const Standard_Integer, const Handle(BRepAdaptor_HSurface)&, const Handle(Adaptor3d_TopolTool)&, const Handle(BRepAdaptor_HCurve2d)&, const Handle(BRepAdaptor_HSurface)&, const Handle(BRepAdaptor_HCurve2d)&, Standard_Boolean&, const TopAbs_Orientation, const Handle(BRepAdaptor_HSurface)&, const Handle(Adaptor3d_TopolTool)&, const Handle(BRepAdaptor_HCurve2d)&, const Handle(BRepAdaptor_HSurface)&, const Handle(BRepAdaptor_HCurve2d)&, Standard_Boolean&, const TopAbs_Orientation, const Standard_Real, const Standard_Real, const Standard_Real, Standard_Real&, Standard_Real&, const Standard_Boolean, const Standard_Boolean, const Standard_Boolean, const Standard_Boolean, const Standard_Boolean, const Standard_Boolean, const Standard_Boolean, const math_Vector&)
 {
  Standard_DomainError::Raise("BlendFunc_CSConstRad::Section : Not implemented");
 }
Index: oce/src/Geom2d/Geom2d_BezierCurve.cxx
===================================================================
--- oce.orig/src/Geom2d/Geom2d_BezierCurve.cxx
+++ oce/src/Geom2d/Geom2d_BezierCurve.cxx
@@ -892,7 +892,7 @@ void Geom2d_BezierCurve::Init
 //Standard_Boolean Geom2d_BezierCurve::CoefficientsOK(const Standard_Real U)const
 Standard_Boolean Geom2d_BezierCurve::CoefficientsOK(const Standard_Real )const
 {
-  return (validcache) ;
+  return (0 != validcache) ;
 			
 }
 
Index: oce/src/GeometryTest/GeometryTest_CurveCommands.cxx
===================================================================
--- oce.orig/src/GeometryTest/GeometryTest_CurveCommands.cxx
+++ oce/src/GeometryTest/GeometryTest_CurveCommands.cxx
@@ -295,7 +295,7 @@ static Standard_Integer gproject(Draw_In
 
   Standard_Integer k;
   Standard_Real Udeb, Ufin, UIso, VIso;
-  Standard_Integer Only2d, Only3d;
+  Standard_Boolean Only2d, Only3d;
   gp_Pnt2d P2d, Pdeb, Pfin;
   gp_Pnt P;
   Handle(Adaptor2d_HCurve2d) HPCur;
Index: oce/src/HLRAlgo/HLRAlgo_BiPoint.cdl
===================================================================
--- oce.orig/src/HLRAlgo/HLRAlgo_BiPoint.cdl
+++ oce/src/HLRAlgo/HLRAlgo_BiPoint.cdl
@@ -34,8 +34,7 @@ is
     
     Create(X1,Y1,Z1,X2,Y2,Z2       : Real    from Standard;
            XT1,YT1,ZT1,XT2,YT2,ZT2 : Real    from Standard;
-           Index                   : Integer from Standard;
-           flag                    : Boolean from Standard)
+           Index,flag              : Integer from Standard)
     returns BiPoint from HLRAlgo; 
     
     Create(X1,Y1,Z1,X2,Y2,Z2       : Real    from Standard;
@@ -46,8 +45,7 @@ is
     
     Create(X1,Y1,Z1,X2,Y2,Z2       : Real    from Standard;
            XT1,YT1,ZT1,XT2,YT2,ZT2 : Real    from Standard;
-           Index,i1,i1p1,i1p2      : Integer from Standard;
-           flag                    : Boolean from Standard)
+           Index,i1,i1p1,i1p2,flag : Integer from Standard)
     returns BiPoint from HLRAlgo; 
     
     Create(X1,Y1,Z1,X2,Y2,Z2               : Real    from Standard;
@@ -59,7 +57,7 @@ is
     Create(X1,Y1,Z1,X2,Y2,Z2               : Real    from Standard;
            XT1,YT1,ZT1,XT2,YT2,ZT2         : Real    from Standard;
            Index,i1,i1p1,i1p2,i2,i2p1,i2p2 : Integer from Standard;
-           flag                            : Boolean from Standard)
+           flag                            : Integer from Standard)
     returns BiPoint from HLRAlgo; 
     
     Rg1Line(me) returns Boolean from Standard
Index: oce/src/HLRAlgo/HLRAlgo_BiPoint.cxx
===================================================================
--- oce.orig/src/HLRAlgo/HLRAlgo_BiPoint.cxx
+++ oce/src/HLRAlgo/HLRAlgo_BiPoint.cxx
@@ -107,7 +107,7 @@ HLRAlgo_BiPoint::HLRAlgo_BiPoint (const
 				  const Standard_Real YT2,
 				  const Standard_Real ZT2,
 				  const Standard_Integer Index,
-				  const Standard_Boolean flag)
+				  const Standard_Integer flag)
 {
   PntX1 = X1;
   PntY1 = Y1;
@@ -200,7 +200,7 @@ HLRAlgo_BiPoint::HLRAlgo_BiPoint (const
 				  const Standard_Integer i1,
 				  const Standard_Integer i1p1,
 				  const Standard_Integer i1p2,
-				  const Standard_Boolean flag)
+				  const Standard_Integer flag)
 {
   PntX1 = X1;
   PntY1 = Y1;
@@ -303,7 +303,7 @@ HLRAlgo_BiPoint::HLRAlgo_BiPoint (const
 				  const Standard_Integer i2,
 				  const Standard_Integer i2p1,
 				  const Standard_Integer i2p2,
-				  const Standard_Boolean flag)
+				  const Standard_Integer flag)
 {
   PntX1 = X1;
   PntY1 = Y1;
Index: oce/src/HLRAlgo/HLRAlgo_BiPoint.lxx
===================================================================
--- oce.orig/src/HLRAlgo/HLRAlgo_BiPoint.lxx
+++ oce/src/HLRAlgo/HLRAlgo_BiPoint.lxx
@@ -14,11 +14,11 @@
 // Alternatively, this file may be used under the terms of Open CASCADE
 // commercial license or contractual agreement.
 
-#define EMskRg1Line  ((Standard_Boolean)1)
-#define EMskRgNLine  ((Standard_Boolean)2)
-#define EMskOutLine  ((Standard_Boolean)4)
-#define EMskIntLine  ((Standard_Boolean)8)
-#define EMskHidden   ((Standard_Boolean)16)
+#define EMskRg1Line  0x01u
+#define EMskRgNLine  0x02u
+#define EMskOutLine  0x04u
+#define EMskIntLine  0x08u
+#define EMskHidden   0x10u
 
 //=======================================================================
 //function : HLRAlgo_BiPoint
Index: oce/src/HLRAlgo/HLRAlgo_EdgeStatus.cdl
===================================================================
--- oce.orig/src/HLRAlgo/HLRAlgo_EdgeStatus.cdl
+++ oce/src/HLRAlgo/HLRAlgo_EdgeStatus.cdl
@@ -121,7 +121,7 @@ fields
     myEnd         : Real      from Standard;
     myTolStart    : ShortReal from Standard;
     myTolEnd      : ShortReal from Standard;
-    myFlags       : Boolean   from Standard;
+    myFlags       : Integer   from Standard;
     myVisibles    : Intervals from Intrv;
 
 end EdgeStatus;
Index: oce/src/HLRAlgo/HLRAlgo_EdgeStatus.lxx
===================================================================
--- oce.orig/src/HLRAlgo/HLRAlgo_EdgeStatus.lxx
+++ oce/src/HLRAlgo/HLRAlgo_EdgeStatus.lxx
@@ -14,8 +14,8 @@
 // Alternatively, this file may be used under the terms of Open CASCADE
 // commercial license or contractual agreement.
 
-#define EMaskAllHidden  ((Standard_Boolean)1)
-#define EMaskAllVisible ((Standard_Boolean)2)
+#define EMaskAllHidden    0x01u
+#define EMaskAllVisible   0x02u
 
 //=======================================================================
 //function : Bounds
Index: oce/src/HLRAlgo/HLRAlgo_EdgesBlock.cdl
===================================================================
--- oce.orig/src/HLRAlgo/HLRAlgo_EdgesBlock.cdl
+++ oce/src/HLRAlgo/HLRAlgo_EdgesBlock.cdl
@@ -115,7 +115,7 @@ is
 
 fields
     myEdges  : Array1OfInteger from TColStd;
-    myFlags  : Array1OfBoolean from TColStd;
+    myFlags  : Array1OfInteger from TColStd;
     myMinMax : Integer         from Standard[16];
 
 end EdgesBlock;
Index: oce/src/HLRAlgo/HLRAlgo_EdgesBlock.lxx
===================================================================
--- oce.orig/src/HLRAlgo/HLRAlgo_EdgesBlock.lxx
+++ oce/src/HLRAlgo/HLRAlgo_EdgesBlock.lxx
@@ -14,11 +14,11 @@
 // Alternatively, this file may be used under the terms of Open CASCADE
 // commercial license or contractual agreement.
 
-#define EMaskOrient   ((Standard_Boolean)15)
-#define EMaskOutLine  ((Standard_Boolean)16)
-#define EMaskInternal ((Standard_Boolean)32)
-#define EMaskDouble   ((Standard_Boolean)64)
-#define EMaskIsoLine  ((Standard_Boolean)128)
+#define EMaskOrient    0x0fu
+#define EMaskOutLine   0x10u
+#define EMaskInternal  0x20u
+#define EMaskDouble    0x40u
+#define EMaskIsoLine   0x80u
 
 //=======================================================================
 //function : NbEdges
@@ -73,7 +73,7 @@ HLRAlgo_EdgesBlock::Orientation (const S
 				 const TopAbs_Orientation Or)
 {
   myFlags(I) &= ~EMaskOrient;
-  myFlags(I) |= (((Standard_Boolean)Or) & EMaskOrient);
+  myFlags(I) |= (0 != (Or & EMaskOrient));
 }
 
 //=======================================================================
Index: oce/src/HLRAlgo/HLRAlgo_PolyAlgo.cxx
===================================================================
--- oce.orig/src/HLRAlgo/HLRAlgo_PolyAlgo.cxx
+++ oce/src/HLRAlgo/HLRAlgo_PolyAlgo.cxx
@@ -24,15 +24,15 @@
 #include <HLRAlgo_BiPoint.hxx>
 #include <Precision.hxx>
 
-#define EMskGrALin1  ((Standard_Boolean)   8)
-#define EMskGrALin2  ((Standard_Boolean)  16)
-#define EMskGrALin3  ((Standard_Boolean)  32)
-#define FMskHiding   ((Standard_Boolean) 256)
+#define EMskGrALin1  0x008u
+#define EMskGrALin2  0x010u
+#define EMskGrALin3  0x020u
+#define FMskHiding   0x100u
 
 #define TriNode1 ((Standard_Integer*)TriIndices)[0]
 #define TriNode2 ((Standard_Integer*)TriIndices)[1]
 #define TriNode3 ((Standard_Integer*)TriIndices)[2]
-#define TriFlags ((Standard_Boolean*)TriIndices)[3]
+#define TriFlags ((Standard_Integer*)TriIndices)[3]
 
 #define XV1          myRealPtr[0]
 #define XV2          myRealPtr[1]
Index: oce/src/HLRAlgo/HLRAlgo_PolyData.cdl
===================================================================
--- oce.orig/src/HLRAlgo/HLRAlgo_PolyData.cdl
+++ oce/src/HLRAlgo/HLRAlgo_PolyData.cdl
@@ -84,8 +84,9 @@ is
     HideByOneTriangle(me          : mutable;
 		      Coordinates :     Address    from Standard;
                       RealPtr     :     Address    from Standard;
-                      BooleanPtr  :     Address    from Standard;
-                      PlanPtr     :     Address    from Standard;
+                      Crossing    :     Boolean    from Standard;
+                      HideBefore  :     Boolean    from Standard;
+                      TrFlags     :     Integer    from Standard;
 		      status      : out EdgeStatus from HLRAlgo)
 	---Purpose: evident.
     is static private;
Index: oce/src/HLRAlgo/HLRAlgo_PolyData.cxx
===================================================================
--- oce.orig/src/HLRAlgo/HLRAlgo_PolyData.cxx
+++ oce/src/HLRAlgo/HLRAlgo_PolyData.cxx
@@ -19,10 +19,10 @@
 #endif
 #include <HLRAlgo_PolyData.ixx>
 
-#define EMskGrALin1  ((Standard_Boolean)   8)
-#define EMskGrALin2  ((Standard_Boolean)  16)
-#define EMskGrALin3  ((Standard_Boolean)  32)
-#define FMskHiding   ((Standard_Boolean) 256)
+#define EMskGrALin1  0x008u
+#define EMskGrALin2  0x010u
+#define EMskGrALin3  0x020u
+#define FMskHiding   0x100u
 
 #define FIndex  myIndices[0]
 #define MinFac  myIndices[1]
@@ -31,15 +31,7 @@
 #define TriNode1   ((Standard_Integer*)TriIndices)[0]
 #define TriNode2   ((Standard_Integer*)TriIndices)[1]
 #define TriNode3   ((Standard_Integer*)TriIndices)[2]
-#define TriFlags   ((Standard_Boolean*)TriIndices)[3]
-
-#define Crossing   ((Standard_Boolean*)BooleanPtr)[0]
-#define HideBefore ((Standard_Boolean*)BooleanPtr)[1]
-#define TrFlags    ((Standard_Boolean*)BooleanPtr)[2]
-
-#define Crosi      BooleanPtr[0]
-#define HdBef      BooleanPtr[1]
-#define TFlag      BooleanPtr[2]
+#define TriFlags   ((Standard_Integer*)TriIndices)[3]
 
 #define PntX1  ((Standard_Real*)Coordinates)[ 0]
 #define PntY1  ((Standard_Real*)Coordinates)[ 1]
@@ -195,7 +187,8 @@ void HLRAlgo_PolyData::HideByPolyData (c
     HLRAlgo_Array1OfPHDat& PHDat = myHPHDat->ChangeArray1();
     const HLRAlgo_Array1OfTData& TData = myHTData->Array1();
     Standard_Real d1,d2;
-    Standard_Boolean NotConnex,BooleanPtr[3];
+    Standard_Boolean NotConnex,Crosi, HdBef = Standard_False;
+    Standard_Integer TFlag;
     Standard_Address PlanPtr,MinMaxPtr,TriIndices;
     Standard_Integer h,h2 = PHDat.Upper();
     HLRAlgo_PolyHidingData* PH = &(PHDat(1));
@@ -246,8 +239,7 @@ void HLRAlgo_PolyData::HideByPolyData (c
 	      YV3 = P3.Y();
 	      HideByOneTriangle(Coordinates,
 				RealPtr,
-				&BooleanPtr,
-				PlanPtr,
+				Crosi, HdBef, TFlag,
 				status);
 	    }
 	  }
@@ -269,8 +261,7 @@ void HLRAlgo_PolyData::HideByPolyData (c
 	      YV3 = P3.Y();
 	      HideByOneTriangle(Coordinates,
 				RealPtr,
-				&BooleanPtr,
-				PlanPtr,
+				Crosi, HdBef, TFlag,
 				status);
 	    }
 	    else {
@@ -288,8 +279,7 @@ void HLRAlgo_PolyData::HideByPolyData (c
 	      YV3 = P3.Y();
 	      HideByOneTriangle(Coordinates,
 				RealPtr,
-				&BooleanPtr,
-				PlanPtr,
+				Crosi, HdBef, TFlag,
 				status);
 	    }
 	  }
@@ -308,8 +298,7 @@ void HLRAlgo_PolyData::HideByPolyData (c
 	    YV3 = P3.Y();
 	    HideByOneTriangle(Coordinates,
 			      RealPtr,
-			      &BooleanPtr,
-			      PlanPtr,
+			      Crosi, HdBef, TFlag,
 			      status);
 	  }
 	}
@@ -327,8 +316,7 @@ void HLRAlgo_PolyData::HideByPolyData (c
 void HLRAlgo_PolyData::
 HideByOneTriangle (const Standard_Address Coordinates,
 		   const Standard_Address RealPtr,
-		   const Standard_Address BooleanPtr,
-		   const Standard_Address ,
+		   const Standard_Boolean Crossing, const Standard_Boolean HideBefore, const Standard_Integer TrFlags,
 		   HLRAlgo_EdgeStatus& status)
 {
   Standard_Boolean o[2],m[2];
@@ -433,7 +421,7 @@ HideByOneTriangle (const Standard_Addres
 	if (m[l]) {
 	  OutSideP = Standard_True;
 
-	  if (o[l] != (Standard_Boolean)(n1 == -1)) {
+	  if (o[l] != (n1 == -1)) {
 	    if (l == 0 && npi == 1) {
 	      p[0] = p[1];
 	      o[0] = o[1];
@@ -452,7 +440,7 @@ HideByOneTriangle (const Standard_Addres
       for (l = 0; l <= npi; l++) {
 	if (m[l]) {
 	  OutSideP = Standard_True;
-	  if (o[l] != (Standard_Boolean)(n1 == -1)) {
+	  if (o[l] != (n1 == -1)) {
 	    if (l == 0 && npi == 1) {
 	      p[0] = p[1];
 	      o[0] = o[1];
@@ -578,7 +566,7 @@ HideByOneTriangle (const Standard_Addres
       for (l = 0; l <= npi; l++) {
 	if (m[l]) {
 	  OutSideP = Standard_True;
-	  if (o[l] != (Standard_Boolean)(n1 == -1)) {
+	  if (o[l] != (n1 == -1)) {
 	    if (l == 0 && npi == 1) {
 	      p[0] = p[1];
 	      o[0] = o[1];
@@ -597,7 +585,7 @@ HideByOneTriangle (const Standard_Addres
       for (l = 0; l <= npi; l++) {
 	if (m[l]) {
 	  OutSideP = Standard_True;
-	  if (o[l] != (Standard_Boolean)(n1 == -1)) {
+	  if (o[l] != (n1 == -1)) {
 	    if (l == 0 && npi == 1) {
 	      p[0] = p[1];
 	      o[0] = o[1];
@@ -723,7 +711,7 @@ HideByOneTriangle (const Standard_Addres
       for (l = 0; l <= npi; l++) {
 	if (m[l]) {
 	  OutSideP = Standard_True;
-	  if (o[l] != (Standard_Boolean)(n1 == -1)) {
+	  if (o[l] != (n1 == -1)) {
 	    if (l == 0 && npi == 1) {
 	      p[0] = p[1];
 	      o[0] = o[1];
@@ -742,7 +730,7 @@ HideByOneTriangle (const Standard_Addres
       for (l = 0; l <= npi; l++) {
 	if (m[l]) {
 	  OutSideP = Standard_True;
-	  if (o[l] != (Standard_Boolean)(n1 == -1)) {
+	  if (o[l] != (n1 == -1)) {
 	    if (l == 0 && npi == 1) {
 	      p[0] = p[1];
 	      o[0] = o[1];
Index: oce/src/HLRBRep/HLRBRep_BiPnt2D.cdl
===================================================================
--- oce.orig/src/HLRBRep/HLRBRep_BiPnt2D.cdl
+++ oce/src/HLRBRep/HLRBRep_BiPnt2D.cdl
@@ -88,6 +88,6 @@ fields
     myP1    : Pnt2d   from gp;
     myP2    : Pnt2d   from gp;
     myShape : Shape   from TopoDS;
-    myFlags : Boolean from Standard;
+    myFlags : Integer from Standard;
 
 end BiPnt2D;
Index: oce/src/HLRBRep/HLRBRep_BiPnt2D.lxx
===================================================================
--- oce.orig/src/HLRBRep/HLRBRep_BiPnt2D.lxx
+++ oce/src/HLRBRep/HLRBRep_BiPnt2D.lxx
@@ -14,10 +14,10 @@
 // Alternatively, this file may be used under the terms of Open CASCADE
 // commercial license or contractual agreement.
 
-#define EMskRg1Line  ((Standard_Boolean)1)
-#define EMskRgNLine  ((Standard_Boolean)2)
-#define EMskOutLine  ((Standard_Boolean)4)
-#define EMskIntLine  ((Standard_Boolean)8)
+#define EMskRg1Line    0x01u
+#define EMskRgNLine    0x02u
+#define EMskOutLine    0x04u
+#define EMskIntLine    0x08u
 
 //=======================================================================
 //function : P1
Index: oce/src/HLRBRep/HLRBRep_BiPoint.cdl
===================================================================
--- oce.orig/src/HLRBRep/HLRBRep_BiPoint.cdl
+++ oce/src/HLRBRep/HLRBRep_BiPoint.cdl
@@ -88,6 +88,6 @@ fields
     myP1    : Pnt     from gp;
     myP2    : Pnt     from gp;
     myShape : Shape   from TopoDS;
-    myFlags : Boolean from Standard;
+    myFlags : Integer from Standard;
 
 end BiPoint;
Index: oce/src/HLRBRep/HLRBRep_BiPoint.lxx
===================================================================
--- oce.orig/src/HLRBRep/HLRBRep_BiPoint.lxx
+++ oce/src/HLRBRep/HLRBRep_BiPoint.lxx
@@ -14,10 +14,10 @@
 // Alternatively, this file may be used under the terms of Open CASCADE
 // commercial license or contractual agreement.
 
-#define EMskRg1Line  ((Standard_Boolean)1)
-#define EMskRgNLine  ((Standard_Boolean)2)
-#define EMskOutLine  ((Standard_Boolean)4)
-#define EMskIntLine  ((Standard_Boolean)8)
+#define EMskRg1Line    0x01u
+#define EMskRgNLine    0x02u
+#define EMskOutLine    0x04u
+#define EMskIntLine    0x08u
 
 //=======================================================================
 //function : P1
Index: oce/src/HLRBRep/HLRBRep_EdgeData.cdl
===================================================================
--- oce.orig/src/HLRBRep/HLRBRep_EdgeData.cdl
+++ oce/src/HLRBRep/HLRBRep_EdgeData.cdl
@@ -202,7 +202,7 @@ is
     is static;
 
 fields
-    myFlags     : Boolean    from Standard;
+    myFlags     : Integer    from Standard;
     myHideCount : Integer    from Standard;
     myVSta      : Integer    from Standard;
     myVEnd      : Integer    from Standard;
Index: oce/src/HLRBRep/HLRBRep_EdgeData.lxx
===================================================================
--- oce.orig/src/HLRBRep/HLRBRep_EdgeData.lxx
+++ oce/src/HLRBRep/HLRBRep_EdgeData.lxx
@@ -14,19 +14,19 @@
 // Alternatively, this file may be used under the terms of Open CASCADE
 // commercial license or contractual agreement.
 
-#define EMaskSelected ((Standard_Boolean)1)
-#define EMaskUsed     ((Standard_Boolean)2)
-#define EMaskRg1Line  ((Standard_Boolean)4)
-#define EMaskVertical ((Standard_Boolean)8)
-#define EMaskSimple   ((Standard_Boolean)16)
-#define EMaskOutLVSta ((Standard_Boolean)32)
-#define EMaskOutLVEnd ((Standard_Boolean)64)
-#define EMaskIntDone  ((Standard_Boolean)128)
-#define EMaskCutAtSta ((Standard_Boolean)256)
-#define EMaskCutAtEnd ((Standard_Boolean)512)
-#define EMaskVerAtSta ((Standard_Boolean)1024)
-#define EMaskVerAtEnd ((Standard_Boolean)2048)
-#define EMaskRgNLine  ((Standard_Boolean)4096)
+#define EMaskSelected   0x0001u
+#define EMaskUsed       0x0002u
+#define EMaskRg1Line    0x0004u
+#define EMaskVertical   0x0008u
+#define EMaskSimple     0x0010u
+#define EMaskOutLVSta   0x0020u
+#define EMaskOutLVEnd   0x0040u
+#define EMaskIntDone    0x0080u
+#define EMaskCutAtSta   0x0100u
+#define EMaskCutAtEnd   0x0200u
+#define EMaskVerAtSta   0x0400u
+#define EMaskVerAtEnd   0x0800u
+#define EMaskRgNLine    0x1000u
 
 //=======================================================================
 //function : Selected
Index: oce/src/HLRBRep/HLRBRep_FaceData.cdl
===================================================================
--- oce.orig/src/HLRBRep/HLRBRep_FaceData.cdl
+++ oce/src/HLRBRep/HLRBRep_FaceData.cdl
@@ -184,7 +184,7 @@ is
     is static;
 
 fields
-    myFlags       : Boolean    from Standard;
+    myFlags       : Integer    from Standard;
     myWires       : WiresBlock from HLRAlgo;
     myGeometry    : Surface    from HLRBRep;
     mySize        : Real       from Standard;
Index: oce/src/HLRBRep/HLRBRep_FaceData.lxx
===================================================================
--- oce.orig/src/HLRBRep/HLRBRep_FaceData.lxx
+++ oce/src/HLRBRep/HLRBRep_FaceData.lxx
@@ -14,20 +14,20 @@
 // Alternatively, this file may be used under the terms of Open CASCADE
 // commercial license or contractual agreement.
 
-#define EMaskOrient   ((Standard_Boolean)15)
-#define FMaskSelected ((Standard_Boolean)16)
-#define FMaskBack     ((Standard_Boolean)32)
-#define FMaskSide     ((Standard_Boolean)64)
-#define FMaskClosed   ((Standard_Boolean)128)
-#define FMaskHiding   ((Standard_Boolean)256)
-#define FMaskSimple   ((Standard_Boolean)512)
-#define FMaskCut      ((Standard_Boolean)1024)
-#define FMaskWithOutL ((Standard_Boolean)2048)
-#define FMaskPlane    ((Standard_Boolean)4096)
-#define FMaskCylinder ((Standard_Boolean)8192)
-#define FMaskCone     ((Standard_Boolean)16384)
-#define FMaskSphere   ((Standard_Boolean)32768)
-#define FMaskTorus    ((Standard_Boolean)65536)
+#define EMaskOrient     0x0000fu
+#define FMaskSelected   0x00010u
+#define FMaskBack       0x00020u
+#define FMaskSide       0x00040u
+#define FMaskClosed     0x00080u
+#define FMaskHiding     0x00100u
+#define FMaskSimple     0x00200u
+#define FMaskCut        0x00400u
+#define FMaskWithOutL   0x00800u
+#define FMaskPlane      0x01000u
+#define FMaskCylinder   0x02000u
+#define FMaskCone       0x04000u
+#define FMaskSphere     0x08000u
+#define FMaskTorus      0x10000u
 
 //=======================================================================
 //function : Selected
@@ -308,7 +308,7 @@ inline TopAbs_Orientation HLRBRep_FaceDa
 inline void HLRBRep_FaceData::Orientation(const TopAbs_Orientation O)
 {
   myFlags &= ~EMaskOrient;
-  myFlags |= (((Standard_Boolean)O) & EMaskOrient);
+  myFlags |= (0 != (O & EMaskOrient));
 }
 
 //=======================================================================
Index: oce/src/HLRBRep/HLRBRep_PolyAlgo.cdl
===================================================================
--- oce.orig/src/HLRBRep/HLRBRep_PolyAlgo.cdl
+++ oce/src/HLRBRep/HLRBRep_PolyAlgo.cdl
@@ -321,7 +321,7 @@ is
 	              coef3          :     Real             from Standard;
 	              U3             :     Real             from Standard;
                       insP3,mP3P1    :     Boolean          from Standard; 
-		      flag           :     Boolean          from Standard)
+		      flag           :     Integer          from Standard)
     is static private;
 
     MoveOrInsertPoint(me;
@@ -355,7 +355,7 @@ is
 	              coef3          :     Real             from Standard;
 	              U3             :     Real             from Standard;
                       insP3,mP3P1    :     Boolean          from Standard; 
-		      flag           :     Boolean          from Standard)
+		      flag           :     Integer          from Standard)
     is static private;
 
     MoveOrInsertPoint(me;
@@ -394,7 +394,7 @@ is
 	              coef4          :     Real             from Standard;
 	              U4             :     Real             from Standard;
                       insP4,mP4P1    :     Boolean          from Standard; 
-		      flag           :     Boolean          from Standard)
+		      flag           :     Integer          from Standard)
     is static private;
 
     InsertOnOutLine(me  : mutable;
Index: oce/src/HLRBRep/HLRBRep_PolyAlgo.cxx
===================================================================
--- oce.orig/src/HLRBRep/HLRBRep_PolyAlgo.cxx
+++ oce/src/HLRBRep/HLRBRep_PolyAlgo.cxx
@@ -46,26 +46,26 @@
 #include <Precision.hxx>
 #include <gp.hxx>
 
-#define EMskOutLin1  ((Standard_Boolean)   1)
-#define EMskOutLin2  ((Standard_Boolean)   2)
-#define EMskOutLin3  ((Standard_Boolean)   4)
-#define EMskGrALin1  ((Standard_Boolean)   8)
-#define EMskGrALin2  ((Standard_Boolean)  16)
-#define EMskGrALin3  ((Standard_Boolean)  32)
-#define FMskBack     ((Standard_Boolean)  64)
-#define FMskSide     ((Standard_Boolean) 128)
-#define FMskHiding   ((Standard_Boolean) 256)
-#define FMskFlat     ((Standard_Boolean) 512)
-#define FMskOnOutL   ((Standard_Boolean)1024)
-#define FMskOrBack   ((Standard_Boolean)2048)
-#define FMskFrBack   ((Standard_Boolean)4096)
-
-#define NMskVert ((Standard_Boolean) 1)
-#define NMskOutL ((Standard_Boolean) 2)
-#define NMskNorm ((Standard_Boolean) 4)
-#define NMskFuck ((Standard_Boolean) 8)
-#define NMskEdge ((Standard_Boolean)16)
-#define NMskMove ((Standard_Boolean)32)
+#define EMskOutLin1  0x0001u
+#define EMskOutLin2  0x0002u
+#define EMskOutLin3  0x0004u
+#define EMskGrALin1  0x0008u
+#define EMskGrALin2  0x0010u
+#define EMskGrALin3  0x0020u
+#define FMskBack     0x0040u
+#define FMskSide     0x0080u
+#define FMskHiding   0x0100u
+#define FMskFlat     0x0200u
+#define FMskOnOutL   0x0400u
+#define FMskOrBack   0x0800u
+#define FMskFrBack   0x1000u
+
+#define NMskVert  0x01u
+#define NMskOutL  0x02u
+#define NMskNorm  0x04u
+#define NMskFuck  0x08u
+#define NMskEdge  0x10u
+#define NMskMove  0x20u
 
 #define PntXTI1 ((Standard_Real*)Coordinates)[ 0]
 #define PntYTI1 ((Standard_Real*)Coordinates)[ 1]
@@ -96,17 +96,17 @@
 #define Tri1Node1 ((Standard_Integer*)Tri1Indices)[0]
 #define Tri1Node2 ((Standard_Integer*)Tri1Indices)[1]
 #define Tri1Node3 ((Standard_Integer*)Tri1Indices)[2]
-#define Tri1Flags ((Standard_Boolean*)Tri1Indices)[3]
+#define Tri1Flags ((Standard_Integer*)Tri1Indices)[3]
 
 #define Tri2Node1 ((Standard_Integer*)Tri2Indices)[0]
 #define Tri2Node2 ((Standard_Integer*)Tri2Indices)[1]
 #define Tri2Node3 ((Standard_Integer*)Tri2Indices)[2]
-#define Tri2Flags ((Standard_Boolean*)Tri2Indices)[3]
+#define Tri2Flags ((Standard_Integer*)Tri2Indices)[3]
 
 #define Tri3Node1 ((Standard_Integer*)Tri3Indices)[0]
 #define Tri3Node2 ((Standard_Integer*)Tri3Indices)[1]
 #define Tri3Node3 ((Standard_Integer*)Tri3Indices)[2]
-#define Tri3Flags ((Standard_Boolean*)Tri3Indices)[3]
+#define Tri3Flags ((Standard_Integer*)Tri3Indices)[3]
 
 #define Seg1LstSg1 ((Standard_Integer*)Seg1Indices)[0]
 #define Seg1LstSg2 ((Standard_Integer*)Seg1Indices)[1]
@@ -123,9 +123,9 @@
 #define Seg2Conex2 ((Standard_Integer*)Seg2Indices)[5]
 
 #define Nod1NdSg ((Standard_Integer*)Nod1Indices)[0]
-#define Nod1Flag ((Standard_Boolean*)Nod1Indices)[1]
-#define Nod1Edg1 ((Standard_Boolean*)Nod1Indices)[2]
-#define Nod1Edg2 ((Standard_Boolean*)Nod1Indices)[3]
+#define Nod1Flag ((Standard_Integer*)Nod1Indices)[1]
+#define Nod1Edg1 ((Standard_Integer*)Nod1Indices)[2]
+#define Nod1Edg2 ((Standard_Integer*)Nod1Indices)[3]
 
 #define Nod1PntX ((Standard_Real*)Nod1RValues)[ 0]
 #define Nod1PntY ((Standard_Real*)Nod1RValues)[ 1]
@@ -140,9 +140,9 @@
 #define Nod1Scal ((Standard_Real*)Nod1RValues)[10]
 
 #define NodANdSg ((Standard_Integer*)NodAIndices)[0]
-#define NodAFlag ((Standard_Boolean*)NodAIndices)[1]
-#define NodAEdg1 ((Standard_Boolean*)NodAIndices)[2]
-#define NodAEdg2 ((Standard_Boolean*)NodAIndices)[3]
+#define NodAFlag ((Standard_Integer*)NodAIndices)[1]
+#define NodAEdg1 ((Standard_Integer*)NodAIndices)[2]
+#define NodAEdg2 ((Standard_Integer*)NodAIndices)[3]
 
 #define NodAPntX ((Standard_Real*)NodARValues)[ 0]
 #define NodAPntY ((Standard_Real*)NodARValues)[ 1]
@@ -157,9 +157,9 @@
 #define NodAScal ((Standard_Real*)NodARValues)[10]
 
 #define NodBNdSg ((Standard_Integer*)NodBIndices)[0]
-#define NodBFlag ((Standard_Boolean*)NodBIndices)[1]
-#define NodBEdg1 ((Standard_Boolean*)NodBIndices)[2]
-#define NodBEdg2 ((Standard_Boolean*)NodBIndices)[3]
+#define NodBFlag ((Standard_Integer*)NodBIndices)[1]
+#define NodBEdg1 ((Standard_Integer*)NodBIndices)[2]
+#define NodBEdg2 ((Standard_Integer*)NodBIndices)[3]
 
 #define NodBPntX ((Standard_Real*)NodBRValues)[ 0]
 #define NodBPntY ((Standard_Real*)NodBRValues)[ 1]
@@ -174,9 +174,9 @@
 #define NodBScal ((Standard_Real*)NodBRValues)[10]
 
 #define Nod2NdSg ((Standard_Integer*)Nod2Indices)[0]
-#define Nod2Flag ((Standard_Boolean*)Nod2Indices)[1]
-#define Nod2Edg1 ((Standard_Boolean*)Nod2Indices)[2]
-#define Nod2Edg2 ((Standard_Boolean*)Nod2Indices)[3]
+#define Nod2Flag ((Standard_Integer*)Nod2Indices)[1]
+#define Nod2Edg1 ((Standard_Integer*)Nod2Indices)[2]
+#define Nod2Edg2 ((Standard_Integer*)Nod2Indices)[3]
 
 #define Nod2PntX ((Standard_Real*)Nod2RValues)[ 0]
 #define Nod2PntY ((Standard_Real*)Nod2RValues)[ 1]
@@ -191,9 +191,9 @@
 #define Nod2Scal ((Standard_Real*)Nod2RValues)[10]
 
 #define Nod3NdSg ((Standard_Integer*)Nod3Indices)[0]
-#define Nod3Flag ((Standard_Boolean*)Nod3Indices)[1]
-#define Nod3Edg1 ((Standard_Boolean*)Nod3Indices)[2]
-#define Nod3Edg2 ((Standard_Boolean*)Nod3Indices)[3]
+#define Nod3Flag ((Standard_Integer*)Nod3Indices)[1]
+#define Nod3Edg1 ((Standard_Integer*)Nod3Indices)[2]
+#define Nod3Edg2 ((Standard_Integer*)Nod3Indices)[3]
 
 #define Nod3PntX ((Standard_Real*)Nod3RValues)[ 0]
 #define Nod3PntY ((Standard_Real*)Nod3RValues)[ 1]
@@ -208,9 +208,9 @@
 #define Nod3Scal ((Standard_Real*)Nod3RValues)[10]
 
 #define Nod4NdSg ((Standard_Integer*)Nod4Indices)[0]
-#define Nod4Flag ((Standard_Boolean*)Nod4Indices)[1]
-#define Nod4Edg1 ((Standard_Boolean*)Nod4Indices)[2]
-#define Nod4Edg2 ((Standard_Boolean*)Nod4Indices)[3]
+#define Nod4Flag ((Standard_Integer*)Nod4Indices)[1]
+#define Nod4Edg1 ((Standard_Integer*)Nod4Indices)[2]
+#define Nod4Edg2 ((Standard_Integer*)Nod4Indices)[3]
 
 #define Nod4PntX ((Standard_Real*)Nod4RValues)[ 0]
 #define Nod4PntY ((Standard_Real*)Nod4RValues)[ 1]
@@ -225,9 +225,9 @@
 #define Nod4Scal ((Standard_Real*)Nod4RValues)[10]
 
 #define Nod11NdSg ((Standard_Integer*)Nod11Indices)[0]
-#define Nod11Flag ((Standard_Boolean*)Nod11Indices)[1]
-#define Nod11Edg1 ((Standard_Boolean*)Nod11Indices)[2]
-#define Nod11Edg2 ((Standard_Boolean*)Nod11Indices)[3]
+#define Nod11Flag ((Standard_Integer*)Nod11Indices)[1]
+#define Nod11Edg1 ((Standard_Integer*)Nod11Indices)[2]
+#define Nod11Edg2 ((Standard_Integer*)Nod11Indices)[3]
 
 #define Nod11PntX ((Standard_Real*)Nod11RValues)[ 0]
 #define Nod11PntY ((Standard_Real*)Nod11RValues)[ 1]
@@ -242,9 +242,9 @@
 #define Nod11Scal ((Standard_Real*)Nod11RValues)[10]
 
 #define Nod1ANdSg ((Standard_Integer*)Nod1AIndices)[0]
-#define Nod1AFlag ((Standard_Boolean*)Nod1AIndices)[1]
-#define Nod1AEdg1 ((Standard_Boolean*)Nod1AIndices)[2]
-#define Nod1AEdg2 ((Standard_Boolean*)Nod1AIndices)[3]
+#define Nod1AFlag ((Standard_Integer*)Nod1AIndices)[1]
+#define Nod1AEdg1 ((Standard_Integer*)Nod1AIndices)[2]
+#define Nod1AEdg2 ((Standard_Integer*)Nod1AIndices)[3]
 
 #define Nod1APntX ((Standard_Real*)Nod1ARValues)[ 0]
 #define Nod1APntY ((Standard_Real*)Nod1ARValues)[ 1]
@@ -259,9 +259,9 @@
 #define Nod1AScal ((Standard_Real*)Nod1ARValues)[10]
 
 #define Nod1BNdSg ((Standard_Integer*)Nod1BIndices)[0]
-#define Nod1BFlag ((Standard_Boolean*)Nod1BIndices)[1]
-#define Nod1BEdg1 ((Standard_Boolean*)Nod1BIndices)[2]
-#define Nod1BEdg2 ((Standard_Boolean*)Nod1BIndices)[3]
+#define Nod1BFlag ((Standard_Integer*)Nod1BIndices)[1]
+#define Nod1BEdg1 ((Standard_Integer*)Nod1BIndices)[2]
+#define Nod1BEdg2 ((Standard_Integer*)Nod1BIndices)[3]
 
 #define Nod1BPntX ((Standard_Real*)Nod1BRValues)[ 0]
 #define Nod1BPntY ((Standard_Real*)Nod1BRValues)[ 1]
@@ -276,9 +276,9 @@
 #define Nod1BScal ((Standard_Real*)Nod1BRValues)[10]
 
 #define Nod12NdSg ((Standard_Integer*)Nod12Indices)[0]
-#define Nod12Flag ((Standard_Boolean*)Nod12Indices)[1]
-#define Nod12Edg1 ((Standard_Boolean*)Nod12Indices)[2]
-#define Nod12Edg2 ((Standard_Boolean*)Nod12Indices)[3]
+#define Nod12Flag ((Standard_Integer*)Nod12Indices)[1]
+#define Nod12Edg1 ((Standard_Integer*)Nod12Indices)[2]
+#define Nod12Edg2 ((Standard_Integer*)Nod12Indices)[3]
 
 #define Nod12PntX ((Standard_Real*)Nod12RValues)[ 0]
 #define Nod12PntY ((Standard_Real*)Nod12RValues)[ 1]
@@ -293,9 +293,9 @@
 #define Nod12Scal ((Standard_Real*)Nod12RValues)[10]
 
 #define Nod13NdSg ((Standard_Integer*)Nod13Indices)[0]
-#define Nod13Flag ((Standard_Boolean*)Nod13Indices)[1]
-#define Nod13Edg1 ((Standard_Boolean*)Nod13Indices)[2]
-#define Nod13Edg2 ((Standard_Boolean*)Nod13Indices)[3]
+#define Nod13Flag ((Standard_Integer*)Nod13Indices)[1]
+#define Nod13Edg1 ((Standard_Integer*)Nod13Indices)[2]
+#define Nod13Edg2 ((Standard_Integer*)Nod13Indices)[3]
 
 #define Nod13PntX ((Standard_Real*)Nod13RValues)[ 0]
 #define Nod13PntY ((Standard_Real*)Nod13RValues)[ 1]
@@ -310,9 +310,9 @@
 #define Nod13Scal ((Standard_Real*)Nod13RValues)[10]
 
 #define Nod14NdSg ((Standard_Integer*)Nod14Indices)[0]
-#define Nod14Flag ((Standard_Boolean*)Nod14Indices)[1]
-#define Nod14Edg1 ((Standard_Boolean*)Nod14Indices)[2]
-#define Nod14Edg2 ((Standard_Boolean*)Nod14Indices)[3]
+#define Nod14Flag ((Standard_Integer*)Nod14Indices)[1]
+#define Nod14Edg1 ((Standard_Integer*)Nod14Indices)[2]
+#define Nod14Edg2 ((Standard_Integer*)Nod14Indices)[3]
 
 #define Nod14PntX ((Standard_Real*)Nod14RValues)[ 0]
 #define Nod14PntY ((Standard_Real*)Nod14RValues)[ 1]
@@ -327,9 +327,9 @@
 #define Nod14Scal ((Standard_Real*)Nod14RValues)[10]
 
 #define Nod21NdSg ((Standard_Integer*)Nod21Indices)[0]
-#define Nod21Flag ((Standard_Boolean*)Nod21Indices)[1]
-#define Nod21Edg1 ((Standard_Boolean*)Nod21Indices)[2]
-#define Nod21Edg2 ((Standard_Boolean*)Nod21Indices)[3]
+#define Nod21Flag ((Standard_Integer*)Nod21Indices)[1]
+#define Nod21Edg1 ((Standard_Integer*)Nod21Indices)[2]
+#define Nod21Edg2 ((Standard_Integer*)Nod21Indices)[3]
 
 #define Nod21PntX ((Standard_Real*)Nod21RValues)[ 0]
 #define Nod21PntY ((Standard_Real*)Nod21RValues)[ 1]
@@ -344,9 +344,9 @@
 #define Nod21Scal ((Standard_Real*)Nod21RValues)[10]
 
 #define Nod2ANdSg ((Standard_Integer*)Nod2AIndices)[0]
-#define Nod2AFlag ((Standard_Boolean*)Nod2AIndices)[1]
-#define Nod2AEdg1 ((Standard_Boolean*)Nod2AIndices)[2]
-#define Nod2AEdg2 ((Standard_Boolean*)Nod2AIndices)[3]
+#define Nod2AFlag ((Standard_Integer*)Nod2AIndices)[1]
+#define Nod2AEdg1 ((Standard_Integer*)Nod2AIndices)[2]
+#define Nod2AEdg2 ((Standard_Integer*)Nod2AIndices)[3]
 
 #define Nod2APntX ((Standard_Real*)Nod2ARValues)[ 0]
 #define Nod2APntY ((Standard_Real*)Nod2ARValues)[ 1]
@@ -361,9 +361,9 @@
 #define Nod2AScal ((Standard_Real*)Nod2ARValues)[10]
 
 #define Nod2BNdSg ((Standard_Integer*)Nod2BIndices)[0]
-#define Nod2BFlag ((Standard_Boolean*)Nod2BIndices)[1]
-#define Nod2BEdg1 ((Standard_Boolean*)Nod2BIndices)[2]
-#define Nod2BEdg2 ((Standard_Boolean*)Nod2BIndices)[3]
+#define Nod2BFlag ((Standard_Integer*)Nod2BIndices)[1]
+#define Nod2BEdg1 ((Standard_Integer*)Nod2BIndices)[2]
+#define Nod2BEdg2 ((Standard_Integer*)Nod2BIndices)[3]
 
 #define Nod2BPntX ((Standard_Real*)Nod2BRValues)[ 0]
 #define Nod2BPntY ((Standard_Real*)Nod2BRValues)[ 1]
@@ -378,9 +378,9 @@
 #define Nod2BScal ((Standard_Real*)Nod2BRValues)[10]
 
 #define Nod22NdSg ((Standard_Integer*)Nod22Indices)[0]
-#define Nod22Flag ((Standard_Boolean*)Nod22Indices)[1]
-#define Nod22Edg1 ((Standard_Boolean*)Nod22Indices)[2]
-#define Nod22Edg2 ((Standard_Boolean*)Nod22Indices)[3]
+#define Nod22Flag ((Standard_Integer*)Nod22Indices)[1]
+#define Nod22Edg1 ((Standard_Integer*)Nod22Indices)[2]
+#define Nod22Edg2 ((Standard_Integer*)Nod22Indices)[3]
 
 #define Nod22PntX ((Standard_Real*)Nod22RValues)[ 0]
 #define Nod22PntY ((Standard_Real*)Nod22RValues)[ 1]
@@ -395,9 +395,9 @@
 #define Nod22Scal ((Standard_Real*)Nod22RValues)[10]
 
 #define Nod23NdSg ((Standard_Integer*)Nod23Indices)[0]
-#define Nod23Flag ((Standard_Boolean*)Nod23Indices)[1]
-#define Nod23Edg1 ((Standard_Boolean*)Nod23Indices)[2]
-#define Nod23Edg2 ((Standard_Boolean*)Nod23Indices)[3]
+#define Nod23Flag ((Standard_Integer*)Nod23Indices)[1]
+#define Nod23Edg1 ((Standard_Integer*)Nod23Indices)[2]
+#define Nod23Edg2 ((Standard_Integer*)Nod23Indices)[3]
 
 #define Nod23PntX ((Standard_Real*)Nod23RValues)[ 0]
 #define Nod23PntY ((Standard_Real*)Nod23RValues)[ 1]
@@ -412,9 +412,9 @@
 #define Nod23Scal ((Standard_Real*)Nod23RValues)[10]
 
 #define Nod24NdSg ((Standard_Integer*)Nod24Indices)[0]
-#define Nod24Flag ((Standard_Boolean*)Nod24Indices)[1]
-#define Nod24Edg1 ((Standard_Boolean*)Nod24Indices)[2]
-#define Nod24Edg2 ((Standard_Boolean*)Nod24Indices)[3]
+#define Nod24Flag ((Standard_Integer*)Nod24Indices)[1]
+#define Nod24Edg1 ((Standard_Integer*)Nod24Indices)[2]
+#define Nod24Edg2 ((Standard_Integer*)Nod24Indices)[3]
 
 #define Nod24PntX ((Standard_Real*)Nod24RValues)[ 0]
 #define Nod24PntY ((Standard_Real*)Nod24RValues)[ 1]
@@ -1262,7 +1262,7 @@ InitBiPointsWithConnexity (const Standar
 	    &(((HLRAlgo_Array1OfPINod*)PINod1)->ChangeValue(Pol1(iPol)));
 	  Standard_Address Nod1AIndices = (*pi1pA)->Indices();
 	  Standard_Address Nod1ARValues = (*pi1pA)->RValues();
-	  if (Nod1AEdg1 == 0 || Nod1AEdg1 == (Standard_Boolean) e) {
+	  if (Nod1AEdg1 == 0 || Nod1AEdg1 == e) {
 	    Nod1AEdg1 = e;
 	    Nod1APCu1 = par->Value(iPol);
 	  }
@@ -1278,8 +1278,8 @@ InitBiPointsWithConnexity (const Standar
 	XTI2 = X2 = Nod12PntX;
 	YTI2 = Y2 = Nod12PntY;
 	ZTI2 = Z2 = Nod12PntZ;
-	if      (Nod12Edg1 ==  (Standard_Boolean) e) U2 = Nod12PCu1;
-	else if (Nod12Edg2 ==  (Standard_Boolean) e) U2 = Nod12PCu2;
+	if      (Nod12Edg1 ==  e) U2 = Nod12PCu1;
+	else if (Nod12Edg2 ==  e) U2 = Nod12PCu2;
 #ifdef DEB
 	else {
 	  cout << " HLRBRep_PolyAlgo::InitBiPointsWithConnexity : ";
@@ -1330,8 +1330,8 @@ InitBiPointsWithConnexity (const Standar
 	    XTI2 = X2 = Nod12PntX;
 	    YTI2 = Y2 = Nod12PntY;
 	    ZTI2 = Z2 = Nod12PntZ;
-	    if      (Nod12Edg1 ==  (Standard_Boolean) e) U2 = Nod12PCu1;
-	    else if (Nod12Edg2 ==  (Standard_Boolean) e) U2 = Nod12PCu2;
+	    if      (Nod12Edg1 ==  e) U2 = Nod12PCu1;
+	    else if (Nod12Edg2 ==  e) U2 = Nod12PCu2;
 #ifdef DEB
 	    else {
 	      cout << " HLRBRep_PolyAlgo::InitBiPointsWithConnexity : ";
@@ -1421,7 +1421,7 @@ InitBiPointsWithConnexity (const Standar
 	  Standard_Address Nod2AIndices = (*pi2pA)->Indices();
 	  Standard_Address Nod2ARValues = (*pi2pA)->RValues();
 	  Standard_Real PCu = par->Value(iPol);
-	  if (Nod1AEdg1 == 0 || Nod1AEdg1 ==  (Standard_Boolean) e) {
+	  if (Nod1AEdg1 == 0 || Nod1AEdg1 ==  e) {
 	    Nod1AEdg1 = e;
 	    Nod1APCu1 = PCu;
 	  }
@@ -1429,7 +1429,7 @@ InitBiPointsWithConnexity (const Standar
 	    Nod1AEdg2 = e;
 	    Nod1APCu2 = PCu;
 	  }
-	  if (Nod2AEdg1 == 0 || Nod2AEdg1 == (Standard_Boolean) e) {
+	  if (Nod2AEdg1 == 0 || Nod2AEdg1 == e) {
 	    Nod2AEdg1 = e;
 	    Nod2APCu1 = PCu;
 	  }
@@ -1448,8 +1448,8 @@ InitBiPointsWithConnexity (const Standar
 	XTI2 = X2 = Nod12PntX;
 	YTI2 = Y2 = Nod12PntY;
 	ZTI2 = Z2 = Nod12PntZ;
-	if      (Nod12Edg1 == (Standard_Boolean) e) U2 = Nod12PCu1;
-	else if (Nod12Edg2 == (Standard_Boolean) e) U2 = Nod12PCu2;
+	if      (Nod12Edg1 == e) U2 = Nod12PCu1;
+	else if (Nod12Edg2 == e) U2 = Nod12PCu2;
 #ifdef DEB
 	else {
 	  cout << " HLRBRep_PolyAlgo::InitBiPointsWithConnexity : ";
@@ -1521,8 +1521,8 @@ InitBiPointsWithConnexity (const Standar
 	    XTI2 = X2 = Nod12PntX;
 	    YTI2 = Y2 = Nod12PntY;
 	    ZTI2 = Z2 = Nod12PntZ;
-	    if      (Nod12Edg1 == (Standard_Boolean) e) U2 = Nod12PCu1;
-	    else if (Nod12Edg2 == (Standard_Boolean) e) U2 = Nod12PCu2;
+	    if      (Nod12Edg1 == e) U2 = Nod12PCu1;
+	    else if (Nod12Edg2 == e) U2 = Nod12PCu2;
 #ifdef DEB
 	    else {
 	      cout << " HLRBRep_PolyAlgo::InitBiPointsWithConnexity : ";
@@ -1717,7 +1717,7 @@ Interpolation (HLRAlgo_ListOfBPoint& Lis
   Standard_Real X3,Y3,Z3,XTI3,YTI3,ZTI3,coef3,U3;
   Standard_Real X4,Y4,Z4,XTI4,YTI4,ZTI4,coef4,U4;
 //  gp_Pnt P3,PT3,P4,PT4;
-  Standard_Boolean flag = 0;
+  Standard_Integer flag = 0;
   if (rg >= GeomAbs_G1) flag += 1;
   if (rg >= GeomAbs_G2) flag += 2;
   insP3 = Interpolation(U1,U2,Nod11RValues,Nod12RValues,
@@ -1793,7 +1793,7 @@ Interpolation (HLRAlgo_ListOfBPoint& Lis
     List.Prepend(HLRAlgo_BiPoint
 		 (XTI1,YTI1,ZTI1,XTI2,YTI2,ZTI2,
 		  X1  ,Y1  ,Z1  ,X2  ,Y2  ,Z2  ,   e,
-		  i1  ,i1p1,i1p2,i2  ,i2p1,i2p2,flag));
+		  i1  ,i1p1,i1p2,i2  ,i2p1,i2p2, flag));
 }
 
 //=======================================================================
@@ -1873,7 +1873,7 @@ MoveOrInsertPoint (HLRAlgo_ListOfBPoint&
 		   const Standard_Real U3,
 		   const Standard_Boolean insP3,
 		   const Standard_Boolean mP3P1,
-		   const Standard_Boolean flag) const
+		   const Standard_Integer flag) const
 {
   Standard_Address TData2 = 0;
   Standard_Address PISeg2 = 0;
@@ -1897,8 +1897,8 @@ MoveOrInsertPoint (HLRAlgo_ListOfBPoint&
       Nod11PntX = X3;
       Nod11PntY = Y3;
       Nod11PntZ = Z3;
-      if      (Nod11Edg1 == (Standard_Boolean) e) Nod11PCu1 = U3;
-      else if (Nod11Edg2 == (Standard_Boolean) e) Nod11PCu2 = U3;
+      if      (Nod11Edg1 == e) Nod11PCu1 = U3;
+      else if (Nod11Edg2 == e) Nod11PCu2 = U3;
 #ifdef DEB
       else {
 	cout << " HLRBRep_PolyAlgo::MoveOrInsertPoint : ";
@@ -1935,8 +1935,8 @@ MoveOrInsertPoint (HLRAlgo_ListOfBPoint&
       Nod12PntX = X3;
       Nod12PntY = Y3;
       Nod12PntZ = Z3;
-      if      (Nod12Edg1 == (Standard_Boolean) e) Nod12PCu1 = U3;
-      else if (Nod12Edg2 == (Standard_Boolean) e) Nod12PCu2 = U3;
+      if      (Nod12Edg1 == e) Nod12PCu1 = U3;
+      else if (Nod12Edg2 == e) Nod12PCu2 = U3;
 #ifdef DEB
       else {
 	cout << " HLRBRep_PolyAlgo::MoveOrInsertPoint : ";
@@ -1966,17 +1966,17 @@ MoveOrInsertPoint (HLRAlgo_ListOfBPoint&
     List.Prepend(HLRAlgo_BiPoint
 		 (XTI1,YTI1,ZTI1,XTI3,YTI3,ZTI3,
 		  X1  ,Y1  ,Z1  ,X3  ,Y3  ,Z3  ,   e,
-		  i1  ,i1p1,i1p3,flag));
+		  i1  ,i1p1,i1p3, flag));
     List.Prepend(HLRAlgo_BiPoint
 		 (XTI3,YTI3,ZTI3,XTI2,YTI2,ZTI2,
 		  X3  ,Y3  ,Z3  ,X2  ,Y2  ,Z2  ,   e,
-		  i1  ,i1p3,i1p2,flag));
+		  i1  ,i1p3,i1p2, flag));
   }
   else                                             // p1 p2
     List.Prepend(HLRAlgo_BiPoint
 		 (XTI1,YTI1,ZTI1,XTI2,YTI2,ZTI2,
 		  X1  ,Y1  ,Z1  ,X2  ,Y2  ,Z2  ,   e,
-		  i1  ,i1p1,i1p2,flag));
+		  i1  ,i1p1,i1p2, flag));
 }
 
 //=======================================================================
@@ -2034,7 +2034,7 @@ MoveOrInsertPoint (HLRAlgo_ListOfBPoint&
 		   const Standard_Real U3,
 		   const Standard_Boolean insP3,
 		   const Standard_Boolean mP3P1,
-		   const Standard_Boolean flag) const
+		   const Standard_Integer flag) const
 {
   Standard_Boolean ins3 = insP3;
   if (ins3 && mP3P1) {                             // P1 ---> P3
@@ -2060,8 +2060,8 @@ MoveOrInsertPoint (HLRAlgo_ListOfBPoint&
       Nod11PntX = X3;
       Nod11PntY = Y3;
       Nod11PntZ = Z3;
-      if      (Nod11Edg1 == (Standard_Boolean) e) Nod11PCu1 = U3;
-      else if (Nod11Edg2 == (Standard_Boolean) e) Nod11PCu2 = U3;
+      if      (Nod11Edg1 == e) Nod11PCu1 = U3;
+      else if (Nod11Edg2 == e) Nod11PCu2 = U3;
 #ifdef DEB
       else {
 	cout << " HLRBRep_PolyAlgo::MoveOrInsertPoint : ";
@@ -2074,8 +2074,8 @@ MoveOrInsertPoint (HLRAlgo_ListOfBPoint&
       Nod21PntX  = X3;
       Nod21PntY  = Y3;
       Nod21PntZ  = Z3;
-      if      (Nod21Edg1 == (Standard_Boolean) e) Nod21PCu1 = U3;
-      else if (Nod21Edg2 == (Standard_Boolean) e) Nod21PCu2 = U3;
+      if      (Nod21Edg1 == e) Nod21PCu1 = U3;
+      else if (Nod21Edg2 == e) Nod21PCu2 = U3;
 #ifdef DEB
       else {
 	cout << " HLRBRep_PolyAlgo::MoveOrInsertPoint : ";
@@ -2117,8 +2117,8 @@ MoveOrInsertPoint (HLRAlgo_ListOfBPoint&
       Nod12PntX = X3;
       Nod12PntY = Y3;
       Nod12PntZ = Z3;
-      if      (Nod12Edg1 == (Standard_Boolean) e) Nod12PCu1 = U3;
-      else if (Nod12Edg2 == (Standard_Boolean) e) Nod12PCu2 = U3;
+      if      (Nod12Edg1 == e) Nod12PCu1 = U3;
+      else if (Nod12Edg2 == e) Nod12PCu2 = U3;
 #ifdef DEB
       else {
 	cout << " HLRBRep_PolyAlgo::MoveOrInsertPoint : ";
@@ -2131,8 +2131,8 @@ MoveOrInsertPoint (HLRAlgo_ListOfBPoint&
       Nod22PntX  = X3;
       Nod22PntY  = Y3;
       Nod22PntZ  = Z3;
-      if      (Nod22Edg1 == (Standard_Boolean) e) Nod22PCu1 = U3;
-      else if (Nod22Edg2 == (Standard_Boolean) e) Nod22PCu2 = U3;
+      if      (Nod22Edg1 == e) Nod22PCu1 = U3;
+      else if (Nod22Edg2 == e) Nod22PCu2 = U3;
 #ifdef DEB
       else {
 	cout << " HLRBRep_PolyAlgo::MoveOrInsertPoint : ";
@@ -2176,17 +2176,17 @@ MoveOrInsertPoint (HLRAlgo_ListOfBPoint&
     List.Prepend(HLRAlgo_BiPoint
 		 (XTI1,YTI1,ZTI1,XTI3,YTI3,ZTI3,
 		  X1  ,Y1  ,Z1  ,X3  ,Y3  ,Z3  ,   e,
-		  i1  ,i1p1,i1p3,i2  ,i2p1,i2p3,flag));
+		  i1  ,i1p1,i1p3,i2  ,i2p1,i2p3, flag));
     List.Prepend(HLRAlgo_BiPoint
 		 (XTI3,YTI3,ZTI3,XTI2,YTI2,ZTI2,
 		  X3  ,Y3  ,Z3  ,X2  ,Y2  ,Z2  ,   e,
-		  i1  ,i1p3,i1p2,i2  ,i2p3,i2p2,flag));
+		  i1  ,i1p3,i1p2,i2  ,i2p3,i2p2, flag));
   }
   else                                             // p1 p2
     List.Prepend(HLRAlgo_BiPoint
 		 (XTI1,YTI1,ZTI1,XTI2,YTI2,ZTI2,
 		  X1  ,Y1  ,Z1  ,X2  ,Y2  ,Z2  ,   e,
-		  i1  ,i1p1,i1p2,i2  ,i2p1,i2p2,flag));
+		  i1  ,i1p1,i1p2,i2  ,i2p1,i2p2, flag));
 }
 
 //=======================================================================
@@ -2254,7 +2254,7 @@ MoveOrInsertPoint (HLRAlgo_ListOfBPoint&
 		   const Standard_Real U4,
 		   const Standard_Boolean insP4,
 		   const Standard_Boolean mP4P1,
-		   const Standard_Boolean flag) const
+		   const Standard_Integer flag) const
 {
   Standard_Boolean ins3 = insP3;
   Standard_Boolean ins4 = insP4;
@@ -2281,8 +2281,8 @@ MoveOrInsertPoint (HLRAlgo_ListOfBPoint&
       Nod11PntX = X3;
       Nod11PntY = Y3;
       Nod11PntZ = Z3;
-      if      (Nod11Edg1 == (Standard_Boolean) e) Nod11PCu1 = U3;
-      else if (Nod11Edg2 == (Standard_Boolean) e) Nod11PCu2 = U3;
+      if      (Nod11Edg1 == e) Nod11PCu1 = U3;
+      else if (Nod11Edg2 == e) Nod11PCu2 = U3;
 #ifdef DEB
       else {
 	cout << " HLRBRep_PolyAlgo::MoveOrInsertPoint : ";
@@ -2295,8 +2295,8 @@ MoveOrInsertPoint (HLRAlgo_ListOfBPoint&
       Nod21PntX  = X3;
       Nod21PntY  = Y3;
       Nod21PntZ  = Z3;
-      if      (Nod21Edg1 == (Standard_Boolean) e) Nod21PCu1 = U3;
-      else if (Nod21Edg2 == (Standard_Boolean) e) Nod21PCu2 = U3;
+      if      (Nod21Edg1 == e) Nod21PCu1 = U3;
+      else if (Nod21Edg2 == e) Nod21PCu2 = U3;
 #ifdef DEB
       else {
 	cout << " HLRBRep_PolyAlgo::MoveOrInsertPoint : ";
@@ -2338,8 +2338,8 @@ MoveOrInsertPoint (HLRAlgo_ListOfBPoint&
       Nod12PntX = X4;
       Nod12PntY = Y4;
       Nod12PntZ = Z4;
-      if      (Nod12Edg1 == (Standard_Boolean) e) Nod12PCu1 = U4;
-      else if (Nod12Edg2 == (Standard_Boolean) e) Nod12PCu2 = U4;
+      if      (Nod12Edg1 == e) Nod12PCu1 = U4;
+      else if (Nod12Edg2 == e) Nod12PCu2 = U4;
 #ifdef DEB
       else {
 	cout << " HLRBRep_PolyAlgo::MoveOrInsertPoint : ";
@@ -2352,8 +2352,8 @@ MoveOrInsertPoint (HLRAlgo_ListOfBPoint&
       Nod22PntX  = X4;
       Nod22PntY  = Y4;
       Nod22PntZ  = Z4;
-      if      (Nod22Edg1 == (Standard_Boolean) e) Nod22PCu1 = U4;
-      else if (Nod22Edg2 == (Standard_Boolean) e) Nod22PCu2 = U4;
+      if      (Nod22Edg1 == e) Nod22PCu1 = U4;
+      else if (Nod22Edg2 == e) Nod22PCu2 = U4;
 #ifdef DEB
       else {
 	cout << " HLRBRep_PolyAlgo::MoveOrInsertPoint : ";
@@ -2450,22 +2450,22 @@ MoveOrInsertPoint (HLRAlgo_ListOfBPoint&
       List.Prepend(HLRAlgo_BiPoint
 		   (XTI1,YTI1,ZTI1,XTI3,YTI3,ZTI3,
 		    X1  ,Y1  ,Z1  ,X3  ,Y3  ,Z3  ,   e,
-		    i1  ,i1p1,i1p3,i2  ,i2p1,i2p3,flag));
+		    i1  ,i1p1,i1p3,i2  ,i2p1,i2p3, flag));
       List.Prepend(HLRAlgo_BiPoint
 		   (XTI3,YTI3,ZTI3,XTI4,YTI4,ZTI4,
 		    X3  ,Y3  ,Z3  ,X4  ,Y4  ,Z4  ,   e,
-		    i1  ,i1p3,i1p4,i2  ,i2p3,i2p4,flag));
+		    i1  ,i1p3,i1p4,i2  ,i2p3,i2p4, flag));
       List.Prepend(HLRAlgo_BiPoint
 		   (XTI4,YTI4,ZTI4,XTI2,YTI2,ZTI2,
 		    X4  ,Y4  ,Z4  ,X2  ,Y2  ,Z2  ,   e,
-		    i1  ,i1p4,i1p2,i2  ,i2p4,i2p2,flag));
+		    i1  ,i1p4,i1p2,i2  ,i2p4,i2p2, flag));
     }
   }
   else                                             // p1 p2
     List.Prepend(HLRAlgo_BiPoint
 		 (XTI1,YTI1,ZTI1,XTI2,YTI2,ZTI2,
 		  X1  ,Y1  ,Z1  ,X2  ,Y2  ,Z2  ,   e,
-		  i1  ,i1p1,i1p2,i2  ,i2p1,i2p2,flag));
+		  i1  ,i1p1,i1p2,i2  ,i2p1,i2p2, flag));
 }
 
 //=======================================================================
@@ -3152,9 +3152,9 @@ HLRBRep_PolyAlgo::OrientTriangle(const S
 				 const Standard_Address Nod3Indices,
 				 const Standard_Address Nod3RValues) const
 {
-  Standard_Boolean o1 = Nod1Flag & NMskOutL;
-  Standard_Boolean o2 = Nod2Flag & NMskOutL;
-  Standard_Boolean o3 = Nod3Flag & NMskOutL;
+  Standard_Boolean o1 = (0 != (Nod1Flag & NMskOutL));
+  Standard_Boolean o2 = (0 != (Nod2Flag & NMskOutL));
+  Standard_Boolean o3 = (0 != (Nod3Flag & NMskOutL));
   Tri1Flags &= ~FMskFlat;
   Tri1Flags &= ~FMskOnOutL;
   if (o1 && o2 && o3) {
Index: oce/src/IFSelect/IFSelect_DispGlobal.cdl
===================================================================
--- oce.orig/src/IFSelect/IFSelect_DispGlobal.cdl
+++ oce/src/IFSelect/IFSelect_DispGlobal.cdl
@@ -35,7 +35,7 @@ is
     	is redefined;
     ---Purpose : Returns True : maximum equates 1
 
-    PacketsCount (me; G : Graph; count : out Integer) returns Boolean
+    PacketsCount (me; G : Graph; count : out Integer) returns Integer
     	is redefined;
     ---Purpose : Returns True (count of packets is well known) and count is 1
 
Index: oce/src/IFSelect/IFSelect_DispGlobal.cxx
===================================================================
--- oce.orig/src/IFSelect/IFSelect_DispGlobal.cxx
+++ oce/src/IFSelect/IFSelect_DispGlobal.cxx
@@ -27,7 +27,7 @@ IFSelect_DispGlobal::IFSelect_DispGlobal
   (const Standard_Integer /* nbent */, Standard_Integer& pcount) const 
       {  pcount = 1;  return Standard_True;  }
 
-    Standard_Boolean  IFSelect_DispGlobal::PacketsCount
+    Standard_Integer  IFSelect_DispGlobal::PacketsCount
   (const Interface_Graph& /* G */, Standard_Integer& pcount) const 
       {  pcount = 1;  return Standard_True;  }
 
Index: oce/src/IFSelect/IFSelect_DispPerCount.cdl
===================================================================
--- oce.orig/src/IFSelect/IFSelect_DispPerCount.cdl
+++ oce/src/IFSelect/IFSelect_DispPerCount.cdl
@@ -49,7 +49,7 @@ is
     	is redefined;
     ---Purpose : Returns True, maximum count is given as <nbent>
 
-    PacketsCount (me; G : Graph; count : out Integer) returns Boolean
+    PacketsCount (me; G : Graph; count : out Integer) returns Integer
     	is redefined;
     ---Purpose : Returns True (count is easy to know) and count is computed
     --           from length of input list (RootResult from Final Selection)
Index: oce/src/IFSelect/IFSelect_DispPerCount.cxx
===================================================================
--- oce.orig/src/IFSelect/IFSelect_DispPerCount.cxx
+++ oce/src/IFSelect/IFSelect_DispPerCount.cxx
@@ -51,7 +51,7 @@ IFSelect_DispPerCount::IFSelect_DispPerC
   return Standard_True;
 }
 
-    Standard_Boolean  IFSelect_DispPerCount::PacketsCount
+    Standard_Integer  IFSelect_DispPerCount::PacketsCount
   (const Interface_Graph& G, Standard_Integer& /*count*/) const 
       {  return 1 + G.Size() / CountValue();  }
 
Index: oce/src/IFSelect/IFSelect_DispPerFiles.cdl
===================================================================
--- oce.orig/src/IFSelect/IFSelect_DispPerFiles.cdl
+++ oce/src/IFSelect/IFSelect_DispPerFiles.cdl
@@ -52,7 +52,7 @@ is
     	is redefined;
     ---Purpose : Returns True, maximum count is given as CountValue
 
-    PacketsCount (me; G : Graph; count : out Integer) returns Boolean
+    PacketsCount (me; G : Graph; count : out Integer) returns Integer
     	is redefined;
     ---Purpose : Returns True (count is easy to know) and count is the minimum
     --           value between  length of input list and CountValue
Index: oce/src/IFSelect/IFSelect_DispPerFiles.cxx
===================================================================
--- oce.orig/src/IFSelect/IFSelect_DispPerFiles.cxx
+++ oce/src/IFSelect/IFSelect_DispPerFiles.cxx
@@ -51,7 +51,7 @@ IFSelect_DispPerFiles::IFSelect_DispPerF
   return Standard_True;
 }
 
-    Standard_Boolean  IFSelect_DispPerFiles::PacketsCount
+    Standard_Integer  IFSelect_DispPerFiles::PacketsCount
   (const Interface_Graph& G, Standard_Integer& /*count*/) const 
       {  return (G.Size() < CountValue() ? G.Size() : CountValue());  }
 
Index: oce/src/IFSelect/IFSelect_DispPerOne.cdl
===================================================================
--- oce.orig/src/IFSelect/IFSelect_DispPerOne.cdl
+++ oce/src/IFSelect/IFSelect_DispPerOne.cdl
@@ -36,7 +36,7 @@ is
     	is redefined;
     ---Purpose : Returns True, maximum limit is given as <nbent>
 
-    PacketsCount (me; G : Graph; count : out Integer) returns Boolean
+    PacketsCount (me; G : Graph; count : out Integer) returns Integer
     	is redefined;
     ---Purpose : Returns True (count is easy to know) and count is the length
     --           of the input list (RootResult from FinalSelection)
Index: oce/src/IFSelect/IFSelect_DispPerOne.cxx
===================================================================
--- oce.orig/src/IFSelect/IFSelect_DispPerOne.cxx
+++ oce/src/IFSelect/IFSelect_DispPerOne.cxx
@@ -31,7 +31,7 @@ IFSelect_DispPerOne::IFSelect_DispPerOne
   (const Standard_Integer nbent, Standard_Integer& pcount) const 
 {  pcount = nbent;  return Standard_True;  }
 
-    Standard_Boolean  IFSelect_DispPerOne::PacketsCount
+    Standard_Integer  IFSelect_DispPerOne::PacketsCount
   (const Interface_Graph& G, Standard_Integer& pcount) const 
 {  pcount = G.Size();  return Standard_True;  }
 
Index: oce/src/IFSelect/IFSelect_Dispatch.cdl
===================================================================
--- oce.orig/src/IFSelect/IFSelect_Dispatch.cdl
+++ oce/src/IFSelect/IFSelect_Dispatch.cdl
@@ -93,7 +93,7 @@ is
     --           input Graph
     --           This the starting step for an Evaluation (Packets - Remainder)
 
-    PacketsCount (me; G : Graph; count : out Integer) returns Boolean  is virtual;
+    PacketsCount (me; G : Graph; count : out Integer) returns Integer  is virtual;
     ---Purpose : Returns True if Count of Packets is actually known, and the
     --           value of the count in argument "count". Returns False if
     --           this count is unknown. Input is given as a Graph.
Index: oce/src/IFSelect/IFSelect_Dispatch.cxx
===================================================================
--- oce.orig/src/IFSelect/IFSelect_Dispatch.cxx
+++ oce/src/IFSelect/IFSelect_Dispatch.cxx
@@ -56,7 +56,7 @@ void  IFSelect_Dispatch::SetRootName
   (const Interface_Graph& G) const
       {  return thefinal->UniqueResult(G);  }
 
-    Standard_Boolean  IFSelect_Dispatch::PacketsCount
+    Standard_Integer  IFSelect_Dispatch::PacketsCount
   (const Interface_Graph& , Standard_Integer& pcount) const 
       {  pcount = 0;  return Standard_False;  }    // par defaut 0
 
Index: oce/src/IFSelect/IFSelect_Functions.cxx
===================================================================
--- oce.orig/src/IFSelect/IFSelect_Functions.cxx
+++ oce/src/IFSelect/IFSelect_Functions.cxx
@@ -128,7 +128,7 @@ static IFSelect_ReturnStatus fun1
 {
   Handle(IFSelect_WorkSession) WS = pilot->Session();
 //        ****    ToggleHandler     ****
-  int hand = !WS->ErrorHandle();
+  Standard_Boolean hand = !WS->ErrorHandle();
   Handle(Message_Messenger) sout = Message::DefaultMessenger();
   if (hand) sout << " --  Mode Catch Error now Active"   <<endl;
   else      sout << " --  Mode Catch Error now Inactive" <<endl;
Index: oce/src/IFSelect/IFSelect_SelectRootComps.cxx
===================================================================
--- oce.orig/src/IFSelect/IFSelect_SelectRootComps.cxx
+++ oce/src/IFSelect/IFSelect_SelectRootComps.cxx
@@ -48,7 +48,7 @@ IFSelect_SelectRootComps::IFSelect_Selec
 //  (N.B.: on prend inp1, qui donne UNE entite par composant, simple ou cycle)
   for (inp1.Start(); inp1.More(); inp1.Next()) {
     Handle(Standard_Transient) ent = inp1.Value();
-    if ((Standard_Boolean)(GC.NbTimes(ent) <= 1) == IsDirect()) iter.GetOneItem(ent);
+    if ((GC.NbTimes(ent) <= 1) == IsDirect()) iter.GetOneItem(ent);
   }
   return iter;
 }
Index: oce/src/IFSelect/IFSelect_SelectRoots.cxx
===================================================================
--- oce.orig/src/IFSelect/IFSelect_SelectRoots.cxx
+++ oce/src/IFSelect/IFSelect_SelectRoots.cxx
@@ -36,7 +36,7 @@ IFSelect_SelectRoots::IFSelect_SelectRoo
 //  A present, on retient, parmi les inputs, celles comptees une seule fois
   for (input.Start(); input.More(); input.Next()) {
     Handle(Standard_Transient) ent = input.Value();
-    if ((Standard_Boolean)(GC.NbTimes(ent) <= 1) == IsDirect()) iter.GetOneItem(ent);
+    if ((GC.NbTimes(ent) <= 1) == IsDirect()) iter.GetOneItem(ent);
   }
   return iter;
 }
Index: oce/src/IFSelect/IFSelect_SessionPilot.cxx
===================================================================
--- oce.orig/src/IFSelect/IFSelect_SessionPilot.cxx
+++ oce/src/IFSelect/IFSelect_SessionPilot.cxx
@@ -275,7 +275,7 @@ static TCollection_AsciiString nulword;
 //  Ici, resultat non nomme;  Resultat nomme par commande x (plus loin)
     if (!theobjrec.IsNull()) {
       thesession->RemoveItem(theobjrec);  //// depannage ?
-      Standard_Boolean addws = thesession->AddItem(theobjrec);
+      Standard_Boolean addws = (0 != thesession->AddItem(theobjrec));
       if (!addws) { cout<<"Could not add item to session, sorry"<<endl; return IFSelect_RetFail; }
     }
 
@@ -487,8 +487,8 @@ static TCollection_AsciiString nulword;
 //  Prise en compte des commandes a resultat
 	  if (!theobjrec.IsNull()) {
 	    thesession->RemoveItem(theobjrec);  //// depannage ?
-	    Standard_Boolean addws =
-	      thesession->AddNamedItem(name.ToCString(),theobjrec);
+	    Standard_Boolean addws = (0 !=
+	      thesession->AddNamedItem(name.ToCString(),theobjrec));
 	    theobjrec.Nullify();
 	    if (!addws) { cout<<"Could not add named item:"<<name<<", sorry"<<endl; return IFSelect_RetFail; }
 	  }
Index: oce/src/IGESData/IGESData_IGESEntity.cxx
===================================================================
--- oce.orig/src/IGESData/IGESData_IGESEntity.cxx
+++ oce/src/IGESData/IGESData_IGESEntity.cxx
@@ -375,7 +375,7 @@ Handle(TCollection_HAsciiString) IGESDat
     Standard_Boolean IGESData_IGESEntity::ArePresentAssociativities () const
 {
   if (!theAssocs.IsEmpty()) return Standard_True;
-  return (theStatusNum & IGESFlagAssocs);
+  return 0 != (theStatusNum & IGESFlagAssocs);
 }
 
     Standard_Integer IGESData_IGESEntity::NbAssociativities () const
@@ -426,7 +426,7 @@ Handle(TCollection_HAsciiString) IGESDat
     Standard_Boolean IGESData_IGESEntity::ArePresentProperties () const
 {
   if (!theProps.IsEmpty()) return Standard_True;
-  return (theStatusNum & IGESFlagProps);
+  return 0 != (theStatusNum & IGESFlagProps);
 }
 
     Standard_Integer IGESData_IGESEntity::NbProperties () const
Index: oce/src/IGESDraw/IGESDraw_CircArraySubfigure.cxx
===================================================================
--- oce.orig/src/IGESDraw/IGESDraw_CircArraySubfigure.cxx
+++ oce/src/IGESDraw/IGESDraw_CircArraySubfigure.cxx
@@ -113,15 +113,15 @@ IGESDraw_CircArraySubfigure::IGESDraw_Ci
   //          else Search Index in to the Array. If 'Index' found in the
   //          array return theDoDontFlag else return !theDoDontFlag.
 
-  if (thePositions.IsNull())        return theDoDontFlag;
+  if (thePositions.IsNull())        return 0 != theDoDontFlag;
 
   else {
     Standard_Integer I;
     Standard_Integer up  = thePositions->Upper();
     for (I = 1; I <= up; I ++) {
-      if (thePositions->Value(I) == Index)     return theDoDontFlag;
+      if (thePositions->Value(I) == Index)     return 0 != theDoDontFlag;
     }
-    return (! theDoDontFlag);
+    return (0 == theDoDontFlag);
   }
 }
 
Index: oce/src/IGESDraw/IGESDraw_ConnectPoint.cxx
===================================================================
--- oce.orig/src/IGESDraw/IGESDraw_ConnectPoint.cxx
+++ oce/src/IGESDraw/IGESDraw_ConnectPoint.cxx
@@ -132,7 +132,7 @@ IGESDraw_ConnectPoint::IGESDraw_ConnectP
 
     Standard_Boolean IGESDraw_ConnectPoint::SwapFlag () const
 {
-  return theSwapFlag;
+  return 0 != theSwapFlag;
 }
 
     Standard_Boolean IGESDraw_ConnectPoint::HasOwnerSubfigure () const
Index: oce/src/IGESDraw/IGESDraw_RectArraySubfigure.cxx
===================================================================
--- oce.orig/src/IGESDraw/IGESDraw_RectArraySubfigure.cxx
+++ oce/src/IGESDraw/IGESDraw_RectArraySubfigure.cxx
@@ -115,7 +115,7 @@ IGESDraw_RectArraySubfigure::IGESDraw_Re
 
     Standard_Boolean IGESDraw_RectArraySubfigure::DoDontFlag () const
 {
-  return (theDoDontFlag);
+  return (0 != theDoDontFlag);
 }
 
     Standard_Boolean IGESDraw_RectArraySubfigure::PositionNum
@@ -125,14 +125,14 @@ IGESDraw_RectArraySubfigure::IGESDraw_Re
   //          else Search Index in to the Array. If 'Index' found in the
   //          array return theDoDontFlag else return !theDoDontFlag.
 
-  if (thePositions.IsNull())   return theDoDontFlag;
+  if (thePositions.IsNull())   return 0 != theDoDontFlag;
 
   Standard_Integer I;
   Standard_Integer up  = thePositions->Upper();
   for (I = 1; I <= up; I++) {
-    if (thePositions->Value(I) == Index)   return theDoDontFlag;
+    if (thePositions->Value(I) == Index)   return 0 != theDoDontFlag;
   }
-  return (! theDoDontFlag);
+  return (0 == theDoDontFlag);
 }
 
     Standard_Integer IGESDraw_RectArraySubfigure::ListPosition
Index: oce/src/IGESSolid/IGESSolid_TopoBuilder.cxx
===================================================================
--- oce.orig/src/IGESSolid/IGESSolid_TopoBuilder.cxx
+++ oce/src/IGESSolid/IGESSolid_TopoBuilder.cxx
@@ -248,7 +248,7 @@ IGESSolid_TopoBuilder::IGESSolid_TopoBui
     for (i = 1; i <= nb; i ++) loops->SetValue
       (i, GetCasted(IGESSolid_Loop,theinner->Value(i)));
   }
-  theface->Init (thesurf,theouter,loops);
+  theface->Init (thesurf,0 != theouter,loops);
   thefaces->Append(theface);
   thefflag->Append(orientation);
 }
@@ -313,7 +313,7 @@ IGESSolid_TopoBuilder::IGESSolid_TopoBui
       flags->SetValue  (i,thevflag->Value(i));
     }
   }
-  thesolid->Init (themains,themflag, shells,flags);
+  thesolid->Init (themains,0 != themflag, shells,flags);
 }
 
     Handle(IGESSolid_Shell)  IGESSolid_TopoBuilder::Shell () const
Index: oce/src/IntPatch/IntPatch_RstInt.cxx
===================================================================
--- oce.orig/src/IntPatch/IntPatch_RstInt.cxx
+++ oce/src/IntPatch/IntPatch_RstInt.cxx
@@ -741,7 +741,7 @@ void IntPatch_RstInt::PutVertexOnLine (H
 	    }
 	  }
 
-	  Standard_Boolean nbTreated = 0;
+	  Standard_Integer nbTreated = 0;
 	  for (Standard_Integer ip=0; ip < nbpt; ip++) {
 	    GetLinePoint2d (L, W1[ip]+1, !OnFirst, U,V);
 
Index: oce/src/MDataStd/MDataStd_BooleanListRetrievalDriver.cxx
===================================================================
--- oce.orig/src/MDataStd/MDataStd_BooleanListRetrievalDriver.cxx
+++ oce/src/MDataStd/MDataStd_BooleanListRetrievalDriver.cxx
@@ -70,6 +70,6 @@ void MDataStd_BooleanListRetrievalDriver
   Standard_Integer i, lower = S->Lower(), upper = S->Upper();
   for (i = lower; i <= upper; i++)
   {
-    T->Append(S->Value(i));
+    T->Append(0 != S->Value(i));
   }
 }
Index: oce/src/MeshTest/MeshTest.cxx
===================================================================
--- oce.orig/src/MeshTest/MeshTest.cxx
+++ oce/src/MeshTest/MeshTest.cxx
@@ -213,7 +213,7 @@ static Standard_Integer fastdiscret(Draw
   const Standard_Real d = Draw::Atof(argv[2]);
 
   Standard_Boolean WithShare = Standard_True;
-  if (nbarg > 3) WithShare = Draw::Atoi(argv[3]);
+  if (nbarg > 3) WithShare = (0 != Draw::Atoi(argv[3]));
 
   Bnd_Box B;
   BRepBndLib::Add(S,B);
Index: oce/src/NIS/NIS_Triangulated.cxx
===================================================================
--- oce.orig/src/NIS/NIS_Triangulated.cxx
+++ oce/src/NIS/NIS_Triangulated.cxx
@@ -904,46 +904,46 @@ Standard_Real NIS_Triangulated::Intersec
         const unsigned char * pTri =
           reinterpret_cast<unsigned char *>(mypTriangles) + (3 * i);
         if (myNodeCoord > 2)
-          isIntersect = tri_line_intersect (start, dir,
+          isIntersect = (0 != tri_line_intersect (start, dir,
                                             &mypNodes[myNodeCoord * pTri[0]],
                                             &mypNodes[myNodeCoord * pTri[1]],
                                             &mypNodes[myNodeCoord * pTri[2]],
-                                            &anInter);
+                                            &anInter));
         else
-          isIntersect = tri2d_line_intersect (start, dir,
+          isIntersect = (0 != tri2d_line_intersect (start, dir,
                                               &mypNodes[myNodeCoord * pTri[0]],
                                               &mypNodes[myNodeCoord * pTri[1]],
                                               &mypNodes[myNodeCoord * pTri[2]],
-                                              &anInter);
+                                              &anInter));
       } else if (myIndexType == 1) {
         const unsigned short * pTri =
           reinterpret_cast<unsigned short *>(mypTriangles) + (3 * i);
         if (myNodeCoord > 2)
-          isIntersect = tri_line_intersect (start, dir,
+          isIntersect = (0 != tri_line_intersect (start, dir,
                                             &mypNodes[myNodeCoord * pTri[0]],
                                             &mypNodes[myNodeCoord * pTri[1]],
                                             &mypNodes[myNodeCoord * pTri[2]],
-                                            &anInter);
+                                            &anInter));
         else
-          isIntersect = tri2d_line_intersect (start, dir,
+          isIntersect = (0 != tri2d_line_intersect (start, dir,
                                               &mypNodes[myNodeCoord * pTri[0]],
                                               &mypNodes[myNodeCoord * pTri[1]],
                                               &mypNodes[myNodeCoord * pTri[2]],
-                                              &anInter);
+                                              &anInter));
       } else {
         const Standard_Integer * pTri = &mypTriangles[3 * i];
         if (myNodeCoord > 2)
-          isIntersect = tri_line_intersect (start, dir,
+          isIntersect = (0 != tri_line_intersect (start, dir,
                                             &mypNodes[myNodeCoord * pTri[0]],
                                             &mypNodes[myNodeCoord * pTri[1]],
                                             &mypNodes[myNodeCoord * pTri[2]],
-                                            &anInter);
+                                            &anInter));
         else
-          isIntersect = tri2d_line_intersect (start, dir,
+          isIntersect = (0 != tri2d_line_intersect (start, dir,
                                               &mypNodes[myNodeCoord * pTri[0]],
                                               &mypNodes[myNodeCoord * pTri[1]],
                                               &mypNodes[myNodeCoord * pTri[2]],
-                                              &anInter);
+                                              &anInter));
       }
       if (isIntersect && anInter < aResult)
         aResult = anInter;
Index: oce/src/OSD/OSD_DirectoryIterator.cdl
===================================================================
--- oce.orig/src/OSD/OSD_DirectoryIterator.cdl
+++ oce/src/OSD/OSD_DirectoryIterator.cdl
@@ -84,7 +84,7 @@ is
 
  fields
       TheIterator  : Directory;     -- The iterator item
-      myFlag       : Integer; 
+      myFlag       : Boolean;
       myMask       : AsciiString;
       myPlace      : AsciiString;
       myDescr      : Address ;      -- unused by Windows NT code
Index: oce/src/OSD/OSD_FileIterator.cdl
===================================================================
--- oce.orig/src/OSD/OSD_FileIterator.cdl
+++ oce/src/OSD/OSD_FileIterator.cdl
@@ -81,7 +81,7 @@ is
 
  fields
       TheIterator  : File;     -- The iterator item
-      myFlag       : Integer; 
+      myFlag       : Boolean;
       myMask       : AsciiString;
       myPlace      : AsciiString;
       myDescr      : Address ;      -- unused by Windows NT code
Index: oce/src/OpenGl/OpenGl_Workspace_2.cxx
===================================================================
--- oce.orig/src/OpenGl/OpenGl_Workspace_2.cxx
+++ oce/src/OpenGl/OpenGl_Workspace_2.cxx
@@ -759,7 +759,7 @@ Standard_Boolean OpenGl_Workspace::Print
   NamedStatus &= ~OPENGL_NS_WHITEBACK;
 
   myPrintContext.Nullify();
-  return (Standard_Boolean) isDone;
+  return isDone;
 
 #else // not _WIN32
   myPrintContext.Nullify();
Index: oce/src/PBRep/PBRep_TEdge.cxx
===================================================================
--- oce.orig/src/PBRep/PBRep_TEdge.cxx
+++ oce/src/PBRep/PBRep_TEdge.cxx
@@ -83,7 +83,7 @@ void  PBRep_TEdge::SameParameter(const S
 
  Standard_Boolean  PBRep_TEdge::SameRange()const 
 {
-  return myFlags & RangeMask;
+  return 0 != (myFlags & RangeMask);
 }
 
 
@@ -105,7 +105,7 @@ void  PBRep_TEdge::SameParameter(const S
 
 Standard_Boolean  PBRep_TEdge::Degenerated()const 
 {
-  return myFlags & DegeneratedMask;
+  return 0 != (myFlags & DegeneratedMask);
 }
 
 
Index: oce/src/PBRep/PBRep_TEdge1.cxx
===================================================================
--- oce.orig/src/PBRep/PBRep_TEdge1.cxx
+++ oce/src/PBRep/PBRep_TEdge1.cxx
@@ -86,7 +86,7 @@ void  PBRep_TEdge1::SameParameter(const
 
  Standard_Boolean  PBRep_TEdge1::SameRange()const 
 {
-  return myFlags & PBRep_RangeMask;
+  return 0 != (myFlags & PBRep_RangeMask);
 }
 
 
@@ -108,7 +108,7 @@ void  PBRep_TEdge1::SameParameter(const
 
 Standard_Boolean  PBRep_TEdge1::Degenerated()const 
 {
-  return myFlags & PBRep_DegeneratedMask;
+  return 0 != (myFlags & PBRep_DegeneratedMask);
 }
 
 
Index: oce/src/PTopoDS/PTopoDS_TShape.cxx
===================================================================
--- oce.orig/src/PTopoDS/PTopoDS_TShape.cxx
+++ oce/src/PTopoDS/PTopoDS_TShape.cxx
@@ -47,7 +47,7 @@ PTopoDS_TShape::PTopoDS_TShape() : myFla
 
 Standard_Boolean  PTopoDS_TShape::Modified() const 
 {
-  return myFlags & ModifiedMask;
+  return 0 != (myFlags & ModifiedMask);
 }
 
 //=======================================================================
@@ -68,7 +68,7 @@ void  PTopoDS_TShape::Modified(const Sta
 
 Standard_Boolean  PTopoDS_TShape::Checked() const 
 {
-  return myFlags & CheckedMask;
+  return 0 != (myFlags & CheckedMask);
 }
 
 //=======================================================================
@@ -89,7 +89,7 @@ void  PTopoDS_TShape::Checked(const Stan
 
 Standard_Boolean  PTopoDS_TShape::Orientable() const 
 {
-  return myFlags & OrientableMask;
+  return 0 != (myFlags & OrientableMask);
 }
 
 //=======================================================================
@@ -110,7 +110,7 @@ void  PTopoDS_TShape::Orientable(const S
 
 Standard_Boolean  PTopoDS_TShape::Closed() const 
 {
-  return myFlags & ClosedMask;
+  return 0 != (myFlags & ClosedMask);
 }
 
 //=======================================================================
@@ -131,7 +131,7 @@ void  PTopoDS_TShape::Closed(const Stand
 
 Standard_Boolean  PTopoDS_TShape::Infinite() const 
 {
-  return myFlags & InfiniteMask;
+  return 0 != (myFlags & InfiniteMask);
 }
 
 //=======================================================================
@@ -152,7 +152,7 @@ void  PTopoDS_TShape::Infinite(const Sta
 
 Standard_Boolean  PTopoDS_TShape::Convex() const 
 {
-  return myFlags & ConvexMask;
+  return 0 != (myFlags & ConvexMask);
 }
 
 //=======================================================================
Index: oce/src/PTopoDS/PTopoDS_TShape1.cxx
===================================================================
--- oce.orig/src/PTopoDS/PTopoDS_TShape1.cxx
+++ oce/src/PTopoDS/PTopoDS_TShape1.cxx
@@ -55,7 +55,7 @@ PTopoDS_TShape1::PTopoDS_TShape1()
 //=======================================================================
 
 Standard_Boolean  PTopoDS_TShape1::Modified() const 
-{ return myFlags & PTopoDS_ModifiedMask; }
+{ return 0 != (myFlags & PTopoDS_ModifiedMask); }
 
 //=======================================================================
 //function : Modified
@@ -74,7 +74,7 @@ void  PTopoDS_TShape1::Modified(const St
 //=======================================================================
 
 Standard_Boolean  PTopoDS_TShape1::Checked() const 
-{ return myFlags & PTopoDS_CheckedMask; }
+{ return 0 != (myFlags & PTopoDS_CheckedMask); }
 
 //=======================================================================
 //function : Checked
@@ -93,7 +93,7 @@ void  PTopoDS_TShape1::Checked(const Sta
 //=======================================================================
 
 Standard_Boolean  PTopoDS_TShape1::Orientable() const 
-{ return myFlags & PTopoDS_OrientableMask; }
+{ return 0 != (myFlags & PTopoDS_OrientableMask); }
 
 //=======================================================================
 //function : Orientable
@@ -112,7 +112,7 @@ void  PTopoDS_TShape1::Orientable(const
 //=======================================================================
 
 Standard_Boolean  PTopoDS_TShape1::Closed() const 
-{ return myFlags & PTopoDS_ClosedMask; }
+{ return 0 != (myFlags & PTopoDS_ClosedMask); }
 
 //=======================================================================
 //function : Closed
@@ -131,7 +131,7 @@ void  PTopoDS_TShape1::Closed(const Stan
 //=======================================================================
 
 Standard_Boolean  PTopoDS_TShape1::Infinite() const 
-{ return myFlags & PTopoDS_InfiniteMask; }
+{ return 0 != (myFlags & PTopoDS_InfiniteMask); }
 
 //=======================================================================
 //function : Infinite
@@ -150,7 +150,7 @@ void  PTopoDS_TShape1::Infinite(const St
 //=======================================================================
 
 Standard_Boolean  PTopoDS_TShape1::Convex() const 
-{ return myFlags & PTopoDS_ConvexMask; }
+{ return 0 != (myFlags & PTopoDS_ConvexMask); }
 
 //=======================================================================
 //function : Convex
Index: oce/src/Poly/Poly_MakeLoops.hxx
===================================================================
--- oce.orig/src/Poly/Poly_MakeLoops.hxx
+++ oce/src/Poly/Poly_MakeLoops.hxx
@@ -60,7 +60,7 @@ public:
 
     Standard_Boolean IsReversed() const
     {
-      return flags & Poly_MakeLoops::LF_Reversed;
+      return 0 != (flags & Poly_MakeLoops::LF_Reversed);
     }
 
     void Nullify()
Index: oce/src/QABugs/QABugs_3.cxx
===================================================================
--- oce.orig/src/QABugs/QABugs_3.cxx
+++ oce/src/QABugs/QABugs_3.cxx
@@ -312,7 +312,7 @@ Standard_Integer ksection(Draw_Interpret
   NbPntMax=Draw::Atoi(a[4]);
   Toler3d=Draw::Atof(a[5]);
   Toler2d=Draw::Atof(a[6]);
-  RelativeTol=Draw::Atoi(a[7]);
+  RelativeTol=(0 != Draw::Atoi(a[7]));
 
   di << "BRepAlgo_BooleanOperations myalgo" << "\n";
   BRepAlgo_BooleanOperations myalgo;
Index: oce/src/QADNaming/QADNaming_BasicCommands.cxx
===================================================================
--- oce.orig/src/QADNaming/QADNaming_BasicCommands.cxx
+++ oce/src/QADNaming/QADNaming_BasicCommands.cxx
@@ -388,7 +388,7 @@ static Standard_Integer Collect (Draw_In
     if (!DDF::GetDF(arg[1],DF)) return 1;
     if (!DDF::Find(DF,arg[2],TNaming_NamedShape::GetID(),A)) return 1;
     if (nb >= 4) {
-      OnlyModif = Draw::Atoi(arg[3]);
+      OnlyModif = (0 != Draw::Atoi(arg[3]));
     }
     TNaming_Tool::Collect(A,MNS,OnlyModif);
     for (TNaming_MapIteratorOfMapOfNamedShape it(MNS); it.More(); it.Next()) {
Index: oce/src/QANewBRepNaming/QANewBRepNaming_Loader.cxx
===================================================================
--- oce.orig/src/QANewBRepNaming/QANewBRepNaming_Loader.cxx
+++ oce/src/QANewBRepNaming/QANewBRepNaming_Loader.cxx
@@ -259,7 +259,7 @@ Standard_Boolean QANewBRepNaming_Loader:
     const TopTools_ListOfShape& ancestors = subShapeAndAncestors.FindFromIndex(i);
     if (ancestors.Extent() == 1) Dangles.Bind(ancestors.First(), mayBeDangle);
   }
-  return Dangles.Extent();
+  return !Dangles.IsEmpty();
 }
 
 //=======================================================================
@@ -282,7 +282,7 @@ Standard_Boolean QANewBRepNaming_Loader:
     const TopTools_ListOfShape& ancestors = subShapeAndAncestors.FindFromIndex(i);
     if (ancestors.Extent() == 1) Dangles.Add(mayBeDangle);
   }
-  return Dangles.Extent();
+  return !Dangles.IsEmpty();
 }
 
 //=======================================================================
Index: oce/src/QANewBRepNaming/QANewBRepNaming_LoaderParent.cxx
===================================================================
--- oce.orig/src/QANewBRepNaming/QANewBRepNaming_LoaderParent.cxx
+++ oce/src/QANewBRepNaming/QANewBRepNaming_LoaderParent.cxx
@@ -56,7 +56,7 @@ Standard_Boolean QANewBRepNaming_LoaderP
     const TopTools_ListOfShape& ancestors = subShapeAndAncestors.FindFromIndex(i);
     if (ancestors.Extent() == 1) Dangles.Bind(ancestors.First(), mayBeDangle);
   }
-  return Dangles.Extent();
+  return !Dangles.IsEmpty();
 }
 
 //=======================================================================
Index: oce/src/QANewDBRepNaming/QANewDBRepNaming_PrimitiveCommands.cxx
===================================================================
--- oce.orig/src/QANewDBRepNaming/QANewDBRepNaming_PrimitiveCommands.cxx
+++ oce/src/QANewDBRepNaming/QANewDBRepNaming_PrimitiveCommands.cxx
@@ -216,7 +216,7 @@ static Standard_Integer QANewDBRepNaming
       namePrism.Load(mkPrism, Basis);
     }      
     else if (nb == 9) {
-      BRepPrimAPI_MakePrism mkPrism(Basis, Direction, (Standard_Boolean)Draw::Atoi(arg[8]));  
+      BRepPrimAPI_MakePrism mkPrism(Basis, Direction, 0 != Draw::Atoi(arg[8]));  
       mkPrism.Build();
       
       if(!mkPrism.IsDone()) {
Index: oce/src/QANewModTopOpe/QANewModTopOpe_Tools.cxx
===================================================================
--- oce.orig/src/QANewModTopOpe/QANewModTopOpe_Tools.cxx
+++ oce/src/QANewModTopOpe/QANewModTopOpe_Tools.cxx
@@ -178,7 +178,7 @@ TopoDS_Shape QANewModTopOpe_Tools::NewVe
 Standard_Boolean QANewModTopOpe_Tools::HasSameDomain(const BOPAlgo_PBOP& theBuilder, 
                                                      const TopoDS_Shape& theFace) 
 {
-  Standard_Integer bRet;
+  Standard_Boolean bRet;
   bRet = Standard_False;
   //
   if(theFace.IsNull() || (theFace.ShapeType() != TopAbs_FACE))
Index: oce/src/RWStl/RWStl.cxx
===================================================================
--- oce.orig/src/RWStl/RWStl.cxx
+++ oce/src/RWStl/RWStl.cxx
@@ -95,7 +95,7 @@ inline static void WriteDouble2Float(OSD
 inline static Standard_Real ReadFloat2Double(OSD_File &aFile)
 {
   union {
-    Standard_Boolean i; // don't be afraid, this is just an unsigned int
+    Standard_Integer i;// don't be afraid, this is just an unsigned int
     Standard_ShortReal f;
   }bidargum;
 
Index: oce/src/STEPControl/STEPControl_ActorRead.cxx
===================================================================
--- oce.orig/src/STEPControl/STEPControl_ActorRead.cxx
+++ oce/src/STEPControl/STEPControl_ActorRead.cxx
@@ -778,7 +778,7 @@ Handle(TransferBRep_ShapeBinder) STEPCon
   Message_ProgressSentry PS ( TP->GetProgress(), "Sub-assembly", 0, nb, 1 );
 
   // [BEGIN] Proceed with non-manifold topology (ssv; 12.11.2010)
-  Standard_Boolean isNMMode = Interface_Static::IVal("read.step.nonmanifold");
+  Standard_Boolean isNMMode = (0 != Interface_Static::IVal("read.step.nonmanifold"));
   Standard_Boolean isManifold = Standard_True;
   if ( isNMMode && sr->IsKind(STANDARD_TYPE(StepShape_NonManifoldSurfaceShapeRepresentation)) ) {
     isManifold = Standard_False;
Index: oce/src/STEPControl/STEPControl_ActorWrite.cxx
===================================================================
--- oce.orig/src/STEPControl/STEPControl_ActorWrite.cxx
+++ oce/src/STEPControl/STEPControl_ActorWrite.cxx
@@ -639,7 +639,7 @@ Handle(Transfer_Binder) STEPControl_Acto
     return TransferCompound(start, SDR0, FP);
 
   // [BEGIN] Separate manifold topology from non-manifold in group mode 0 (ssv; 18.11.2010)
-  Standard_Boolean isNMMode = Interface_Static::IVal("write.step.nonmanifold");
+  Standard_Boolean isNMMode = (0 != Interface_Static::IVal("write.step.nonmanifold"));
   Handle(Transfer_Binder) aNMBinder;
   if (isNMMode && !GroupMode() && theShape.ShapeType() == TopAbs_COMPOUND) {
     TopoDS_Compound aNMCompound;
@@ -1275,7 +1275,7 @@ Handle(Transfer_Binder) STEPControl_Acto
   TopoDS_Shape theShape = mapper->Value();
 
   // Inspect non-manifold topology case (ssv; 10.11.2010)
-  Standard_Boolean isNMMode = Interface_Static::IVal("write.step.nonmanifold");
+  Standard_Boolean isNMMode = (0 != Interface_Static::IVal("write.step.nonmanifold"));
   Standard_Boolean isManifold;
   if (isNMMode)
     isManifold = IsManifoldShape(theShape);
Index: oce/src/STEPControl/STEPControl_Reader.cxx
===================================================================
--- oce.orig/src/STEPControl/STEPControl_Reader.cxx
+++ oce/src/STEPControl/STEPControl_Reader.cxx
@@ -550,6 +550,6 @@ Standard_Boolean STEPControl_Reader::fin
        
    }
     
-  return (nbFind);
+  return (0 != nbFind);
 }
                                    
Index: oce/src/SWDRAW/SWDRAW_ShapeAnalysis.cxx
===================================================================
--- oce.orig/src/SWDRAW/SWDRAW_ShapeAnalysis.cxx
+++ oce/src/SWDRAW/SWDRAW_ShapeAnalysis.cxx
@@ -621,8 +621,8 @@ static Standard_Integer freebounds (Draw
   if (shape.IsNull()) return 1;
   Standard_Real toler = Draw::Atof (a[2]);
   Standard_Boolean splitclosed = Standard_False, splitopen = Standard_False;
-  if ( n > 3) splitclosed = Draw::Atoi (a[3]);
-  if ( n > 4) splitopen   = Draw::Atoi (a[4]);
+  if ( n > 3) splitclosed = (0 != Draw::Atoi (a[3]));
+  if ( n > 4) splitopen   = (0 != Draw::Atoi (a[4]));
 
   ShapeAnalysis_FreeBounds F;
   if (toler <= 0)
@@ -685,8 +685,8 @@ static Standard_Integer FreeBoundsProps(
   Standard_Real toler = 0.;
   Standard_Boolean splitclosed = Standard_False, splitopen = Standard_False;
   if (n > 2) toler =  Draw::Atof(a[2]);
-  if (n > 3) splitclosed = Draw::Atoi(a[3]);
-  if (n > 4) splitopen   = Draw::Atoi(a[4]);
+  if (n > 3) splitclosed = (0 != Draw::Atoi(a[3]));
+  if (n > 4) splitopen   = (0 != Draw::Atoi(a[4]));
   ShapeAnalysis_FreeBoundsProperties analyzer;
   if (toler > 0)
     analyzer.Init(source, toler, splitclosed, splitopen);
@@ -743,8 +743,8 @@ static Standard_Integer closefreebounds
   if (shape.IsNull()) return 1;
   Standard_Real sewtoler = Draw::Atof (a[2]), closetoler = Draw::Atof (a[3]);
   Standard_Boolean splitclosed = Standard_False, splitopen = Standard_False;
-  if ( n > 4) splitclosed = Draw::Atoi (a[3]);
-  if ( n > 5) splitopen   = Draw::Atoi (a[4]);
+  if ( n > 4) splitclosed = (0 != Draw::Atoi (a[3]));
+  if ( n > 5) splitopen   = (0 != Draw::Atoi (a[4]));
 
   ShapeFix_FreeBounds F;
   if (sewtoler <= 0)
Index: oce/src/SWDRAW/SWDRAW_ShapeCustom.cxx
===================================================================
--- oce.orig/src/SWDRAW/SWDRAW_ShapeCustom.cxx
+++ oce/src/SWDRAW/SWDRAW_ShapeCustom.cxx
@@ -162,7 +162,7 @@ static void expcurv2d(const Handle(Geom2
   if (aCurve->IsKind(STANDARD_TYPE(Geom2d_BezierCurve))) {
     Handle(Geom2d_BezierCurve) Bs = Handle(Geom2d_BezierCurve)::DownCast(aCurve); 
     if(Bs->Degree() > Degree) Nb.ChangeValue(2,1)++;
-    if(Bs->IsRational() > ((unsigned int)MaxSeg) )  Nb.ChangeValue(2,3)++;
+    if(Bs->IsRational() && 0 == MaxSeg )  Nb.ChangeValue(2,3)++;
     if(aCont < theCont)
     {
 
@@ -214,7 +214,7 @@ static void expcurv(const Handle(Geom_Cu
   if (aCurve->IsKind(STANDARD_TYPE(Geom_BezierCurve))) {
     Handle(Geom_BezierCurve) Bs = Handle(Geom_BezierCurve)::DownCast(aCurve); 
     if(Bs->Degree() > Degree) Nb.ChangeValue(2,1)++;
-    if(Bs->IsRational() > ((unsigned int)MaxSeg) )  Nb.ChangeValue(2,3)++;
+    if(Bs->IsRational() && 0 == MaxSeg )  Nb.ChangeValue(2,3)++;
     if(aCont < theCont) 
       Nb.ChangeValue(2,4)++;
     return;
@@ -440,7 +440,7 @@ static Standard_Integer BSplRes(Draw_Int
     di<< "Invalid argument Cont3e" << "\n"; return 1; }
 
   Handle(ShapeCustom_RestrictionParameters) aParameters = new ShapeCustom_RestrictionParameters;
-  TopoDS_Shape result = ShapeCustom::BSplineRestriction (Shape, Draw::Atof(argv[3]), Draw::Atof(argv[4]), Draw::Atoi(argv[5]),Draw::Atoi(argv[6]),aCont3,aCont2,(Standard_Boolean) Draw::Atoi(argv[9]),(Standard_Boolean) Draw::Atoi(argv[10]),aParameters);
+  TopoDS_Shape result = ShapeCustom::BSplineRestriction (Shape, Draw::Atof(argv[3]), Draw::Atof(argv[4]), Draw::Atoi(argv[5]),Draw::Atoi(argv[6]),aCont3,aCont2,0 != Draw::Atoi(argv[9]), 0 != Draw::Atoi(argv[10]),aParameters);
   if (result.IsNull()) { di << "NO RESULT" << "\n"; return 1; }
   else if (result == Shape) { 
     di << "NO MODIFICATIONS" << "\n";
Index: oce/src/SWDRAW/SWDRAW_ShapeExtend.cxx
===================================================================
--- oce.orig/src/SWDRAW/SWDRAW_ShapeExtend.cxx
+++ oce/src/SWDRAW/SWDRAW_ShapeExtend.cxx
@@ -38,7 +38,7 @@ static Standard_Integer sortcompound (Dr
   if (argc < 4) {
     ShapeExtend_Explorer sbx;
     for (int i = 0; i < 2; i ++) {
-      TopAbs_ShapeEnum ts = sbx.ShapeType(Shape,i);
+      TopAbs_ShapeEnum ts = sbx.ShapeType(Shape,0 != i);
       //cout<<"   Type "<<(i ? " (via Compound) : " : "(True) : ");
       if (i == 0) {
 	di<<"   Type "<<"(True) : ";
Index: oce/src/ShapeAnalysis/ShapeAnalysis_Surface.cdl
===================================================================
--- oce.orig/src/ShapeAnalysis/ShapeAnalysis_Surface.cdl
+++ oce/src/ShapeAnalysis/ShapeAnalysis_Surface.cdl
@@ -356,7 +356,7 @@ is
     	    	                P3D    : Pnt from gp;
                                 preci  : Real;
                                 sol    :in out Pnt2d from gp)
-    returns Boolean is private;
+    returns Integer is private;
     
     SortSingularities (me: mutable) is private;
     
Index: oce/src/ShapeAnalysis/ShapeAnalysis_Surface.cxx
===================================================================
--- oce.orig/src/ShapeAnalysis/ShapeAnalysis_Surface.cxx
+++ oce/src/ShapeAnalysis/ShapeAnalysis_Surface.cxx
@@ -780,7 +780,7 @@ Standard_Boolean ShapeAnalysis_Surface::
 //function : SurfaceNewton
 //purpose  : Newton algo (S4030)
 //=======================================================================
-Standard_Boolean ShapeAnalysis_Surface::SurfaceNewton(const gp_Pnt2d &p2dPrev,
+Standard_Integer ShapeAnalysis_Surface::SurfaceNewton(const gp_Pnt2d &p2dPrev,
                                                       const gp_Pnt& P3D,
                                                       const Standard_Real preci,
                                                       gp_Pnt2d &sol)
@@ -878,7 +878,7 @@ gp_Pnt2d ShapeAnalysis_Surface::NextValu
 //    if ( ! mySurf->Continuity() == GeomAbs_C0 ) //: S4030: fix on BUC40132 8355 & PRO7978 1987: SI because of bad data
     {
       gp_Pnt2d sol;
-      Standard_Boolean res = SurfaceNewton(p2dPrev,P3D,preci,sol);
+      Standard_Integer res = SurfaceNewton(p2dPrev,P3D,preci,sol);
       if ( res ) {
 	Standard_Real gap = P3D.Distance ( Value(sol) );
 	if ( res ==2 || //:q6 abv 19 Mar 99: protect against strange attractors
Index: oce/src/ShapeCustom/ShapeCustom_DirectModification.cxx
===================================================================
--- oce.orig/src/ShapeCustom/ShapeCustom_DirectModification.cxx
+++ oce/src/ShapeCustom/ShapeCustom_DirectModification.cxx
@@ -59,7 +59,7 @@ static Standard_Integer IsIndirectSurfac
     Standard_Boolean neg = t.IsNegative();
     Standard_Boolean det = ( t.VectorialPart().Determinant() < 0.0 );
     Standard_Boolean dir = ES->Position().Direct();
-    if ( (Standard_Boolean)( neg != det ) == dir ) result = 1;
+    if ( ( neg != det ) == dir ) result = 1;
     Handle(Geom_ConicalSurface) CS = Handle(Geom_ConicalSurface)::DownCast(ES);
     if (!CS.IsNull()) {
       // does the cone have negative semiangle ?
Index: oce/src/ShapeFix/ShapeFix_ComposeShell.cxx
===================================================================
--- oce.orig/src/ShapeFix/ShapeFix_ComposeShell.cxx
+++ oce/src/ShapeFix/ShapeFix_ComposeShell.cxx
@@ -407,7 +407,7 @@ static Standard_Integer ApplyContext (Sh
 //purpose  : auxilary
 //=======================================================================
 // check points coincidence
-static inline Standard_Integer IsCoincided (const gp_Pnt2d &p1, const gp_Pnt2d &p2,
+static inline Standard_Boolean IsCoincided (const gp_Pnt2d &p1, const gp_Pnt2d &p2,
 					    const Standard_Real UResolution,
 					    const Standard_Real VResolution,
 					    const Standard_Real tol)
@@ -736,7 +736,7 @@ static void DistributeSplitPoints (const
   
   for ( i=1; i <= indexes.Length() && indexes(i) < index; i++ );
   for ( Standard_Integer shift = 1; i <= indexes.Length() && indexes(i) == index; i++ ) {
-    while (  shift < nsplit  && isreversed != (Standard_Boolean) ( values(i) > params(shift) ) ) shift++;
+    while (  shift < nsplit  && isreversed != ( values(i) > params(shift) ) ) shift++;
     indexes.SetValue ( i, index + shift - 1 );
   }
   for ( ; i <= indexes.Length(); i++ ) 
@@ -1146,7 +1146,7 @@ ShapeFix_WireSegment ShapeFix_ComposeShe
         B.SameRange(newEdge, Standard_False);
       //pdn take into account 0 codes (if ext)
       if(code == 0 && wire.Orientation()==TopAbs_EXTERNAL){
-        code  = ( ( isCutByU == (Standard_Boolean)( j == 1 ) ) ? 1 : 2 );
+        code  = ( ( isCutByU == ( j == 1 ) ) ? 1 : 2 );
       }
       
       result.AddEdge ( 0, newEdge, iumin, iumax, ivmin, ivmax );
@@ -1189,7 +1189,7 @@ ShapeFix_WireSegment ShapeFix_ComposeShe
         result.AddEdge ( 0, edge, iumin, iumax, ivmin, ivmax );
       if(code == 0 && wire.Orientation()==TopAbs_EXTERNAL){
 	//pdn defining code for intersection of two isos
-        code = ( ( isCutByU == (Standard_Boolean)( Abs(firstPar-currPar) < Abs(lastPar-currPar) ) ) ? 2 : 1 );
+        code = ( ( isCutByU == ( Abs(firstPar-currPar) < Abs(lastPar-currPar) ) ) ? 2 : 1 );
       }
       DefinePatch ( result, code, isCutByU, cutIndex );
     }
@@ -1401,7 +1401,7 @@ Standard_Boolean ShapeFix_ComposeShell::
     // Sort by parameter on edge
     for ( i = IntEdgePar.Length(); i > start; i-- ) 
       for ( Standard_Integer j = start; j < i; j++ ) {
-        if ( isreversed == (Standard_Boolean) ( IntEdgePar(j+1) < IntEdgePar(j) ) ) continue;
+        if ( isreversed == ( IntEdgePar(j+1) < IntEdgePar(j) ) ) continue;
         IntLinePar.Exchange ( j, j+1 );
         IntEdgePar.Exchange ( j, j+1 );
       }
@@ -2013,7 +2013,8 @@ void ShapeFix_ComposeShell::CollectWires
   for(;;) {
     Standard_Integer index = 0;
     Standard_Boolean misoriented = Standard_True, samepatch = Standard_False;
-    Standard_Boolean reverse = Standard_False, connected = Standard_False;
+    Standard_Integer reverse = Standard_False;
+    Standard_Boolean connected = Standard_False;
     Standard_Real angle = -M_PI, mindist = RealLast();
     Standard_Integer weigth = 0;
     Standard_Real shiftu=0., shiftv=0.;
@@ -2039,7 +2040,7 @@ void ShapeFix_ComposeShell::CollectWires
       }
 
       // check whether current segment is on the same patch with previous
-      Standard_Integer sp = ( myClosedMode || // no indexation in closed mode
+      Standard_Boolean sp = ( myClosedMode || // no indexation in closed mode
 			      IsSamePatch ( seg, myGrid->NbUPatches(), myGrid->NbVPatches(), 
 					    iumin, iumax, ivmin, ivmax ) );
 
@@ -2061,7 +2062,7 @@ void ShapeFix_ComposeShell::CollectWires
         if ( ! endV.IsSame ( j ? seg.LastVertex() : seg.FirstVertex() ) ) continue;
 
 	// check for misorientation only if nothing better is found
-        Standard_Integer misor = ( anOr == ( j ? TopAbs_REVERSED : TopAbs_FORWARD ) );
+        Standard_Boolean misor = ( anOr == ( j ? TopAbs_REVERSED : TopAbs_FORWARD ) );
 //	if ( misor ) continue; // temporarily, to be improved
 
 	// returning back by the same edge is lowest priority
@@ -2237,7 +2238,7 @@ void ShapeFix_ComposeShell::CollectWires
       for ( Standard_Integer k=1; k <= sbwd->NbEdges(); k++ ) {
 	if ( !V.IsSame ( sae.FirstVertex ( sbwd->Edge(k) ) ) ) continue; //pdn I suppose that short segment should be inserted into the SAME vertex.
 	
-	Standard_Integer sp = IsSamePatch ( wires(j), myGrid->NbUPatches(), myGrid->NbVPatches(), 
+	Standard_Boolean sp = IsSamePatch ( wires(j), myGrid->NbUPatches(), myGrid->NbVPatches(), 
 					   iumin, iumax, ivmin, ivmax );
 	if ( samepatch && !sp) continue;
 	gp_Pnt2d pp;
@@ -2487,7 +2488,7 @@ void ShapeFix_ComposeShell::MakeFacesOnP
       else
         continue;
       TopAbs_State state = clas.Perform (unp,Standard_False);
-      if ( (Standard_Boolean) ( state == TopAbs_OUT ) == reverse ) {
+      if ( ( state == TopAbs_OUT ) == reverse ) {
         holes.Append ( loops(j) );
         loops.Remove ( j-- );
       }
Index: oce/src/ShapeFix/ShapeFix_Face.cxx
===================================================================
--- oce.orig/src/ShapeFix/ShapeFix_Face.cxx
+++ oce/src/ShapeFix/ShapeFix_Face.cxx
@@ -1093,7 +1093,7 @@ Standard_Boolean ShapeFix_Face::FixOrien
     TopoDS_Face af = TopoDS::Face ( dummy );
     af.Orientation ( TopAbs_FORWARD );
     B.Add (af,ws.Value(1));
-    if ((myFixAddNaturalBoundMode != Standard_True || //: abv 29.08.01: Spatial_firex_lofting.sat
+    if ((myFixAddNaturalBoundMode != 1 || //: abv 29.08.01: Spatial_firex_lofting.sat
          !IsSurfaceUVPeriodic (mySurf->Surface())    ) &&
         !ShapeAnalysis::IsOuterBound (af)                )
     {
Index: oce/src/ShapeFix/ShapeFix_Shape.cxx
===================================================================
--- oce.orig/src/ShapeFix/ShapeFix_Shape.cxx
+++ oce/src/ShapeFix/ShapeFix_Shape.cxx
@@ -140,7 +140,7 @@ Standard_Boolean ShapeFix_Shape::Perform
   case TopAbs_COMPOUND:  
   case TopAbs_COMPSOLID: {
     TopoDS_Shape shape = myShape;
-    Standard_Boolean savFixSameParameterMode = myFixSameParameterMode;
+    Standard_Integer savFixSameParameterMode = myFixSameParameterMode;
     myFixSameParameterMode = Standard_False;
 
     Standard_Integer aShapesNb = 0;
@@ -190,7 +190,7 @@ Standard_Boolean ShapeFix_Shape::Perform
   case TopAbs_FACE: {
     if ( ! NeedFix ( myFixFaceMode ) ) break;
     Handle(ShapeFix_Face) sff = FixFaceTool();
-    Standard_Integer savTopoMode = sff->FixWireTool()->ModifyTopologyMode();
+    Standard_Boolean savTopoMode = sff->FixWireTool()->ModifyTopologyMode();
     sff->FixWireTool()->ModifyTopologyMode() = Standard_True;
     sff->Init(TopoDS::Face(S)); 
     sff->SetContext(Context());
@@ -205,8 +205,8 @@ Standard_Boolean ShapeFix_Shape::Perform
   case TopAbs_WIRE: {
     if ( ! NeedFix ( myFixWireMode ) ) break;
     Handle(ShapeFix_Wire) sfw = FixWireTool();
-    Standard_Integer savTopoMode = sfw->ModifyTopologyMode();
-    Standard_Integer savClosedMode = sfw->ClosedWireMode();
+    Standard_Boolean savTopoMode = sfw->ModifyTopologyMode();
+    Standard_Boolean savClosedMode = sfw->ClosedWireMode();
     sfw->ModifyTopologyMode() = Standard_True;
     if ( ! S.Closed() ) 
       sfw->ClosedWireMode() = Standard_False;
Index: oce/src/ShapeFix/ShapeFix_Shell.cxx
===================================================================
--- oce.orig/src/ShapeFix/ShapeFix_Shell.cxx
+++ oce/src/ShapeFix/ShapeFix_Shell.cxx
@@ -185,7 +185,7 @@ static Standard_Boolean GetFreeEdges(con
       else  MapEdges.Remove(edge);
     }
   }
-  return (MapEdges.Extent());
+  return (!MapEdges.IsEmpty());
 }
 //=======================================================================
 // function : GetShells
@@ -656,7 +656,7 @@ static void GlueClosedCandidate(TopTools
       for(Standard_Integer j1 = i+1 ; j1 <= OpenShells.Length();j1++ )  {
         if(!MapOtherShells.IsBound(OpenShells.Value(j1))) continue;
         addShell = OpenShells.Value(j1);
-        isReversed = MapOtherShells.Find(addShell);
+        isReversed = (0 != MapOtherShells.Find(addShell));
         OpenShells.Remove(j1);
         break;
       }
Index: oce/src/ShapeFix/ShapeFix_Solid.cdl
===================================================================
--- oce.orig/src/ShapeFix/ShapeFix_Solid.cdl
+++ oce/src/ShapeFix/ShapeFix_Solid.cdl
@@ -50,7 +50,7 @@ is
     returns Solid from TopoDS;
     	---Purpose: Calls MakeSolid and orients the solid to be "not infinite"
 	
-    Status (me; status : Status from  ShapeExtend) returns Boolean;
+    Status (me; status : Status from  ShapeExtend) returns Integer;
     	---Purpose: Returns the status of the last Fix.	
 	
     Solid (me) returns Shape from TopoDS;
Index: oce/src/ShapeFix/ShapeFix_Solid.cxx
===================================================================
--- oce.orig/src/ShapeFix/ShapeFix_Solid.cxx
+++ oce/src/ShapeFix/ShapeFix_Solid.cxx
@@ -567,7 +567,7 @@ TopoDS_Solid ShapeFix_Solid::SolidFromSh
 //purpose  : 
 //=======================================================================
 
- Standard_Boolean ShapeFix_Solid::Status(const ShapeExtend_Status /*status*/) const
+ Standard_Integer ShapeFix_Solid::Status(const ShapeExtend_Status /*status*/) const
 {
  return myStatus;
 }
Index: oce/src/ShapeFix/ShapeFix_Wire.cxx
===================================================================
--- oce.orig/src/ShapeFix/ShapeFix_Wire.cxx
+++ oce/src/ShapeFix/ShapeFix_Wire.cxx
@@ -317,7 +317,7 @@ Standard_Boolean ShapeFix_Wire::Perform(
   if ( ! IsLoaded() ) return Standard_False;
   
 
-  Standard_Integer Fixed = Standard_False;
+  Standard_Boolean Fixed = Standard_False;
   
   // FixReorder is first, because as a rule wire is required to be ordered
   // We shall analyze the order of edges in the wire and set appropriate 
Index: oce/src/ShapeProcess/ShapeProcess_Context.cxx
===================================================================
--- oce.orig/src/ShapeProcess/ShapeProcess_Context.cxx
+++ oce/src/ShapeProcess/ShapeProcess_Context.cxx
@@ -270,7 +270,7 @@ Standard_Boolean ShapeProcess_Context::G
   if ( myRC.IsNull() ) return Standard_False;
   try {
     OCC_CATCH_SIGNALS
-    val = (Standard_Boolean)myRC->Integer ( MakeName ( myScope, param )->ToCString() );
+    val = (0 != myRC->Integer ( MakeName ( myScope, param )->ToCString() ));
     return Standard_True;
   }
   catch (Standard_Failure) {
Index: oce/src/ShapeProcess/ShapeProcess_OperLibrary.cxx
===================================================================
--- oce.orig/src/ShapeProcess/ShapeProcess_OperLibrary.cxx
+++ oce/src/ShapeProcess/ShapeProcess_OperLibrary.cxx
@@ -135,7 +135,7 @@ static Standard_Boolean sameparam (const
   Handle(ShapeProcess_ShapeContext) ctx = Handle(ShapeProcess_ShapeContext)::DownCast ( context );
   if ( ctx.IsNull() ) return Standard_False;
   ShapeFix::SameParameter ( ctx->Result(), 
-			    ctx->IntegerVal ( "Force", Standard_False ),
+			    ctx->BooleanVal ( "Force", Standard_False ),
 			    ctx->RealVal ( "Tolerance3d", Precision::Confusion() /* -1 */) ); 
   // WARNING: no update of context yet!
   return Standard_True;
@@ -208,9 +208,9 @@ static Standard_Boolean bsplinerestricti
   Handle(ShapeProcess_ShapeContext) ctx = Handle(ShapeProcess_ShapeContext)::DownCast ( context );
   if ( ctx.IsNull() ) return Standard_False;
 
-  Standard_Boolean ModeSurf  = ctx->IntegerVal ( "SurfaceMode", Standard_True );
-  Standard_Boolean ModeC3d   = ctx->IntegerVal ( "Curve3dMode", Standard_True );
-  Standard_Boolean ModeC2d   = ctx->IntegerVal ( "Curve2dMode", Standard_True );
+  Standard_Boolean ModeSurf  = ctx->BooleanVal ( "SurfaceMode", Standard_True );
+  Standard_Boolean ModeC3d   = ctx->BooleanVal ( "Curve3dMode", Standard_True );
+  Standard_Boolean ModeC2d   = ctx->BooleanVal ( "Curve2dMode", Standard_True );
 
   Standard_Real aTol3d = ctx->RealVal ( "Tolerance3d", 0.01 );
   Standard_Real aTol2d = ctx->RealVal ( "Tolerance2d", 1e-06 );
@@ -221,8 +221,8 @@ static Standard_Boolean bsplinerestricti
   Standard_Integer aMaxDeg = ctx->IntegerVal ( "RequiredDegree", 9 );
   Standard_Integer aMaxSeg = ctx->IntegerVal ( "RequiredNbSegments", 10000 );
   
-  Standard_Boolean ModeDeg  = ctx->IntegerVal ( "PreferDegree", Standard_True );
-  Standard_Boolean Rational = ctx->IntegerVal ( "RationalToPolynomial", Standard_False );
+  Standard_Boolean ModeDeg  = ctx->BooleanVal ( "PreferDegree", Standard_True );
+  Standard_Boolean Rational = ctx->BooleanVal ( "RationalToPolynomial", Standard_False );
   
   Handle(ShapeCustom_RestrictionParameters)   aParameters = new ShapeCustom_RestrictionParameters;
   ctx->GetInteger ( "MaxDegree",          aParameters->GMaxDegree() );
@@ -594,7 +594,7 @@ static Standard_Boolean fixshape (const
   sfs->FixVertexPositionMode() = ctx->IntegerVal ( "FixVertexPositionMode", 0 );
 
   sfs->FixSolidTool()->FixShellMode() = ctx->IntegerVal ( "FixShellMode", -1 );
-  sfs->FixSolidTool()->CreateOpenSolidMode() = ctx->IntegerVal ( "CreateOpenSolidMode", 1 );
+  sfs->FixSolidTool()->CreateOpenSolidMode() = ctx->BooleanVal ( "CreateOpenSolidMode", Standard_True );
 
   sfs->FixShellTool()->FixFaceMode() = ctx->IntegerVal ( "FixFaceMode", -1 );
 
Index: oce/src/Standard/Handle_Standard_Transient.hxx
===================================================================
--- oce.orig/src/Standard/Handle_Standard_Transient.hxx
+++ oce/src/Standard/Handle_Standard_Transient.hxx
@@ -140,13 +140,13 @@ public:
   }
 
   //! Check for equality
-  int operator==(const Handle(Standard_Transient)& right) const
+  Standard_Boolean operator==(const Handle(Standard_Transient)& right) const
   {
     return entity == right.entity;
   }
 
   //! Check for equality
-  int operator==(const Standard_Transient *right) const
+  Standard_Boolean operator==(const Standard_Transient *right) const
   {
     return entity == right;
   }
Index: oce/src/Standard/Standard_Character.hxx
===================================================================
--- oce.orig/src/Standard/Standard_Character.hxx
+++ oce/src/Standard/Standard_Character.hxx
@@ -62,19 +62,19 @@ inline Standard_Boolean IsSimilar(const
 // IsAlphabetic : Returns Standard_True if a character is alphabetic
 // ==================================================================
 inline Standard_Boolean IsAlphabetic(const Standard_Character me) 
-{ return std::isalpha ((unsigned char)me); }
+{ return 0 != std::isalpha ((unsigned char)me); }
 
 // ==================================================================
 // IsDigit : Returns Standard_True if a character is a digit
 // ==================================================================
 inline Standard_Boolean IsDigit(const Standard_Character me) 
-{ return std::isdigit ((unsigned char)me); }
+{ return 0 != std::isdigit ((unsigned char)me); }
 
 // ==================================================================
 // IsXDigit : Returns Standard_True if a character is a digit
 // ==================================================================
 inline Standard_Boolean IsXDigit(const Standard_Character me) 
-{ return std::isxdigit((unsigned char)me); }
+{ return 0 != std::isxdigit((unsigned char)me); }
 
 // ==================================================================
 // IsAlphanumeric : Returns Standard_True if a character is alphanumeric
@@ -86,26 +86,26 @@ inline Standard_Boolean IsAlphanumeric(c
 // IsControl : Returns Standard_True if a character  is a control character
 // ==================================================================
 inline Standard_Boolean IsControl(const Standard_Character me) 
-{ return std::iscntrl((unsigned char)me); }
+{ return 0 != std::iscntrl((unsigned char)me); }
 
 
 // ==================================================================
 // IsGraphic : Returns Standard_True if a character is graphic
 // ==================================================================
 inline Standard_Boolean IsGraphic(const Standard_Character me) 
-{ return std::isgraph((unsigned char)me); }
+{ return 0 != std::isgraph((unsigned char)me); }
 
 // ==================================================================
 // IsLowerCase : Returns Standard_True if a character is lowercase
 // ==================================================================
 inline Standard_Boolean IsLowerCase(const Standard_Character me) 
-{ return std::islower((unsigned char)me); }
+{ return 0 != std::islower((unsigned char)me); }
 
 // ==================================================================
 // IsPrintable : Returns Standard_True if a character is printable
 // ==================================================================
 inline Standard_Boolean IsPrintable(const Standard_Character me) 
-{ return std::isprint((unsigned char)me); }
+{ return 0 != std::isprint((unsigned char)me); }
 
 // ==================================================================
 // IsPunctuation : Returns Standard_True if a character is a graphic and 
@@ -118,13 +118,13 @@ inline Standard_Boolean IsPunctuation(co
 // IsSpace : Returns Standard_True if a character is a space
 // ==================================================================
 inline Standard_Boolean IsSpace(const Standard_Character me) 
-{ return std::isspace((unsigned char)me); }
+{ return 0 != std::isspace((unsigned char)me); }
 
 // ==================================================================
 // IsUppercase : Returns Standard_True if a character is uppercase
 // ==================================================================
 inline Standard_Boolean IsUpperCase(const Standard_Character me) 
-{ return std::isupper((unsigned char)me); }
+{ return 0 != std::isupper((unsigned char)me); }
 
 // ==================================================================
 // LowerCase : Returns a lowercase character
Index: oce/src/Standard/Standard_Persistent.cxx
===================================================================
--- oce.orig/src/Standard/Standard_Persistent.cxx
+++ oce/src/Standard/Standard_Persistent.cxx
@@ -67,7 +67,7 @@ Standard_Persistent& Standard_Persistent
 Standard_Boolean Standard_Persistent::IsInstance(const Handle(Standard_Type)
 						&AType) const
 {
-  return (Standard_Boolean) (AType ==  DynamicType());
+  return (AType ==  DynamicType());
 }
 
 //
Index: oce/src/Standard/Standard_Transient.cxx
===================================================================
--- oce.orig/src/Standard/Standard_Transient.cxx
+++ oce/src/Standard/Standard_Transient.cxx
@@ -43,7 +43,7 @@ Standard_Transient::~Standard_Transient(
 //
 Standard_Boolean Standard_Transient::IsInstance(const Handle(Standard_Type) &AType) const
 {
-  return (Standard_Boolean) (AType ==  DynamicType());
+  return (AType ==  DynamicType());
 }
 
 //
Index: oce/src/Standard/Standard_TypeDef.hxx
===================================================================
--- oce.orig/src/Standard/Standard_TypeDef.hxx
+++ oce/src/Standard/Standard_TypeDef.hxx
@@ -51,14 +51,14 @@
   #include <inttypes.h>
 #endif
 
-#define Standard_False (Standard_Boolean)0
-#define Standard_True  (Standard_Boolean)1
+#define Standard_False false
+#define Standard_True  true
 
 #include <Standard_Macro.hxx>
 
 typedef int           Standard_Integer;
 typedef double        Standard_Real;
-typedef unsigned int  Standard_Boolean;
+typedef bool          Standard_Boolean;
 typedef float         Standard_ShortReal;
 typedef char          Standard_Character;
 typedef short         Standard_ExtCharacter;
Index: oce/src/StepToTopoDS/StepToTopoDS_TranslateEdge.cxx
===================================================================
--- oce.orig/src/StepToTopoDS/StepToTopoDS_TranslateEdge.cxx
+++ oce/src/StepToTopoDS/StepToTopoDS_TranslateEdge.cxx
@@ -375,7 +375,7 @@ static void GetCartesianPoints ( const H
 				 gp_Pnt &P1, gp_Pnt &P2)
 {
   for ( Standard_Integer i=1; i<=2; i++ ) {
-    const Handle(StepShape_Vertex) V = ( (Standard_Boolean)(i==1) == EC->SameSense() ? EC->EdgeStart() : EC->EdgeEnd() );
+    const Handle(StepShape_Vertex) V = ( (i==1) == EC->SameSense() ? EC->EdgeStart() : EC->EdgeEnd() );
     const Handle(StepShape_VertexPoint) VP = Handle(StepShape_VertexPoint)::DownCast(V);
     if ( VP.IsNull() ) continue;
     const Handle(StepGeom_CartesianPoint) P = Handle(StepGeom_CartesianPoint)::DownCast(VP->VertexGeometry());
Index: oce/src/TColStd/TColStd_PackedMapOfInteger.hxx
===================================================================
--- oce.orig/src/TColStd/TColStd_PackedMapOfInteger.hxx
+++ oce/src/TColStd/TColStd_PackedMapOfInteger.hxx
@@ -65,7 +65,7 @@ class TColStd_PackedMapOfInteger : priva
   inline Standard_Integer Extent        () const
   { return Standard_Integer (myExtent); }
 
-  inline Standard_Integer IsEmpty       () const
+  inline Standard_Boolean IsEmpty       () const
   { return TCollection_BasicMap::IsEmpty(); }
 
   inline void             Statistics    (Standard_OStream& outStream) const
Index: oce/src/TDataStd/TDataStd_BooleanList.cxx
===================================================================
--- oce.orig/src/TDataStd/TDataStd_BooleanList.cxx
+++ oce/src/TDataStd/TDataStd_BooleanList.cxx
@@ -170,7 +170,7 @@ void TDataStd_BooleanList::Paste (const
   TDataStd_ListIteratorOfListOfByte itr(myList);
   for (; itr.More(); itr.Next())
   {
-    aList->Append(itr.Value());
+    aList->Append(0 != itr.Value());
   }
 }
 
Index: oce/src/TFunction/TFunction_Function.lxx
===================================================================
--- oce.orig/src/TFunction/TFunction_Function.lxx
+++ oce/src/TFunction/TFunction_Function.lxx
@@ -21,7 +21,7 @@ inline const Standard_GUID& TFunction_Fu
 
 inline Standard_Boolean TFunction_Function::Failed() const
 {
-  return myFailure;
+  return 0 != myFailure;
 }
 
 inline Standard_Integer TFunction_Function::GetFailure() const
Index: oce/src/TObj/TObj_Object.cxx
===================================================================
--- oce.orig/src/TObj/TObj_Object.cxx
+++ oce/src/TObj/TObj_Object.cxx
@@ -1396,7 +1396,7 @@ void TObj_Object::SetFlags(const Standar
 Standard_Boolean TObj_Object::TestFlags(const Standard_Integer theMask) const
 {
   Standard_Integer aFlags = getInteger(DataTag_Flags);
-  return aFlags & theMask;
+  return 0 != (aFlags & theMask);
 }
 
 //=======================================================================
Index: oce/src/TestTopOpe/TestTopOpe_BOOPCommands.cxx
===================================================================
--- oce.orig/src/TestTopOpe/TestTopOpe_BOOPCommands.cxx
+++ oce/src/TestTopOpe/TestTopOpe_BOOPCommands.cxx
@@ -459,7 +459,7 @@ Standard_Integer VARSTOPOARGS(TestTopOpe
     else if (!strcmp(thea,"-c")) {
       suppressarg(na,a,ia);
       if (ia < na) {
-	VT.SetClear((Standard_Boolean)Draw::Atoi(a[ia]));
+	VT.SetClear(0!=Draw::Atoi(a[ia]));
 	suppressarg(na,a,ia);
       }
       else VT.SetClear(Standard_True);
Index: oce/src/TopOpeBRep/TopOpeBRep_FFTransitionTool.cxx
===================================================================
--- oce.orig/src/TopOpeBRep/TopOpeBRep_FFTransitionTool.cxx
+++ oce/src/TopOpeBRep/TopOpeBRep_FFTransitionTool.cxx
@@ -288,7 +288,7 @@ static Standard_Boolean FUN_ProjectPoint
   if ( C2.IsNull() ) {
     return Standard_False;
   }
-  Standard_Real res = Standard_False;
+  Standard_Boolean res = Standard_False;
   
   GeomAPI_ProjectPointOnCurve mydist(P1,C2,FC2,LC2);
   if ( mydist.Extrema().IsDone() ) {
@@ -300,7 +300,7 @@ static Standard_Boolean FUN_ProjectPoint
 //#ifdef DEB
 //  return res; // BUG ???
 //#else
-  return (Standard_Boolean ) res ;
+  return res ;
 //#endif
 
 }
Index: oce/src/TopOpeBRep/TopOpeBRep_FacesFiller.cdl
===================================================================
--- oce.orig/src/TopOpeBRep/TopOpeBRep_FacesFiller.cdl
+++ oce/src/TopOpeBRep/TopOpeBRep_FacesFiller.cdl
@@ -369,7 +369,7 @@ fields
         -- shape.
 
     myLastVPison0 : Boolean;-- only for walking.
-    mykeptVPnbr : Boolean;  -- number of current line's VP kept 
+    mykeptVPnbr : Integer;  -- number of current line's VP kept
     	    
     -- curve on current line
     myDSCIndex : Integer;
Index: oce/src/TopOpeBRep/TopOpeBRep_FacesFiller_1.cxx
===================================================================
--- oce.orig/src/TopOpeBRep/TopOpeBRep_FacesFiller_1.cxx
+++ oce/src/TopOpeBRep/TopOpeBRep_FacesFiller_1.cxx
@@ -1260,7 +1260,7 @@ Standard_Boolean TopOpeBRep_FacesFiller:
 Standard_Boolean TopOpeBRep_FacesFiller::GetFFGeometry(const TopOpeBRep_VPointInter& VP,TopOpeBRepDS_Kind& K,Standard_Integer& G) const 
 {
   TopOpeBRepDS_Point DSP = TopOpeBRep_PointGeomTool::MakePoint(VP);
-  Standard_Integer found = GetFFGeometry(DSP,K,G);
+  Standard_Boolean found = GetFFGeometry(DSP,K,G);
   return found;
 }
 
Index: oce/src/TopOpeBRep/TopOpeBRep_vpr.cxx
===================================================================
--- oce.orig/src/TopOpeBRep/TopOpeBRep_vpr.cxx
+++ oce/src/TopOpeBRep/TopOpeBRep_vpr.cxx
@@ -617,7 +617,7 @@ void TopOpeBRep_FacesFiller::ProcessVPon
 {
   Standard_Integer absindex = VP.ShapeIndex(); // 0,1,2,3
   Standard_Integer iVP = VP.Index();
-  Standard_Boolean OOShapeIndex = (ShapeIndex == 1) ? 2 : 1;
+  Standard_Integer OOShapeIndex = (ShapeIndex == 1) ? 2 : 1;
   Standard_Boolean on2edges = (absindex == 3);
   Standard_Boolean hasONedge = (VP.State(OOShapeIndex) == TopAbs_ON);
   Standard_Boolean hasOOedge = (on2edges) ? Standard_True : hasONedge;
Index: oce/src/TopOpeBRep/TopOpeBRep_vprclo.cxx
===================================================================
--- oce.orig/src/TopOpeBRep/TopOpeBRep_vprclo.cxx
+++ oce/src/TopOpeBRep/TopOpeBRep_vprclo.cxx
@@ -160,7 +160,7 @@ void TopOpeBRep_FacesFiller::ProcessVPon
 //  Standard_Boolean isvertex = VP.IsVertex(ShapeIndex);
   Standard_Boolean isvertex = (PVKind == TopOpeBRepDS_VERTEX);
   Standard_Integer absindex = VP.ShapeIndex(); // 0,1,2,3
-  Standard_Boolean OOShapeIndex = (ShapeIndex == 1) ? 2 : 1;
+  Standard_Integer OOShapeIndex = (ShapeIndex == 1) ? 2 : 1;
   Standard_Boolean on2edges = (absindex == 3);
   Standard_Boolean hasONedge = (VP.State(OOShapeIndex) == TopAbs_ON);
   Standard_Boolean hasOOedge = (on2edges) ? Standard_True : hasONedge;
Index: oce/src/TopOpeBRepBuild/TopOpeBRepBuild_Builder1.cxx
===================================================================
--- oce.orig/src/TopOpeBRepBuild/TopOpeBRepBuild_Builder1.cxx
+++ oce/src/TopOpeBRepBuild/TopOpeBRepBuild_Builder1.cxx
@@ -547,7 +547,7 @@ void TopOpeBRepBuild_Builder1::GFillFace
     for(Standard_Integer i = 1; i <= aEM.Extent(); i++) {
       const TopoDS_Shape& anEdge = aEM(i);
       if(myMapOfEdgeWithFaceState.IsBound(anEdge)) {
-	rev = (Standard_Boolean)myMapOfEdgeWithFaceState.Find(anEdge);
+	rev = (0 != myMapOfEdgeWithFaceState.Find(anEdge));
 	break;
       }
     }
Index: oce/src/TopOpeBRepBuild/TopOpeBRepBuild_GTopo.cxx
===================================================================
--- oce.orig/src/TopOpeBRepBuild/TopOpeBRepBuild_GTopo.cxx
+++ oce/src/TopOpeBRepBuild/TopOpeBRepBuild_GTopo.cxx
@@ -44,9 +44,9 @@ TopOpeBRepBuild_GTopo::TopOpeBRepBuild_G
  const TopOpeBRepDS_Config C1, const TopOpeBRepDS_Config C2)
 {
   Reset();
-  Set((Standard_Boolean)ii,(Standard_Boolean)in,(Standard_Boolean)io,
-      (Standard_Boolean)ni,(Standard_Boolean)nn,(Standard_Boolean)no,  
-      (Standard_Boolean)oi,(Standard_Boolean)on,(Standard_Boolean)oo);
+  Set(0 != ii, 0 != in, 0 != io,
+      0 != ni, 0 != nn, 0 != no,
+      0 != oi, 0 != on, 0 != oo);
   myt1 = t1; 
   myt2 = t2;
   myConfig1 = C1;
Index: oce/src/TopOpeBRepBuild/TopOpeBRepBuild_KPart.cxx
===================================================================
--- oce.orig/src/TopOpeBRepBuild/TopOpeBRepBuild_KPart.cxx
+++ oce/src/TopOpeBRepBuild/TopOpeBRepBuild_KPart.cxx
@@ -277,7 +277,7 @@ static Standard_Boolean FUN_changev(cons
   if (!changev) return Standard_False;
   changev = HDS->HasSameDomain(v);
   if (!changev) return Standard_False;
-  Standard_Boolean rankv = HDS->DS().AncestorRank(v);
+  Standard_Integer rankv = HDS->DS().AncestorRank(v);
   changev = (rankv == 2);
   return changev;
 }
@@ -1094,11 +1094,9 @@ Standard_Integer TopOpeBRepBuild_Builder
   Standard_Boolean TKPB = TopOpeBRepBuild_GettraceKPB();
 #endif*/
   
-  Standard_Boolean iskp1 = KPisfafash(myShape1);
-  if ( !iskp1 ) return 0;
+  if ( !KPisfafash(myShape1) ) return 0;
   
-  Standard_Boolean iskp2 = KPisfafash(myShape2);
-  if ( !iskp2 ) return 0;
+  if ( !KPisfafash(myShape2) ) return 0;
   
   return 1;
 }
@@ -1114,11 +1112,9 @@ Standard_Integer TopOpeBRepBuild_Builder
   Standard_Boolean TKPB = TopOpeBRepBuild_GettraceKPB();
 #endif*/
   
-  Standard_Boolean iskp1 = KPissososh(myShape1);
-  if ( !iskp1 ) return 0;
+  if ( !KPissososh(myShape1) ) return 0;
   
-  Standard_Boolean iskp2 = KPissososh(myShape2);
-  if ( !iskp2 ) return 0;
+  if ( !KPissososh(myShape2) ) return 0;
   
   return 1;
 }
Index: oce/src/TopOpeBRepDS/TopOpeBRepDS_redu.cxx
===================================================================
--- oce.orig/src/TopOpeBRepDS/TopOpeBRepDS_redu.cxx
+++ oce/src/TopOpeBRepDS/TopOpeBRepDS_redu.cxx
@@ -137,18 +137,18 @@ Standard_EXPORT Standard_Boolean FUN_ds_
   
   TopOpeBRepDS_ListOfInterference l1dFOR,l1dREV,l1dINT,l1dEXT; Standard_Integer FOR1d,REV1d,INT1d,EXT1d;
   ::FUN_scanloi(l1d, l1dFOR,FOR1d, l1dREV,REV1d, l1dINT,INT1d, l1dEXT,EXT1d);
-  Standard_Boolean beforeIN1d = (REV1d + INT1d > 0); Standard_Boolean beforeOU1d = (FOR1d + EXT1d); 
-  Standard_Boolean afterIN1d  = (FOR1d + INT1d > 0);	Standard_Boolean afterOU1d = (REV1d + EXT1d);  
+  Standard_Boolean beforeIN1d = (REV1d + INT1d > 0); Standard_Boolean beforeOU1d = (0 != FOR1d + EXT1d);
+  Standard_Boolean afterIN1d  = (FOR1d + INT1d > 0); Standard_Boolean afterOU1d  = (0 != REV1d + EXT1d);
   
   TopOpeBRepDS_ListOfInterference l2dFOR,l2dREV,l2dINT,l2dEXT; Standard_Integer FOR2d,REV2d,INT2d,EXT2d;
   ::FUN_scanloi(l2d, l2dFOR,FOR2d, l2dREV,REV2d, l2dINT,INT2d, l2dEXT,EXT2d);
-  Standard_Boolean beforeIN2d = (REV2d + INT2d > 0); Standard_Boolean beforeOU2d = (FOR2d + EXT2d); 
-  Standard_Boolean afterIN2d  = (FOR2d + INT2d > 0);	Standard_Boolean afterOU2d = (REV2d + EXT2d);  
+  Standard_Boolean beforeIN2d = (REV2d + INT2d > 0); Standard_Boolean beforeOU2d = (0 != FOR2d + EXT2d);
+  Standard_Boolean afterIN2d  = (FOR2d + INT2d > 0); Standard_Boolean afterOU2d  = (0 != REV2d + EXT2d);
 
   TopOpeBRepDS_ListOfInterference l3dFOR,l3dREV,l3dINT,l3dEXT; Standard_Integer FOR3d,REV3d,INT3d,EXT3d;
   ::FUN_scanloi(l3d, l3dFOR,FOR3d, l3dREV,REV3d, l3dINT,INT3d, l3dEXT,EXT3d);
-  Standard_Boolean beforeIN3d = (REV3d + INT3d > 0); Standard_Boolean beforeOU3d = (FOR3d + EXT3d); 
-  Standard_Boolean afterIN3d  = (FOR3d + INT3d > 0);	Standard_Boolean afterOU3d = (REV3d + EXT3d);  
+  Standard_Boolean beforeIN3d = (REV3d + INT3d > 0); Standard_Boolean beforeOU3d = (0 != FOR3d + EXT3d);
+  Standard_Boolean afterIN3d  = (FOR3d + INT3d > 0); Standard_Boolean afterOU3d  = (0 != REV3d + EXT3d);
 
   // state before
   stb = TopAbs_UNKNOWN; isb=0; bdim=0;
Index: oce/src/TopOpeBRepDS/TopOpeBRepDS_repvg.cxx
===================================================================
--- oce.orig/src/TopOpeBRepDS/TopOpeBRepDS_repvg.cxx
+++ oce/src/TopOpeBRepDS/TopOpeBRepDS_repvg.cxx
@@ -63,7 +63,7 @@ Standard_EXPORT void FDS_repvg2
   Standard_Boolean ispoint  = (GT == TopOpeBRepDS_POINT);
   Standard_Boolean isvertex = (GT == TopOpeBRepDS_VERTEX);
 
-  Standard_Boolean nLI = LI.Extent();
+  Standard_Integer nLI = LI.Extent();
 
   TopOpeBRepDS_ListIteratorOfListOfInterference it1(LI);
   while (it1.More()) {
Index: oce/src/TopoDSToStep/TopoDSToStep_MakeStepEdge.cxx
===================================================================
--- oce.orig/src/TopoDSToStep/TopoDSToStep_MakeStepEdge.cxx
+++ oce/src/TopoDSToStep/TopoDSToStep_MakeStepEdge.cxx
@@ -95,7 +95,7 @@ void TopoDSToStep_MakeStepEdge::Init(con
   aTool.SetCurrentEdge(aEdge);
 
   // [BEGIN] Processing non-manifold topology (ssv; 11.11.2010)
-  Standard_Boolean isNMMode = Interface_Static::IVal("write.step.nonmanifold");
+  Standard_Boolean isNMMode = (0 != Interface_Static::IVal("write.step.nonmanifold"));
   if (isNMMode) {
     Handle(StepShape_EdgeCurve) anEC;
     Handle(TransferBRep_ShapeMapper) aSTEPMapper = TransferBRep::ShapeMapper(FP, aEdge);
Index: oce/src/TopoDSToStep/TopoDSToStep_MakeStepFace.cxx
===================================================================
--- oce.orig/src/TopoDSToStep/TopoDSToStep_MakeStepFace.cxx
+++ oce/src/TopoDSToStep/TopoDSToStep_MakeStepFace.cxx
@@ -132,7 +132,7 @@ void TopoDSToStep_MakeStepFace::Init(con
     new TransferBRep_ShapeMapper(aFace);  // on ne sait jamais
 
   // [BEGIN] Processing non-manifold topology (another approach) (ssv; 10.11.2010)
-  Standard_Boolean isNMMode = Interface_Static::IVal("write.step.nonmanifold");
+  Standard_Boolean isNMMode = (0 != Interface_Static::IVal("write.step.nonmanifold"));
   if (isNMMode) {
     Handle(StepShape_AdvancedFace) anAF;
     Handle(TransferBRep_ShapeMapper) aSTEPMapper = TransferBRep::ShapeMapper(FP, aFace);
Index: oce/src/TopoDSToStep/TopoDSToStep_MakeStepVertex.cxx
===================================================================
--- oce.orig/src/TopoDSToStep/TopoDSToStep_MakeStepVertex.cxx
+++ oce/src/TopoDSToStep/TopoDSToStep_MakeStepVertex.cxx
@@ -63,7 +63,7 @@ void TopoDSToStep_MakeStepVertex::Init(c
   aTool.SetCurrentVertex(aVertex);
 
   // [BEGIN] Processing non-manifold topology (ssv; 11.11.2010)
-  Standard_Boolean isNMMode = Interface_Static::IVal("write.step.nonmanifold");
+  Standard_Boolean isNMMode = (0 != Interface_Static::IVal("write.step.nonmanifold"));
   if (isNMMode) {
     Handle(StepShape_VertexPoint) aVP;
     Handle(TransferBRep_ShapeMapper) aSTEPMapper = TransferBRep::ShapeMapper(FP, aVertex);
Index: oce/src/ViewerTest/ViewerTest.cxx
===================================================================
--- oce.orig/src/ViewerTest/ViewerTest.cxx
+++ oce/src/ViewerTest/ViewerTest.cxx
@@ -1044,7 +1044,7 @@ static int VDispMode (Draw_Interpretor&
     }
     else{
       for(Ctx->InitSelected();Ctx->MoreSelected();Ctx->NextSelected())
-	Ctx->Display(Ctx->Interactive(),Dmode);
+	Ctx->Display(Ctx->Interactive(),0!=Dmode);
     }
   }
   else{
@@ -3783,7 +3783,7 @@ Standard_Boolean  ViewerTest::PickObject
   // step 2 : wait for the selection...
 //  Standard_Boolean IsGood (Standard_False);
 //  Standard_Integer NbPick(0);
-  Standard_Boolean NbPickGood (0),NbToReach(arr->Length());
+  Standard_Integer NbPickGood (0),NbToReach(arr->Length());
   Standard_Integer NbPickFail(0);
   Standard_Integer argccc = 5;
   const char *bufff[] = { "A", "B", "C","D", "E" };
@@ -3956,7 +3956,7 @@ Standard_Boolean ViewerTest::PickShapes
 
   // step 2 : wait for the selection...
 
-  Standard_Boolean NbPickGood (0),NbToReach(thearr->Length());
+  Standard_Integer NbPickGood (0),NbToReach(thearr->Length());
   Standard_Integer NbPickFail(0);
   Standard_Integer argccc = 5;
   const char *bufff[] = { "A", "B", "C","D", "E" };
Index: oce/src/ViewerTest/ViewerTest_ObjectCommands.cxx
===================================================================
--- oce.orig/src/ViewerTest/ViewerTest_ObjectCommands.cxx
+++ oce/src/ViewerTest/ViewerTest_ObjectCommands.cxx
@@ -2074,7 +2074,7 @@ static int VCircleBuilder(Draw_Interpret
   {
     // Get arguments
     TCollection_AsciiString aName(argv[1]);
-    Standard_Boolean isFilled = (Standard_Boolean)Draw::Atoi(argv[5]);
+    Standard_Boolean isFilled = (0 != Draw::Atoi(argv[5]));
 
     Handle(AIS_InteractiveObject) theShapeA;
     Handle(AIS_InteractiveObject) theShapeB;
@@ -2587,7 +2587,7 @@ static int VDrawText (Draw_Interpretor&
   const Standard_Real angle = Draw::Atof(argv[10]);
 
   // Text zooming
-  const Standard_Boolean zoom = Draw::Atoi(argv[11]);
+  const Standard_Boolean zoom = (0 != Draw::Atoi(argv[11]));
 
   // Text height
   const Standard_Real height = Draw::Atof(argv[12]);
@@ -4026,7 +4026,7 @@ static Standard_Integer VSetSelectionMod
   }
 
   const Standard_Integer aSelectionMode = Draw::Atoi (theArgc == 3 ? theArgv[1] : theArgv[2]);
-  const Standard_Boolean toTurnOn       = Draw::Atoi (theArgc == 3 ? theArgv[2] : theArgv[3]);
+  const Standard_Boolean toTurnOn       = (0 != Draw::Atoi (theArgc == 3 ? theArgv[2] : theArgv[3]));
   if (aSelectionMode == 0 && anAISContext->HasOpenedContext())
   {
     anAISContext->CloseLocalContext();
Index: oce/src/ViewerTest/ViewerTest_ViewerCommands.cxx
===================================================================
--- oce.orig/src/ViewerTest/ViewerTest_ViewerCommands.cxx
+++ oce/src/ViewerTest/ViewerTest_ViewerCommands.cxx
@@ -2039,11 +2039,11 @@ static LRESULT WINAPI ViewerWindowProc(
         {
           if (fwKeys & MK_CONTROL)
           {
-            Ppick = VT_ProcessButton1Press (Pargc, Pargv, Ppick, (fwKeys & MK_SHIFT));
+            Ppick = VT_ProcessButton1Press (Pargc, Pargv, Ppick, 0 != (fwKeys & MK_SHIFT));
           }
           else
           {
-            VT_ProcessButton1Press (Pargc, Pargv, Ppick, (fwKeys & MK_SHIFT));
+            VT_ProcessButton1Press (Pargc, Pargv, Ppick, 0 != (fwKeys & MK_SHIFT));
           }
         }
         else if (Msg == WM_RBUTTONDOWN)
Index: oce/src/Voxel/Voxel_FastConverter.cxx
===================================================================
--- oce.orig/src/Voxel/Voxel_FastConverter.cxx
+++ oce/src/Voxel/Voxel_FastConverter.cxx
@@ -481,7 +481,7 @@ Standard_Boolean Voxel_FastConverter::Fi
 	  }
 	  if (volume && !surface)
 	  {
-	    (myIsBool == 1) ? ((Voxel_BoolDS*)myVoxels)->Set(ix, iy, iz, inner) : 
+	    (myIsBool == 1) ? ((Voxel_BoolDS*)myVoxels)->Set(ix, iy, iz, 0 != inner) : 
 	      ((Voxel_ColorDS*)myVoxels)->Set(ix, iy, iz, inner);
 	  }
 	  prev_surface = surface;
@@ -518,7 +518,7 @@ Standard_Boolean Voxel_FastConverter::Fi
 	  }
 	  if (volume && prev_surface == surface && next_surface)
 	  {
-	    (myIsBool == 1) ? ((Voxel_BoolDS*)myVoxels)->Set(ix, iy, iz, inner) : 
+	    (myIsBool == 1) ? ((Voxel_BoolDS*)myVoxels)->Set(ix, iy, iz, 0 != inner) : 
 	      ((Voxel_ColorDS*)myVoxels)->Set(ix, iy, iz, inner);
 	  }
 	  prev_surface = surface;
Index: oce/src/XSDRAWSTLVRML/XSDRAWSTLVRML.cxx
===================================================================
--- oce.orig/src/XSDRAWSTLVRML/XSDRAWSTLVRML.cxx
+++ oce/src/XSDRAWSTLVRML/XSDRAWSTLVRML.cxx
@@ -839,7 +839,7 @@ static Standard_Integer meshcolors( Draw
                  aViewer->ActiveView()->SetSurfaceDetail(V3d_TEX_ALL);
           }
 
-          aMesh->GetDrawer()->SetBoolean ( MeshVS_DA_ColorReflection, Standard_Boolean(aReflection) );
+          aMesh->GetDrawer()->SetBoolean ( MeshVS_DA_ColorReflection, 0 != aReflection );
 
           anIC->Redisplay( aMesh );
         }
Index: oce/src/XmlMDataStd/XmlMDataStd_ByteArrayDriver.cxx
===================================================================
--- oce.orig/src/XmlMDataStd/XmlMDataStd_ByteArrayDriver.cxx
+++ oce/src/XmlMDataStd/XmlMDataStd_ByteArrayDriver.cxx
@@ -126,7 +126,7 @@ Standard_Boolean XmlMDataStd_ByteArrayDr
 	return Standard_False;
       } 
     else
-      aDelta = (Standard_Boolean)aDeltaValue;
+      aDelta = (0 != aDeltaValue);
   }
 #ifdef DEB
   else if(XmlMDataStd::DocumentVersion() == -1)
Index: oce/src/XmlMDataStd/XmlMDataStd_ExtStringArrayDriver.cxx
===================================================================
--- oce.orig/src/XmlMDataStd/XmlMDataStd_ExtStringArrayDriver.cxx
+++ oce/src/XmlMDataStd/XmlMDataStd_ExtStringArrayDriver.cxx
@@ -124,7 +124,7 @@ Standard_Boolean XmlMDataStd_ExtStringAr
 	return Standard_False;
       } 
     else
-      aDelta = (Standard_Boolean)aDeltaValue;
+      aDelta = (0 != aDeltaValue);
   }
 #ifdef DEB
   else if(XmlMDataStd::DocumentVersion() == -1)
Index: oce/src/XmlMDataStd/XmlMDataStd_IntPackedMapDriver.cxx
===================================================================
--- oce.orig/src/XmlMDataStd/XmlMDataStd_IntPackedMapDriver.cxx
+++ oce/src/XmlMDataStd/XmlMDataStd_IntPackedMapDriver.cxx
@@ -118,7 +118,7 @@ Standard_Boolean XmlMDataStd_IntPackedMa
 	    return Standard_False;
 	  } 
 	else
-	  aDelta = (Standard_Boolean)aDeltaValue;
+	  aDelta = (0 != aDeltaValue);
       }
 #ifdef DEB
       else if(XmlMDataStd::DocumentVersion() == -1)
Index: oce/src/XmlMDataStd/XmlMDataStd_IntegerArrayDriver.cxx
===================================================================
--- oce.orig/src/XmlMDataStd/XmlMDataStd_IntegerArrayDriver.cxx
+++ oce/src/XmlMDataStd/XmlMDataStd_IntegerArrayDriver.cxx
@@ -129,7 +129,7 @@ Standard_Boolean XmlMDataStd_IntegerArra
 	return Standard_False;
       } 
     else
-      aDelta = (Standard_Boolean)aDeltaValue;
+      aDelta = (0 != aDeltaValue);
   }
 #ifdef DEB
   else if(XmlMDataStd::DocumentVersion() == -1)
Index: oce/src/XmlMDataStd/XmlMDataStd_RealArrayDriver.cxx
===================================================================
--- oce.orig/src/XmlMDataStd/XmlMDataStd_RealArrayDriver.cxx
+++ oce/src/XmlMDataStd/XmlMDataStd_RealArrayDriver.cxx
@@ -133,7 +133,7 @@ Standard_Boolean XmlMDataStd_RealArrayDr
 	return Standard_False;
       } 
     else
-      aDelta = (Standard_Boolean)aDeltaValue;
+      aDelta = (0 != aDeltaValue);
   }
 #ifdef DEB
   else if(XmlMDataStd::DocumentVersion() == -1)
Index: oce/src/OpenGl/OpenGl_Clipping.hxx
===================================================================
--- oce.orig/src/OpenGl/OpenGl_Clipping.hxx
+++ oce/src/OpenGl/OpenGl_Clipping.hxx
@@ -219,8 +219,8 @@ private:
   Graphic3d_SequenceOfHClipPlane myPlanes;        //!< defined clipping planes
   OpenGl_MapOfPlaneStates        myPlaneStates;   //!< map of clip planes bound for the props
   OpenGl_EmptyPlaneIds           myEmptyPlaneIds; //!< generator of empty ids
-  Standard_Boolean               myNbClipping;    //!< number of enabled clipping-only planes (NOT capping)
-  Standard_Boolean               myNbCapping;     //!< number of enabled capping  planes
+  Standard_Integer               myNbClipping;    //!< number of enabled clipping-only planes (NOT capping)
+  Standard_Integer               myNbCapping;     //!< number of enabled capping  planes
 
 private:
 
