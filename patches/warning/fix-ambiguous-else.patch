From 93761f419664e222034e0d0cba1a384e9837a0e4 Mon Sep 17 00:00:00 2001
From: Denis Barbier <bouzim@gmail.com>
Date: Thu, 22 Dec 2011 12:12:28 +0100
Subject: [PATCH] [warning-fix][ambiguous-else]

---
 inc/GProp_SGProps.gxx                              |    3 +-
 inc/GProp_VGProps.gxx                              |    3 +-
 src/AIS/AIS_InteractiveContext_1.cxx               |    3 +-
 src/AIS/AIS_LocalContext.cxx                       |    3 +-
 src/AIS/AIS_Selection.cxx                          |    3 +-
 src/AIS2D/AIS2D_InteractiveContext.cxx             |    9 +++--
 src/BRepExtrema/BRepExtrema_DistShapeShape.cxx     |    3 +-
 src/BRepFill/BRepFill_Sweep.cxx                    |    3 +-
 src/BRepTest/BRepTest_TopologyCommands.cxx         |    3 +-
 .../BRepTools_NurbsConvertModification.cxx         |    6 ++-
 src/ChFi3d/ChFi3d_Builder_6.cxx                    |   12 +++++--
 src/GeomPlate/GeomPlate_BuildPlateSurface.cxx      |    3 +-
 src/Hermit/Hermit.cxx                              |    6 ++-
 src/IGESControl/IGESControl_IGESBoundary.cxx       |    3 +-
 src/IGESDefs/IGESDefs_ToolAttributeTable.cxx       |    3 +-
 src/IGESToBRep/IGESToBRep_IGESBoundary.cxx         |    3 +-
 src/IntPatch/IntPatch_RstInt.cxx                   |    3 +-
 src/IntPolyh/IntPolyh_MaillageAffinage.cxx         |    6 ++-
 src/LocOpe/LocOpe_SplitShape.cxx                   |    6 ++-
 src/MeshVS/MeshVS_Mesh.cxx                         |    3 +-
 src/MeshVS/MeshVS_MeshPrsBuilder.cxx               |    3 +-
 src/NCollection/NCollection_BaseSequence.cxx       |    3 +-
 src/NIS/NIS_InteractiveObject.cxx                  |    3 +-
 src/NIS/NIS_TriangulatedDrawer.cxx                 |    3 +-
 src/OpenGl/OpenGl_ResourceCleaner.cxx              |    3 +-
 .../ProjLib_ComputeApproxOnPolarSurface.cxx        |   33 +++++++++++++------
 src/Resource/Resource_Manager.cxx                  |    3 +-
 src/STEPControl/STEPControl_ActorWrite.cxx         |    3 +-
 src/SWDRAW/SWDRAW_ShapeFix.cxx                     |    3 +-
 src/SWDRAW/SWDRAW_ShapeUpgrade.cxx                 |   12 +++++--
 src/SelectMgr/SelectMgr_EntityOwner.cxx            |    3 +-
 src/SelectMgr/SelectMgr_SelectableObject.cxx       |    4 +-
 src/ShapeAnalysis/ShapeAnalysis_CheckSmallFace.cxx |    3 +-
 src/ShapeCustom/ShapeCustom_ConvertToBSpline.cxx   |    3 +-
 src/ShapeFix/ShapeFix_ComposeShell.cxx             |    3 +-
 src/ShapeFix/ShapeFix_Face.cxx                     |    9 +++--
 src/ShapeFix/ShapeFix_Wire.cxx                     |    3 +-
 src/ShapeProcess/ShapeProcess_ShapeContext.cxx     |    3 +-
 .../ShapeProcessAPI_ApplySequence.cxx              |    6 ++-
 src/TNaming/TNaming_NamedShape.cxx                 |    3 +-
 src/TopTrans/TopTrans_SurfaceTransition.cxx        |    6 ++-
 src/ViewerTest/ViewerTest.cxx                      |   22 ++++++++-----
 src/VrmlData/VrmlData_Geometry.cxx                 |    6 ++-
 src/VrmlData/VrmlData_IndexedFaceSet.cxx           |    3 +-
 src/VrmlData/VrmlData_Node.cxx                     |    3 +-
 src/VrmlData/VrmlData_Scene.cxx                    |   24 +++++++++-----
 src/XCAFDoc/XCAFDoc_ColorTool.cxx                  |    3 +-
 src/XSDRAWSTLVRML/XSDRAWSTLVRML.cxx                |    6 ++-
 48 files changed, 178 insertions(+), 91 deletions(-)

Index: oce/inc/GProp_SGProps.gxx
===================================================================
--- oce.orig/inc/GProp_SGProps.gxx
+++ oce/inc/GProp_SGProps.gxx
@@ -112,8 +112,9 @@ static Standard_Integer FillIntervalBoun
   VA(j++) = A;
   for(; i <= iEnd; i++){
     Standard_Real kn = Knots(i);
-    if(A < kn)
+    if(A < kn) {
       if(kn < B) VA(j++) = VB(k++) = kn; else break;
+    }
   }
   VB(k) = B;
   return k;
Index: oce/inc/GProp_VGProps.gxx
===================================================================
--- oce.orig/inc/GProp_VGProps.gxx
+++ oce/inc/GProp_VGProps.gxx
@@ -81,8 +81,9 @@ static Standard_Integer FillIntervalBoun
   VA(j++) = A;
   for(; i <= iEnd; i++){
     Standard_Real kn = Knots(i);
-    if(A < kn)
+    if(A < kn) {
       if(kn < B) VA(j++) = VB(k++) = kn; else break;
+    }
   }
   VB(k) = B;
   return k;
Index: oce/src/AIS/AIS_InteractiveContext_1.cxx
===================================================================
--- oce.orig/src/AIS/AIS_InteractiveContext_1.cxx
+++ oce/src/AIS/AIS_InteractiveContext_1.cxx
@@ -207,12 +207,13 @@ AIS_StatusOfDetection AIS_InteractiveCon
   selector->Init();
   if ( selector->More() )
   {
-    if ( HasOpenedContext() )
+    if ( HasOpenedContext() ) {
       if ( !myFilters->IsOk( selector->OnePicked() ) ) 
 	return AIS_SOD_AllBad;
       else
         if ( !myLocalContexts( myCurLocalIndex )->Filter()->IsOk( selector->OnePicked() ) )
           return AIS_SOD_AllBad;
+    }
     
  
     // Does nothing if previously detected object is equal to the current one
Index: oce/src/AIS/AIS_LocalContext.cxx
===================================================================
--- oce.orig/src/AIS/AIS_LocalContext.cxx
+++ oce/src/AIS/AIS_LocalContext.cxx
@@ -536,7 +536,7 @@ Standard_Boolean AIS_LocalContext::Remov
   const Handle(V3d_Viewer)& aViewer = myCTX->CurrentViewer();
   for(i = 1; i <= myMapOfOwner.Extent(); i++){
     const Handle(SelectMgr_EntityOwner)& anOwner = myMapOfOwner(i) ;
-    if(!anOwner.IsNull())
+    if(!anOwner.IsNull()) {
       if(anOwner->Selectable() != aSelectable)
         ownersToKeep.Add(anOwner);
       else
@@ -547,6 +547,7 @@ Standard_Boolean AIS_LocalContext::Remov
             Unhilight(anOwner, aViewer->ActiveView());
         }
       }
+    }
   }
   myMapOfOwner.Clear();
   myMapOfOwner.Assign(ownersToKeep);
Index: oce/src/AIS/AIS_Selection.cxx
===================================================================
--- oce.orig/src/AIS/AIS_Selection.cxx
+++ oce/src/AIS/AIS_Selection.cxx
@@ -248,11 +248,12 @@ AIS_SelectStatus AIS_Selection::Select(c
   if ( S->myResultMap.IsBound( anObject ) ){
     AIS_NListTransient::Iterator aListIter = S->myResultMap.Find( anObject );
 //skt-----------------------------------------------------------------
-    if( S->myIterator == aListIter )
+    if( S->myIterator == aListIter ) {
 	if( S->myIterator.More() )
 	    S->myIterator.Next();
 	else
 	    S->myIterator = AIS_NListTransient::Iterator();
+    }
 //--------------------------------------------------------------------
 #ifdef BUC60953
     // In the mode of advanced mesh selection only one owner is created
Index: oce/src/BRepExtrema/BRepExtrema_DistShapeShape.cxx
===================================================================
--- oce.orig/src/BRepExtrema/BRepExtrema_DistShapeShape.cxx
+++ oce/src/BRepExtrema/BRepExtrema_DistShapeShape.cxx
@@ -96,7 +96,7 @@ void BRepExtrema_DistShapeShape::Distanc
       const TopoDS_Shape &S2 = Map2(j);
 
       BRepExtrema_DistanceSS  dist(S1,S2,box1,box2,myDistRef,myEps);
-      if (dist.IsDone())
+      if (dist.IsDone()) {
         if(dist.DistValue() < (myDistRef-myEps))
         {
           mySolutionsShape1.Clear();
@@ -116,6 +116,7 @@ void BRepExtrema_DistShapeShape::Distanc
           if (myDistRef > dist.DistValue())
             myDistRef=dist.DistValue();
         }
+      }
     }
   }
 }
Index: oce/src/BRepFill/BRepFill_Sweep.cxx
===================================================================
--- oce.orig/src/BRepFill/BRepFill_Sweep.cxx
+++ oce/src/BRepFill/BRepFill_Sweep.cxx
@@ -2263,7 +2263,7 @@ BRepFill_Sweep::BRepFill_Sweep(const Han
 	 }
        }
 
-      if (ipath == 1)
+      if (ipath == 1) {
 	if (uclose && (isec == NbLaw)) {
 	  Vertex(isec+1, 1) =  Vertex(1, 1);
 	}  
@@ -2283,6 +2283,7 @@ BRepFill_Sweep::BRepFill_Sweep(const Han
 	    VEdge(isec, 1) = NullEdge(Vertex(isec, 1)); 
 	  }
 	}
+      }
 
       if (uclose && (isec == NbLaw)) {
 	Vertex(isec+1, ipath+1) = Vertex(1, ipath+1);
Index: oce/src/BRepTest/BRepTest_TopologyCommands.cxx
===================================================================
--- oce.orig/src/BRepTest/BRepTest_TopologyCommands.cxx
+++ oce/src/BRepTest/BRepTest_TopologyCommands.cxx
@@ -122,12 +122,13 @@ static Standard_Integer section(Draw_Int
 	  else
 	    if (strcasecmp(a[4], "-no2d"))
 	      return 1;
-      if(n > 5)
+      if(n > 5) {
 	if (!strcasecmp(a[5], "-a")) 
 	  Sec.Approximation(TopOpeBRepTool_APPROX);
 	else 
 	  if (strcasecmp(a[5], "-p"))
 	    return 1;
+      }
     } else {// fin a[4],"-2d"
       if (!strcasecmp(a[4], "-a") || !strcasecmp(a[4], "-p")) {
 	if (!strcasecmp(a[4], "-a")) 
Index: oce/src/BRepTools/BRepTools_NurbsConvertModification.cxx
===================================================================
--- oce.orig/src/BRepTools/BRepTools_NurbsConvertModification.cxx
+++ oce/src/BRepTools/BRepTools_NurbsConvertModification.cxx
@@ -553,19 +553,21 @@ Standard_Boolean BRepTools_NurbsConvertM
       v = (Vsup - Vinf)*0.1;
       if(S->IsUPeriodic()) {
 	Standard_Real uperiod = S->UPeriod();
-	if(uperiod < (Usup+2*u-Uinf))
+	if(uperiod < (Usup+2*u-Uinf)) {
 	  if(uperiod <= (Usup-Uinf))
 	    u = 0;
 	  else
 	    u = (uperiod-(Usup-Uinf))*0.5;
+	}
       }
       if(S->IsVPeriodic()) {
 	Standard_Real vperiod = S->VPeriod();
-	if(vperiod < (Vsup+2*v-Vinf))
+	if(vperiod < (Vsup+2*v-Vinf)) {
 	  if(vperiod <= (Vsup-Vinf))
 	    v = 0;
 	  else
 	    v = (vperiod-(Vsup-Vinf))*0.5;
+	}
       }
       GeomAdaptor_Surface GAS(S, Uinf-u,Usup+u,Vinf-v,Vsup+v);
       Handle(GeomAdaptor_HSurface) GAHS = new GeomAdaptor_HSurface(GAS);
Index: oce/src/ChFi3d/ChFi3d_Builder_6.cxx
===================================================================
--- oce.orig/src/ChFi3d/ChFi3d_Builder_6.cxx
+++ oce/src/ChFi3d/ChFi3d_Builder_6.cxx
@@ -1778,7 +1778,7 @@ Standard_Boolean ChFi3d_Builder::Compute
       narc1 = Lin->StartPointOnFirst().NbPointOnRst();
       narc2 = Lin->StartPointOnSecond().NbPointOnRst();
 //  modified by eap Fri Feb  8 11:43:48 2002 ___BEGIN___
-      if(!debarc1)
+      if(!debarc1) {
 	if (narc1 == 0)
 	  backwContinueFailed = Lin->StartPointOnFirst().ParameterOnGuide() > Target;
 	else {
@@ -1799,7 +1799,8 @@ Standard_Boolean ChFi3d_Builder::Compute
 // 	    }
 	  }
 	}
-      if(!debarc2)
+      }
+      if(!debarc2) {
 	if (narc2 == 0)
 	  backwContinueFailed = Lin->StartPointOnSecond().ParameterOnGuide() > Target;
 	else {
@@ -1820,6 +1821,7 @@ Standard_Boolean ChFi3d_Builder::Compute
 //             }
           }
         }
+      }
       if (backwContinueFailed) {
 	// if we leave backwContinueFailed as is, we will stop in this direction
 	// but we are to continue if there are no more faces on the side with arc
@@ -1879,7 +1881,7 @@ Standard_Boolean ChFi3d_Builder::Compute
       narc1 = Lin->EndPointOnFirst().NbPointOnRst();
       narc2 = Lin->EndPointOnSecond().NbPointOnRst();
 //  modified by eap Fri Feb  8 11:44:57 2002 ___BEGIN___
-      if(!finarc1)
+      if(!finarc1) {
 	if (narc1 == 0) 
 	  forwContinueFailed = Lin->EndPointOnFirst().ParameterOnGuide() < Target;
 	else {
@@ -1895,7 +1897,8 @@ Standard_Boolean ChFi3d_Builder::Compute
 // 	    }
 	  }
 	}
-      if(!finarc2)
+      }
+      if(!finarc2) {
 	if (narc2 == 0)
 	  forwContinueFailed = Lin->EndPointOnSecond().ParameterOnGuide() < Target;
 	else {
@@ -1911,6 +1914,7 @@ Standard_Boolean ChFi3d_Builder::Compute
 // 	    }
 	  }
 	}
+      }
       if (forwContinueFailed) {
 	// if we leave forwContinueFailed as is, we will stop in this direction
 	// but we are to continue if there are no more faces on the side with arc
Index: oce/src/GeomPlate/GeomPlate_BuildPlateSurface.cxx
===================================================================
--- oce.orig/src/GeomPlate/GeomPlate_BuildPlateSurface.cxx
+++ oce/src/GeomPlate/GeomPlate_BuildPlateSurface.cxx
@@ -2064,7 +2064,7 @@ Discretise(const Handle(GeomPlate_HArray
 		    // pour sortir de la boucle sans stocker le point	 
 		  }
 	      else
-		{ if (l+1>=NbPtInter) 
+		{ if (l+1>=NbPtInter) {
 		    // on a parcouru tout le tableau : Le point 
 		    // n'appartient pas a un interval point commun 
 		    if (NbPtG1G1!=0) 
@@ -2099,6 +2099,7 @@ Discretise(const Handle(GeomPlate_HArray
 		      { myPlateCont->ChangeValue(i).Append(Inter);
 			// on ajoute le point
 		      }
+		  }
 		}
 	      }
 	  }
Index: oce/src/Hermit/Hermit.cxx
===================================================================
--- oce.orig/src/Hermit/Hermit.cxx
+++ oce/src/Hermit/Hermit.cxx
@@ -239,7 +239,7 @@ static void PolyTest(const TColStd_Array
       if ((max==0)||(max==3))                                                
 	for (i=0;i<=3;i++)
 	  Polesinit(i).SetCoord(0.0,(Polesinit(i).Y()-TolPoles*Polemax));
-      if ((max==1)||(max==2))
+      if ((max==1)||(max==2)) {
 	if ((min==0)||(min==3))                                             
 	  for (i=0;i<=3;i++)
 	    Polesinit(i).SetCoord(0.0,(Polesinit(i).Y()-(1/TolPoles)*Polemin));
@@ -282,6 +282,7 @@ static void PolyTest(const TColStd_Array
 	    }
 	  }
 	}
+      }
     }
   }                          //end of the loop
   
@@ -444,7 +445,7 @@ static void PolyTest(const TColStd_Array
       if ((max==0)||(max==3))                                                
 	for (i=0;i<=3;i++)
 	  Polesinit(i).SetCoord(0.0,(Polesinit(i).Y()-TolPoles*Polemax));
-      if ((max==1)||(max==2))
+      if ((max==1)||(max==2)) {
 	if ((min==0)||(min==3))                                             
 	  for (i=0;i<=3;i++)
 	    Polesinit(i).SetCoord(0.0,(Polesinit(i).Y()-(1/TolPoles)*Polemin));
@@ -487,6 +488,7 @@ static void PolyTest(const TColStd_Array
 	    }
 	  }
 	}
+      }
     }
   }                          //end of the loop
   
Index: oce/src/IGESControl/IGESControl_IGESBoundary.cxx
===================================================================
--- oce.orig/src/IGESControl/IGESControl_IGESBoundary.cxx
+++ oce/src/IGESControl/IGESControl_IGESBoundary.cxx
@@ -204,13 +204,14 @@ static Standard_Boolean Connect (const H
   else if (( surfcurv == -3 && len3d > 0) || len2d == 0)
     GTranslate2d = Standard_False;
  
-  if (GTranslate3d && GTranslate2d)
+  if (GTranslate3d && GTranslate2d) {
     //Setting preference in the case of inconsitency between 3D and 2D
     if      (surfcurv == 2)         Preferred3d = Standard_False;
     else if (surfcurv == 3)         Preferred2d = Standard_False;
     else if (myfilepreference == 2) Preferred3d = Standard_False;
     else if (myfilepreference == 3) Preferred2d = Standard_False;
     else                            Preferred3d = Standard_False;
+  }
   
   if (GTranslate3d && GTranslate2d && len3d != len2d) {
     GTranslate3d = Preferred3d;
Index: oce/src/IGESDefs/IGESDefs_ToolAttributeTable.cxx
===================================================================
--- oce.orig/src/IGESDefs/IGESDefs_ToolAttributeTable.cxx
+++ oce/src/IGESDefs/IGESDefs_ToolAttributeTable.cxx
@@ -281,10 +281,11 @@ void  IGESDefs_ToolAttributeTable::OwnCh
   (const Handle(IGESDefs_AttributeTable)& ent,
    const Interface_ShareTool& , Handle(Interface_Check)& ach) const 
 {
-  if (ent->Definition().IsNull())
+  if (ent->Definition().IsNull()) {
     if (ent->HasStructure()) ach->AddFail
       ("Structure in Directory Entry is not an Attribute Definition Table");
     else ach->AddFail("No Attribute Definition defined");
+  }
   if (ent->FormNumber() == 0 && ent->NbRows() != 1)
     ach->AddFail("Form 0 with several Rows");
   if (ent->NbAttributes() != ent->Definition()->NbAttributes())
Index: oce/src/IGESToBRep/IGESToBRep_IGESBoundary.cxx
===================================================================
--- oce.orig/src/IGESToBRep/IGESToBRep_IGESBoundary.cxx
+++ oce/src/IGESToBRep/IGESToBRep_IGESBoundary.cxx
@@ -168,11 +168,12 @@ IGESToBRep_IGESBoundary::IGESToBRep_IGES
   else if (len2d == 0)
     GTranslate2d = Standard_False;
   
-  if (GTranslate3d && GTranslate2d)
+  if (GTranslate3d && GTranslate2d) {
     //Setting preference in the case of inconsitency between 3D and 2D
     if      (myfilepreference == 2) Preferred3d = Standard_False;
     else if (myfilepreference == 3) Preferred2d = Standard_False;
     else                            Preferred3d = Standard_False;
+  }
   
   if (GTranslate3d && GTranslate2d && len3d != len2d) {
     GTranslate3d = Preferred3d;
Index: oce/src/IntPatch/IntPatch_RstInt.cxx
===================================================================
--- oce.orig/src/IntPatch/IntPatch_RstInt.cxx
+++ oce/src/IntPatch/IntPatch_RstInt.cxx
@@ -810,11 +810,12 @@ void IntPatch_RstInt::PutVertexOnLine (H
 
 		arc->D1(paramarc,p2d,d2d);
 		U1 = p2d.X(); V1 = p2d.Y();
-		if (typL == IntPatch_Walking && SurfaceIsPeriodic)
+		if (typL == IntPatch_Walking && SurfaceIsPeriodic) {
 		  if (OnFirst)
 		    Recadre(TypeS1,TypeS2,wlin,ParamApproxOnLine,U1,V1,U2,V2);
 		  else
 		    Recadre(TypeS1,TypeS2,wlin,ParamApproxOnLine,U2,V2,U1,V1);
+		}
 
 		locpt.Append(ptsommet);
 		locpt2.Append(gp_Pnt2d(U2,V2));
Index: oce/src/IntPolyh/IntPolyh_MaillageAffinage.cxx
===================================================================
--- oce.orig/src/IntPolyh/IntPolyh_MaillageAffinage.cxx
+++ oce/src/IntPolyh/IntPolyh_MaillageAffinage.cxx
@@ -2948,14 +2948,16 @@ Standard_Integer IntPolyh_MaillageAffina
       }
       else {
 	PI=PE1+Edge*lambda;
-	if(TriSurfID==1) 
+	if(TriSurfID==1) {
 	  if(Tri2.GetEdgeOrientation(EdgeIndex)>0)
 	    SP1.SetLambda2(lambda);
 	  else SP1.SetLambda2(1.0-lambda);
-	if(TriSurfID==2) 
+	}
+	if(TriSurfID==2) {
 	  if(Tri1.GetEdgeOrientation(EdgeIndex)>0)
 	    SP1.SetLambda1(lambda);
 	  else SP1.SetLambda1(1.0-lambda);
+	}
 
       }
         
Index: oce/src/MeshVS/MeshVS_Mesh.cxx
===================================================================
--- oce.orig/src/MeshVS/MeshVS_Mesh.cxx
+++ oce/src/MeshVS/MeshVS_Mesh.cxx
@@ -319,7 +319,7 @@ void MeshVS_Mesh::ComputeSelection ( con
           TColStd_MapIteratorOfPackedMapOfInteger anIterN( anAllNodesMap );
 
           for( ; anIterN.More(); anIterN.Next() )
-            if( myDataSource->GetGeom( anIterN.Key(), Standard_False, aCoords, NbNodes, aType ) )
+            if( myDataSource->GetGeom( anIterN.Key(), Standard_False, aCoords, NbNodes, aType ) ) {
               if( first )
               {
                 for( Standard_Integer i=1; i<=3; i++ )
@@ -334,6 +334,7 @@ void MeshVS_Mesh::ComputeSelection ( con
                   if( aCoords( i )>max[i-1] )
                     max[i-1] = aCoords( i );
                 }
+            }
           Bnd_Box box;
           box.Add( gp_Pnt( min[0], min[1], min[2] ) );
           box.Add( gp_Pnt( max[0], max[1], max[2] ) );
Index: oce/src/MeshVS/MeshVS_MeshPrsBuilder.cxx
===================================================================
--- oce.orig/src/MeshVS/MeshVS_MeshPrsBuilder.cxx
+++ oce/src/MeshVS/MeshVS_MeshPrsBuilder.cxx
@@ -852,7 +852,7 @@ void MeshVS_MeshPrsBuilder::HowManyPrimi
                                                Standard_Integer& Vertices,
                                                Standard_Integer& Bounds)
 {
-  if( !Topo.IsNull() )
+  if( !Topo.IsNull() ) {
     if( AsPolygons || IsSelect )
     {
       Standard_Integer B = Topo->Upper()-Topo->Lower()+1;
@@ -872,6 +872,7 @@ void MeshVS_MeshPrsBuilder::HowManyPrimi
       Bounds += E;
       Vertices += 2*E;
     }
+  }
 }
 
 //================================================================
Index: oce/src/NCollection/NCollection_BaseSequence.cxx
===================================================================
--- oce.orig/src/NCollection/NCollection_BaseSequence.cxx
+++ oce/src/NCollection/NCollection_BaseSequence.cxx
@@ -209,7 +209,7 @@ void NCollection_BaseSequence::PInsertAf
 {
   if (theIndex < 0 || theIndex > mySize)
     Standard_OutOfRange::Raise();
-  if (Other.mySize != 0)
+  if (Other.mySize != 0) {
     if (theIndex == 0) 
       PPrepend (Other);
     else {
@@ -226,6 +226,7 @@ void NCollection_BaseSequence::PInsertAf
         myCurrentIndex += Other.mySize;
       Other.Nullify();
     }
+  }
 }
 
 //=======================================================================
Index: oce/src/NIS/NIS_InteractiveObject.cxx
===================================================================
--- oce.orig/src/NIS/NIS_InteractiveObject.cxx
+++ oce/src/NIS/NIS_InteractiveObject.cxx
@@ -47,7 +47,7 @@ const Handle_NIS_Drawer& NIS_Interactive
                                          const Standard_Boolean    setUpdated)
 {
   NIS_InteractiveContext * aCtx = theDrawer->GetContext();
-  if (myDrawer.IsNull() == Standard_False)
+  if (myDrawer.IsNull() == Standard_False) {
     if (aCtx == 0L)
     {
       aCtx = myDrawer->GetContext();
@@ -59,6 +59,7 @@ const Handle_NIS_Drawer& NIS_Interactive
         (myDrawer->GetContext() != 0L && aCtx != myDrawer->GetContext(),
          "NIS_InteractiveObject::SetDrawer: different drawer context");
     }
+  }
 
   Standard_NullValue_Raise_if
     (aCtx == 0L, "NIS_InteractiveObject::SetDrawer: NULL drawer context");
Index: oce/src/ProjLib/ProjLib_ComputeApproxOnPolarSurface.cxx
===================================================================
--- oce.orig/src/ProjLib/ProjLib_ComputeApproxOnPolarSurface.cxx
+++ oce/src/ProjLib/ProjLib_ComputeApproxOnPolarSurface.cxx
@@ -199,34 +199,38 @@ static gp_Pnt2d Function_Value(const Sta
   if(Surf->IsVPeriodic() || Surf->IsVClosed()) {
     vperiod = Surf->LastVParameter() - Surf->FirstVParameter();
   } 
-  if(U0 < Uinf)
+  if(U0 < Uinf) {
     if(!uperiod)
       U0 = Uinf;
     else {
       decalU = int((Uinf - U0)/uperiod)+1;
       U0 += decalU*uperiod;
     }
-  if(U0 > Usup)
+  }
+  if(U0 > Usup) {
     if(!uperiod)
       U0 = Usup;
     else {
       decalU = -(int((U0 - Usup)/uperiod)+1);
       U0 += decalU*uperiod;
     }
-  if(V0 < Vinf)
+  }
+  if(V0 < Vinf) {
     if(!vperiod)
       V0 = Vinf;
     else {
       decalV = int((Vinf - V0)/vperiod)+1;
       V0 += decalV*vperiod;
     }
-  if(V0 > Vsup)
+  }
+  if(V0 > Vsup) {
     if(!vperiod)
       V0 = Vsup;
     else {
       decalV = -int((V0 - Vsup)/vperiod)-1;
       V0 += decalV*vperiod;
     }
+  }
   
   // The surface around U0 is reduced
   Standard_Real uLittle = (Usup - Uinf)/10, vLittle = (Vsup - Vinf)/10;
@@ -1141,7 +1145,7 @@ Handle(Adaptor2d_HCurve2d)
 	      if (Dist2Min < DistTol3d * DistTol3d) {
 	      //if (Dist2Min < Tol3d * Tol3d) {
 		(ext.Point(GoodValue)).Parameter(u,v);
-		if(uperiod)
+		if(uperiod) {
 		  if((U0 - u) > (2*uperiod/3)) {
 		    usens++;
 		  }
@@ -1149,7 +1153,8 @@ Handle(Adaptor2d_HCurve2d)
 		    if((u - U0) > (2*uperiod/3)) {
 		      usens--;
 		    }
-		if(vperiod)
+		}
+		if(vperiod) {
 		  if((V0 - v) > (vperiod/2)) {
 		    vsens++;
 		  }
@@ -1157,6 +1162,7 @@ Handle(Adaptor2d_HCurve2d)
 		    if((v - V0) > (vperiod/2)) {
 		      vsens--;
 		    }
+		}
 		U0 = u; V0 = v;
 		U1 = U0 + usens*uperiod;
 		V1 = V0 + vsens*vperiod;
Index: oce/src/Resource/Resource_Manager.cxx
===================================================================
--- oce.orig/src/Resource/Resource_Manager.cxx
+++ oce/src/Resource/Resource_Manager.cxx
@@ -221,9 +221,10 @@ static Standard_Integer GetLine(OSD_File
   do {
     aFile.ReadLine(Buffer,BufSize,Len);
     aLine += Buffer;
-    if (aFile.IsAtEnd())
+    if (aFile.IsAtEnd()) {
       if (!aLine.Length()) return 0;
       else aLine += "\n";
+    }
   } while (aLine.Value(aLine.Length()) != '\n');
 
   return 1;
Index: oce/src/STEPControl/STEPControl_ActorWrite.cxx
===================================================================
--- oce.orig/src/STEPControl/STEPControl_ActorWrite.cxx
+++ oce/src/STEPControl/STEPControl_ActorWrite.cxx
@@ -1338,12 +1338,13 @@ Handle(Transfer_Binder) STEPControl_Acto
     while ( !bnd.IsNull() ) {
       Handle(Transfer_SimpleBinderOfTransient) bx = 
         Handle(Transfer_SimpleBinderOfTransient)::DownCast(bnd);
-      if ( !bx.IsNull() )
+      if ( !bx.IsNull() ) {
         // Single SDR is created for a non-manifold group (ssv: 12.11.2010)
         if (!isManifold && i > 1)
           break;
         else
           binder->AddResult( TransientResult( bx->Result() ) );
+      }
       bnd = bnd->NextResult();
     }
   }
Index: oce/src/SWDRAW/SWDRAW_ShapeFix.cxx
===================================================================
--- oce.orig/src/SWDRAW/SWDRAW_ShapeFix.cxx
+++ oce/src/SWDRAW/SWDRAW_ShapeFix.cxx
@@ -265,9 +265,10 @@ static Standard_Integer stwire (Draw_Int
       if (sbwd->IsSeam(i))        di<<" SEAM_WIRE";
       if (Shape.ShapeType() == TopAbs_FACE &&
 	  sae.IsSeam(E,TopoDS::Face(Shape)))  di<<" SEAM_FACE";
-      if (Shape.ShapeType() == TopAbs_FACE )
+      if (Shape.ShapeType() == TopAbs_FACE ) {
 	if (sae.HasPCurve(E,TopoDS::Face(Shape)))     di<<" PCU";
 	else di<<" NO_PCU";
+      }
       if (sae.HasCurve3d(E))    di<<" C3D";
       else di<<" NO_C3D";
       if (sae.IsClosed3d(E))  di<<" CLOSED";
Index: oce/src/SWDRAW/SWDRAW_ShapeUpgrade.cxx
===================================================================
--- oce.orig/src/SWDRAW/SWDRAW_ShapeUpgrade.cxx
+++ oce/src/SWDRAW/SWDRAW_ShapeUpgrade.cxx
@@ -1150,21 +1150,25 @@ static Standard_Integer splitface
   Standard_Real Umin, Umax, Vmin, Vmax;
   S->Bounds ( Umin, Umax, Vmin, Vmax );
   if ( Uf < Umin && ! S->IsUPeriodic() ) Uf = Umin;
-  else if ( Uf > Umin )
+  else if ( Uf > Umin ) {
     if ( Precision::IsInfinite(Umin) ) Uf -= 100;
     else Uf = Umin;
+  }
   if ( Vf < Vmin && ! S->IsVPeriodic() ) Vf = Vmin;
-  else if ( Vf > Vmin )
+  else if ( Vf > Vmin ) {
     if ( Precision::IsInfinite(Vmin) ) Vf -= 100;
     else Vf = Vmin;
+  }
   if ( Ul > Umax && ! S->IsUPeriodic() ) Ul = Umax;
-  else if ( Ul < Umax )
+  else if ( Ul < Umax ) {
     if ( Precision::IsInfinite(Umax) ) Ul += 100;
     else Ul = Umax;
+  }
   if ( Vl > Vmax && ! S->IsVPeriodic() ) Vl = Vmax;
-  else if ( Vl < Vmax )
+  else if ( Vl < Vmax ) {
     if ( Precision::IsInfinite(Vmax) ) Vl += 100;
     else Vl = Vmax;
+  }
   
   TColStd_SequenceOfReal uval;
   TColStd_SequenceOfReal vval;
Index: oce/src/SelectMgr/SelectMgr_EntityOwner.cxx
===================================================================
--- oce.orig/src/SelectMgr/SelectMgr_EntityOwner.cxx
+++ oce/src/SelectMgr/SelectMgr_EntityOwner.cxx
@@ -87,11 +87,12 @@ void SelectMgr_EntityOwner::HilightWithC
 					     const Quantity_NameOfColor aColor,
 					     const Standard_Integer aMode)
 {
-  if( HasSelectable() )
+  if( HasSelectable() ) {
     if( IsAutoHilight() )
       PM->Color(mySelectable,aColor,aMode);
     else
       mySelectable->HilightOwnerWithColor( PM, aColor, this );
+  }
 }
 
 void SelectMgr_EntityOwner::Unhilight(const Handle(PrsMgr_PresentationManager)& PM,
Index: oce/src/SelectMgr/SelectMgr_SelectableObject.cxx
===================================================================
--- oce.orig/src/SelectMgr/SelectMgr_SelectableObject.cxx
+++ oce/src/SelectMgr/SelectMgr_SelectableObject.cxx
@@ -182,7 +182,7 @@ void SelectMgr_SelectableObject::ResetLo
     for(Sel->Init();Sel->More();Sel->Next()){
       SE =  *((Handle(Select3D_SensitiveEntity)*) &(Sel->Sensitive()));
       if(!SE.IsNull()){
-        if(SE->HasLocation())
+        if(SE->HasLocation()) {
           if( SE->Location()==myLocation){
             SE->ResetLocation();
             const Handle(SelectBasics_EntityOwner)& EO = SE->OwnerId();
@@ -192,7 +192,7 @@ void SelectMgr_SelectableObject::ResetLo
             SE->SetLocation(iniloc*myLocation.Inverted());
             const Handle(SelectBasics_EntityOwner)& EO = SE->OwnerId();
             (*((Handle(SelectMgr_EntityOwner)*)&EO))->SetLocation(SE->Location());}
-        
+        }
       }
     }
     Sel->UpdateStatus(SelectMgr_TOU_None);
Index: oce/src/ShapeAnalysis/ShapeAnalysis_CheckSmallFace.cxx
===================================================================
--- oce.orig/src/ShapeAnalysis/ShapeAnalysis_CheckSmallFace.cxx
+++ oce/src/ShapeAnalysis/ShapeAnalysis_CheckSmallFace.cxx
@@ -374,12 +374,13 @@ static Standard_Boolean MinMaxSmall
     else return Standard_False;
   }
   //   Now, check these two edge to define a strip !
-  if (!E1.IsNull()&&!E2.IsNull()) 
+  if (!E1.IsNull()&&!E2.IsNull()) {
     if(!CheckStripEdges (E1,E2,tol,dmax)) return Standard_False; 
       else {   
 	myStatusStrip = ShapeExtend::EncodeStatus (ShapeExtend_DONE3);
 	return Standard_True ;
       }
+  }
   return Standard_False;
 }
 
Index: oce/src/ShapeCustom/ShapeCustom_ConvertToBSpline.cxx
===================================================================
--- oce.orig/src/ShapeCustom/ShapeCustom_ConvertToBSpline.cxx
+++ oce/src/ShapeCustom/ShapeCustom_ConvertToBSpline.cxx
@@ -60,7 +60,7 @@ Standard_Boolean ShapeCustom_ConvertToBS
       Handle(Geom_RectangularTrimmedSurface)::DownCast ( S );
     SS = RTS->BasisSurface();
   }
-  if(SS->IsKind(STANDARD_TYPE(Geom_OffsetSurface)))
+  if(SS->IsKind(STANDARD_TYPE(Geom_OffsetSurface))) {
     if(myOffsetMode)
       return Standard_True;
     else {
@@ -69,6 +69,7 @@ Standard_Boolean ShapeCustom_ConvertToBS
       Handle(Geom_Surface) tmp;
       return IsToConvert(basis,tmp);
     }
+  }
   if ( SS->IsKind(STANDARD_TYPE(Geom_SurfaceOfLinearExtrusion)) )
     return myExtrMode;
   if ( SS->IsKind(STANDARD_TYPE(Geom_SurfaceOfRevolution)) )
Index: oce/src/ShapeFix/ShapeFix_ComposeShell.cxx
===================================================================
--- oce.orig/src/ShapeFix/ShapeFix_ComposeShell.cxx
+++ oce/src/ShapeFix/ShapeFix_ComposeShell.cxx
@@ -666,9 +666,10 @@ Standard_Integer ShapeFix_ComposeShell::
       }
     }
     if ( j < np ) { i = 0; break; } // not tangency
-    if ( i == endInd ) 
+    if ( i == endInd ) {
       if ( special <=0 ) break;
       else special = -1;
+    }
   }
   if ( myClosedMode ) {
     if ( code != IOR_UNDEF && ! begin ) {
Index: oce/src/ShapeFix/ShapeFix_Face.cxx
===================================================================
--- oce.orig/src/ShapeFix/ShapeFix_Face.cxx
+++ oce/src/ShapeFix/ShapeFix_Face.cxx
@@ -1379,16 +1379,18 @@ Standard_Boolean ShapeFix_Face::FixMissi
   if ( ::Precision::IsInfinite ( SUF ) || ::Precision::IsInfinite ( SUL ) ) {
     if ( ::Precision::IsInfinite ( SUF ) ) SUF = fU1;
     if ( ::Precision::IsInfinite ( SUL ) ) SUL = fU2;
-    if(Abs(SUL-SUF) < ::Precision::PConfusion())
+    if(Abs(SUL-SUF) < ::Precision::PConfusion()) {
       if ( ::Precision::IsInfinite ( SUF ) ) SUF-=1000.;
       else SUL+=1000.;
+    }
   }
   if ( ::Precision::IsInfinite ( SVF ) || ::Precision::IsInfinite ( SVL ) ) {
     if ( ::Precision::IsInfinite ( SVF ) ) SVF = fV1;
     if ( ::Precision::IsInfinite ( SVL ) ) SVL = fV2;
-    if(Abs(SVL-SVF) < ::Precision::PConfusion())
+    if(Abs(SVL-SVF) < ::Precision::PConfusion()) {
       if ( ::Precision::IsInfinite ( SVF ) ) SVF-=1000.;
       else SVL+=1000.;
+    }
   }
     
   URange = Abs ( SUL - SUF );
@@ -1609,9 +1611,10 @@ Standard_Boolean ShapeFix_Face::FixMissi
 	vf = pos1.Y();
       }
     }
-    if ( skipU && skipV ) 
+    if ( skipU && skipV ) {
       if ( i1 <= nb1 ) continue;
       else break;
+    }
     // or yet better - if it is end of some edges on both wires
     for ( Standard_Integer i2 = 1; i1 <= nb1 && i2 <= nb2; i2++ ) {
       TopoDS_Edge edge2 = wd2->Edge ( i2 );
Index: oce/src/ShapeFix/ShapeFix_Wire.cxx
===================================================================
--- oce.orig/src/ShapeFix/ShapeFix_Wire.cxx
+++ oce/src/ShapeFix/ShapeFix_Wire.cxx
@@ -1300,9 +1300,10 @@ Standard_Boolean ShapeFix_Wire::FixShift
   SVMid = 0.5*(SVF+SVL);
   if (uclosed) URange = Abs ( SUL - SUF );
   else         URange = RealLast();
-  if (!IsVCrvClosed)
+  if (!IsVCrvClosed) {
     if (vclosed) VRange = Abs ( SVL - SVF );
     else         VRange = RealLast();
+  }
   Standard_Real UTol = 0.2 * URange, VTol = 0.2 * VRange;
 
   Handle(ShapeExtend_WireData) sbwdOring = WireData();
Index: oce/src/ShapeProcess/ShapeProcess_ShapeContext.cxx
===================================================================
--- oce.orig/src/ShapeProcess/ShapeProcess_ShapeContext.cxx
+++ oce/src/ShapeProcess/ShapeProcess_ShapeContext.cxx
@@ -413,10 +413,11 @@ void ShapeProcess_ShapeContext::PrintSta
     if (keyshape.ShapeType() == TopAbs_SHELL)
       if (valueshape.IsNull()) SN++;
       else SS++;
-    else if (keyshape.ShapeType() == TopAbs_FACE)
+    else if (keyshape.ShapeType() == TopAbs_FACE) {
       if (valueshape.IsNull()) FN++;
       else if (valueshape.ShapeType() == TopAbs_SHELL) FS++;
       else FF++;
+    }
   }
   
   // mapping
Index: oce/src/ShapeProcessAPI/ShapeProcessAPI_ApplySequence.cxx
===================================================================
--- oce.orig/src/ShapeProcessAPI/ShapeProcessAPI_ApplySequence.cxx
+++ oce/src/ShapeProcessAPI/ShapeProcessAPI_ApplySequence.cxx
@@ -110,13 +110,15 @@ void ShapeProcessAPI_ApplySequence::Prin
   Standard_Integer SS = 0, SN = 0, FF = 0, FS = 0, FN = 0;
   for (TopTools_DataMapIteratorOfDataMapOfShapeShape It (myContext->Map()); It.More(); It.Next()) {
     TopoDS_Shape keyshape = It.Key(), valueshape = It.Value();
-    if (keyshape.ShapeType() == TopAbs_SHELL)
+    if (keyshape.ShapeType() == TopAbs_SHELL) {
       if (valueshape.IsNull()) SN++;
       else SS++;
-    else if (keyshape.ShapeType() == TopAbs_FACE)
+    }
+    else if (keyshape.ShapeType() == TopAbs_FACE) {
       if (valueshape.IsNull()) FN++;
       else if (valueshape.ShapeType() == TopAbs_SHELL) FS++;
       else FF++;
+    }
   }
   
   Handle(Message_Messenger) aMessenger = myContext->Messenger();
Index: oce/src/TNaming/TNaming_NamedShape.cxx
===================================================================
--- oce.orig/src/TNaming/TNaming_NamedShape.cxx
+++ oce/src/TNaming/TNaming_NamedShape.cxx
@@ -1051,7 +1051,7 @@ static void SelectSameShape (TNaming_Nod
     if (Trans < 0) Valid = pdn->myAtt->IsValid(); 
     else Valid = pdn->IsValidInTrans(Trans);
 
-    if (Valid)
+    if (Valid) {
       if (Old) {
 	if( pdn->myOld == RS && pdn->myNew != 0L && pdn->myNew != RS) {
 	  break;
@@ -1062,6 +1062,7 @@ static void SelectSameShape (TNaming_Nod
 	  break;
 	}
       }
+    }
     pdn = pdn->NextSameShape(RS);
   }
   myNode = pdn;
Index: oce/src/TopTrans/TopTrans_SurfaceTransition.cxx
===================================================================
--- oce.orig/src/TopTrans/TopTrans_SurfaceTransition.cxx
+++ oce/src/TopTrans/TopTrans_SurfaceTransition.cxx
@@ -451,9 +451,10 @@ TopAbs_State TopTrans_SurfaceTransition:
     // we take the state before of after orientations
     before = ::FUN_getstate(myAng,myOri,AFTER,BEFORE);
     // eap Mar 25 2002 
-    if (myTouchFlag)
+    if (myTouchFlag) {
       if (before == TopAbs_OUT) before = TopAbs_IN;
       else if (before == TopAbs_IN) before = TopAbs_OUT;
+    }
   }
   return before;
 }
@@ -467,9 +468,10 @@ TopAbs_State TopTrans_SurfaceTransition:
     // looking back in before for defined states
     after = ::FUN_getstate(myAng,myOri,BEFORE,AFTER);
     // eap Mar 25 2002 
-    if (myTouchFlag)
+    if (myTouchFlag) {
       if (after == TopAbs_OUT) after = TopAbs_IN;
       else if (after == TopAbs_IN) after = TopAbs_OUT;
+    }
   }
   return after;
 }
Index: oce/src/ViewerTest/ViewerTest.cxx
===================================================================
--- oce.orig/src/ViewerTest/ViewerTest.cxx
+++ oce/src/ViewerTest/ViewerTest.cxx
@@ -474,13 +474,14 @@ Handle(AIS_Shape) GetAISShapeFromName(co
     const Handle(AIS_InteractiveObject) IO =
       Handle(AIS_InteractiveObject)::DownCast(GetMapOfAIS().Find2(name));
     if (!IO.IsNull()) {
-      if(IO->Type()==AIS_KOI_Shape)
+      if(IO->Type()==AIS_KOI_Shape) {
         if(IO->Signature()==0){
           retsh = *((Handle(AIS_Shape)*)&IO);
         }
         else
           cout << "an Object which is not an AIS_Shape "
             "already has this name!!!"<<endl;
+      }
     }
     return retsh;
   }
@@ -1044,12 +1045,12 @@ static int VSubInt(Draw_Interpretor& di,
     TCollection_AsciiString name = argv[2];
     if(GetMapOfAIS().IsBound2(name)){
       IO = Handle(AIS_InteractiveObject)::DownCast(GetMapOfAIS().Find2(name));
-      if (!IO.IsNull())
+      if (!IO.IsNull()) {
         if(On==1)
           Ctx->SubIntensityOn(IO);
         else
           Ctx->SubIntensityOff(IO);
-
+      }
     }
     else return 1;
   }
Index: oce/src/VrmlData/VrmlData_Geometry.cxx
===================================================================
--- oce.orig/src/VrmlData/VrmlData_Geometry.cxx
+++ oce/src/VrmlData/VrmlData_Geometry.cxx
@@ -563,7 +563,7 @@ VrmlData_ErrorStatus VrmlData_TextureCoo
     // Match the name with the current word in the stream
     if (VRMLDATA_LCOMPARE (theBuffer.LinePtr, "point"))
       // Read the body of the data node (comma-separated list of duplets)
-      if (OK(aStatus, VrmlData_Scene::ReadLine(theBuffer)))
+      if (OK(aStatus, VrmlData_Scene::ReadLine(theBuffer))) {
         if (theBuffer.LinePtr[0] != '[')  // opening bracket
           aStatus = VrmlData_VrmlFormatError;
         else {
@@ -591,6 +591,7 @@ VrmlData_ErrorStatus VrmlData_TextureCoo
             }
           }
         }
+      }
     if (OK(aStatus) && OK(aStatus, readBrace (theBuffer))) {
       myLength = vecValues.Length();
       if (myLength > 0) {
@@ -652,7 +653,7 @@ VrmlData_ErrorStatus VrmlData_ArrayVec3d
         theBuffer.LinePtr++;
     }
     // Read the body of the data node (list of triplets)
-    if (OK(aStatus) && OK(aStatus, VrmlData_Scene::ReadLine(theBuffer)))
+    if (OK(aStatus) && OK(aStatus, VrmlData_Scene::ReadLine(theBuffer))) {
       if (theBuffer.LinePtr[0] != '[')  // opening bracket
         aStatus = VrmlData_VrmlFormatError;
       else {
@@ -679,6 +680,7 @@ VrmlData_ErrorStatus VrmlData_ArrayVec3d
           }
         }
       }
+    }
     if (OK(aStatus) && OK(aStatus, readBrace (theBuffer))) {
       myLength = vecValues.Length();
       if (myLength > 0) {
Index: oce/src/VrmlData/VrmlData_IndexedFaceSet.cxx
===================================================================
--- oce.orig/src/VrmlData/VrmlData_IndexedFaceSet.cxx
+++ oce/src/VrmlData/VrmlData_IndexedFaceSet.cxx
@@ -66,11 +66,12 @@ VrmlData_ErrorStatus VrmlData_Faceted::r
   } else if (VRMLDATA_LCOMPARE (theBuffer.LinePtr, "creaseAngle")) {
     Standard_Real anAngle;
     if (OK(aStatus, Scene().ReadReal (theBuffer, anAngle,
-                                      Standard_False, Standard_False)))
+                                      Standard_False, Standard_False))) {
       if (anAngle < -Precision::Confusion()*0.001)
         aStatus = VrmlData_IrrelevantNumber;
       else
         myCreaseAngle = anAngle;
+    }
   }
   return aStatus;
 }
Index: oce/src/VrmlData/VrmlData_Node.cxx
===================================================================
--- oce.orig/src/VrmlData/VrmlData_Node.cxx
+++ oce/src/VrmlData/VrmlData_Node.cxx
@@ -181,11 +181,12 @@ VrmlData_ErrorStatus VrmlData_Node::Writ
 VrmlData_ErrorStatus VrmlData_Node::readBrace (VrmlData_InBuffer& theBuffer)
 {
   VrmlData_ErrorStatus aStatus;
-  if (OK(aStatus, VrmlData_Scene::ReadLine(theBuffer)))
+  if (OK(aStatus, VrmlData_Scene::ReadLine(theBuffer))) {
     if (theBuffer.LinePtr[0] == '}')
       theBuffer.LinePtr++;
     else
       aStatus = VrmlData_VrmlFormatError;
+  }
   return aStatus;
 }
 
Index: oce/src/VrmlData/VrmlData_Scene.cxx
===================================================================
--- oce.orig/src/VrmlData/VrmlData_Scene.cxx
+++ oce/src/VrmlData/VrmlData_Scene.cxx
@@ -221,11 +221,12 @@ VrmlData_ErrorStatus VrmlData_Scene::rea
     const int stat = theBuffer.Input.rdstate();
     if (stat & ios::badbit)
       aStatus = VrmlData_UnrecoverableError;
-    else if (stat & ios::failbit)
+    else if (stat & ios::failbit) {
       if (stat & ios::eofbit)
         aStatus = VrmlData_EndOfFile;
       else
         aStatus = VrmlData_GeneralError;
+    }
     theBuffer.LinePtr = &theBuffer.Line[0];
     theBuffer.IsProcessed = Standard_False;
   }
@@ -460,7 +461,7 @@ VrmlData_ErrorStatus VrmlData_Scene::cre
   TCollection_AsciiString aName;
 
   // Read the DEF token to assign the node name
-  if (VrmlData_Node::OK(aStatus, ReadLine(theBuffer)))
+  if (VrmlData_Node::OK(aStatus, ReadLine(theBuffer))) {
     if (VRMLDATA_LCOMPARE(theBuffer.LinePtr, "DEF")) {
       if (VrmlData_Node::OK(aStatus, ReadWord (theBuffer, aName)))
         aStatus = ReadLine(theBuffer);
@@ -468,6 +469,7 @@ VrmlData_ErrorStatus VrmlData_Scene::cre
       theNode.Nullify();
       return aStatus;
     }
+  }
 
   const char * strName = aName.ToCString();
   if (aStatus == VrmlData_StatusOK) {
@@ -528,7 +530,7 @@ VrmlData_ErrorStatus VrmlData_Scene::cre
       aStatus = ReadWord (theBuffer, aTitle);
       if (isProto) {
         aStatus = ReadLine(theBuffer);
-        if (aStatus == VrmlData_StatusOK)
+        if (aStatus == VrmlData_StatusOK) {
           if (theBuffer.LinePtr[0] != '[')
             aStatus = VrmlData_VrmlFormatError;
           else {
@@ -552,6 +554,7 @@ VrmlData_ErrorStatus VrmlData_Scene::cre
               }
             }
           }
+        }
       }
       if (aStatus == VrmlData_StatusOK)
         aNode = new VrmlData_UnknownNode(* this,
@@ -567,13 +570,14 @@ VrmlData_ErrorStatus VrmlData_Scene::cre
       if (aNode->IsKind(theType) == Standard_False)
         aStatus = VrmlData_VrmlFormatError;
   }
-  if (aStatus == VrmlData_StatusOK)
+  if (aStatus == VrmlData_StatusOK) {
     if (theBuffer.LinePtr[0] == '{') {
       theBuffer.LinePtr++;
       theNode = aNode;
       myAllNodes.Append(aNode);
     } else
       aStatus = VrmlData_VrmlFormatError;
+  }
   return aStatus;
 }
 
@@ -729,13 +733,14 @@ VrmlData_ErrorStatus VrmlData_Scene::Rea
       theBuffer.LinePtr = endptr;
     }
   }
-  if (aStatus == VrmlData_StatusOK)
+  if (aStatus == VrmlData_StatusOK) {
     if (isScale)
       theXYZ.SetCoord (aVal[0] * myLinearScale,
                        aVal[1] * myLinearScale,
                        aVal[2] * myLinearScale);
     else
       theXYZ.SetCoord (aVal[0], aVal[1], aVal[2]);
+  }
   return aStatus;
 }
 
@@ -768,11 +773,12 @@ VrmlData_ErrorStatus VrmlData_Scene::Rea
       theBuffer.LinePtr = endptr;
     }
   }
-  if (aStatus == VrmlData_StatusOK)
+  if (aStatus == VrmlData_StatusOK) {
     if (isScale)
       theXY.SetCoord (aVal[0] * myLinearScale, aVal[1] * myLinearScale);
     else
       theXY.SetCoord (aVal[0], aVal[1]);
+  }
   return aStatus;
 }
 
@@ -789,7 +795,7 @@ VrmlData_ErrorStatus VrmlData_Scene::Rea
 {
   VrmlData_ErrorStatus aStatus;
   theNBlocks = 0;
-  if (VrmlData_Node::OK(aStatus, ReadLine(theBuffer)))
+  if (VrmlData_Node::OK(aStatus, ReadLine(theBuffer))) {
     if (theBuffer.LinePtr[0] != '[')  // opening bracket
       aStatus = VrmlData_VrmlFormatError;
     else {
@@ -856,6 +862,7 @@ VrmlData_ErrorStatus VrmlData_Scene::Rea
         }
       }
     }
+  }
   return aStatus;
 }
 
@@ -926,7 +933,7 @@ VrmlData_ErrorStatus VrmlData_Scene::Wri
                                  const char             * thePostfix) const
 {
   char buf[240];
-  if (IsDummyWrite() == Standard_False)
+  if (IsDummyWrite() == Standard_False) {
     if (isApplyScale && myLinearScale > Precision::Confusion())
       Sprintf (buf, "%.12g %.12g %.12g%s", theXYZ.X() / myLinearScale,
                theXYZ.Y() / myLinearScale, theXYZ.Z() / myLinearScale,
@@ -934,6 +941,7 @@ VrmlData_ErrorStatus VrmlData_Scene::Wri
     else
       Sprintf (buf, "%.12g %.12g %.12g%s", theXYZ.X(), theXYZ.Y(), theXYZ.Z(),
                thePostfix ? thePostfix : "");
+  }
   return WriteLine (buf);
 }
 
Index: oce/src/XCAFDoc/XCAFDoc_ColorTool.cxx
===================================================================
--- oce.orig/src/XCAFDoc/XCAFDoc_ColorTool.cxx
+++ oce/src/XCAFDoc/XCAFDoc_ColorTool.cxx
@@ -461,7 +461,7 @@ Standard_Boolean XCAFDoc_ColorTool::SetI
     return Standard_False;
   Handle(XCAFDoc_GraphNode) aSHUO;
   // set the SHUO structure for this component if it is not exist
-  if ( !ShapeTool()->FindSHUO( aLabels, aSHUO ) )
+  if ( !ShapeTool()->FindSHUO( aLabels, aSHUO ) ) {
     if (aLabels.Length() == 1) {
       // set color directly for component as NAUO
       SetColor(aLabels.Value(1), color, type);
@@ -469,6 +469,7 @@ Standard_Boolean XCAFDoc_ColorTool::SetI
     }
     else if ( !IsCreateSHUO ||  !ShapeTool()->SetSHUO( aLabels, aSHUO ) )
       return Standard_False;
+  }
   TDF_Label aSHUOLabel = aSHUO->Label();
   SetColor( aSHUOLabel, color, type );
   return Standard_True;
Index: oce/src/XSDRAWSTLVRML/XSDRAWSTLVRML.cxx
===================================================================
--- oce.orig/src/XSDRAWSTLVRML/XSDRAWSTLVRML.cxx
+++ oce/src/XSDRAWSTLVRML/XSDRAWSTLVRML.cxx
@@ -600,11 +600,12 @@ static Standard_Integer hidesel
     {
       Handle( MeshVS_MeshEntityOwner ) anOwner =
         Handle( MeshVS_MeshEntityOwner )::DownCast( aContext->SelectedOwner() );
-      if( !anOwner.IsNull() )
+      if( !anOwner.IsNull() ) {
         if( anOwner->Type()==MeshVS_ET_Node )
           aHiddenNodes->ChangeMap().Add( anOwner->ID() );
         else
           aHiddenElements->ChangeMap().Add( anOwner->ID() );
+      }
     }
     aContext->ClearSelected();
     aMesh->SetHiddenNodes( aHiddenNodes );
@@ -645,11 +646,12 @@ static Standard_Integer showonly
     {
       Handle( MeshVS_MeshEntityOwner ) anOwner =
         Handle( MeshVS_MeshEntityOwner )::DownCast( aContext->SelectedOwner() );
-      if( !anOwner.IsNull() )
+      if( !anOwner.IsNull() ) {
         if( anOwner->Type()==MeshVS_ET_Node )
           aHiddenNodes->ChangeMap().Remove( anOwner->ID() );
         else
           aHiddenElements->ChangeMap().Remove( anOwner->ID() );
+      }
     }
     aMesh->SetHiddenNodes( aHiddenNodes );
     aMesh->SetHiddenElems( aHiddenElements );
