Index: oce/src/BOPAlgo/BOPAlgo_Builder_3.cxx
===================================================================
--- oce.orig/src/BOPAlgo/BOPAlgo_Builder_3.cxx
+++ oce/src/BOPAlgo/BOPAlgo_Builder_3.cxx
@@ -177,7 +177,7 @@ void BOPAlgo_Builder::FillIn3DParts
    const BOPCol_BaseAllocator& )
 {
   Standard_Boolean bHasImage;
-  Standard_Integer i, k, aNbS, aNbLIF, nFP, aNbFP, aNbFIN, iIsIN;
+  Standard_Integer i, k, aNbS, aNbLIF, nFP, aNbFIN, iIsIN;
   TopoDS_Solid aSD;
   TopoDS_Iterator aIt;
   BRep_Builder aBB; 
@@ -306,8 +306,6 @@ void BOPAlgo_Builder::FillIn3DParts
     aSelector.Clear();
     aSelector.SetBox(aBoxS);
     //
-    aNbFP=aBBTree.Select(aSelector);
-    //
     const BOPCol_ListOfInteger& aLIFP=aSelector.Indices();
     //
     // 2.5. Collect faces that are IN aSolid [ aLFIN ]
Index: oce/src/ChFi3d/ChFi3d_Builder_C2.cxx
===================================================================
--- oce.orig/src/ChFi3d/ChFi3d_Builder_C2.cxx
+++ oce/src/ChFi3d/ChFi3d_Builder_C2.cxx
@@ -173,11 +173,8 @@ Standard_Boolean ChFi3d_Builder::Perform
   // Otherwise the opposite face  
   // and the eventual intersection of 2 pcurves on this face are found.
 
-  ChFiDS_State Stat1,Stat2;
   Standard_Boolean isfirst1 = (Sens1 == 1);
   Standard_Boolean isfirst2 = (Sens2 == 1);
-  Stat1 = Corner1->Spine()->Status(isfirst1);
-  Stat2 = Corner2->Spine()->Status(isfirst2);
 /*#ifdef DEB
   Standard_Boolean evolcoin = ((Stat1 == ChFiDS_OnSame && Stat2 == ChFiDS_OnDiff) || 
 			       (Stat2 == ChFiDS_OnSame && Stat1 == ChFiDS_OnDiff));
Index: oce/src/DsgPrs/DsgPrs.cxx
===================================================================
--- oce.orig/src/DsgPrs/DsgPrs.cxx
+++ oce/src/DsgPrs/DsgPrs.cxx
@@ -483,16 +483,8 @@ void DsgPrs::ComputeFilletRadiusPresenta
       FilletCirc.SetRadius( Center.Distance( FirstPoint ) ); //***
       gp_Vec vec1( dir1 );
       vec1 *= FilletCirc.Radius();
-#ifdef DEB
-      gp_Pnt p1 =
-#endif
-                  Center.Translated( vec1 );
       gp_Vec vec2( dir2 );
       vec2 *= FilletCirc.Radius();
-#ifdef DEB
-      gp_Pnt p2 =
-#endif
-                  Center.Translated( vec2 );
       gp_Vec PosVec;
       if(! Center.IsEqual( Position, Precision::Confusion() ))
 	PosVec.SetXYZ( gp_Vec(Center, Position).XYZ() );
Index: oce/src/IntTools/IntTools.cxx
===================================================================
--- oce.orig/src/IntTools/IntTools.cxx
+++ oce/src/IntTools/IntTools.cxx
@@ -218,8 +218,7 @@
     anArray1OfRoots(j)=mySequenceOfRoots(j);
   }
   
-  IntTools_QuickSort aQS;
-  aQS.Sort(anArray1OfRoots, aComparator);
+  IntTools_QuickSort::Sort(anArray1OfRoots, aComparator);
   
   mySequenceOfRoots.Clear();
   for (j=1; j<=aNbRoots; j++) {
Index: oce/src/IntTools/IntTools_EdgeFace.cxx
===================================================================
--- oce.orig/src/IntTools/IntTools_EdgeFace.cxx
+++ oce/src/IntTools/IntTools_EdgeFace.cxx
@@ -684,9 +684,8 @@ Standard_Real IntTools_EdgeFace::Distanc
       anArray1OfRange(n+i).SetLast (aFSeq(i));
     }
     
-    IntTools_QuickSortRange aQuickSortRange;
     IntTools_CompareRange aComparator;
-    aQuickSortRange.Sort (anArray1OfRange, aComparator);
+    IntTools_QuickSortRange::Sort (anArray1OfRange, aComparator);
     
     // filling the  output arrays
     myArgsArray.Resize(k);
