Index: oce/src/BOPAlgo/BOPAlgo_Builder_3.cxx
===================================================================
--- oce.orig/src/BOPAlgo/BOPAlgo_Builder_3.cxx
+++ oce/src/BOPAlgo/BOPAlgo_Builder_3.cxx
@@ -180,7 +180,7 @@ void BOPAlgo_Builder::FillIn3DParts
    const BOPCol_BaseAllocator& )
 {
   Standard_Boolean bHasImage;
-  Standard_Integer i, k, aNbS, aNbLIF, nFP, aNbFP, aNbFIN, iIsIN;
+  Standard_Integer i, k, aNbS, aNbLIF, nFP, aNbFIN, iIsIN;
   TopoDS_Solid aSD;
   TopoDS_Iterator aIt;
   BRep_Builder aBB; 
@@ -310,8 +310,6 @@ void BOPAlgo_Builder::FillIn3DParts
     aSelector.Clear();
     aSelector.SetBox(aBoxS);
     //
-    aNbFP=aBBTree.Select(aSelector);
-    //
     const BOPCol_ListOfInteger& aLIFP=aSelector.Indices();
     //
     // 2.5. Collect faces that are IN aSolid [ aLFIN ]
Index: oce/src/ChFi3d/ChFi3d_Builder_C2.cxx
===================================================================
--- oce.orig/src/ChFi3d/ChFi3d_Builder_C2.cxx
+++ oce/src/ChFi3d/ChFi3d_Builder_C2.cxx
@@ -173,11 +173,8 @@ Standard_Boolean ChFi3d_Builder::Perform
   // Otherwise the opposite face  
   // and the eventual intersection of 2 pcurves on this face are found.
 
-  ChFiDS_State Stat1,Stat2;
   Standard_Boolean isfirst1 = (Sens1 == 1);
   Standard_Boolean isfirst2 = (Sens2 == 1);
-  Stat1 = Corner1->Spine()->Status(isfirst1);
-  Stat2 = Corner2->Spine()->Status(isfirst2);
 /*#ifdef OCCT_DEBUG
   Standard_Boolean evolcoin = ((Stat1 == ChFiDS_OnSame && Stat2 == ChFiDS_OnDiff) || 
 			       (Stat2 == ChFiDS_OnSame && Stat1 == ChFiDS_OnDiff));
Index: oce/src/DsgPrs/DsgPrs.cxx
===================================================================
--- oce.orig/src/DsgPrs/DsgPrs.cxx
+++ oce/src/DsgPrs/DsgPrs.cxx
@@ -483,16 +483,8 @@ void DsgPrs::ComputeFilletRadiusPresenta
       FilletCirc.SetRadius( Center.Distance( FirstPoint ) ); //***
       gp_Vec vec1( dir1 );
       vec1 *= FilletCirc.Radius();
-#ifdef OCCT_DEBUG
-      gp_Pnt p1 =
-#endif
-                  Center.Translated( vec1 );
       gp_Vec vec2( dir2 );
       vec2 *= FilletCirc.Radius();
-#ifdef OCCT_DEBUG
-      gp_Pnt p2 =
-#endif
-                  Center.Translated( vec2 );
       gp_Vec PosVec;
       if(! Center.IsEqual( Position, Precision::Confusion() ))
 	PosVec.SetXYZ( gp_Vec(Center, Position).XYZ() );
Index: oce/src/IntTools/IntTools.cxx
===================================================================
--- oce.orig/src/IntTools/IntTools.cxx
+++ oce/src/IntTools/IntTools.cxx
@@ -218,8 +218,7 @@
     anArray1OfRoots(j)=mySequenceOfRoots(j);
   }
   
-  IntTools_QuickSort aQS;
-  aQS.Sort(anArray1OfRoots, aComparator);
+  IntTools_QuickSort::Sort(anArray1OfRoots, aComparator);
   
   mySequenceOfRoots.Clear();
   for (j=1; j<=aNbRoots; j++) {
Index: oce/src/IntTools/IntTools_EdgeFace.cxx
===================================================================
--- oce.orig/src/IntTools/IntTools_EdgeFace.cxx
+++ oce/src/IntTools/IntTools_EdgeFace.cxx
@@ -718,9 +718,8 @@ void IntTools_EdgeFace::AddDerivativePoi
       anArray1OfRange(n+i).SetLast (aFSeq(i));
     }
     
-    IntTools_QuickSortRange aQuickSortRange;
     IntTools_CompareRange aComparator;
-    aQuickSortRange.Sort (anArray1OfRange, aComparator);
+    IntTools_QuickSortRange::Sort (anArray1OfRange, aComparator);
     
     // filling the  output arrays
     myArgsArray.Resize(k);
Index: oce/src/Bnd/Bnd_BoundSortBox.cxx
===================================================================
--- oce.orig/src/Bnd/Bnd_BoundSortBox.cxx
+++ oce/src/Bnd/Bnd_BoundSortBox.cxx
@@ -636,11 +636,10 @@ const TColStd_ListOfInteger& Bnd_BoundSo
   //-- Rejection with the table of bits
   Standard_Boolean touch = Standard_True;
   touch = Standard_False;
-  Standard_Real _Xmin,_Ymin,_Zmin,_Xmax,_Ymax,_Zmax;
+  Standard_Real _Xmax,_Ymax,_Zmax;
   BSB_T3Bits* Map = (BSB_T3Bits *)TabBits;
   Standard_Real xmin, ymin, zmin, xmax, ymax, zmax;
   _Xmax=Map->Xmax; _Ymax=Map->Ymax; _Zmax=Map->Zmax;
-  _Xmin=Map->Xmin; _Ymin=Map->Ymin; _Zmin=Map->Zmin;
   theBox.Get(xmin, ymin, zmin, xmax, ymax, zmax);
   Standard_Integer i0,i1,j0,j1,k0,k1;
   if(xmin>Xmin) i0=(Standard_Integer )((xmin-Xmin)*deltaX)-1; else  i0=1;
