From: QbProg <tholag@gmail.com>
Date: Thu, 12 May 2011 20:58:37 +0200
Subject: [PATCH 68/82] [warning-fix][unused-local-var]

Fixes warnings like : unused local variable 'name' or  'name' initialized but never used
---
 inc/math_DoubleTab.gxx                     |    4 ++--
 src/OSD/OSD_signal_WNT.cxx                 |    2 +-
 src/math/math_BrentMinimum.cxx             |    2 +-
 src/math/math_KronrodSingleIntegration.cxx |    6 +++---
 4 files changed, 7 insertions(+), 7 deletions(-)

From: tpaviot <tpaviot@gmail.com>
Date: Fri, 20 May 2011 08:45:50 +0200
Subject: [PATCH 69/82] [warning-fix][unused-local-var]

Removed unused-local-var identified with XCode/gcc 4.2.1
Removed lines do not contain method calls (or call methods
which are known to have no side effect, like Abs), these
changes should thus be safe.

Fixes deal with all Toolkits as well as DRAW.
---
 drv/ShapeSchema/ShapeSchema_PCDM_Document.cxx      |    4 +---
 .../ShapeSchema_PGeom2d_BoundedCurve.cxx           |    4 +---
 drv/ShapeSchema/ShapeSchema_PGeom2d_Curve.cxx      |    2 --
 drv/ShapeSchema/ShapeSchema_PGeom2d_Geometry.cxx   |    4 +---
 drv/ShapeSchema/ShapeSchema_PGeom2d_Point.cxx      |    4 +---
 drv/ShapeSchema/ShapeSchema_PGeom_BoundedCurve.cxx |    2 --
 .../ShapeSchema_PGeom_BoundedSurface.cxx           |    4 +---
 drv/ShapeSchema/ShapeSchema_PGeom_Curve.cxx        |    4 +---
 drv/ShapeSchema/ShapeSchema_PGeom_Geometry.cxx     |    4 +---
 drv/ShapeSchema/ShapeSchema_PGeom_Point.cxx        |    4 +---
 drv/ShapeSchema/ShapeSchema_PGeom_Surface.cxx      |    4 +---
 drv/ShapeSchema/ShapeSchema_PMMgt_PManaged.cxx     |    4 +---
 .../ShapeSchema_Standard_Persistent.cxx            |    4 +---
 drv/StdLSchema/StdLSchema_PCDM_Document.cxx        |    4 +---
 drv/StdLSchema/StdLSchema_PDF_Attribute.cxx        |    4 +---
 drv/StdLSchema/StdLSchema_PDataStd_Directory.cxx   |    4 +---
 drv/StdLSchema/StdLSchema_PDataStd_NoteBook.cxx    |    4 +---
 drv/StdLSchema/StdLSchema_PDataStd_Tick.cxx        |    4 +---
 drv/StdLSchema/StdLSchema_Standard_Persistent.cxx  |    4 +---
 drv/StdSchema/StdSchema_PDF_Attribute.cxx          |    2 --
 drv/StdSchema/StdSchema_PDataXtd_Axis.cxx          |    4 +---
 drv/StdSchema/StdSchema_PDataXtd_Placement.cxx     |    4 +---
 drv/StdSchema/StdSchema_PDataXtd_Plane.cxx         |    4 +---
 drv/StdSchema/StdSchema_PDataXtd_Point.cxx         |    4 +---
 drv/StdSchema/StdSchema_PDataXtd_Shape.cxx         |    4 +---
 drv/StdSchema/StdSchema_Standard_Persistent.cxx    |    4 +---
 drv/XCAFSchema/XCAFSchema_PDF_Attribute.cxx        |    4 +---
 drv/XCAFSchema/XCAFSchema_PMMgt_PManaged.cxx       |    4 +---
 drv/XCAFSchema/XCAFSchema_PXCAFDoc_ColorTool.cxx   |    2 --
 drv/XCAFSchema/XCAFSchema_PXCAFDoc_DimTolTool.cxx  |    4 +---
 .../XCAFSchema_PXCAFDoc_DocumentTool.cxx           |    4 +---
 drv/XCAFSchema/XCAFSchema_PXCAFDoc_LayerTool.cxx   |    4 +---
 .../XCAFSchema_PXCAFDoc_MaterialTool.cxx           |    2 --
 drv/XCAFSchema/XCAFSchema_PXCAFDoc_ShapeTool.cxx   |    4 +---
 drv/XCAFSchema/XCAFSchema_Standard_Persistent.cxx  |    2 --
 inc/IntCurveSurface_Polygon.gxx                    |    1 -
 inc/IntStart_SearchOnBoundaries_1.gxx              |    1 -
 inc/IntWalk_IWalking_2.gxx                         |    1 -
 inc/IntWalk_PWalking_1.gxx                         |    1 -
 inc/Intf_InterferencePolygonPolyhedron.gxx         |    1 -
 src/BOPTools/BOPTools_Tools3D.cxx                  |    4 ++--
 src/BRepExtrema/BRepExtrema_DistanceSS.cxx         |    2 --
 src/BRepFill/BRepFill_OffsetWire.cxx               |    1 -
 src/BRepFill/BRepFill_PipeShell.cxx                |    1 -
 src/BRepMesh/BRepMesh_FastDiscretFace.cxx          |    6 ------
 src/BRepOffset/BRepOffset_Inter2d.cxx              |    2 --
 src/BRepTools/BRepTools_Quilt.cxx                  |    2 --
 src/BRepTopAdaptor/BRepTopAdaptor_FClass2d.cxx     |    2 +-
 .../BinMDataStd_ExtStringArrayDriver.cxx           |    1 -
 .../BinMDataStd_ExtStringListDriver.cxx            |    1 -
 src/DNaming/DNaming_ModelingCommands.cxx           |    3 ---
 src/DNaming/DNaming_ToolsCommands.cxx              |    1 -
 src/HLRTopoBRep/HLRTopoBRep_OutLiner.cxx           |    3 +--
 src/IntPatch/IntPatch_ImpPrmIntersection.cxx       |    2 +-
 .../IntPatch_PrmPrmIntersection_T3Bits.cxx         |    1 -
 src/MeshVS/MeshVS_TextPrsBuilder.cxx               |    1 -
 src/OpenGl/OpenGl_initelem.cxx                     |    2 +-
 src/OpenGl/OpenGl_lightstate.cxx                   |    1 -
 src/OpenGl/OpenGl_togl_begin_layer_mode.cxx        |    6 ------
 src/OpenGl/OpenGl_togl_markercontextgroup.cxx      |    2 +-
 src/OpenGl/OpenGl_txgl.cxx                         |    3 +--
 src/Select3D/Select3D_SensitiveTriangle.cxx        |    1 -
 src/SelectBasics/SelectBasics_BasicTool.cxx        |    1 -
 src/ShapeAnalysis/ShapeAnalysis.cxx                |    2 +-
 src/ShapeBuild/ShapeBuild_ReShape.cxx              |    2 +-
 .../ShapeUpgrade_RemoveInternalWires.cxx           |    1 -
 src/Viewer2dTest/Viewer2dTest_DisplayCommands.cxx  |    9 ---------
 src/ViewerTest/ViewerTest.cxx                      |    3 ---
 src/Visual3d/Visual3d_ViewManager.cxx              |    1 -
 src/Voxel/Voxel_FastConverter.cxx                  |    2 +-
 src/VrmlData/VrmlData_Scene.cxx                    |    3 +--
 src/XDEDRAW/XDEDRAW_Props.cxx                      |    1 -
 src/XSDRAWSTLVRML/XSDRAWSTLVRML.cxx                |    1 -
 src/XmlMDataStd/XmlMDataStd_BooleanArrayDriver.cxx |    2 +-
 src/XmlMDataStd/XmlMDataStd_NamedDataDriver.cxx    |    2 +-
 src/XmlMFunction/XmlMFunction_ScopeDriver.cxx      |    1 -
 76 files changed, 43 insertions(+), 169 deletions(-)

From: QbProg <tholag@gmail.com>
Date: Sat, 11 Jun 2011 14:32:57 +0200
Subject: [PATCH 70/82] [warning-fix][unused-local-var]

Removed unused-local-var identified with XCode/gcc 4.2.1.
Lines removed call methods which may have side effects, so this
commit must be double-checked.

Fixes deal with all Toolkits as well as DRAW.

(QbProg : included only commits without side effects )
---
 inc/Extrema_GenExtCC.gxx                           |    2 --
 inc/GProp_TFunction.gxx                            |    2 --
 inc/Intf_InterferencePolygonPolyhedron.gxx         |    3 +--
 inc/Prs3d_Datum.gxx                                |    1 -
 inc/Prs3d_WFRestrictedFace.gxx                     |    1 -
 src/BOPTools/BOPTools_PaveFiller_2.cxx             |    1 -
 src/BOPTools/BOPTools_Tools3D.cxx                  |    2 --
 src/BRepBuilderAPI/BRepBuilderAPI_Sewing.cxx       |    1 -
 src/BRepCheck/BRepCheck_Wire.cxx                   |    1 -
 src/BRepExtrema/BRepExtrema_DistanceSS.cxx         |    1 -
 src/BRepMesh/BRepMesh_FastDiscret.cxx              |    1 -
 src/BRepMesh/BRepMesh_FastDiscretFace.cxx          |    1 -
 src/BRepOffset/BRepOffset_Inter2d.cxx              |    2 --
 src/BlendFunc/BlendFunc_RuledInv.cxx               |    1 -
 src/BndLib/BndLib_AddSurface.cxx                   |    2 --
 src/DNaming/DNaming_BooleanOperationDriver.cxx     |    1 -
 src/DNaming/DNaming_ModelingCommands.cxx           |    2 --
 src/IntPolyh/IntPolyh_Intersection.cxx             |    2 --
 src/IntPolyh/IntPolyh_MaillageAffinage_1.cxx       |    8 --------
 src/OpenGl/OpenGl_FontMgr.cxx                      |    1 -
 src/OpenGl/OpenGl_togl_begin_layer_mode.cxx        |    1 -
 src/OpenGl/OpenGl_ws.cxx                           |    1 -
 .../RWHeaderSection_ReadWriteModule.cxx            |    2 +-
 src/Select3D/Select3D_SensitiveTriangulation.cxx   |    1 -
 src/TFunction/TFunction_Iterator.cxx               |    1 -
 src/TNaming/TNaming_Naming.cxx                     |    1 -
 src/V3d/V3d_View.cxx                               |    1 -
 .../XmlLDrivers_DocumentRetrievalDriver.cxx        |    2 --
 28 files changed, 2 insertions(+), 44 deletions(-)

From: QbProg <tholag@gmail.com>
Date: Sat, 11 Jun 2011 20:01:16 +0200
Subject: [PATCH 71/82] [warning-fix][unused-local-var]

Unused local var
---
 src/Draw/Draw_Window.cxx                     |    1 -
 src/ViewerTest/ViewerTest_ViewerCommands.cxx |    2 +-
 2 files changed, 1 insertions(+), 2 deletions(-)

From: QbProg <tholag@gmail.com>
Date: Fri, 17 Jun 2011 21:14:14 +0200
Subject: [PATCH 72/82] [warning-fix][unused-local-var]

in this case a static function was called through an useless local var
---
 src/Extrema/Extrema_ExtCS.cxx |    3 +--
 1 files changed, 1 insertions(+), 2 deletions(-)

From: QbProg <tholag@gmail.com>
Date: Sun, 19 Jun 2011 18:16:25 +0200
Subject: [PATCH 73/82] [warning-fix][unused-local-var] Fixes warnings like :
 unused local variable 'name' or 'name' initialized
 but never used

---
 src/BRepGProp/BRepGProp_Face.cxx         |    3 +--
 src/HLRTopoBRep/HLRTopoBRep_OutLiner.cxx |    2 +-
 src/OpenGl/OpenGl_TextRender.cxx         |    3 ++-
 src/OpenGl/OpenGl_togl_begin.cxx         |    2 +-
 src/OpenGl/OpenGl_togl_print.cxx         |    2 --
 src/WNT/WNT_Allocator.cxx                |    2 --
 src/WNT/WNT_FontMapEntry.cxx             |    1 -
 src/WNT/WNT_WDriver.cxx                  |    3 +--
 8 files changed, 6 insertions(+), 12 deletions(-)

From: tpaviot <tpaviot@gmail.com>
Date: Tue, 28 Jun 2011 10:45:39 +0200
Subject: [PATCH 74/82] [warning-fix][unused-local-var] Fix warnings: *
 oce/src/IntTools/IntTools_EdgeFace.cxx:860:0 Unused
 variable 'dt' *
 oce/src/IntTools/IntTools_EdgeFace.cxx:860:0 Unused
 variable 'df2'

---
 src/IntTools/IntTools_EdgeFace.cxx |    2 +-
 1 files changed, 1 insertions(+), 1 deletions(-)

From 51a80c93f482771d223638a2b5ca6f005203670d Mon Sep 17 00:00:00 2001
From: tpaviot <tpaviot@gmail.com>
Date: Tue, 19 Jul 2011 12:03:57 +0200
Subject: [PATCH 04/26] [warning-fix][unused-local-var]

The 'a' variable in OSD_MAllocHook.cxx was introduced only to
enable inserting a breakpoint -> compiled in DEBUG mode only.
---
 src/OSD/OSD_MAllocHook.cxx |    6 +++++-
 1 files changed, 5 insertions(+), 1 deletions(-)

From 0e1560c478bc26735ccba6634542d9d32aa0aa7f Mon Sep 17 00:00:00 2001
From: tpaviot <tpaviot@gmail.com>
Date: Tue, 19 Jul 2011 12:16:20 +0200
Subject: [PATCH 05/26] [warning-fix][unused-local-var]

Removed unused local vars, taking care to avoid side effects.
---
 src/BRepCheck/BRepCheck_Edge.cxx           |    2 +-
 src/BRepExtrema/BRepExtrema_DistanceSS.cxx |    3 ---
 src/OpenGl/OpenGl_togl_setplane.cxx        |    1 -
 3 files changed, 1 insertions(+), 5 deletions(-)

From 95e0d033d99562b61d61a8968cdc3fe7e51da090 Mon Sep 17 00:00:00 2001
From: Denis Barbier <bouzim@gmail.com>
Date: Wed, 20 Jul 2011 20:59:16 +0000
Subject: [PATCH 09/26] [warning-fix][unused-local-var]

---
 inc/AppParCurves_LeastSquare.gxx                   |    5 +---
 inc/Approx_ComputeLine.gxx                         |   23 +++++++++++++-------
 inc/GCPnts_UniformAbscissa.gxx                     |    2 -
 inc/Image_GImage.gxx                               |    6 +---
 inc/IntCurve_IntPolyPolyGen.gxx                    |   22 -------------------
 inc/IntImpParGen_Intersector.gxx                   |    8 -------
 inc/IntPatch_ImpImpIntersection_2.gxx              |    3 --
 inc/IntPatch_ImpImpIntersection_5.gxx              |    3 +-
 inc/IntWalk_PWalking_1.gxx                         |    6 +----
 inc/Intf_InterferencePolygonPolyhedron.gxx         |    4 ---
 inc/Intf_InterferencePolyhedron.gxx                |   14 +++++-------
 inc/Primitives_Wedge.gxx                           |    7 ------
 src/Adaptor3d/Adaptor3d_CurveOnSurface.cxx         |    4 +--
 src/AdvApp2Var/AdvApp2Var_ApproxAFunc2Var.cxx      |    3 +-
 src/AdvApp2Var/AdvApp2Var_ApproxF2var.cxx          |    3 +-
 src/AdvApp2Var/AdvApp2Var_MathBase.cxx             |    6 -----
 src/AlienImage/AlienImage_SunRFAlienData.cxx       |    4 +--
 src/AlienImage/AlienImage_X11XWDAlienData.cxx      |    4 +--
 src/AppParCurves/AppParCurves.cxx                  |    4 +-
 src/BOPTools/BOPTools_Checker.cxx                  |    4 +--
 src/BRepCheck/BRepCheck_Edge.cxx                   |    3 +-
 src/Bisector/Bisector_BisecAna.cxx                 |    7 +----
 src/Bnd/Bnd_BoundSortBox.cxx                       |    3 +-
 src/CSLib/CSLib_Class2d.cxx                        |    3 +-
 src/Dynamic/Dynamic_FuzzyDefinitionsDictionary.cxx |    5 +---
 .../Dynamic_MethodDefinitionsDictionary.cxx        |    5 +---
 src/GccAna/GccAna_Circ2d3Tan_2.cxx                 |    4 ---
 src/GccAna/GccAna_Circ2d3Tan_5.cxx                 |    4 ---
 src/GccAna/GccAna_Circ2d3Tan_6.cxx                 |    4 ---
 src/GccAna/GccAna_Lin2dTanPer.cxx                  |    4 ---
 src/Geom/Geom_BSplineSurface.cxx                   |    8 -------
 src/GeomConvert/GeomConvert_1.cxx                  |    2 -
 src/GeomFill/GeomFill_ConstrainedFilling.cxx       |    6 +++++
 src/GeomFill/GeomFill_Sweep.cxx                    |    3 +-
 src/GeomInt/GeomInt_IntSS_1.cxx                    |    3 +-
 src/IntAna/IntAna_IntQuadQuad.cxx                  |    6 +---
 src/IntAna/IntAna_QuadQuadGeo.cxx                  |    3 +-
 src/IntPatch/IntPatch_ALineToWLine.cxx             |    2 -
 src/IntPatch/IntPatch_ImpPrmIntersection.cxx       |   11 +-------
 src/IntPatch/IntPatch_Polyhedron.cxx               |    3 --
 src/IntPatch/IntPatch_PrmPrmIntersection.cxx       |    4 +-
 src/LDOM/LDOMParser.cxx                            |    2 -
 src/MAT2d/MAT2d_Tool2d.cxx                         |    3 +-
 src/PlotMgt/PlotMgt_PlotterParameter.cxx           |    2 -
 src/TDF/TDF_CopyLabel.cxx                          |    3 --
 src/TDF/TDF_Delta.cxx                              |    6 ++--
 src/Units/Units_Sentence.cxx                       |    2 +
 src/Xw/Xw_Driver.cxx                               |    2 -
 src/Xw/Xw_draw_polytext.cxx                        |    3 +-
 src/Xw/Xw_draw_text.cxx                            |    3 +-
 src/Xw/Xw_draw_zoomed_image.cxx                    |    2 -
 src/Xw/Xw_get_window_pixelcoord.cxx                |    2 -
 src/Xw/Xw_set_line_attrib.cxx                      |    6 ++--
 src/Xw/Xw_set_poly_attrib.cxx                      |    6 ++--
 src/Xw/Xw_set_text_attrib.cxx                      |    6 ++--
 src/Xw/Xw_zoom_image.cxx                           |    2 -
 src/math/math_Recipes.cxx                          |    2 -
 src/math/math_TrigonometricFunctionRoots.cxx       |    3 +-
 58 files changed, 74 insertions(+), 209 deletions(-)

From 86eb65d693600d458b3901fb373cbc70eead4f31 Mon Sep 17 00:00:00 2001
From: Denis Barbier <bouzim@gmail.com>
Date: Wed, 20 Jul 2011 23:09:06 +0000
Subject: [PATCH 17/26] [warning-fix][unused-local-var]

To be merged with 95e0d03.
---
 src/Units/Units_Sentence.cxx |    5 +++--
 1 files changed, 3 insertions(+), 2 deletions(-)

From c83287840c2f60cd97bbe0558dd22dda481edbab Mon Sep 17 00:00:00 2001
From: Denis Barbier <bouzim@gmail.com>
Date: Wed, 20 Jul 2011 23:51:53 +0000
Subject: [PATCH 18/26] [warning-fix][unused-local-var]

---
 inc/Graphic3d_ArrayOfPrimitives.lxx |    6 +-----
 1 files changed, 1 insertions(+), 5 deletions(-)

From ab8fb6025b8ca61b83f0600d967f89d6f559bbf5 Mon Sep 17 00:00:00 2001
From: QbProg <tholag@gmail.com>
Date: Sun, 24 Jul 2011 18:15:41 +0200
Subject: [PATCH 07/11] [warning-fix][unused-local-var] Fixes warnings like :
 unused local variable 'name' or 'name' initialized
 but never used

---
 src/BOPTools/BOPTools_PaveSet.cxx         |    3 +--
 src/BRepMesh/BRepMesh_FastDiscretFace.cxx |    2 --
 src/Extrema/Extrema_GenExtPS.cxx          |    4 ++--
 src/GeomFill/GeomFill_Sweep.cxx           |    1 -
 src/IntTools/IntTools.cxx                 |    3 +--
 src/IntTools/IntTools_EdgeFace.cxx        |    3 +--
 src/TDF/TDF_Delta.cxx                     |    4 ++--
 7 files changed, 7 insertions(+), 13 deletions(-)

From 80addda91a582908af3926cb969d0af4cd394a4e Mon Sep 17 00:00:00 2001
From: tpaviot <tpaviot@gmail.com>
Date: Sat, 19 Nov 2011 14:19:55 +0100
Subject: [PATCH] Fix missing MilTol2 in debug mode

---
 src/BRepOffset/BRepOffset_Inter2d.cxx |    6 ++++++
 1 files changed, 6 insertions(+), 0 deletions(-)

From e716bed354e9b136c2e858206ff83b96cdd5fce4 Mon Sep 17 00:00:00 2001
From: Denis Barbier <bouzim@gmail.com>
Date: Sun, 18 Dec 2011 00:31:58 +0100
Subject: [PATCH] [warning-fix][unused-local-var]

---
 inc/AppParCurves_LeastSquare.gxx                   |    8 +-
 inc/AppParCurves_ResolConstraint.gxx               |   90 ++++++++++----------
 inc/Blend_CSWalking_2.gxx                          |    3 +-
 inc/Blend_Walking_1.gxx                            |    4 +-
 inc/GCPnts_TangentialDeflection.gxx                |    3 -
 inc/GProp_SGProps.gxx                              |    4 +-
 inc/GccGeo_Circ2d2TanOn.gxx                        |    5 -
 inc/GccIter_Circ2d2TanOn.gxx                       |   36 ++-------
 inc/IntCurve_Polygon2dGen.gxx                      |   12 +--
 inc/IntPatch_ImpImpIntersection_4.gxx              |    3 +-
 inc/IntPatch_ImpImpIntersection_5.gxx              |   12 +--
 inc/IntStart_SearchOnBoundaries_1.gxx              |    3 +-
 inc/TopOpeBRepBuild_SplitEdge.hxx                  |   21 +----
 inc/Transfer_TransferProcess.gxx                   |    3 +-
 src/AIS/AIS_AngleDimension.cxx                     |   10 --
 src/AIS/AIS_DiameterDimension.cxx                  |    2 -
 src/AIS/AIS_EqualDistanceRelation.cxx              |    3 -
 src/AIS/AIS_InteractiveContext.cxx                 |    4 +-
 src/AIS/AIS_LocalContext.cxx                       |    2 -
 src/AIS2D/AIS2D_InteractiveContext.cxx             |    7 +--
 src/AdvApp2Var/AdvApp2Var_Patch.cxx                |    8 +--
 src/AdvApp2Var/AdvApp2Var_SysBase.cxx              |   51 +-----------
 src/Aspect/Aspect_ColorScale.cxx                   |    2 -
 src/BOP/BOP_FaceBuilder.cxx                        |    7 +-
 src/BOP/BOP_SDFWESFiller.cxx                       |    6 +-
 src/BOP/BOP_ShellShell.cxx                         |    5 +-
 src/BOP/BOP_ShellSolid.cxx                         |    5 +-
 src/BOP/BOP_ShellSolid_1.cxx                       |    8 +--
 src/BOP/BOP_ShellSolid_2.cxx                       |    4 +-
 src/BOP/BOP_ShellSplitter.cxx                      |   13 +---
 src/BOP/BOP_SolidSolid_1.cxx                       |    2 -
 src/BOP/BOP_WireShape.cxx                          |    3 +-
 src/BOPTest/BOPTest_BOPCommands.cxx                |   10 +--
 src/BOPTest/BOPTest_TolerCommands.cxx              |    6 +-
 src/BOPTools/BOPTools_Checker.cxx                  |    3 +-
 src/BOPTools/BOPTools_DEProcessor.cxx              |    3 +-
 src/BOPTools/BOPTools_PaveFiller_1.cxx             |    4 +-
 src/BOPTools/BOPTools_PaveFiller_3.cxx             |   10 +--
 src/BOPTools/BOPTools_SolidStateFiller.cxx         |    4 +-
 src/BRepAdaptor/BRepAdaptor_CompCurve.cxx          |    3 +-
 src/BRepAlgo/BRepAlgo_TopOpe.cxx                   |    4 +-
 src/BRepBlend/BRepBlend_CurvPointRadInv.cxx        |    9 +--
 src/BRepBlend/BRepBlend_RstRstConstRad.cxx         |   17 +---
 src/BRepBlend/BRepBlend_RstRstEvolRad.cxx          |   17 +---
 src/BRepBlend/BRepBlend_RstRstLineBuilder.cxx      |    6 +-
 src/BRepBlend/BRepBlend_SurfPointEvolRadInv.cxx    |    3 +-
 src/BRepCheck/BRepCheck_Wire.cxx                   |   10 +--
 src/BRepFeat/BRepFeat_Form.cxx                     |    2 -
 src/BRepFeat/BRepFeat_MakeLinearForm.cxx           |    4 +-
 src/BRepFeat/BRepFeat_RibSlot.cxx                  |    6 --
 src/BRepFill/BRepFill_CompatibleWires.cxx          |    5 +-
 src/BRepFill/BRepFill_Sweep.cxx                    |    4 -
 src/BRepFill/BRepFill_TrimShellCorner.cxx          |    6 --
 src/BRepFill/BRepFill_TrimSurfaceTool.cxx          |    3 -
 src/BRepGProp/BRepGProp.cxx                        |    5 +-
 src/BRepSweep/BRepSweep_Rotation.cxx               |    5 -
 src/BRepTest/BRepTest_BasicCommands.cxx            |    3 -
 src/BRepTest/BRepTest_CurveCommands.cxx            |    2 -
 src/BRepTopAdaptor/BRepTopAdaptor_FClass2d.cxx     |    3 -
 src/BiTgte/BiTgte_Blend.cxx                        |   13 ---
 src/Bisector/Bisector_BisecAna.cxx                 |    4 +-
 src/Bisector/Bisector_BisecPC.cxx                  |    4 +-
 src/Bisector/Bisector_Inter.cxx                    |    5 -
 src/BlendFunc/BlendFunc_ConstRad.cxx               |    6 +-
 src/BlendFunc/BlendFunc_EvolRad.cxx                |    6 +-
 src/ChFi2d/ChFi2d_Builder.cxx                      |    7 +-
 src/ChFi3d/ChFi3d_Builder_2.cxx                    |    4 +-
 src/ChFi3d/ChFi3d_Builder_C1.cxx                   |    3 +-
 src/ChFi3d/ChFi3d_Builder_C2.cxx                   |    3 -
 src/ChFi3d/ChFi3d_FilBuilder.cxx                   |    6 +-
 src/ChFiDS/ChFiDS_FilSpine.cxx                     |    3 -
 src/ChFiKPart/ChFiKPart_ComputeData_FilPlnCyl.cxx  |    3 +-
 src/DDataStd/DDataStd_Sample.cxx                   |   13 +---
 src/DPrsStd/DPrsStd_Sample.cxx                     |    4 -
 src/Draw/Draw_Window.cxx                           |    7 --
 src/DrawDim/DrawDim_Angle.cxx                      |    5 +-
 src/DrawTrSurf/DrawTrSurf.cxx                      |    2 -
 src/DsgPrs/DsgPrs_AnglePresentation.cxx            |   20 +----
 src/DsgPrs/DsgPrs_DiameterPresentation.cxx         |    2 -
 src/ExprIntrp/ExprIntrp_yaccintrf.cxx              |   39 ++-------
 src/Extrema/Extrema_ExtElC2d.cxx                   |    9 --
 src/Extrema/Extrema_ExtElCS.cxx                    |    4 -
 src/GccAna/GccAna_Circ2d3Tan_6.cxx                 |    7 +-
 src/GccAna/GccAna_Circ2d3Tan_8.cxx                 |    4 -
 src/GccAna/GccAna_Circ2dTanOnRad.cxx               |    2 -
 src/Geom2dConvert/Geom2dConvert.cxx                |    6 +-
 src/GeomConvert/GeomConvert.cxx                    |    6 +-
 src/GeomFill/GeomFill_EvolvedSection.cxx           |    3 +-
 src/GeomFill/GeomFill_GuideTrihedronAC.cxx         |    4 -
 src/GeomFill/GeomFill_LocationGuide.cxx            |    3 +-
 src/GeomFill/GeomFill_Pipe.cxx                     |    4 -
 src/GeomFill/GeomFill_TgtOnCoons.cxx               |    4 -
 src/GeomFill/GeomFill_UniformSection.cxx           |    3 +-
 src/GeometryTest/GeometryTest_APICommands.cxx      |    7 --
 src/GeometryTest/GeometryTest_CurveCommands.cxx    |    8 +--
 .../GeometryTest_FairCurveCommands.cxx             |    6 +-
 src/GeomliteTest/GeomliteTest_SurfaceCommands.cxx  |   14 ---
 src/Graphic2d/Graphic2d_Image.cxx                  |   10 +--
 src/Graphic3d/Graphic3d_GraphicDevice.cxx          |    4 +-
 src/HLRBRep/HLRBRep_Hider.cxx                      |    2 -
 src/HLRBRep/HLRBRep_PolyAlgo.cxx                   |    5 +-
 src/HLRTest/HLRTest.cxx                            |    2 -
 src/IFGraph/IFGraph_Articulations.cxx              |    2 +-
 src/IFSelect/IFSelect_BasicDumper.cxx              |    5 +-
 src/IFSelect/IFSelect_ListEditor.cxx               |    2 -
 src/IFSelect/IFSelect_WorkSession.cxx              |    2 -
 src/IGESConvGeom/IGESConvGeom.cxx                  |    3 +-
 src/Image/Image_BilinearPixelInterpolation.cxx     |    3 +-
 src/IntAna/IntAna_Quadric.cxx                      |    6 --
 src/IntPatch/IntPatch_ALineToWLine.cxx             |    7 +--
 src/IntPatch/IntPatch_RLine.cxx                    |    3 -
 src/IntPatch/IntPatch_RstInt.cxx                   |    7 +-
 src/IntPatch/IntPatch_WLine.cxx                    |    3 -
 src/IntTools/IntTools.cxx                          |    4 +-
 src/IntTools/IntTools_Context.cxx                  |    7 +-
 src/IntTools/IntTools_EdgeEdge.cxx                 |   23 ++----
 src/IntTools/IntTools_EdgeFace.cxx                 |   22 ++----
 src/IntTools/IntTools_FaceFace.cxx                 |    4 +-
 src/LocOpe/LocOpe.cxx                              |    2 -
 src/LocOpe/LocOpe_BuildWires.cxx                   |    3 -
 src/LocOpe/LocOpe_Builder.cxx                      |    4 +-
 src/LocOpe/LocOpe_Generator.cxx                    |   10 +--
 src/LocOpe/LocOpe_SplitDrafts.cxx                  |    3 +-
 src/MAT2d/MAT2d_Circuit.cxx                        |    7 +-
 src/MAT2d/MAT2d_Tool2d.cxx                         |    2 -
 src/MFT/MFT_FontManager.cxx                        |    6 +-
 src/Materials/Materials_MaterialDefinition.cxx     |    4 +-
 src/MeshTest/MeshTest.cxx                          |    4 -
 src/MeshVS/MeshVS_ElementalColorPrsBuilder.cxx     |    5 -
 src/NCollection/NCollection_BaseAllocator.cxx      |    3 -
 src/NIS/NIS_View.cxx                               |    1 -
 src/OSD/OSD.cxx                                    |    3 +-
 src/OpenGl/OpenGl_GraphicDriver_703.cxx            |   12 ++--
 src/OpenGl/OpenGl_curve.cxx                        |    6 --
 src/OpenGl/OpenGl_execstruct.cxx                   |    2 -
 src/OpenGl/OpenGl_indexpolygons.cxx                |    6 +-
 src/OpenGl/OpenGl_polygon.cxx                      |    8 +-
 src/OpenGl/OpenGl_polygonholes.cxx                 |   12 +--
 src/OpenGl/OpenGl_qstrip.cxx                       |   10 +--
 src/OpenGl/OpenGl_text.cxx                         |   21 ++---
 src/OpenGl/OpenGl_tmesh.cxx                        |    3 +-
 src/OpenGl/OpenGl_togl_set_environment.cxx         |    4 +-
 src/OpenGl/OpenGl_togl_triedron.cxx                |    3 +-
 src/OpenGl/OpenGl_triedron.cxx                     |    5 +-
 src/PS/PS_Driver.cxx                               |    2 -
 .../ProjLib_ComputeApproxOnPolarSurface.cxx        |    4 +-
 src/ProjLib/ProjLib_Cone.cxx                       |    4 +-
 src/Prs2d/Prs2d_Diameter.cxx                       |    2 -
 src/Prs2d/Prs2d_Radius.cxx                         |    2 -
 .../RWHeaderSection_RWFileDescription.cxx          |    3 +-
 src/RWHeaderSection/RWHeaderSection_RWFileName.cxx |   15 +--
 .../RWStepAP214_RWAppliedDocumentReference.cxx     |    3 +-
 .../RWStepAP214_RWAutoDesignDocumentReference.cxx  |    3 +-
 src/RWStepDimTol/RWStepDimTol_RWCommonDatum.cxx    |    4 -
 .../RWStepRepr_RWCompositeShapeAspect.cxx          |    4 -
 src/RWStepRepr/RWStepRepr_RWDerivedShapeAspect.cxx |    4 -
 src/RWStepRepr/RWStepRepr_RWExtension.cxx          |    4 -
 src/Select3D/Select3D_SensitiveCircle.cxx          |    3 -
 src/Select3D/Select3D_SensitiveCurve.cxx           |    3 -
 src/Select3D/Select3D_SensitiveFace.cxx            |    3 -
 src/Select3D/Select3D_SensitivePoint.cxx           |    3 -
 src/Select3D/Select3D_SensitiveSegment.cxx         |    3 -
 src/Select3D/Select3D_SensitiveTriangle.cxx        |    3 -
 src/Select3D/Select3D_SensitiveTriangulation.cxx   |    3 -
 src/ShapeAnalysis/ShapeAnalysis_FreeBounds.cxx     |    5 +-
 src/ShapeUpgrade/ShapeUpgrade_WireDivide.cxx       |    2 -
 src/StlTransfer/StlTransfer.cxx                    |    5 +-
 src/TNaming/TNaming.cxx                            |    5 +-
 src/TPrsStd/TPrsStd_ConstraintTools.cxx            |    3 -
 src/TestTopOpe/TestTopOpe_CORCommands.cxx          |   14 +---
 src/TestTopOpe/TestTopOpe_DSACommands.cxx          |    3 +-
 src/TestTopOpe/TestTopOpe_HDSCommands.cxx          |   10 +--
 src/TestTopOpe/TestTopOpe_OtherCommands.cxx        |    5 +-
 src/TopOpeBRep/TopOpeBRep_EdgesFiller.cxx          |    2 -
 src/TopOpeBRep/TopOpeBRep_FaceEdgeFiller.cxx       |    3 -
 src/TopOpeBRep/TopOpeBRep_FaceEdgeIntersector.cxx  |    5 +-
 src/TopOpeBRep/TopOpeBRep_FacesFiller_1.cxx        |    7 +-
 src/TopOpeBRep/TopOpeBRep_FacesIntersector.cxx     |    3 +-
 src/TopOpeBRep/TopOpeBRep_kpart.cxx                |    4 -
 src/TopOpeBRep/TopOpeBRep_vpr.cxx                  |    9 --
 src/TopOpeBRep/TopOpeBRep_vprclo.cxx               |    4 +-
 src/TopOpeBRep/TopOpeBRep_vprdeg.cxx               |    3 +-
 src/TopOpeBRepBuild/TopOpeBRepBuild_BuildEdges.cxx |    2 -
 src/TopOpeBRepBuild/TopOpeBRepBuild_Builder1.cxx   |    6 --
 src/TopOpeBRepBuild/TopOpeBRepBuild_BuilderON.cxx  |    4 +-
 .../TopOpeBRepBuild_CorrectFace2d.cxx              |    6 +-
 src/TopOpeBRepBuild/TopOpeBRepBuild_FREGU.cxx      |    4 -
 src/TopOpeBRepBuild/TopOpeBRepBuild_FuseFace.cxx   |    3 +-
 src/TopOpeBRepBuild/TopOpeBRepBuild_Grid.cxx       |    8 --
 src/TopOpeBRepBuild/TopOpeBRepBuild_GridEE.cxx     |   14 ++--
 src/TopOpeBRepBuild/TopOpeBRepBuild_GridFF.cxx     |    4 +-
 src/TopOpeBRepBuild/TopOpeBRepBuild_GridSS.cxx     |    8 --
 src/TopOpeBRepBuild/TopOpeBRepBuild_KPart.cxx      |    4 -
 src/TopOpeBRepBuild/TopOpeBRepBuild_PaveSet.cxx    |    4 +-
 src/TopOpeBRepBuild/TopOpeBRepBuild_SREGU.cxx      |    3 -
 src/TopOpeBRepBuild/TopOpeBRepBuild_Tools.cxx      |    4 +-
 src/TopOpeBRepBuild/TopOpeBRepBuild_Tools2d.cxx    |    4 +-
 src/TopOpeBRepBuild/TopOpeBRepBuild_VertexInfo.cxx |    3 +-
 .../TopOpeBRepBuild_WireEdgeSet.cxx                |    6 --
 src/TopOpeBRepBuild/TopOpeBRepBuild_ffsfs.cxx      |    4 +-
 src/TopOpeBRepBuild/TopOpeBRepBuild_kpkole.cxx     |    2 -
 src/TopOpeBRepDS/TopOpeBRepDS_EIR.cxx              |   10 +--
 src/TopOpeBRepDS/TopOpeBRepDS_EXPORT.cxx           |   11 +--
 .../TopOpeBRepDS_ProcessEdgeInterferences.cxx      |    5 +-
 .../TopOpeBRepDS_ProcessFaceInterferences.cxx      |    2 -
 src/TopOpeBRepTool/TopOpeBRepTool_REGUS.cxx        |    3 -
 src/TopOpeBRepTool/TopOpeBRepTool_ShapeTool.cxx    |    3 -
 src/Transfer/Transfer_TransferInput.cxx            |    2 -
 src/Units/Units_Lexicon.cxx                        |    8 +-
 src/V3d/V3d_PerspectiveView.cxx                    |    4 +-
 src/ViewerTest/ViewerTest_ObjectCommands.cxx       |    4 -
 src/ViewerTest/ViewerTest_RelationCommands.cxx     |    6 --
 src/Visual3d/Visual3d_View.cxx                     |    5 -
 src/Visual3d/Visual3d_ViewManager.cxx              |   18 +---
 src/Xw/Xw_GraphicDevice.cxx                        |   13 ++--
 src/Xw/Xw_Window.cxx                               |    6 +-
 src/Xw/Xw_alloc_pixel.cxx                          |    6 +-
 src/Xw/Xw_def_colormap.cxx                         |    3 +-
 src/Xw/Xw_load_icons.cxx                           |   15 ++--
 src/Xw/Xw_put_rgbpixel.cxx                         |    5 +-
 src/Xw/Xw_resize_window.cxx                        |    3 +-
 src/Xw/Xw_set_soft_cursor.cxx                      |   17 ++--
 src/math/math_BracketedRoot.cxx                    |    7 +-
 src/math/math_FunctionAllRoots.cxx                 |   10 +-
 src/math/math_FunctionRoot.cxx                     |    6 +-
 src/math/math_Powell.cxx                           |    7 +-
 226 files changed, 345 insertions(+), 1128 deletions(-)

From 8da6ce067188c07412eaa9f746f721361af0c48f Mon Sep 17 00:00:00 2001
From: Denis Barbier <bouzim@gmail.com>
Date: Thu, 22 Dec 2011 15:26:22 +0100
Subject: [PATCH] [warning-fix][unused-local-var]

---
 inc/ApproxInt_ImpPrmSvSurfaces.gxx                 |    4 -
 inc/ApproxInt_PrmPrmSvSurfaces.gxx                 |    8 --
 inc/Approx_ComputeLine.gxx                         |    1 -
 inc/Extrema_GLocateExtCC.gxx                       |    7 --
 inc/Extrema_GLocateExtCC2d.gxx                     |    7 --
 inc/Extrema_GLocateExtPC.gxx                       |    5 -
 inc/GCPnts_UniformAbscissa.gxx                     |    5 +-
 inc/GccGeo_Circ2dTanOnRad.gxx                      |   12 ---
 inc/GccIter_Circ2d2TanOn.gxx                       |   72 ------------------
 inc/GccIter_Circ2d3Tan.gxx                         |   50 ------------
 inc/GccIter_FunctionTanCirCu.gxx                   |    5 -
 inc/GccIter_FunctionTanCuCuOnCu.gxx                |   15 ----
 inc/GccIter_Lin2d2Tan.gxx                          |    3 -
 inc/HatchGen_Hatcher.gxx                           |    4 -
 inc/IntCurveSurface_Inter.gxx                      |   15 ----
 inc/IntCurveSurface_Polyhedron.gxx                 |    4 -
 inc/IntPatch_ImpImpIntersection_0.gxx              |    3 -
 inc/IntPatch_ImpImpIntersection_5.gxx              |   12 ---
 inc/IntWalk_IWalking_1.gxx                         |    3 -
 inc/IntWalk_IWalking_2.gxx                         |   20 +----
 inc/IntWalk_IWalking_3.gxx                         |    5 +-
 inc/IntWalk_IWalking_6.gxx                         |    3 -
 inc/Intf_InterferencePolygonPolyhedron.gxx         |    3 -
 inc/TopOpeBRepBuild_SplitEdge.hxx                  |    7 --
 src/AIS/AIS_EqualDistanceRelation.cxx              |    2 -
 src/AIS/AIS_InteractiveContext.cxx                 |    5 +-
 src/AIS2D/AIS2D_InteractiveContext.cxx             |   22 +-----
 src/AIS2D/AIS2D_LocalContext.cxx                   |    7 --
 src/AdvApp2Var/AdvApp2Var_SysBase.cxx              |    2 +-
 src/AlienImage/AlienImage_X11XWDAlienData.cxx      |    4 -
 src/BRep/BRep_Builder.cxx                          |   12 ---
 src/BRepAlgo/BRepAlgo_Loop.cxx                     |    8 +--
 src/BRepBlend/BRepBlend_RstRstConstRad.cxx         |    3 -
 src/BRepBlend/BRepBlend_RstRstEvolRad.cxx          |    3 -
 src/BRepBlend/BRepBlend_SurfCurvConstRadInv.cxx    |    3 -
 src/BRepBlend/BRepBlend_SurfCurvEvolRadInv.cxx     |    3 -
 src/BRepBlend/BRepBlend_SurfRstConstRad.cxx        |    3 -
 src/BRepBlend/BRepBlend_SurfRstEvolRad.cxx         |    3 -
 src/BRepBlend/BRepBlend_SurfRstLineBuilder.cxx     |    3 -
 src/BRepBuilderAPI/BRepBuilderAPI_Collect.cxx      |    6 +-
 src/BRepCheck/BRepCheck_Face.cxx                   |    4 -
 src/BRepCheck/BRepCheck_Shell.cxx                  |    1 -
 src/BRepClass3d/BRepClass3d_SolidExplorer.cxx      |    4 -
 src/BRepFeat/BRepFeat.cxx                          |    4 -
 src/BRepFeat/BRepFeat_MakeLinearForm.cxx           |   14 ----
 src/BRepFeat/BRepFeat_MakeRevolutionForm.cxx       |   16 ----
 src/BRepFill/BRepFill_CompatibleWires.cxx          |    9 --
 src/BRepFill/BRepFill_Draft.cxx                    |    3 -
 src/BRepFill/BRepFill_Evolved.cxx                  |   20 +----
 src/BRepFill/BRepFill_MultiLine.cxx                |    2 +-
 src/BRepFill/BRepFill_OffsetWire.cxx               |   11 +--
 src/BRepFill/BRepFill_TrimShellCorner.cxx          |    1 -
 src/BRepOffset/BRepOffset_Inter2d.cxx              |    5 +-
 src/BRepOffset/BRepOffset_MakeLoops.cxx            |    2 +-
 src/BRepOffset/BRepOffset_MakeOffset.cxx           |    8 +--
 src/BRepOffset/BRepOffset_Offset.cxx               |    2 +-
 src/BRepOffset/BRepOffset_Tool.cxx                 |   10 +--
 src/BRepTest/BRepTest_FillingCommands.cxx          |   10 +--
 src/BRepTest/BRepTest_SurfaceCommands.cxx          |   14 +---
 src/BRepTools/BRepTools_Quilt.cxx                  |    5 -
 src/Bisector/Bisector_Inter.cxx                    |    3 +-
 src/BlendFunc/BlendFunc_CSConstRad.cxx             |    3 -
 src/BlendFunc/BlendFunc_Chamfer.cxx                |    3 -
 src/ChFi2d/ChFi2d_Builder.cxx                      |    5 +-
 src/DBRep/DBRep_IsoBuilder.cxx                     |   15 +---
 src/DDataStd/DDataStd_DrawDriver.cxx               |    6 --
 src/DDocStd/DDocStd.cxx                            |    6 --
 src/Draw/Draw_VariableCommands.cxx                 |    3 +-
 src/Draw/Draw_Viewer.cxx                           |    3 -
 src/Draw/Draw_Window.cxx                           |    4 +-
 src/DrawDim/DrawDim_Angle.cxx                      |    4 -
 src/DrawDim/DrawDim_PlanarAngle.cxx                |    8 --
 src/DrawFairCurve/DrawFairCurve_Batten.cxx         |    5 +-
 src/DsgPrs/DsgPrs.cxx                              |    8 --
 src/DsgPrs/DsgPrs_ShapeDirPresentation.cxx         |    4 -
 src/DsgPrs/DsgPrs_SymmetricPresentation.cxx        |    8 --
 src/DsgPrs/DsgPrs_XYZAxisPresentation.cxx          |    5 -
 src/Extrema/Extrema_ExtElC.cxx                     |    1 -
 src/Extrema/Extrema_ExtPElC.cxx                    |   10 ---
 src/Extrema/Extrema_ExtPElC2d.cxx                  |   15 ----
 src/Extrema/Extrema_ExtPElS.cxx                    |    5 -
 src/FEmTool/FEmTool_Assembly.cxx                   |    8 --
 src/GccAna/GccAna_Circ2d2TanOn.cxx                 |    5 -
 src/GccAna/GccAna_Circ2d2TanOn_10.cxx              |    6 --
 src/GccAna/GccAna_Circ2d2TanOn_6.cxx               |    5 -
 src/GccAna/GccAna_Circ2d2TanOn_9.cxx               |    3 -
 src/GccAna/GccAna_Circ2d2TanRad_4.cxx              |    3 -
 src/GccAna/GccAna_Circ2d3Tan_3.cxx                 |    3 -
 src/GccAna/GccAna_Circ2d3Tan_8.cxx                 |    5 -
 src/GccAna/GccAna_Circ2dTanOnRad_1.cxx             |    5 -
 src/Geom/Geom_CylindricalSurface.cxx               |   11 ---
 src/Geom/Geom_OffsetCurve.cxx                      |   12 ---
 src/Geom2d/Geom2d_OffsetCurve.cxx                  |   23 ------
 src/GeomFill/GeomFill_CorrectedFrenet.cxx          |    4 -
 src/GeomFill/GeomFill_Curved.cxx                   |    4 -
 src/GeomFill/GeomFill_DraftTrihedron.cxx           |    5 -
 src/GeomFill/GeomFill_GuideTrihedronAC.cxx         |    5 -
 src/GeomFill/GeomFill_LocationGuide.cxx            |   12 ---
 src/GeomFill/GeomFill_PolynomialConvertor.cxx      |    5 -
 src/GeomFill/GeomFill_QuasiAngularConvertor.cxx    |    5 -
 src/GeomFill/GeomFill_SweepSectionGenerator.cxx    |    8 +--
 src/GeomPlate/GeomPlate_BuildPlateSurface.cxx      |    7 +-
 src/GeomPlate/GeomPlate_PlateG0Criterion.cxx       |    4 -
 src/GeomPlate/GeomPlate_PlateG1Criterion.cxx       |    5 -
 src/GeomProjLib/GeomProjLib.cxx                    |    9 +--
 src/GeomToIGES/GeomToIGES_GeomSurface.cxx          |    6 --
 .../GeometryTest_ConstraintCommands.cxx            |    4 -
 src/GeometryTest/GeometryTest_SurfaceCommands.cxx  |    6 --
 src/GeomliteTest/GeomliteTest_ApproxCommands.cxx   |    5 -
 src/Graphic2d/Graphic2d_Paragraph.cxx              |    8 --
 src/Graphic3d/Graphic3d_ArrayOfPrimitives.cxx      |    2 +-
 src/HLRBRep/HLRBRep_Data.cxx                       |    9 +--
 src/HLRBRep/HLRBRep_PolyAlgo.cxx                   |    1 -
 src/HLRBRep/HLRBRep_ShapeToHLR.cxx                 |    4 -
 src/IFGraph/IFGraph_Articulations.cxx              |    1 -
 src/IFSelect/IFSelect_WorkSession.cxx              |    5 +-
 src/IntPatch/IntPatch_ALine.cxx                    |   11 +--
 src/IntPatch/IntPatch_LineConstructor.cxx          |    4 -
 src/IntPatch/IntPatch_Polyhedron.cxx               |    7 --
 src/IntRes2d/IntRes2d_Intersection.cxx             |   36 ++--------
 src/IntTools/IntTools.cxx                          |    2 +-
 src/Law/Law_Interpol.cxx                           |    8 --
 src/LocOpe/LocOpe_CSIntersector.cxx                |   12 ---
 src/LocOpe/LocOpe_Generator.cxx                    |    5 +-
 src/LocOpe/LocOpe_SplitDrafts.cxx                  |    8 --
 src/LocOpe/LocOpe_SplitShape.cxx                   |    4 -
 src/MAT2d/MAT2d_Tool2d.cxx                         |    3 -
 src/MXCAFDoc/MXCAFDoc_AreaRetrievalDriver.cxx      |    4 -
 src/MXCAFDoc/MXCAFDoc_AreaStorageDriver.cxx        |    4 -
 src/MXCAFDoc/MXCAFDoc_CentroidRetrievalDriver.cxx  |    4 -
 src/MXCAFDoc/MXCAFDoc_CentroidStorageDriver.cxx    |    4 -
 src/MXCAFDoc/MXCAFDoc_DatumRetrievalDriver.cxx     |    4 -
 src/MXCAFDoc/MXCAFDoc_DatumStorageDriver.cxx       |    4 -
 src/MXCAFDoc/MXCAFDoc_DimTolRetrievalDriver.cxx    |    4 -
 src/MXCAFDoc/MXCAFDoc_DimTolStorageDriver.cxx      |    4 -
 src/MXCAFDoc/MXCAFDoc_MaterialRetrievalDriver.cxx  |    4 -
 src/MXCAFDoc/MXCAFDoc_MaterialStorageDriver.cxx    |    4 -
 src/MXCAFDoc/MXCAFDoc_VolumeRetrievalDriver.cxx    |    4 -
 src/MXCAFDoc/MXCAFDoc_VolumeStorageDriver.cxx      |    4 -
 src/NCollection/NCollection_IncAllocator.cxx       |    1 -
 src/OpenGl/OpenGl_curve.cxx                        |    1 -
 src/OpenGl/OpenGl_indexpolygons.cxx                |    6 +-
 src/OpenGl/OpenGl_triedron.cxx                     |    5 -
 src/OpenGl/OpenGl_txgl.cxx                         |    2 -
 src/ProjLib/ProjLib_PrjResolve.cxx                 |    3 -
 src/Prs2d/Prs2d_Angle.cxx                          |    3 -
 .../RWStepAP214_RWAppliedApprovalAssignment.cxx    |    5 +-
 .../RWStepAP214_RWAppliedDateAndTimeAssignment.cxx |   10 +--
 .../RWStepAP214_RWAppliedDateAssignment.cxx        |   10 +--
 .../RWStepAP214_RWAppliedDocumentReference.cxx     |    6 +-
 ...RWStepAP214_RWAppliedOrganizationAssignment.cxx |   10 +--
 ...14_RWAppliedPersonAndOrganizationAssignment.cxx |   10 +--
 ...4_RWAppliedSecurityClassificationAssignment.cxx |    5 +-
 ...214_RWAutoDesignActualDateAndTimeAssignment.cxx |   10 +--
 ...WStepAP214_RWAutoDesignActualDateAssignment.cxx |   10 +--
 .../RWStepAP214_RWAutoDesignApprovalAssignment.cxx |    5 +-
 ...epAP214_RWAutoDesignDateAndPersonAssignment.cxx |   10 +--
 .../RWStepAP214_RWAutoDesignDocumentReference.cxx  |    6 +-
 ...14_RWAutoDesignNominalDateAndTimeAssignment.cxx |   10 +--
 ...tepAP214_RWAutoDesignOrganizationAssignment.cxx |   10 +--
 ...RWAutoDesignPersonAndOrganizationAssignment.cxx |   10 +--
 ...WAutoDesignSecurityClassificationAssignment.cxx |    5 +-
 .../RWStepBasic_RWApplicationContextElement.cxx    |    5 +-
 src/RWStepShape/RWStepShape_RWFaceBound.cxx        |    4 -
 src/Select2D/Select2D_SensitivePoint.cxx           |    3 -
 src/StlTransfer/StlTransfer.cxx                    |    5 -
 src/TDF/TDF_ComparisonTool.cxx                     |    4 -
 src/TPrsStd/TPrsStd_ConstraintTools.cxx            |   21 -----
 src/TestTopOpe/TestTopOpe_BOOPCommands.cxx         |    8 --
 src/TestTopOpe/TestTopOpe_CORCommands.cxx          |   10 ---
 src/TestTopOpe/TestTopOpe_DSACommands.cxx          |   13 +---
 src/TestTopOpe/TestTopOpe_HDSCommands.cxx          |   19 +-----
 src/TestTopOpeDraw/TestTopOpeDraw_Displayer.cxx    |    5 +-
 .../TestTopOpeDraw_DrawableMesure.cxx              |    4 -
 src/TopOpeBRep/TopOpeBRep_DSFiller.cxx             |   34 +--------
 src/TopOpeBRep/TopOpeBRep_EdgesFiller.cxx          |   46 +-----------
 src/TopOpeBRep/TopOpeBRep_EdgesIntersector.cxx     |   51 -------------
 src/TopOpeBRep/TopOpeBRep_FaceEdgeFiller.cxx       |    9 +--
 src/TopOpeBRep/TopOpeBRep_FacesFiller.cxx          |    3 -
 src/TopOpeBRep/TopOpeBRep_FacesFiller_1.cxx        |   15 +---
 src/TopOpeBRep/TopOpeBRep_FacesIntersector.cxx     |   15 ----
 src/TopOpeBRep/TopOpeBRep_Hctxee2d.cxx             |   20 -----
 src/TopOpeBRep/TopOpeBRep_Point2d.cxx              |    3 +-
 src/TopOpeBRep/TopOpeBRep_ProcessGR.cxx            |   10 +--
 src/TopOpeBRep/TopOpeBRep_ProcessSectionEdges.cxx  |   13 +---
 src/TopOpeBRep/TopOpeBRep_ShapeIntersector.cxx     |    6 --
 src/TopOpeBRep/TopOpeBRep_ShapeIntersector2d.cxx   |   16 +----
 .../TopOpeBRep_VPointInterClassifier.cxx           |    4 -
 src/TopOpeBRep/TopOpeBRep_VPointInterIterator.cxx  |    8 --
 src/TopOpeBRep/TopOpeBRep_kpart.cxx                |    7 --
 src/TopOpeBRep/TopOpeBRep_vpr.cxx                  |   11 ---
 src/TopOpeBRep/TopOpeBRep_vprclo.cxx               |   18 +----
 src/TopOpeBRep/TopOpeBRep_vprdeg.cxx               |    5 -
 src/TopOpeBRepBuild/TopOpeBRepBuild_Tools2d.cxx    |    2 -
 .../TopOpeBRepDS_ProcessFaceInterferences.cxx      |    2 -
 src/TopOpeBRepTool/TopOpeBRepTool_2d.cxx           |    3 -
 src/TopOpeBRepTool/TopOpeBRepTool_BoxSort.cxx      |    4 -
 src/TopOpeBRepTool/TopOpeBRepTool_CORRISO.cxx      |   79 +++-----------------
 src/TopOpeBRepTool/TopOpeBRepTool_GEOMETRY.cxx     |   11 ---
 src/TopOpeBRepTool/TopOpeBRepTool_HBoxTool.cxx     |    4 -
 src/TopOpeBRepTool/TopOpeBRepTool_PURGE.cxx        |    8 --
 src/TopOpeBRepTool/TopOpeBRepTool_REGUS.cxx        |   12 ---
 src/TopOpeBRepTool/TopOpeBRepTool_REGUW.cxx        |   27 +------
 src/TopOpeBRepTool/TopOpeBRepTool_RegularizeW.cxx  |   12 ---
 .../TopOpeBRepTool_ShapeClassifier.cxx             |    4 -
 src/TopOpeBRepTool/TopOpeBRepTool_ShapeTool.cxx    |    8 --
 src/TopOpeBRepTool/TopOpeBRepTool_TOOL.cxx         |   40 +----------
 src/TopOpeBRepTool/TopOpeBRepTool_TOPOLOGY.cxx     |   44 ++----------
 src/TopOpeBRepTool/TopOpeBRepTool_closing.cxx      |   40 ++--------
 src/TopOpeBRepTool/TopOpeBRepTool_connexity.cxx    |    8 --
 src/TopOpeBRepTool/TopOpeBRepTool_mkTondgE.cxx     |    5 +-
 src/V3d/V3d_View.cxx                               |    4 -
 src/V3d/V3d_View_3.cxx                             |    8 --
 src/ViewerTest/ViewerTest.cxx                      |    6 --
 src/ViewerTest/ViewerTest_FilletCommands.cxx       |    7 --
 src/Visual3d/Visual3d_View.cxx                     |   15 +---
 src/Visual3d/Visual3d_ViewManager.cxx              |   66 ----------------
 src/XSDRAW/XSDRAW.cxx                              |    5 +-
 src/Xw/Xw_Driver.cxx                               |    7 ++-
 src/Xw/Xw_load_icons.cxx                           |   12 +--
 src/math/math_BFGS.cxx                             |    4 -
 src/math/math_FunctionRoot.cxx                     |    8 --
 src/math/math_FunctionRoots.cxx                    |   10 ---
 src/math/math_IntegerVector.cxx                    |    3 -
 src/math/math_TrigonometricFunctionRoots.cxx       |    3 -
 src/math/math_Vector.cxx                           |    3 -
 226 files changed, 160 insertions(+), 1854 deletions(-)

Index: oce/drv/ShapeSchema/ShapeSchema_PCDM_Document.cxx
===================================================================
--- oce.orig/drv/ShapeSchema/ShapeSchema_PCDM_Document.cxx
+++ oce/drv/ShapeSchema/ShapeSchema_PCDM_Document.cxx
@@ -38,7 +38,6 @@ void ShapeSchema_PCDM_Document::Add(cons
 void ShapeSchema_PCDM_Document::SWrite(const Handle(Standard_Persistent)& p, Storage_BaseDriver& f, const Handle(Storage_Schema)& theSchema)
 { 
   if (!p.IsNull()) {
-    Handle(PCDM_Document) &pp = (Handle(PCDM_Document)&)p;
     theSchema->WritePersistentObjectHeader(p,f);
     
     f.BeginWritePersistentObjectData();
@@ -56,8 +55,7 @@ void ShapeSchema_PCDM_Document::Write(co
 void ShapeSchema_PCDM_Document::SRead(const Handle(Standard_Persistent)& p, Storage_BaseDriver& f, const Handle(Storage_Schema)& theSchema)
 { 
   if (!p.IsNull()) {
-    Handle(PCDM_Document) &pp = (Handle(PCDM_Document)&)p;
-
+  
     theSchema->ReadPersistentObjectHeader(f);
     f.BeginReadPersistentObjectData();
 
Index: oce/drv/ShapeSchema/ShapeSchema_PGeom2d_BoundedCurve.cxx
===================================================================
--- oce.orig/drv/ShapeSchema/ShapeSchema_PGeom2d_BoundedCurve.cxx
+++ oce/drv/ShapeSchema/ShapeSchema_PGeom2d_BoundedCurve.cxx
@@ -38,7 +38,6 @@ void ShapeSchema_PGeom2d_BoundedCurve::A
 void ShapeSchema_PGeom2d_BoundedCurve::SWrite(const Handle(Standard_Persistent)& p, Storage_BaseDriver& f, const Handle(Storage_Schema)& theSchema)
 { 
   if (!p.IsNull()) {
-    Handle(PGeom2d_BoundedCurve) &pp = (Handle(PGeom2d_BoundedCurve)&)p;
     theSchema->WritePersistentObjectHeader(p,f);
     
     f.BeginWritePersistentObjectData();
@@ -56,8 +55,7 @@ void ShapeSchema_PGeom2d_BoundedCurve::W
 void ShapeSchema_PGeom2d_BoundedCurve::SRead(const Handle(Standard_Persistent)& p, Storage_BaseDriver& f, const Handle(Storage_Schema)& theSchema)
 { 
   if (!p.IsNull()) {
-    Handle(PGeom2d_BoundedCurve) &pp = (Handle(PGeom2d_BoundedCurve)&)p;
-
+ 
     theSchema->ReadPersistentObjectHeader(f);
     f.BeginReadPersistentObjectData();
 
Index: oce/drv/ShapeSchema/ShapeSchema_PGeom2d_Curve.cxx
===================================================================
--- oce.orig/drv/ShapeSchema/ShapeSchema_PGeom2d_Curve.cxx
+++ oce/drv/ShapeSchema/ShapeSchema_PGeom2d_Curve.cxx
@@ -38,7 +38,6 @@ void ShapeSchema_PGeom2d_Curve::Add(cons
 void ShapeSchema_PGeom2d_Curve::SWrite(const Handle(Standard_Persistent)& p, Storage_BaseDriver& f, const Handle(Storage_Schema)& theSchema)
 { 
   if (!p.IsNull()) {
-    Handle(PGeom2d_Curve) &pp = (Handle(PGeom2d_Curve)&)p;
     theSchema->WritePersistentObjectHeader(p,f);
     
     f.BeginWritePersistentObjectData();
@@ -56,7 +55,6 @@ void ShapeSchema_PGeom2d_Curve::Write(co
 void ShapeSchema_PGeom2d_Curve::SRead(const Handle(Standard_Persistent)& p, Storage_BaseDriver& f, const Handle(Storage_Schema)& theSchema)
 { 
   if (!p.IsNull()) {
-    Handle(PGeom2d_Curve) &pp = (Handle(PGeom2d_Curve)&)p;
 
     theSchema->ReadPersistentObjectHeader(f);
     f.BeginReadPersistentObjectData();
Index: oce/drv/ShapeSchema/ShapeSchema_PGeom2d_Geometry.cxx
===================================================================
--- oce.orig/drv/ShapeSchema/ShapeSchema_PGeom2d_Geometry.cxx
+++ oce/drv/ShapeSchema/ShapeSchema_PGeom2d_Geometry.cxx
@@ -38,7 +38,6 @@ void ShapeSchema_PGeom2d_Geometry::Add(c
 void ShapeSchema_PGeom2d_Geometry::SWrite(const Handle(Standard_Persistent)& p, Storage_BaseDriver& f, const Handle(Storage_Schema)& theSchema)
 { 
   if (!p.IsNull()) {
-    Handle(PGeom2d_Geometry) &pp = (Handle(PGeom2d_Geometry)&)p;
     theSchema->WritePersistentObjectHeader(p,f);
     
     f.BeginWritePersistentObjectData();
@@ -56,8 +55,7 @@ void ShapeSchema_PGeom2d_Geometry::Write
 void ShapeSchema_PGeom2d_Geometry::SRead(const Handle(Standard_Persistent)& p, Storage_BaseDriver& f, const Handle(Storage_Schema)& theSchema)
 { 
   if (!p.IsNull()) {
-    Handle(PGeom2d_Geometry) &pp = (Handle(PGeom2d_Geometry)&)p;
-
+   
     theSchema->ReadPersistentObjectHeader(f);
     f.BeginReadPersistentObjectData();
 
Index: oce/drv/ShapeSchema/ShapeSchema_PGeom2d_Point.cxx
===================================================================
--- oce.orig/drv/ShapeSchema/ShapeSchema_PGeom2d_Point.cxx
+++ oce/drv/ShapeSchema/ShapeSchema_PGeom2d_Point.cxx
@@ -38,7 +38,6 @@ void ShapeSchema_PGeom2d_Point::Add(cons
 void ShapeSchema_PGeom2d_Point::SWrite(const Handle(Standard_Persistent)& p, Storage_BaseDriver& f, const Handle(Storage_Schema)& theSchema)
 { 
   if (!p.IsNull()) {
-    Handle(PGeom2d_Point) &pp = (Handle(PGeom2d_Point)&)p;
     theSchema->WritePersistentObjectHeader(p,f);
     
     f.BeginWritePersistentObjectData();
@@ -56,8 +55,7 @@ void ShapeSchema_PGeom2d_Point::Write(co
 void ShapeSchema_PGeom2d_Point::SRead(const Handle(Standard_Persistent)& p, Storage_BaseDriver& f, const Handle(Storage_Schema)& theSchema)
 { 
   if (!p.IsNull()) {
-    Handle(PGeom2d_Point) &pp = (Handle(PGeom2d_Point)&)p;
-
+  
     theSchema->ReadPersistentObjectHeader(f);
     f.BeginReadPersistentObjectData();
 
Index: oce/drv/ShapeSchema/ShapeSchema_PGeom_BoundedCurve.cxx
===================================================================
--- oce.orig/drv/ShapeSchema/ShapeSchema_PGeom_BoundedCurve.cxx
+++ oce/drv/ShapeSchema/ShapeSchema_PGeom_BoundedCurve.cxx
@@ -38,7 +38,6 @@ void ShapeSchema_PGeom_BoundedCurve::Add
 void ShapeSchema_PGeom_BoundedCurve::SWrite(const Handle(Standard_Persistent)& p, Storage_BaseDriver& f, const Handle(Storage_Schema)& theSchema)
 { 
   if (!p.IsNull()) {
-    Handle(PGeom_BoundedCurve) &pp = (Handle(PGeom_BoundedCurve)&)p;
     theSchema->WritePersistentObjectHeader(p,f);
     
     f.BeginWritePersistentObjectData();
@@ -56,7 +55,6 @@ void ShapeSchema_PGeom_BoundedCurve::Wri
 void ShapeSchema_PGeom_BoundedCurve::SRead(const Handle(Standard_Persistent)& p, Storage_BaseDriver& f, const Handle(Storage_Schema)& theSchema)
 { 
   if (!p.IsNull()) {
-    Handle(PGeom_BoundedCurve) &pp = (Handle(PGeom_BoundedCurve)&)p;
 
     theSchema->ReadPersistentObjectHeader(f);
     f.BeginReadPersistentObjectData();
Index: oce/drv/ShapeSchema/ShapeSchema_PGeom_BoundedSurface.cxx
===================================================================
--- oce.orig/drv/ShapeSchema/ShapeSchema_PGeom_BoundedSurface.cxx
+++ oce/drv/ShapeSchema/ShapeSchema_PGeom_BoundedSurface.cxx
@@ -38,7 +38,6 @@ void ShapeSchema_PGeom_BoundedSurface::A
 void ShapeSchema_PGeom_BoundedSurface::SWrite(const Handle(Standard_Persistent)& p, Storage_BaseDriver& f, const Handle(Storage_Schema)& theSchema)
 { 
   if (!p.IsNull()) {
-    Handle(PGeom_BoundedSurface) &pp = (Handle(PGeom_BoundedSurface)&)p;
     theSchema->WritePersistentObjectHeader(p,f);
     
     f.BeginWritePersistentObjectData();
@@ -56,8 +55,7 @@ void ShapeSchema_PGeom_BoundedSurface::W
 void ShapeSchema_PGeom_BoundedSurface::SRead(const Handle(Standard_Persistent)& p, Storage_BaseDriver& f, const Handle(Storage_Schema)& theSchema)
 { 
   if (!p.IsNull()) {
-    Handle(PGeom_BoundedSurface) &pp = (Handle(PGeom_BoundedSurface)&)p;
-
+  
     theSchema->ReadPersistentObjectHeader(f);
     f.BeginReadPersistentObjectData();
 
Index: oce/drv/ShapeSchema/ShapeSchema_PGeom_Curve.cxx
===================================================================
--- oce.orig/drv/ShapeSchema/ShapeSchema_PGeom_Curve.cxx
+++ oce/drv/ShapeSchema/ShapeSchema_PGeom_Curve.cxx
@@ -38,7 +38,6 @@ void ShapeSchema_PGeom_Curve::Add(const
 void ShapeSchema_PGeom_Curve::SWrite(const Handle(Standard_Persistent)& p, Storage_BaseDriver& f, const Handle(Storage_Schema)& theSchema)
 { 
   if (!p.IsNull()) {
-    Handle(PGeom_Curve) &pp = (Handle(PGeom_Curve)&)p;
     theSchema->WritePersistentObjectHeader(p,f);
     
     f.BeginWritePersistentObjectData();
@@ -56,8 +55,7 @@ void ShapeSchema_PGeom_Curve::Write(cons
 void ShapeSchema_PGeom_Curve::SRead(const Handle(Standard_Persistent)& p, Storage_BaseDriver& f, const Handle(Storage_Schema)& theSchema)
 { 
   if (!p.IsNull()) {
-    Handle(PGeom_Curve) &pp = (Handle(PGeom_Curve)&)p;
-
+ 
     theSchema->ReadPersistentObjectHeader(f);
     f.BeginReadPersistentObjectData();
 
Index: oce/drv/ShapeSchema/ShapeSchema_PGeom_Geometry.cxx
===================================================================
--- oce.orig/drv/ShapeSchema/ShapeSchema_PGeom_Geometry.cxx
+++ oce/drv/ShapeSchema/ShapeSchema_PGeom_Geometry.cxx
@@ -38,7 +38,6 @@ void ShapeSchema_PGeom_Geometry::Add(con
 void ShapeSchema_PGeom_Geometry::SWrite(const Handle(Standard_Persistent)& p, Storage_BaseDriver& f, const Handle(Storage_Schema)& theSchema)
 { 
   if (!p.IsNull()) {
-    Handle(PGeom_Geometry) &pp = (Handle(PGeom_Geometry)&)p;
     theSchema->WritePersistentObjectHeader(p,f);
     
     f.BeginWritePersistentObjectData();
@@ -56,8 +55,7 @@ void ShapeSchema_PGeom_Geometry::Write(c
 void ShapeSchema_PGeom_Geometry::SRead(const Handle(Standard_Persistent)& p, Storage_BaseDriver& f, const Handle(Storage_Schema)& theSchema)
 { 
   if (!p.IsNull()) {
-    Handle(PGeom_Geometry) &pp = (Handle(PGeom_Geometry)&)p;
-
+ 
     theSchema->ReadPersistentObjectHeader(f);
     f.BeginReadPersistentObjectData();
 
Index: oce/drv/ShapeSchema/ShapeSchema_PGeom_Point.cxx
===================================================================
--- oce.orig/drv/ShapeSchema/ShapeSchema_PGeom_Point.cxx
+++ oce/drv/ShapeSchema/ShapeSchema_PGeom_Point.cxx
@@ -38,7 +38,6 @@ void ShapeSchema_PGeom_Point::Add(const
 void ShapeSchema_PGeom_Point::SWrite(const Handle(Standard_Persistent)& p, Storage_BaseDriver& f, const Handle(Storage_Schema)& theSchema)
 { 
   if (!p.IsNull()) {
-    Handle(PGeom_Point) &pp = (Handle(PGeom_Point)&)p;
     theSchema->WritePersistentObjectHeader(p,f);
     
     f.BeginWritePersistentObjectData();
@@ -56,8 +55,7 @@ void ShapeSchema_PGeom_Point::Write(cons
 void ShapeSchema_PGeom_Point::SRead(const Handle(Standard_Persistent)& p, Storage_BaseDriver& f, const Handle(Storage_Schema)& theSchema)
 { 
   if (!p.IsNull()) {
-    Handle(PGeom_Point) &pp = (Handle(PGeom_Point)&)p;
-
+  
     theSchema->ReadPersistentObjectHeader(f);
     f.BeginReadPersistentObjectData();
 
Index: oce/drv/ShapeSchema/ShapeSchema_PGeom_Surface.cxx
===================================================================
--- oce.orig/drv/ShapeSchema/ShapeSchema_PGeom_Surface.cxx
+++ oce/drv/ShapeSchema/ShapeSchema_PGeom_Surface.cxx
@@ -38,7 +38,6 @@ void ShapeSchema_PGeom_Surface::Add(cons
 void ShapeSchema_PGeom_Surface::SWrite(const Handle(Standard_Persistent)& p, Storage_BaseDriver& f, const Handle(Storage_Schema)& theSchema)
 { 
   if (!p.IsNull()) {
-    Handle(PGeom_Surface) &pp = (Handle(PGeom_Surface)&)p;
     theSchema->WritePersistentObjectHeader(p,f);
     
     f.BeginWritePersistentObjectData();
@@ -56,8 +55,7 @@ void ShapeSchema_PGeom_Surface::Write(co
 void ShapeSchema_PGeom_Surface::SRead(const Handle(Standard_Persistent)& p, Storage_BaseDriver& f, const Handle(Storage_Schema)& theSchema)
 { 
   if (!p.IsNull()) {
-    Handle(PGeom_Surface) &pp = (Handle(PGeom_Surface)&)p;
-
+  
     theSchema->ReadPersistentObjectHeader(f);
     f.BeginReadPersistentObjectData();
 
Index: oce/drv/ShapeSchema/ShapeSchema_PMMgt_PManaged.cxx
===================================================================
--- oce.orig/drv/ShapeSchema/ShapeSchema_PMMgt_PManaged.cxx
+++ oce/drv/ShapeSchema/ShapeSchema_PMMgt_PManaged.cxx
@@ -38,7 +38,6 @@ void ShapeSchema_PMMgt_PManaged::Add(con
 void ShapeSchema_PMMgt_PManaged::SWrite(const Handle(Standard_Persistent)& p, Storage_BaseDriver& f, const Handle(Storage_Schema)& theSchema)
 { 
   if (!p.IsNull()) {
-    Handle(PMMgt_PManaged) &pp = (Handle(PMMgt_PManaged)&)p;
     theSchema->WritePersistentObjectHeader(p,f);
     
     f.BeginWritePersistentObjectData();
@@ -56,8 +55,7 @@ void ShapeSchema_PMMgt_PManaged::Write(c
 void ShapeSchema_PMMgt_PManaged::SRead(const Handle(Standard_Persistent)& p, Storage_BaseDriver& f, const Handle(Storage_Schema)& theSchema)
 { 
   if (!p.IsNull()) {
-    Handle(PMMgt_PManaged) &pp = (Handle(PMMgt_PManaged)&)p;
-
+ 
     theSchema->ReadPersistentObjectHeader(f);
     f.BeginReadPersistentObjectData();
 
Index: oce/drv/ShapeSchema/ShapeSchema_Standard_Persistent.cxx
===================================================================
--- oce.orig/drv/ShapeSchema/ShapeSchema_Standard_Persistent.cxx
+++ oce/drv/ShapeSchema/ShapeSchema_Standard_Persistent.cxx
@@ -38,7 +38,6 @@ void ShapeSchema_Standard_Persistent::Ad
 void ShapeSchema_Standard_Persistent::SWrite(const Handle(Standard_Persistent)& p, Storage_BaseDriver& f, const Handle(Storage_Schema)& theSchema)
 { 
   if (!p.IsNull()) {
-    Handle(Standard_Persistent) &pp = (Handle(Standard_Persistent)&)p;
     theSchema->WritePersistentObjectHeader(p,f);
     
     f.BeginWritePersistentObjectData();
@@ -56,8 +55,7 @@ void ShapeSchema_Standard_Persistent::Wr
 void ShapeSchema_Standard_Persistent::SRead(const Handle(Standard_Persistent)& p, Storage_BaseDriver& f, const Handle(Storage_Schema)& theSchema)
 { 
   if (!p.IsNull()) {
-    Handle(Standard_Persistent) &pp = (Handle(Standard_Persistent)&)p;
-
+  
     theSchema->ReadPersistentObjectHeader(f);
     f.BeginReadPersistentObjectData();
 
Index: oce/drv/StdLSchema/StdLSchema_PCDM_Document.cxx
===================================================================
--- oce.orig/drv/StdLSchema/StdLSchema_PCDM_Document.cxx
+++ oce/drv/StdLSchema/StdLSchema_PCDM_Document.cxx
@@ -38,7 +38,6 @@ void StdLSchema_PCDM_Document::Add(const
 void StdLSchema_PCDM_Document::SWrite(const Handle(Standard_Persistent)& p, Storage_BaseDriver& f, const Handle(Storage_Schema)& theSchema)
 { 
   if (!p.IsNull()) {
-    Handle(PCDM_Document) &pp = (Handle(PCDM_Document)&)p;
     theSchema->WritePersistentObjectHeader(p,f);
     
     f.BeginWritePersistentObjectData();
@@ -56,8 +55,7 @@ void StdLSchema_PCDM_Document::Write(con
 void StdLSchema_PCDM_Document::SRead(const Handle(Standard_Persistent)& p, Storage_BaseDriver& f, const Handle(Storage_Schema)& theSchema)
 { 
   if (!p.IsNull()) {
-    Handle(PCDM_Document) &pp = (Handle(PCDM_Document)&)p;
-
+  
     theSchema->ReadPersistentObjectHeader(f);
     f.BeginReadPersistentObjectData();
 
Index: oce/drv/StdLSchema/StdLSchema_PDF_Attribute.cxx
===================================================================
--- oce.orig/drv/StdLSchema/StdLSchema_PDF_Attribute.cxx
+++ oce/drv/StdLSchema/StdLSchema_PDF_Attribute.cxx
@@ -38,7 +38,6 @@ void StdLSchema_PDF_Attribute::Add(const
 void StdLSchema_PDF_Attribute::SWrite(const Handle(Standard_Persistent)& p, Storage_BaseDriver& f, const Handle(Storage_Schema)& theSchema)
 { 
   if (!p.IsNull()) {
-    Handle(PDF_Attribute) &pp = (Handle(PDF_Attribute)&)p;
     theSchema->WritePersistentObjectHeader(p,f);
     
     f.BeginWritePersistentObjectData();
@@ -56,8 +55,7 @@ void StdLSchema_PDF_Attribute::Write(con
 void StdLSchema_PDF_Attribute::SRead(const Handle(Standard_Persistent)& p, Storage_BaseDriver& f, const Handle(Storage_Schema)& theSchema)
 { 
   if (!p.IsNull()) {
-    Handle(PDF_Attribute) &pp = (Handle(PDF_Attribute)&)p;
-
+  
     theSchema->ReadPersistentObjectHeader(f);
     f.BeginReadPersistentObjectData();
 
Index: oce/drv/StdLSchema/StdLSchema_PDataStd_Directory.cxx
===================================================================
--- oce.orig/drv/StdLSchema/StdLSchema_PDataStd_Directory.cxx
+++ oce/drv/StdLSchema/StdLSchema_PDataStd_Directory.cxx
@@ -37,7 +37,6 @@ void StdLSchema_PDataStd_Directory::Add(
 void StdLSchema_PDataStd_Directory::SWrite(const Handle(Standard_Persistent)& p, Storage_BaseDriver& f, const Handle(Storage_Schema)& theSchema)
 { 
   if (!p.IsNull()) {
-    Handle(PDataStd_Directory) &pp = (Handle(PDataStd_Directory)&)p;
     theSchema->WritePersistentObjectHeader(p,f);
     
     f.BeginWritePersistentObjectData();
@@ -55,8 +54,7 @@ void StdLSchema_PDataStd_Directory::Writ
 void StdLSchema_PDataStd_Directory::SRead(const Handle(Standard_Persistent)& p, Storage_BaseDriver& f, const Handle(Storage_Schema)& theSchema)
 { 
   if (!p.IsNull()) {
-    Handle(PDataStd_Directory) &pp = (Handle(PDataStd_Directory)&)p;
-
+ 
     theSchema->ReadPersistentObjectHeader(f);
     f.BeginReadPersistentObjectData();
 
Index: oce/drv/StdLSchema/StdLSchema_PDataStd_NoteBook.cxx
===================================================================
--- oce.orig/drv/StdLSchema/StdLSchema_PDataStd_NoteBook.cxx
+++ oce/drv/StdLSchema/StdLSchema_PDataStd_NoteBook.cxx
@@ -37,7 +37,6 @@ void StdLSchema_PDataStd_NoteBook::Add(c
 void StdLSchema_PDataStd_NoteBook::SWrite(const Handle(Standard_Persistent)& p, Storage_BaseDriver& f, const Handle(Storage_Schema)& theSchema)
 { 
   if (!p.IsNull()) {
-    Handle(PDataStd_NoteBook) &pp = (Handle(PDataStd_NoteBook)&)p;
     theSchema->WritePersistentObjectHeader(p,f);
     
     f.BeginWritePersistentObjectData();
@@ -55,8 +54,7 @@ void StdLSchema_PDataStd_NoteBook::Write
 void StdLSchema_PDataStd_NoteBook::SRead(const Handle(Standard_Persistent)& p, Storage_BaseDriver& f, const Handle(Storage_Schema)& theSchema)
 { 
   if (!p.IsNull()) {
-    Handle(PDataStd_NoteBook) &pp = (Handle(PDataStd_NoteBook)&)p;
-
+ 
     theSchema->ReadPersistentObjectHeader(f);
     f.BeginReadPersistentObjectData();
 
Index: oce/drv/StdLSchema/StdLSchema_PDataStd_Tick.cxx
===================================================================
--- oce.orig/drv/StdLSchema/StdLSchema_PDataStd_Tick.cxx
+++ oce/drv/StdLSchema/StdLSchema_PDataStd_Tick.cxx
@@ -37,7 +37,6 @@ void StdLSchema_PDataStd_Tick::Add(const
 void StdLSchema_PDataStd_Tick::SWrite(const Handle(Standard_Persistent)& p, Storage_BaseDriver& f, const Handle(Storage_Schema)& theSchema)
 { 
   if (!p.IsNull()) {
-    Handle(PDataStd_Tick) &pp = (Handle(PDataStd_Tick)&)p;
     theSchema->WritePersistentObjectHeader(p,f);
     
     f.BeginWritePersistentObjectData();
@@ -55,8 +54,7 @@ void StdLSchema_PDataStd_Tick::Write(con
 void StdLSchema_PDataStd_Tick::SRead(const Handle(Standard_Persistent)& p, Storage_BaseDriver& f, const Handle(Storage_Schema)& theSchema)
 { 
   if (!p.IsNull()) {
-    Handle(PDataStd_Tick) &pp = (Handle(PDataStd_Tick)&)p;
-
+ 
     theSchema->ReadPersistentObjectHeader(f);
     f.BeginReadPersistentObjectData();
 
Index: oce/drv/StdLSchema/StdLSchema_Standard_Persistent.cxx
===================================================================
--- oce.orig/drv/StdLSchema/StdLSchema_Standard_Persistent.cxx
+++ oce/drv/StdLSchema/StdLSchema_Standard_Persistent.cxx
@@ -38,7 +38,6 @@ void StdLSchema_Standard_Persistent::Add
 void StdLSchema_Standard_Persistent::SWrite(const Handle(Standard_Persistent)& p, Storage_BaseDriver& f, const Handle(Storage_Schema)& theSchema)
 { 
   if (!p.IsNull()) {
-    Handle(Standard_Persistent) &pp = (Handle(Standard_Persistent)&)p;
     theSchema->WritePersistentObjectHeader(p,f);
     
     f.BeginWritePersistentObjectData();
@@ -56,8 +55,7 @@ void StdLSchema_Standard_Persistent::Wri
 void StdLSchema_Standard_Persistent::SRead(const Handle(Standard_Persistent)& p, Storage_BaseDriver& f, const Handle(Storage_Schema)& theSchema)
 { 
   if (!p.IsNull()) {
-    Handle(Standard_Persistent) &pp = (Handle(Standard_Persistent)&)p;
-
+ 
     theSchema->ReadPersistentObjectHeader(f);
     f.BeginReadPersistentObjectData();
 
Index: oce/drv/StdSchema/StdSchema_PDF_Attribute.cxx
===================================================================
--- oce.orig/drv/StdSchema/StdSchema_PDF_Attribute.cxx
+++ oce/drv/StdSchema/StdSchema_PDF_Attribute.cxx
@@ -38,7 +38,6 @@ void StdSchema_PDF_Attribute::Add(const
 void StdSchema_PDF_Attribute::SWrite(const Handle(Standard_Persistent)& p, Storage_BaseDriver& f, const Handle(Storage_Schema)& theSchema)
 { 
   if (!p.IsNull()) {
-    Handle(PDF_Attribute) &pp = (Handle(PDF_Attribute)&)p;
     theSchema->WritePersistentObjectHeader(p,f);
     
     f.BeginWritePersistentObjectData();
@@ -56,7 +55,6 @@ void StdSchema_PDF_Attribute::Write(cons
 void StdSchema_PDF_Attribute::SRead(const Handle(Standard_Persistent)& p, Storage_BaseDriver& f, const Handle(Storage_Schema)& theSchema)
 { 
   if (!p.IsNull()) {
-    Handle(PDF_Attribute) &pp = (Handle(PDF_Attribute)&)p;
 
     theSchema->ReadPersistentObjectHeader(f);
     f.BeginReadPersistentObjectData();
Index: oce/drv/StdSchema/StdSchema_PDataXtd_Axis.cxx
===================================================================
--- oce.orig/drv/StdSchema/StdSchema_PDataXtd_Axis.cxx
+++ oce/drv/StdSchema/StdSchema_PDataXtd_Axis.cxx
@@ -37,7 +37,6 @@ void StdSchema_PDataXtd_Axis::Add(const
 void StdSchema_PDataXtd_Axis::SWrite(const Handle(Standard_Persistent)& p, Storage_BaseDriver& f, const Handle(Storage_Schema)& theSchema)
 { 
   if (!p.IsNull()) {
-    Handle(PDataXtd_Axis) &pp = (Handle(PDataXtd_Axis)&)p;
     theSchema->WritePersistentObjectHeader(p,f);
     
     f.BeginWritePersistentObjectData();
@@ -55,8 +54,7 @@ void StdSchema_PDataXtd_Axis::Write(cons
 void StdSchema_PDataXtd_Axis::SRead(const Handle(Standard_Persistent)& p, Storage_BaseDriver& f, const Handle(Storage_Schema)& theSchema)
 { 
   if (!p.IsNull()) {
-    Handle(PDataXtd_Axis) &pp = (Handle(PDataXtd_Axis)&)p;
-
+ 
     theSchema->ReadPersistentObjectHeader(f);
     f.BeginReadPersistentObjectData();
 
Index: oce/drv/StdSchema/StdSchema_PDataXtd_Placement.cxx
===================================================================
--- oce.orig/drv/StdSchema/StdSchema_PDataXtd_Placement.cxx
+++ oce/drv/StdSchema/StdSchema_PDataXtd_Placement.cxx
@@ -37,7 +37,6 @@ void StdSchema_PDataXtd_Placement::Add(c
 void StdSchema_PDataXtd_Placement::SWrite(const Handle(Standard_Persistent)& p, Storage_BaseDriver& f, const Handle(Storage_Schema)& theSchema)
 { 
   if (!p.IsNull()) {
-    Handle(PDataXtd_Placement) &pp = (Handle(PDataXtd_Placement)&)p;
     theSchema->WritePersistentObjectHeader(p,f);
     
     f.BeginWritePersistentObjectData();
@@ -55,8 +54,7 @@ void StdSchema_PDataXtd_Placement::Write
 void StdSchema_PDataXtd_Placement::SRead(const Handle(Standard_Persistent)& p, Storage_BaseDriver& f, const Handle(Storage_Schema)& theSchema)
 { 
   if (!p.IsNull()) {
-    Handle(PDataXtd_Placement) &pp = (Handle(PDataXtd_Placement)&)p;
-
+  
     theSchema->ReadPersistentObjectHeader(f);
     f.BeginReadPersistentObjectData();
 
Index: oce/drv/StdSchema/StdSchema_PDataXtd_Plane.cxx
===================================================================
--- oce.orig/drv/StdSchema/StdSchema_PDataXtd_Plane.cxx
+++ oce/drv/StdSchema/StdSchema_PDataXtd_Plane.cxx
@@ -37,7 +37,6 @@ void StdSchema_PDataXtd_Plane::Add(const
 void StdSchema_PDataXtd_Plane::SWrite(const Handle(Standard_Persistent)& p, Storage_BaseDriver& f, const Handle(Storage_Schema)& theSchema)
 { 
   if (!p.IsNull()) {
-    Handle(PDataXtd_Plane) &pp = (Handle(PDataXtd_Plane)&)p;
     theSchema->WritePersistentObjectHeader(p,f);
     
     f.BeginWritePersistentObjectData();
@@ -55,8 +54,7 @@ void StdSchema_PDataXtd_Plane::Write(con
 void StdSchema_PDataXtd_Plane::SRead(const Handle(Standard_Persistent)& p, Storage_BaseDriver& f, const Handle(Storage_Schema)& theSchema)
 { 
   if (!p.IsNull()) {
-    Handle(PDataXtd_Plane) &pp = (Handle(PDataXtd_Plane)&)p;
-
+  
     theSchema->ReadPersistentObjectHeader(f);
     f.BeginReadPersistentObjectData();
 
Index: oce/drv/StdSchema/StdSchema_PDataXtd_Point.cxx
===================================================================
--- oce.orig/drv/StdSchema/StdSchema_PDataXtd_Point.cxx
+++ oce/drv/StdSchema/StdSchema_PDataXtd_Point.cxx
@@ -37,7 +37,6 @@ void StdSchema_PDataXtd_Point::Add(const
 void StdSchema_PDataXtd_Point::SWrite(const Handle(Standard_Persistent)& p, Storage_BaseDriver& f, const Handle(Storage_Schema)& theSchema)
 { 
   if (!p.IsNull()) {
-    Handle(PDataXtd_Point) &pp = (Handle(PDataXtd_Point)&)p;
     theSchema->WritePersistentObjectHeader(p,f);
     
     f.BeginWritePersistentObjectData();
@@ -55,8 +54,7 @@ void StdSchema_PDataXtd_Point::Write(con
 void StdSchema_PDataXtd_Point::SRead(const Handle(Standard_Persistent)& p, Storage_BaseDriver& f, const Handle(Storage_Schema)& theSchema)
 { 
   if (!p.IsNull()) {
-    Handle(PDataXtd_Point) &pp = (Handle(PDataXtd_Point)&)p;
-
+ 
     theSchema->ReadPersistentObjectHeader(f);
     f.BeginReadPersistentObjectData();
 
Index: oce/drv/StdSchema/StdSchema_PDataXtd_Shape.cxx
===================================================================
--- oce.orig/drv/StdSchema/StdSchema_PDataXtd_Shape.cxx
+++ oce/drv/StdSchema/StdSchema_PDataXtd_Shape.cxx
@@ -37,7 +37,6 @@ void StdSchema_PDataXtd_Shape::Add(const
 void StdSchema_PDataXtd_Shape::SWrite(const Handle(Standard_Persistent)& p, Storage_BaseDriver& f, const Handle(Storage_Schema)& theSchema)
 { 
   if (!p.IsNull()) {
-    Handle(PDataXtd_Shape) &pp = (Handle(PDataXtd_Shape)&)p;
     theSchema->WritePersistentObjectHeader(p,f);
     
     f.BeginWritePersistentObjectData();
@@ -55,8 +54,7 @@ void StdSchema_PDataXtd_Shape::Write(con
 void StdSchema_PDataXtd_Shape::SRead(const Handle(Standard_Persistent)& p, Storage_BaseDriver& f, const Handle(Storage_Schema)& theSchema)
 { 
   if (!p.IsNull()) {
-    Handle(PDataXtd_Shape) &pp = (Handle(PDataXtd_Shape)&)p;
-
+ 
     theSchema->ReadPersistentObjectHeader(f);
     f.BeginReadPersistentObjectData();
 
Index: oce/drv/StdSchema/StdSchema_Standard_Persistent.cxx
===================================================================
--- oce.orig/drv/StdSchema/StdSchema_Standard_Persistent.cxx
+++ oce/drv/StdSchema/StdSchema_Standard_Persistent.cxx
@@ -38,7 +38,6 @@ void StdSchema_Standard_Persistent::Add(
 void StdSchema_Standard_Persistent::SWrite(const Handle(Standard_Persistent)& p, Storage_BaseDriver& f, const Handle(Storage_Schema)& theSchema)
 { 
   if (!p.IsNull()) {
-    Handle(Standard_Persistent) &pp = (Handle(Standard_Persistent)&)p;
     theSchema->WritePersistentObjectHeader(p,f);
     
     f.BeginWritePersistentObjectData();
@@ -56,8 +55,7 @@ void StdSchema_Standard_Persistent::Writ
 void StdSchema_Standard_Persistent::SRead(const Handle(Standard_Persistent)& p, Storage_BaseDriver& f, const Handle(Storage_Schema)& theSchema)
 { 
   if (!p.IsNull()) {
-    Handle(Standard_Persistent) &pp = (Handle(Standard_Persistent)&)p;
-
+ 
     theSchema->ReadPersistentObjectHeader(f);
     f.BeginReadPersistentObjectData();
 
Index: oce/drv/XCAFSchema/XCAFSchema_PDF_Attribute.cxx
===================================================================
--- oce.orig/drv/XCAFSchema/XCAFSchema_PDF_Attribute.cxx
+++ oce/drv/XCAFSchema/XCAFSchema_PDF_Attribute.cxx
@@ -38,7 +38,6 @@ void XCAFSchema_PDF_Attribute::Add(const
 void XCAFSchema_PDF_Attribute::SWrite(const Handle(Standard_Persistent)& p, Storage_BaseDriver& f, const Handle(Storage_Schema)& theSchema)
 { 
   if (!p.IsNull()) {
-    Handle(PDF_Attribute) &pp = (Handle(PDF_Attribute)&)p;
     theSchema->WritePersistentObjectHeader(p,f);
     
     f.BeginWritePersistentObjectData();
@@ -56,8 +55,7 @@ void XCAFSchema_PDF_Attribute::Write(con
 void XCAFSchema_PDF_Attribute::SRead(const Handle(Standard_Persistent)& p, Storage_BaseDriver& f, const Handle(Storage_Schema)& theSchema)
 { 
   if (!p.IsNull()) {
-    Handle(PDF_Attribute) &pp = (Handle(PDF_Attribute)&)p;
-
+ 
     theSchema->ReadPersistentObjectHeader(f);
     f.BeginReadPersistentObjectData();
 
Index: oce/drv/XCAFSchema/XCAFSchema_PMMgt_PManaged.cxx
===================================================================
--- oce.orig/drv/XCAFSchema/XCAFSchema_PMMgt_PManaged.cxx
+++ oce/drv/XCAFSchema/XCAFSchema_PMMgt_PManaged.cxx
@@ -38,7 +38,6 @@ void XCAFSchema_PMMgt_PManaged::Add(cons
 void XCAFSchema_PMMgt_PManaged::SWrite(const Handle(Standard_Persistent)& p, Storage_BaseDriver& f, const Handle(Storage_Schema)& theSchema)
 { 
   if (!p.IsNull()) {
-    Handle(PMMgt_PManaged) &pp = (Handle(PMMgt_PManaged)&)p;
     theSchema->WritePersistentObjectHeader(p,f);
     
     f.BeginWritePersistentObjectData();
@@ -56,8 +55,7 @@ void XCAFSchema_PMMgt_PManaged::Write(co
 void XCAFSchema_PMMgt_PManaged::SRead(const Handle(Standard_Persistent)& p, Storage_BaseDriver& f, const Handle(Storage_Schema)& theSchema)
 { 
   if (!p.IsNull()) {
-    Handle(PMMgt_PManaged) &pp = (Handle(PMMgt_PManaged)&)p;
-
+ 
     theSchema->ReadPersistentObjectHeader(f);
     f.BeginReadPersistentObjectData();
 
Index: oce/drv/XCAFSchema/XCAFSchema_PXCAFDoc_ColorTool.cxx
===================================================================
--- oce.orig/drv/XCAFSchema/XCAFSchema_PXCAFDoc_ColorTool.cxx
+++ oce/drv/XCAFSchema/XCAFSchema_PXCAFDoc_ColorTool.cxx
@@ -37,7 +37,6 @@ void XCAFSchema_PXCAFDoc_ColorTool::Add(
 void XCAFSchema_PXCAFDoc_ColorTool::SWrite(const Handle(Standard_Persistent)& p, Storage_BaseDriver& f, const Handle(Storage_Schema)& theSchema)
 { 
   if (!p.IsNull()) {
-    Handle(PXCAFDoc_ColorTool) &pp = (Handle(PXCAFDoc_ColorTool)&)p;
     theSchema->WritePersistentObjectHeader(p,f);
     
     f.BeginWritePersistentObjectData();
@@ -55,7 +54,6 @@ void XCAFSchema_PXCAFDoc_ColorTool::Writ
 void XCAFSchema_PXCAFDoc_ColorTool::SRead(const Handle(Standard_Persistent)& p, Storage_BaseDriver& f, const Handle(Storage_Schema)& theSchema)
 { 
   if (!p.IsNull()) {
-    Handle(PXCAFDoc_ColorTool) &pp = (Handle(PXCAFDoc_ColorTool)&)p;
 
     theSchema->ReadPersistentObjectHeader(f);
     f.BeginReadPersistentObjectData();
Index: oce/drv/XCAFSchema/XCAFSchema_PXCAFDoc_DimTolTool.cxx
===================================================================
--- oce.orig/drv/XCAFSchema/XCAFSchema_PXCAFDoc_DimTolTool.cxx
+++ oce/drv/XCAFSchema/XCAFSchema_PXCAFDoc_DimTolTool.cxx
@@ -37,7 +37,6 @@ void XCAFSchema_PXCAFDoc_DimTolTool::Add
 void XCAFSchema_PXCAFDoc_DimTolTool::SWrite(const Handle(Standard_Persistent)& p, Storage_BaseDriver& f, const Handle(Storage_Schema)& theSchema)
 { 
   if (!p.IsNull()) {
-    Handle(PXCAFDoc_DimTolTool) &pp = (Handle(PXCAFDoc_DimTolTool)&)p;
     theSchema->WritePersistentObjectHeader(p,f);
     
     f.BeginWritePersistentObjectData();
@@ -55,8 +54,7 @@ void XCAFSchema_PXCAFDoc_DimTolTool::Wri
 void XCAFSchema_PXCAFDoc_DimTolTool::SRead(const Handle(Standard_Persistent)& p, Storage_BaseDriver& f, const Handle(Storage_Schema)& theSchema)
 { 
   if (!p.IsNull()) {
-    Handle(PXCAFDoc_DimTolTool) &pp = (Handle(PXCAFDoc_DimTolTool)&)p;
-
+  
     theSchema->ReadPersistentObjectHeader(f);
     f.BeginReadPersistentObjectData();
 
Index: oce/drv/XCAFSchema/XCAFSchema_PXCAFDoc_DocumentTool.cxx
===================================================================
--- oce.orig/drv/XCAFSchema/XCAFSchema_PXCAFDoc_DocumentTool.cxx
+++ oce/drv/XCAFSchema/XCAFSchema_PXCAFDoc_DocumentTool.cxx
@@ -37,7 +37,6 @@ void XCAFSchema_PXCAFDoc_DocumentTool::A
 void XCAFSchema_PXCAFDoc_DocumentTool::SWrite(const Handle(Standard_Persistent)& p, Storage_BaseDriver& f, const Handle(Storage_Schema)& theSchema)
 { 
   if (!p.IsNull()) {
-    Handle(PXCAFDoc_DocumentTool) &pp = (Handle(PXCAFDoc_DocumentTool)&)p;
     theSchema->WritePersistentObjectHeader(p,f);
     
     f.BeginWritePersistentObjectData();
@@ -55,8 +54,7 @@ void XCAFSchema_PXCAFDoc_DocumentTool::W
 void XCAFSchema_PXCAFDoc_DocumentTool::SRead(const Handle(Standard_Persistent)& p, Storage_BaseDriver& f, const Handle(Storage_Schema)& theSchema)
 { 
   if (!p.IsNull()) {
-    Handle(PXCAFDoc_DocumentTool) &pp = (Handle(PXCAFDoc_DocumentTool)&)p;
-
+ 
     theSchema->ReadPersistentObjectHeader(f);
     f.BeginReadPersistentObjectData();
 
Index: oce/drv/XCAFSchema/XCAFSchema_PXCAFDoc_LayerTool.cxx
===================================================================
--- oce.orig/drv/XCAFSchema/XCAFSchema_PXCAFDoc_LayerTool.cxx
+++ oce/drv/XCAFSchema/XCAFSchema_PXCAFDoc_LayerTool.cxx
@@ -37,7 +37,6 @@ void XCAFSchema_PXCAFDoc_LayerTool::Add(
 void XCAFSchema_PXCAFDoc_LayerTool::SWrite(const Handle(Standard_Persistent)& p, Storage_BaseDriver& f, const Handle(Storage_Schema)& theSchema)
 { 
   if (!p.IsNull()) {
-    Handle(PXCAFDoc_LayerTool) &pp = (Handle(PXCAFDoc_LayerTool)&)p;
     theSchema->WritePersistentObjectHeader(p,f);
     
     f.BeginWritePersistentObjectData();
@@ -55,8 +54,7 @@ void XCAFSchema_PXCAFDoc_LayerTool::Writ
 void XCAFSchema_PXCAFDoc_LayerTool::SRead(const Handle(Standard_Persistent)& p, Storage_BaseDriver& f, const Handle(Storage_Schema)& theSchema)
 { 
   if (!p.IsNull()) {
-    Handle(PXCAFDoc_LayerTool) &pp = (Handle(PXCAFDoc_LayerTool)&)p;
-
+ 
     theSchema->ReadPersistentObjectHeader(f);
     f.BeginReadPersistentObjectData();
 
Index: oce/drv/XCAFSchema/XCAFSchema_PXCAFDoc_MaterialTool.cxx
===================================================================
--- oce.orig/drv/XCAFSchema/XCAFSchema_PXCAFDoc_MaterialTool.cxx
+++ oce/drv/XCAFSchema/XCAFSchema_PXCAFDoc_MaterialTool.cxx
@@ -37,7 +37,6 @@ void XCAFSchema_PXCAFDoc_MaterialTool::A
 void XCAFSchema_PXCAFDoc_MaterialTool::SWrite(const Handle(Standard_Persistent)& p, Storage_BaseDriver& f, const Handle(Storage_Schema)& theSchema)
 { 
   if (!p.IsNull()) {
-    Handle(PXCAFDoc_MaterialTool) &pp = (Handle(PXCAFDoc_MaterialTool)&)p;
     theSchema->WritePersistentObjectHeader(p,f);
     
     f.BeginWritePersistentObjectData();
@@ -55,7 +54,6 @@ void XCAFSchema_PXCAFDoc_MaterialTool::W
 void XCAFSchema_PXCAFDoc_MaterialTool::SRead(const Handle(Standard_Persistent)& p, Storage_BaseDriver& f, const Handle(Storage_Schema)& theSchema)
 { 
   if (!p.IsNull()) {
-    Handle(PXCAFDoc_MaterialTool) &pp = (Handle(PXCAFDoc_MaterialTool)&)p;
 
     theSchema->ReadPersistentObjectHeader(f);
     f.BeginReadPersistentObjectData();
Index: oce/drv/XCAFSchema/XCAFSchema_PXCAFDoc_ShapeTool.cxx
===================================================================
--- oce.orig/drv/XCAFSchema/XCAFSchema_PXCAFDoc_ShapeTool.cxx
+++ oce/drv/XCAFSchema/XCAFSchema_PXCAFDoc_ShapeTool.cxx
@@ -37,7 +37,6 @@ void XCAFSchema_PXCAFDoc_ShapeTool::Add(
 void XCAFSchema_PXCAFDoc_ShapeTool::SWrite(const Handle(Standard_Persistent)& p, Storage_BaseDriver& f, const Handle(Storage_Schema)& theSchema)
 { 
   if (!p.IsNull()) {
-    Handle(PXCAFDoc_ShapeTool) &pp = (Handle(PXCAFDoc_ShapeTool)&)p;
     theSchema->WritePersistentObjectHeader(p,f);
     
     f.BeginWritePersistentObjectData();
@@ -55,8 +54,7 @@ void XCAFSchema_PXCAFDoc_ShapeTool::Writ
 void XCAFSchema_PXCAFDoc_ShapeTool::SRead(const Handle(Standard_Persistent)& p, Storage_BaseDriver& f, const Handle(Storage_Schema)& theSchema)
 { 
   if (!p.IsNull()) {
-    Handle(PXCAFDoc_ShapeTool) &pp = (Handle(PXCAFDoc_ShapeTool)&)p;
-
+ 
     theSchema->ReadPersistentObjectHeader(f);
     f.BeginReadPersistentObjectData();
 
Index: oce/drv/XCAFSchema/XCAFSchema_Standard_Persistent.cxx
===================================================================
--- oce.orig/drv/XCAFSchema/XCAFSchema_Standard_Persistent.cxx
+++ oce/drv/XCAFSchema/XCAFSchema_Standard_Persistent.cxx
@@ -38,7 +38,6 @@ void XCAFSchema_Standard_Persistent::Add
 void XCAFSchema_Standard_Persistent::SWrite(const Handle(Standard_Persistent)& p, Storage_BaseDriver& f, const Handle(Storage_Schema)& theSchema)
 { 
   if (!p.IsNull()) {
-    Handle(Standard_Persistent) &pp = (Handle(Standard_Persistent)&)p;
     theSchema->WritePersistentObjectHeader(p,f);
     
     f.BeginWritePersistentObjectData();
@@ -56,7 +55,6 @@ void XCAFSchema_Standard_Persistent::Wri
 void XCAFSchema_Standard_Persistent::SRead(const Handle(Standard_Persistent)& p, Storage_BaseDriver& f, const Handle(Storage_Schema)& theSchema)
 { 
   if (!p.IsNull()) {
-    Handle(Standard_Persistent) &pp = (Handle(Standard_Persistent)&)p;
 
     theSchema->ReadPersistentObjectHeader(f);
     f.BeginReadPersistentObjectData();
Index: oce/inc/AppParCurves_LeastSquare.gxx
===================================================================
--- oce.orig/inc/AppParCurves_LeastSquare.gxx
+++ oce/inc/AppParCurves_LeastSquare.gxx
@@ -417,7 +417,7 @@ void AppParCurves_LeastSquare::Perform(c
   if (!isready) {
     return;
   }
-  Standard_Integer i, j, k, Ci, Nincx, Neq, i2, k1, k2;
+  Standard_Integer i, j, k, Ci, Nincx, i2, k1, k2;
   Standard_Integer nbpol1 = nbpoles-1, Ninc1 = Ninc-1;
   Standard_Real AD1, A0;
 //  gp_Pnt Pt;
@@ -486,7 +486,7 @@ void AppParCurves_LeastSquare::Perform(c
     math_Vector myTABB(1, Nincx, 0.0);
     
     MakeTAA(TheAA, mytab);
-    Standard_Integer Error = DACTCL_Decompose(TheAA, Index);
+    DACTCL_Decompose(TheAA, Index);
     
     Standard_Integer kk2;
     for (j = 1; j <= B2.ColNumber(); j++) {
@@ -495,7 +495,7 @@ void AppParCurves_LeastSquare::Perform(c
 	myTABB(kk2) = mytab(i, j);
 	kk2++;
       }
-      Error = DACTCL_Solve(TheAA, myTABB, Index);
+      DACTCL_Solve(TheAA, myTABB, Index);
       
       i2 = 1;
       for (k = resinit; k <= resfin; k++) {
@@ -511,7 +511,6 @@ void AppParCurves_LeastSquare::Perform(c
   // ===========================================================
 
   Nincx = resfin-resinit+1;
-  Neq = LastP-FirstP+1;
   Standard_Integer deport = 0, Nincx2 = 2*Nincx;
   
   math_IntegerVector InternalIndex(1, Nincx);
@@ -855,7 +854,7 @@ void AppParCurves_LeastSquare::Perform(c
 
   math_Vector myTABB(1, Nincx, 0.0);
 
-  Standard_Integer Error = DACTCL_Decompose(AA, Index);
+  DACTCL_Decompose(AA, Index);
   
   Standard_Integer kk2;
   for (j = 1; j <= B2.ColNumber(); j++) {
@@ -865,7 +864,7 @@ void AppParCurves_LeastSquare::Perform(c
       kk2++;
     }
     
-    Error = DACTCL_Solve(AA, myTABB, Index);
+    DACTCL_Solve(AA, myTABB, Index);
     
     i2 = 1;
     for (k = resinit; k <= resfin; k++) {
@@ -979,7 +978,6 @@ void AppParCurves_LeastSquare::Error(Sta
   F = 0.0;
   i2 = 1;
   math_Vector Px(1, nbpoles), Py(1, nbpoles), Pz(1, nbpoles);
-  Standard_Integer l;
 
   for (k = 1 ; k <= nbP+nbP2d; k++) {
     i21 = i2+1; i22 = i2+2;
@@ -992,7 +990,6 @@ void AppParCurves_LeastSquare::Error(Sta
       AA = 0.0; BB = 0.0; CC = 0.0;
       indexdeb = myindex(i) + 1;
       indexfin = indexdeb + deg;
-      l = (i-1)*(deg+1)-indexdeb+1;
       for (j = indexdeb; j <= indexfin; j++) {
 	AIJ = A(i, j);
 	AA += AIJ*Px(j);
Index: oce/inc/AppParCurves_ResolConstraint.gxx
===================================================================
--- oce.orig/inc/AppParCurves_ResolConstraint.gxx
+++ oce/inc/AppParCurves_ResolConstraint.gxx
@@ -63,7 +63,6 @@ AppParCurves_ResolConstraint::
   Standard_Integer myindex, Def = SCurv.NbPoles()-1;    
   Standard_Integer nb3d, nb2d, Npol= Def+1, Npol2 = 2*Npol;
   Standard_Real T1 = 0, T2, T3, Tmax, Daij;
-  Standard_Boolean Ok;
   gp_Vec V;
   gp_Vec2d V2d;
   gp_Pnt Poi;
@@ -149,7 +148,7 @@ AppParCurves_ResolConstraint::
       for (i = 1; i <= IncTan; i++) {
 	Npt = ITan(i);
 	// choix du maximum de tangence pour exprimer la colinearite:
-	Ok = ToolLine::Tangency(SSP, Npt, tabV);
+	ToolLine::Tangency(SSP, Npt, tabV);
 	V = tabV(k);
 	V.Coord(T1, T2, T3);
 	Tmax = Abs(T1);
@@ -216,7 +215,7 @@ AppParCurves_ResolConstraint::
     else {
       for (i = 1; i <= IncTan; i++) {
 	Npt = ITan(i);
-	Ok = ToolLine::Tangency(SSP, Npt, tabV2d);
+	ToolLine::Tangency(SSP, Npt, tabV2d);
 	V2d = tabV2d(k-nb3d);
 	T1 = V2d.X();
 	T2 = V2d.Y();
@@ -264,25 +263,25 @@ AppParCurves_ResolConstraint::
       Inc3 = Inc3 + 1;
       if (Ibont(k, i) == 1) {
 	if (k <= nb3d) {
-	  Ok = ToolLine::Tangency(SSP, Npt, tabV);
+	  ToolLine::Tangency(SSP, Npt, tabV);
 	  V = tabV(k);
 	  T1 = V.X(); 
 	  IP = 3*Npol;
 	}
 	else { 
-	  Ok = ToolLine::Tangency(SSP, Npt, tabV2d);
+	  ToolLine::Tangency(SSP, Npt, tabV2d);
 	  V2d = tabV2d(k-nb3d);
 	  T1 = V2d.X(); 
 	  IP = 2*Npol;
 	}
 	if (Ibont(k+1, i) == 1) {  // Relations entre T1x et T2x:
 	  if ((k+1) <= nb3d) { 
-	    Ok = ToolLine::Tangency(SSP, Npt, tabV);
+	    ToolLine::Tangency(SSP, Npt, tabV);
 	    V = tabV(k+1);
 	    T2 = V.X();
 	  }
 	  else { 
-	    Ok = ToolLine::Tangency(SSP, Npt, tabV2d);
+	    ToolLine::Tangency(SSP, Npt, tabV2d);
 	    V2d = tabV2d(k+1-nb3d);
 	    T2 = V2d.X();
 	  }
@@ -295,12 +294,12 @@ AppParCurves_ResolConstraint::
 	}
 	else if (Ibont(k+1, i) == 2) {  // Relations entre T1x et T2y:
 	  if ((k+1) <= nb3d) { 
-	    Ok = ToolLine::Tangency(SSP, Npt, tabV);
+	    ToolLine::Tangency(SSP, Npt, tabV);
 	    V = tabV(k+1);
 	    T2 = V.Y();
 	  }
 	  else { 
-	    Ok = ToolLine::Tangency(SSP, Npt, tabV2d);
+	    ToolLine::Tangency(SSP, Npt, tabV2d);
 	    V2d = tabV2d(k+1-nb3d);
 	    T2 = V2d.Y();
 	  }
@@ -312,7 +311,7 @@ AppParCurves_ResolConstraint::
 	  IncCol = IncCol + IP;
 	}
 	else if (Ibont(k+1,i) == 3) {    // Relations entre T1x et T2z:
-	  Ok = ToolLine::Tangency(SSP, Npt, tabV);
+	  ToolLine::Tangency(SSP, Npt, tabV);
 	  V = tabV(k+1);
 	  T2 = V.Z();
 	  for (j = 1; j <=  Npol; j++) {
@@ -325,24 +324,24 @@ AppParCurves_ResolConstraint::
       }
       else if (Ibont(k,i) == 2) {  
 	if (k <= nb3d) { 
-	  Ok = ToolLine::Tangency(SSP, Npt, tabV);
+	  ToolLine::Tangency(SSP, Npt, tabV);
 	  V = tabV(k);
 	  IP = 3*Npol;
 	}
 	else { 
-	  Ok = ToolLine::Tangency(SSP, Npt, tabV2d);
+	  ToolLine::Tangency(SSP, Npt, tabV2d);
 	  V2d = tabV2d(k-nb3d);
 	  T1 = V2d.Y();
 	  IP = 2*Npol;
 	}
 	if (Ibont(k+1, i) == 1) {  // Relations entre T1y et T2x:
 	  if ((k+1) <= nb3d) { 
-	    Ok = ToolLine::Tangency(SSP, Npt, tabV);
+	    ToolLine::Tangency(SSP, Npt, tabV);
 	    V = tabV(k+1);
 	    T2 = V.X();
 	  }
 	  else {
-	    Ok = ToolLine::Tangency(SSP, Npt, tabV2d);
+	    ToolLine::Tangency(SSP, Npt, tabV2d);
 	    V2d = tabV2d(k+1-nb3d);
 	    T2 = V2d.X();
 	  }
@@ -356,12 +355,12 @@ AppParCurves_ResolConstraint::
 	}
 	else if (Ibont(k+1, i) == 2) {  // Relations entre T1y et T2y:
 	  if ((k+1) <= nb3d) { 
-	    Ok = ToolLine::Tangency(SSP, Npt, tabV);
+	    ToolLine::Tangency(SSP, Npt, tabV);
 	    V = tabV(k+1);
 	    T2 = V.Y();
 	  }
 	  else { 
-	    Ok = ToolLine::Tangency(SSP, Npt, tabV2d);
+	    ToolLine::Tangency(SSP, Npt, tabV2d);
 	    V2d = tabV2d(k+1-nb3d);
 	    T2 = V2d.Y();
 	  }
@@ -374,7 +373,7 @@ AppParCurves_ResolConstraint::
 
 	}
 	else if (Ibont(k+1,i)== 3) {    // Relations entre T1y et T2z:
-	  Ok = ToolLine::Tangency(SSP, Npt, tabV);
+	  ToolLine::Tangency(SSP, Npt, tabV);
 	  V = tabV(k+1);
 	  T2 = V.Z();
 	  for (j = 1; j <=  Npol; j++) {
@@ -387,18 +386,18 @@ AppParCurves_ResolConstraint::
       }
 
       else {
-	Ok = ToolLine::Tangency(SSP, Npt, tabV);
+	ToolLine::Tangency(SSP, Npt, tabV);
 	V = tabV(k);
 	T1 = V.Z();
 	IP = 3*Npol;
 	if (Ibont(k+1, i) == 1) {  // Relations entre T1z et T2x:
 	  if ((k+1) <= nb3d) { 
-	    Ok = ToolLine::Tangency(SSP, Npt, tabV);
+	    ToolLine::Tangency(SSP, Npt, tabV);
 	    V = tabV(k+1);
 	    T2 = V.X();
 	  }
 	  else { 
-	    Ok = ToolLine::Tangency(SSP, Npt, tabV2d);
+	    ToolLine::Tangency(SSP, Npt, tabV2d);
 	    V2d = tabV2d(k+1-nb3d);
 	    T2 = V2d.X();
 	  }
@@ -412,12 +411,12 @@ AppParCurves_ResolConstraint::
 
 	else if (Ibont(k+1, i) == 2) {  // Relations entre T1z et T2y:   
 	  if ((k+1) <= nb3d) {
-	    Ok = ToolLine::Tangency(SSP, Npt, tabV);
+	    ToolLine::Tangency(SSP, Npt, tabV);
 	    V = tabV(k+1);
 	    T2 = V.Y();
 	  }
 	  else { 
-	    Ok = ToolLine::Tangency(SSP, Npt, tabV2d);
+	    ToolLine::Tangency(SSP, Npt, tabV2d);
 	    V2d = tabV2d(k+1-nb3d);
 	    T2 = V2d.Y();
 	  }
@@ -430,7 +429,7 @@ AppParCurves_ResolConstraint::
 	}
 
 	else if (Ibont(k+1,i)==3) {      // Relations entre T1z et T2z:
-	  Ok = ToolLine::Tangency(SSP, Npt, tabV);
+	  ToolLine::Tangency(SSP, Npt, tabV);
 	  V = tabV(k+1);
 	  T2 = V.Z();
 	  for (j = 1; j <=  Npol; j++) {
@@ -623,7 +622,6 @@ const math_Matrix& AppParCurves_ResolCon
   Standard_Integer IP;
   Standard_Real Daij;
   Npol = Deg+1; Npol2 = 2*Npol;
-  Standard_Boolean Ok;
   TColStd_Array2OfInteger Ibont(1, NbCu, 1, IncTan);
   math_Matrix DeCInit(1, IncPass, 1, Npol);
   math_Vector DDA(1, Npol);
@@ -670,7 +668,7 @@ const math_Matrix& AppParCurves_ResolCon
 	Npt = ITan(i);
 //	MultiPoint MPoint = ToolLine::Value(SSP, Npt);
 	// choix du maximum de tangence pour exprimer la colinearite:
-	Ok = ToolLine::Tangency(SSP, Npt, tabV);
+	ToolLine::Tangency(SSP, Npt, tabV);
 	V = tabV(k);
 	V.Coord(T1, T2, T3);
 	Tmax = Abs(T1);
@@ -719,7 +717,7 @@ const math_Matrix& AppParCurves_ResolCon
       for (i = 1; i <= IncTan; i++) {
 	Npt = ITan(i);
 	AppParCurves::SecondDerivativeBernstein(Parameters(Npt), DDA);
-	Ok = ToolLine::Tangency(SSP, Npt, tabV2d);
+	ToolLine::Tangency(SSP, Npt, tabV2d);
 	V2d = tabV2d(k);
 	V2d.Coord(T1, T2);
 	Tmax = Abs(T1);
@@ -751,25 +749,25 @@ const math_Matrix& AppParCurves_ResolCon
       Inc3 = Inc3 + 1;
       if (Ibont(k, i) == 1) {
 	if (k <= nb3d) {
-	  Ok = ToolLine::Tangency(SSP, Npt, tabV);
+	  ToolLine::Tangency(SSP, Npt, tabV);
 	  V = tabV(k);
 	  T1 = V.X(); 
 	  IP = 3*Npol;
 	}
 	else { 
-	  Ok = ToolLine::Tangency(SSP, Npt, tabV2d);
+	  ToolLine::Tangency(SSP, Npt, tabV2d);
 	  V2d = tabV2d(k);
 	  T1 = V2d.X(); 
 	  IP = 2*Npol;
 	}
 	if (Ibont(k+1, i) == 1) {  // Relations entre T1x et T2x:
 	  if ((k+1) <= nb3d) { 
-	    Ok = ToolLine::Tangency(SSP, Npt, tabV);
+	    ToolLine::Tangency(SSP, Npt, tabV);
 	    V = tabV(k+1);
 	    T2 = V.X();
 	  }
 	  else { 
-	    Ok = ToolLine::Tangency(SSP, Npt, tabV2d);
+	    ToolLine::Tangency(SSP, Npt, tabV2d);
 	    V2d = tabV2d(k+1);
 	    T2 = V2d.X();
 	  }
@@ -782,12 +780,12 @@ const math_Matrix& AppParCurves_ResolCon
 	}
 	else if (Ibont(k+1, i) == 2) {  // Relations entre T1x et T2y:
 	  if ((k+1) <= nb3d) { 
-	    Ok = ToolLine::Tangency(SSP, Npt, tabV);
+	    ToolLine::Tangency(SSP, Npt, tabV);
 	    V = tabV(k+1);
 	    T2 = V.Y();
 	  }
 	  else { 
-	    Ok = ToolLine::Tangency(SSP, Npt, tabV2d);
+	    ToolLine::Tangency(SSP, Npt, tabV2d);
 	    V2d = tabV2d(k+1);
 	    T2 = V2d.Y();
 	  }
@@ -799,7 +797,7 @@ const math_Matrix& AppParCurves_ResolCon
 	  IncCol = IncCol + IP;
 	}
 	else if (Ibont(k+1,i) == 3) {    // Relations entre T1x et T2z:
-	  Ok = ToolLine::Tangency(SSP, Npt, tabV);
+	  ToolLine::Tangency(SSP, Npt, tabV);
 	  V = tabV(k+1);
 	  T2 = V.Z();
 	  for (j = 1; j <=  Npol; j++) {
@@ -812,25 +810,25 @@ const math_Matrix& AppParCurves_ResolCon
       }
       else if (Ibont(k,i) == 2) {  
 	if (k <= nb3d) { 
-	  Ok = ToolLine::Tangency(SSP, Npt, tabV);
+	  ToolLine::Tangency(SSP, Npt, tabV);
 	  V = tabV(k);
 	  T1 = V.Y();
 	  IP = 3*Npol;
 	}
 	else { 
-	  Ok = ToolLine::Tangency(SSP, Npt, tabV2d);
+	  ToolLine::Tangency(SSP, Npt, tabV2d);
 	  V2d = tabV2d(k);
 	  T1 = V2d.Y();
 	  IP = 2*Npol;
 	}
 	if (Ibont(k+1, i) == 1) {  // Relations entre T1y et T2x:
 	  if ((k+1) <= nb3d) { 
-	    Ok = ToolLine::Tangency(SSP, Npt, tabV);
+	    ToolLine::Tangency(SSP, Npt, tabV);
 	    V = tabV(k+1);
 	    T2 = V.X();
 	  }
 	  else {
-	    Ok = ToolLine::Tangency(SSP, Npt, tabV2d);
+	    ToolLine::Tangency(SSP, Npt, tabV2d);
 	    V2d = tabV2d(k+1);
 	    T2 = V2d.X();
 	  }
@@ -844,12 +842,12 @@ const math_Matrix& AppParCurves_ResolCon
 	}
 	else if (Ibont(k+1, i) == 2) {  // Relations entre T1y et T2y:
 	  if ((k+1) <= nb3d) { 
-	    Ok = ToolLine::Tangency(SSP, Npt, tabV);
+	    ToolLine::Tangency(SSP, Npt, tabV);
 	    V = tabV(k+1);
 	    T2 = V.Y();
 	  }
 	  else { 
-	    Ok = ToolLine::Tangency(SSP, Npt, tabV2d);
+	    ToolLine::Tangency(SSP, Npt, tabV2d);
 	    V2d = tabV2d(k+1);
 	    T2 = V2d.Y();
 	  }
@@ -862,7 +860,7 @@ const math_Matrix& AppParCurves_ResolCon
 
 	}
 	else if (Ibont(k+1,i)== 3) {    // Relations entre T1y et T2z:
-	  Ok = ToolLine::Tangency(SSP, Npt, tabV);
+	  ToolLine::Tangency(SSP, Npt, tabV);
 	  V = tabV(k+1);
 	  T2 = V.Z();
 	  for (j = 1; j <=  Npol; j++) {
@@ -875,18 +873,18 @@ const math_Matrix& AppParCurves_ResolCon
       }
 
       else {
-	Ok = ToolLine::Tangency(SSP, Npt, tabV);
+	ToolLine::Tangency(SSP, Npt, tabV);
 	V = tabV(k);
 	T1 = V.Z();
 	IP = 3*Npol;
 	if (Ibont(k+1, i) == 1) {  // Relations entre T1z et T2x:
 	  if ((k+1) <= nb3d) { 
-	    Ok = ToolLine::Tangency(SSP, Npt, tabV);
+	    ToolLine::Tangency(SSP, Npt, tabV);
 	    V = tabV(k+1);
 	    T2 = V.X();
 	  }
 	  else { 
-	    Ok = ToolLine::Tangency(SSP, Npt, tabV2d);
+	    ToolLine::Tangency(SSP, Npt, tabV2d);
 	    V2d = tabV2d(k+1);
 	    T2 = V2d.X();
 	  }
@@ -900,12 +898,12 @@ const math_Matrix& AppParCurves_ResolCon
 
 	else if (Ibont(k+1, i) == 2) {  // Relations entre T1z et T2y:   
 	  if ((k+1) <= nb3d) {
-	    Ok = ToolLine::Tangency(SSP, Npt, tabV);
+	    ToolLine::Tangency(SSP, Npt, tabV);
 	    V = tabV(k+1);
 	    T2 = V.Y();
 	  }
 	  else { 
-	    Ok = ToolLine::Tangency(SSP, Npt, tabV2d);
+	    ToolLine::Tangency(SSP, Npt, tabV2d);
 	    V2d = tabV2d(k+1);
 	    T2 = V2d.Y();
 	  }
@@ -918,7 +916,7 @@ const math_Matrix& AppParCurves_ResolCon
 	}
 
 	else if (Ibont(k+1,i)==3) {      // Relations entre T1z et T2z:
-	  Ok = ToolLine::Tangency(SSP, Npt, tabV);
+	  ToolLine::Tangency(SSP, Npt, tabV);
 	  V = tabV(k+1);
 	  T2 = V.Z();
 	  for (j = 1; j <=  Npol; j++) {
Index: oce/inc/ApproxInt_ImpPrmSvSurfaces.gxx
===================================================================
--- oce.orig/inc/ApproxInt_ImpPrmSvSurfaces.gxx
+++ oce/inc/ApproxInt_ImpPrmSvSurfaces.gxx
@@ -46,11 +46,7 @@ void ApproxInt_ImpPrmSvSurfaces::Pnt(con
   Standard_Real tu2=u2;
   Standard_Real tv1=v1;
   Standard_Real tv2=v2;
-#ifdef DEB
-  Standard_Boolean t=this->Compute(tu1,tv1,tu2,tv2,aP,aT,aTS1,aTS2);
-#else
   this->Compute(tu1,tv1,tu2,tv2,aP,aT,aTS1,aTS2);
-#endif
   P=MyPnt;
 }
 //--------------------------------------------------------------------------------
Index: oce/inc/ApproxInt_PrmPrmSvSurfaces.gxx
===================================================================
--- oce.orig/inc/ApproxInt_PrmPrmSvSurfaces.gxx
+++ oce/inc/ApproxInt_PrmPrmSvSurfaces.gxx
@@ -92,11 +92,7 @@ Standard_Boolean ApproxInt_PrmPrmSvSurfa
   Param(1) = u1; Param(2) = v1;
   Param(3) = u2; Param(4) = v2;
   math_FunctionSetRoot  Rsnld(MyIntersectionOn2S.Function());
-#ifdef DEB
-  IntImp_ConstIsoparametric ChoixIso = MyIntersectionOn2S.Perform(Param,Rsnld);
-#else
   MyIntersectionOn2S.Perform(Param,Rsnld);
-#endif
   if (!MyIntersectionOn2S.IsDone())  { 
     MyHasBeenComputed = MyHasBeenComputedbis = Standard_False;
     return(Standard_False);
@@ -199,11 +195,7 @@ void ApproxInt_PrmPrmSvSurfaces::Pnt(con
   Standard_Real tu2=u2;
   Standard_Real tv1=v1;
   Standard_Real tv2=v2;
-#ifdef DEB
-  Standard_Boolean t=this->Compute(tu1,tv1,tu2,tv2,aP,aT,aTS1,aTS2);
-#else
   this->Compute(tu1,tv1,tu2,tv2,aP,aT,aTS1,aTS2);
-#endif
   P=MyPnt;
 }
 //--------------------------------------------------------------------------------
Index: oce/inc/Approx_ComputeLine.gxx
===================================================================
--- oce.orig/inc/Approx_ComputeLine.gxx
+++ oce/inc/Approx_ComputeLine.gxx
@@ -78,7 +78,6 @@ static void DUMP(const AppParCurves_Mult
   static Standard_Integer nbappel = 0;
   Standard_Integer i;
   Standard_Integer nbpoles = C.NbPoles();
-  Standard_Integer deg = C.Degree();
 
   Handle(Geom_BezierCurve) BSp;
   Handle(Geom2d_BezierCurve) BSp2d;
@@ -601,7 +600,6 @@ void Approx_ComputeLine::Perform(const M
 	// ========================================
 	GoUp = Standard_False;
 	Ok = Standard_True;
-	Standard_Boolean FailOnPointsAdded = Standard_False;
 	if (MyStatus == Approx_PointsAdded) {
 	  // Appel recursif du decoupage:
 	  GoUp = Standard_True;
@@ -615,7 +613,6 @@ void Approx_ComputeLine::Perform(const M
 	  //-- Si MakeML a echoue   on retourne une ligne vide
 	  
 	  if(    (nbpdsotherligne == 0) || nbML >= 3) { 
-	    FailOnPointsAdded = Standard_True; 
 	    //-- cout<<" ** ApproxComputeLine MakeML Echec ** LBR lbr "<<endl;
 	    if (myfirstpt == mylastpt) break;  // Pour etre sur de ne pas 
 	    // planter la station !!
@@ -810,11 +807,10 @@ void Approx_ComputeLine::Parameters(cons
 			       const Standard_Integer lastP,
 			       math_Vector& TheParameters) const
 {
-  Standard_Integer i, j, Nbp, nbP2d, nbP3d;
+  Standard_Integer i, j, nbP2d, nbP3d;
   Standard_Real dist;
   gp_Pnt P1, P2;
   gp_Pnt2d P12d, P22d;
-  Nbp = lastP-firstP+1;
 
   if (Par == Approx_ChordLength || Par == Approx_Centripetal) {
     nbP3d = LineTool::NbP3d(Line);
@@ -976,12 +972,12 @@ Standard_Boolean  Approx_ComputeLine::Co
   gp_Vec2d V12d, V22d;
   gp_Pnt P1, P2;
   gp_Pnt2d P12d, P22d;
-  Standard_Boolean Tangent1, Tangent2, Parallel, mydone= Standard_False;
+  Standard_Boolean Tangent1, Tangent2, mydone= Standard_False;
+#ifdef DEB
+  Standard_Boolean Parallel;
+#endif
   Standard_Integer myfirstpt = firstpt, mylastpt = lastpt;
   Standard_Integer nbp = lastpt-firstpt+1, Kopt = 0;
-  AppParCurves_Constraint FirstC, LastC;
-  FirstC = AppParCurves_PassPoint;
-  LastC = AppParCurves_PassPoint;
   math_Vector Para(firstpt, lastpt);
 
   Parameters(Line, firstpt, lastpt, Para);
@@ -1024,13 +1020,17 @@ Standard_Boolean  Approx_ComputeLine::Co
   if (nbp == 2) {
     // S il n y a que 2 points, on verifie quand meme que les tangentes sont 
     // alignees.
+#ifdef DEB
     Parallel = Standard_True;
+#endif
     if (Tangent1) {
       for (i = 1; i <= nbP3d; i++) {
 	gp_Vec PVec(tabP1(i), tabP2(i));
 	V13d = tabV1(i);
 	if (!PVec.IsParallel(V13d, Precision::Angular())) {
+#ifdef DEB
 	  Parallel = Standard_False;
+#endif
 	  break;
 	}
       }
@@ -1038,7 +1038,9 @@ Standard_Boolean  Approx_ComputeLine::Co
 	gp_Vec2d PVec2d(tabP12d(i), tabP22d(i));
 	V12d = tabV12d(i);
 	if (!PVec2d.IsParallel(V12d, Precision::Angular())) {
+#ifdef DEB
 	  Parallel = Standard_False;
+#endif
 	  break;
 	}
       }
@@ -1049,7 +1051,9 @@ Standard_Boolean  Approx_ComputeLine::Co
 	gp_Vec PVec(tabP1(i), tabP2(i));
 	V23d = tabV2(i);
 	if (!PVec.IsParallel(V23d, Precision::Angular())) {
+#ifdef DEB
 	  Parallel = Standard_False;
+#endif
 	  break;
 	}
       }
@@ -1057,7 +1061,9 @@ Standard_Boolean  Approx_ComputeLine::Co
 	gp_Vec2d PVec2d(tabP12d(i), tabP22d(i));
 	V22d = tabV22d(i);
 	if (!PVec2d.IsParallel(V22d, Precision::Angular())) {
+#ifdef DEB
 	  Parallel = Standard_False;
+#endif
 	  break;
 	}
       }
Index: oce/inc/Blend_CSWalking_2.gxx
===================================================================
--- oce.orig/inc/Blend_CSWalking_2.gxx
+++ oce/inc/Blend_CSWalking_2.gxx
@@ -155,7 +155,7 @@ Blend_Status Blend_CSWalking::CheckDefle
 
   Standard_Real Norme, prevNorme, Cosi, Cosi2; // JAG MODIF 25.04.94
   Standard_Real FlecheCourante;
-  Standard_Real Du,Dv,Duv,SqrtDuv;
+  Standard_Real Du,Dv,Duv;
   Standard_Real paramu,paramv,tolu,tolv;
 //  TColgp_Array1OfPnt Poles(1,4);
 //  gp_Pnt POnCurv,Milieu;
@@ -193,7 +193,6 @@ Blend_Status Blend_CSWalking::CheckDefle
   Du = Ponsurf.X() - paramu;
   Dv = Ponsurf.Y() - paramv;
   Duv = Du * Du + Dv * Dv;
-  SqrtDuv = Sqrt(Duv);
   if ((Abs(Du) < tolu && Abs(Dv) < tolv) ||  // JAG MODIF 25.04.94
       (Abs(previousd2d.X()) < tolu && Abs(previousd2d.Y()) < tolv)){
     // il faudra peut etre  forcer meme point   JAG MODIF 25.04.94
Index: oce/inc/Blend_Walking_1.gxx
===================================================================
--- oce.orig/inc/Blend_Walking_1.gxx
+++ oce/inc/Blend_Walking_1.gxx
@@ -168,8 +168,6 @@ Standard_Boolean Blend_Walking::PerformF
 
   Pos1 = Pos2 = TopAbs_UNKNOWN;
 
-  Blend_Status State;
-
   param = Pdep;
   Func.Set(param);
 
@@ -193,7 +191,7 @@ Standard_Boolean Blend_Walking::PerformF
     return Standard_False;
   }
 
-  State = TestArret(Func, Blend_OK, Standard_False);
+  TestArret(Func, Blend_OK, Standard_False);
 #ifdef DEB
   if (Blend_GettraceDRAWSECT()){
     Drawsect(surf1,surf2,sol,param,Func);
Index: oce/inc/Extrema_GLocateExtCC.gxx
===================================================================
--- oce.orig/inc/Extrema_GLocateExtCC.gxx
+++ oce/inc/Extrema_GLocateExtCC.gxx
@@ -15,13 +15,6 @@ Extrema_GLocateExtCC::Extrema_GLocateExt
 					    const Standard_Real V0)
 {
 
-#ifdef DEB
-  GeomAbs_CurveType type1 = Tool1::GetType(C1);
-  GeomAbs_CurveType type2 = Tool2::GetType(C2);
-#else
-  Tool1::GetType(C1);
-  Tool2::GetType(C2);
-#endif
   Standard_Real TolU = C1.Resolution(Precision::Confusion());
   Standard_Real TolV = C2.Resolution(Precision::Confusion());
   Extrema_POnCurv P1, P2;
Index: oce/inc/Extrema_GLocateExtCC2d.gxx
===================================================================
--- oce.orig/inc/Extrema_GLocateExtCC2d.gxx
+++ oce/inc/Extrema_GLocateExtCC2d.gxx
@@ -21,13 +21,6 @@ Extrema_GLocateExtCC2d::Extrema_GLocateE
 						const Standard_Real U0,
 						const Standard_Real V0)
 {
-#ifdef DEB
-  GeomAbs_CurveType type1 = Tool1::GetType(C1);
-  GeomAbs_CurveType type2 = Tool2::GetType(C2);
-#else
-  Tool1::GetType(C1);
-  Tool2::GetType(C2);
-#endif
   Standard_Real TolU = Tool1::Resolution(C1, Precision::Confusion());
   Standard_Real TolV = Tool2::Resolution(C2, Precision::Confusion());
   Extrema_POnCurv2d P1, P2;
Index: oce/inc/Extrema_GLocateExtPC.gxx
===================================================================
--- oce.orig/inc/Extrema_GLocateExtPC.gxx
+++ oce/inc/Extrema_GLocateExtPC.gxx
@@ -97,11 +97,6 @@ void Extrema_GLocateExtPC::Perform(const
 				   const Standard_Real U0)
 {
   Standard_Integer i, i1, i2, inter;
-#ifdef DEB
-  Standard_Real Tol = TheCurveTool::Resolution(*((TheCurve*)myC), Precision::Confusion());
-#else
-  TheCurveTool::Resolution(*((TheCurve*)myC), Precision::Confusion());
-#endif
   Standard_Real Par, valU, valU2 = RealLast(),
   local_u0 ;
   Standard_Real myintuinf=0, myintusup=0;
Index: oce/inc/Extrema_GenExtCC.gxx
===================================================================
--- oce.orig/inc/Extrema_GenExtCC.gxx
+++ oce/inc/Extrema_GenExtCC.gxx
@@ -140,8 +140,6 @@ a- Constitution du tableau des distances
   U0 = aCache1->TrimFirstParameter() + (U0/2.);
   V0 = aCache2->TrimFirstParameter() + (V0/2.);
 
-  const Curve1& aCurve1 = *((Curve1*)(myF.CurvePtr (1)));
-  const Curve2& aCurve2 = *((Curve1*)(myF.CurvePtr (2)));
   const Handle(ArrayOfPnt)& aPntArray1 = aCache1->Points();
   const Handle(ArrayOfPnt)& aPntArray2 = aCache2->Points();
   Standard_Integer NoU, NoV;
Index: oce/inc/GCPnts_TangentialDeflection.gxx
===================================================================
--- oce.orig/inc/GCPnts_TangentialDeflection.gxx
+++ oce/inc/GCPnts_TangentialDeflection.gxx
@@ -355,8 +355,6 @@ void GCPnts_TangentialDeflection::Perfor
     TooSmall   = Standard_False;
     Correction = Standard_True;
 
-    Standard_Real lastCoef = 0;
-     
     while (Correction) {                     //Ajustement Du
       MiddleU = (U1+U2)*0.5;                 //Verif / au point milieu
       D0 (C, MiddleU, MiddlePoint);
@@ -401,7 +399,6 @@ void GCPnts_TangentialDeflection::Perfor
           }
           else {
             TooSmall = Standard_True;
-            lastCoef = Coef;
             //Standard_Real UUU2 = U2;
             Du += Min((U2-U1)*(1.-Coef), Du*Us3);
 
Index: oce/inc/GCPnts_UniformAbscissa.gxx
===================================================================
--- oce.orig/inc/GCPnts_UniformAbscissa.gxx
+++ oce/inc/GCPnts_UniformAbscissa.gxx
@@ -156,15 +156,11 @@ PerformLengthParametrized( Handle(TColSt
 {
   Standard_Boolean NotDone = Standard_True;
 //  Standard_Boolean LocalDone = Standard_True;
-  Standard_Boolean Forward = Standard_True  ;
   Standard_Real UU1 = Min(U1, U2);
 //  Standard_Real UCurrent;
   Standard_Real Delta, Ui;
   Standard_Real UU2 = Max(U1, U2);
-#ifdef DEB
-  Standard_Real L = 
-#endif
-    CPnts_AbscissaPoint::Length(C, UU1, UU2);
+  CPnts_AbscissaPoint::Length(C, UU1, UU2);
   Standard_Integer   Index ;
 
 // Ratio is defined as dl = Ratio * du
@@ -174,7 +170,6 @@ PerformLengthParametrized( Handle(TColSt
 
 
   if (Abscissa < 0.0e0)    {
-    Forward = Standard_False ;
     UU2 = Min(U1, U2);
     UU1 = Max(U1, U2);
   }
Index: oce/inc/GProp_SGProps.gxx
===================================================================
--- oce.orig/inc/GProp_SGProps.gxx
+++ oce/inc/GProp_SGProps.gxx
@@ -420,7 +420,7 @@ static void Compute(Face& S, Domain& D,
    Standard_Integer NbCGaussgp_Pnts = 0;
 
    Standard_Real l1, l2, lm, lr, l;   //boundary curve parametrization
-   Standard_Real v1, v2, vm, vr, v;   //Face parametrization in v direction
+   Standard_Real v1, v2, v;   //Face parametrization in v direction
    Standard_Real u1, u2, um, ur, u;
    Standard_Real ds;                  //Jacobien (x, y, z) -> (u, v) = ||n||
 
@@ -474,9 +474,7 @@ static void Compute(Face& S, Domain& D,
       lr = 0.5 * (l2 - l1);
 
       Puv = S.Value2d (lm);
-      vm  = Puv.Y();
       Puv = S.Value2d (lr);
-      vr  = Puv.Y();
 
       for (Standard_Integer i = 1; i <= NbCGaussgp_Pnts; i++) {
         l = lm + lr * GaussCP (i);
Index: oce/inc/GProp_TFunction.gxx
===================================================================
--- oce.orig/inc/GProp_TFunction.gxx
+++ oce/inc/GProp_TFunction.gxx
@@ -75,8 +75,6 @@ Standard_Boolean GProp_TFunction::Value(
   // Compute the integral from myUMin to aUMax of myUFunction.
   Standard_Integer i;
   Standard_Real    aCoeff        = aV2d.Y();
-  Standard_Integer aNbUIntervals = anUKnots->Length() - 1;
-  //Standard_Real    aTol          = myTolerance/aNbUIntervals;
   Standard_Real    aTol          = myTolerance;
 
   //aTol /= myNbPntOuter;
Index: oce/inc/GccGeo_Circ2d2TanOn.gxx
===================================================================
--- oce.orig/inc/GccGeo_Circ2d2TanOn.gxx
+++ oce/inc/GccGeo_Circ2d2TanOn.gxx
@@ -141,7 +141,6 @@ GccGeo_Circ2d2TanOn::
 	    Standard_Real dist1 = Center.Distance(C1.Location());
 	    Standard_Real dist2 = Center.Distance(C2.Location());
 	    Standard_Integer nbsol = 0;
-	    Standard_Integer nsol = 0;
 	    Standard_Integer nnsol = 0;
 	    R1 = C1.Radius();
 	    R2 = C2.Radius();
@@ -168,22 +167,18 @@ GccGeo_Circ2d2TanOn::
 	    }
 	    if (Qualified2.IsEnclosed() && nbsol != 0) {
 	      if (dist2-R2 < Tol) {
-		nsol = 1;
 		RBid(1) = Abs(R2-dist2);
 	      }
 	    }
 	    else if (Qualified2.IsOutside() && nbsol != 0) {
 	      if (R2-dist2 < Tol) {
-		nsol = 1;
 		RBid(1) = Abs(R2-dist2);
 	      }
 	    }
 	    else if (Qualified2.IsEnclosing() && nbsol != 0) {
-	      nsol = 1;
 	      RBid(1) = dist2+R2;
 	    }
 	    else if (Qualified2.IsUnqualified() && nbsol != 0) {
-	      nsol = 1;
 	      RBid(1) = dist2+R2;
 	      RBid(2) = Abs(R2-dist2);
 	    }
Index: oce/inc/GccGeo_Circ2dTanOnRad.gxx
===================================================================
--- oce.orig/inc/GccGeo_Circ2dTanOnRad.gxx
+++ oce/inc/GccGeo_Circ2dTanOnRad.gxx
@@ -447,13 +447,6 @@ GccGeo_Circ2dTanOnRad::
        cote1(1) = Radius;
        cote1(2) = -Radius;
      }
-#ifdef DEB
-     Standard_Real x1dir = dir1.X();
-     Standard_Real y1dir = dir1.Y();
-#else
-     dir1.X();
-     dir1.Y();
-#endif
      TheIntConicCurve Intp;
      for (Standard_Integer jcote1 = 1 ; jcote1 <= nbrcote1 ; jcote1++) {
        gp_Pnt2d Point(dir1.XY()+cote1(jcote1)*norm1.XY());
@@ -472,11 +465,6 @@ GccGeo_Circ2dTanOnRad::
 	     cirsol(NbrSol) = gp_Circ2d(gp_Ax2d(Center,dirx),Radius);
 //           =======================================================
 	     gp_Dir2d dc1(origin1.XY()-Center.XY());
-#ifdef DEB
-	     Standard_Real sign = dc1.Dot(norm1);
-#else
-             dc1.Dot(norm1);
-#endif
 	     if (!Qualified1.IsUnqualified()) { 
 	       qualifier1(NbrSol) = Qualified1.Qualifier();
 	     }
Index: oce/inc/GccIter_Circ2d2TanOn.gxx
===================================================================
--- oce.orig/inc/GccIter_Circ2d2TanOn.gxx
+++ oce/inc/GccIter_Circ2d2TanOn.gxx
@@ -76,11 +76,6 @@ GccIter_Circ2d2TanOn::
    Ufirst(4) = (point3.Distance(point2)+point3.Distance(point1))/2.;
    GccIter_FuncTCuCuOnCu Func(L1,Cu2,OnLine,Ufirst(4));
    math_FunctionSetRoot Root(Func,Ufirst,tol,Umin,Umax);
-#ifdef DEB
-   Standard_Boolean Ok = Func.Value(Ufirst,Umin);
-#else
-   Func.Value(Ufirst,Umin);
-#endif
    if (Root.IsDone()) {
      Root.Root(Ufirst);
 //     gp_Vec2d Tan1,Tan2,Nor1,Nor2;
@@ -93,17 +88,11 @@ GccIter_Circ2d2TanOn::
      Standard_Real dist2 = point3.Distance(point2);
      if ( Abs(dist1-dist2)/2. <= Tol) {
        cirsol = gp_Circ2d(gp_Ax2d(point3,dirx),(dist1+dist2)/2.);
-       Standard_Real normetan1 = Tan1.Magnitude();
        Standard_Real normetan2 = Tan2.Magnitude();
        gp_Vec2d Vec1(point1,point3);
        gp_Vec2d Vec2(point2,point3);
-       Standard_Real normevec1 = Vec1.Magnitude();
        Standard_Real normevec2 = Vec2.Magnitude();
-       Standard_Real angle1,angle2;
-       if (normevec1 >= gp::Resolution() && normetan1 >= gp::Resolution()) {
-	 angle1 = Vec1.Angle(Tan1);
-       }
-       else { angle1 = 0.; }
+       Standard_Real angle2;
        if (normevec2 >= gp::Resolution() && normetan2 >= gp::Resolution()) {
 	 angle2 = Vec2.Angle(Tan2);
        }
@@ -187,11 +176,6 @@ GccIter_Circ2d2TanOn::
    Ufirst(4) = (point3.Distance(point2)+point3.Distance(point1))/2.;
    GccIter_FuncTCuCuOnCu Func(Cu1,Cu2,OnLine,Ufirst(4));
    math_FunctionSetRoot Root(Func,Ufirst,tol,Umin,Umax);
-#ifdef DEB
-   Standard_Boolean Ok = Func.Value(Ufirst,Umin);
-#else
-   Func.Value(Ufirst,Umin);
-#endif
    if (Root.IsDone()) {
      Root.Root(Ufirst);
      gp_Vec2d Tan1,Tan2;
@@ -287,11 +271,6 @@ GccIter_Circ2d2TanOn::
    Ufirst(3) = (point3.Distance(Point2)+point3.Distance(point1))/2.;
    GccIter_FuncTCuCuOnCu Func(Cu1,Point2,OnLine,Ufirst(3));
    math_FunctionSetRoot Root(Func,Ufirst,tol,Umin,Umax);
-#ifdef DEB
-   Standard_Boolean Ok = Func.Value(Ufirst,Umin);
-#else
-   Func.Value(Ufirst,Umin);
-#endif
    if (Root.IsDone()) {
      Root.Root(Ufirst);
      gp_Pnt2d point1,point3;
@@ -384,11 +363,6 @@ GccIter_Circ2d2TanOn::
    Ufirst(4) = (point3.Distance(point2)+point3.Distance(point1))/2.;
    GccIter_FuncTCuCuOnCu Func(C1,Cu2,OnLine,Ufirst(4));
    math_FunctionSetRoot Root(Func,Ufirst,tol,Umin,Umax);
-#ifdef DEB
-   Standard_Boolean Ok = Func.Value(Ufirst,Umin);
-#else
-   Func.Value(Ufirst,Umin);
-#endif
    if (Root.IsDone()) {
      Root.Root(Ufirst);
 //     gp_Vec2d Tan1,Tan2,Nor1,Nor2;
@@ -405,17 +379,11 @@ GccIter_Circ2d2TanOn::
      Standard_Real dist2 = point3.Distance(point2);
      if ( Abs(dist1-dist2)/2. <= Tol) {
        cirsol = gp_Circ2d(gp_Ax2d(point3,dirx),(dist1+dist2)/2.);
-       Standard_Real normetan1 = Tan1.Magnitude();
        Standard_Real normetan2 = Tan2.Magnitude();
        gp_Vec2d Vec1(point1,point3);
        gp_Vec2d Vec2(point2,point3);
-       Standard_Real normevec1 = Vec1.Magnitude();
        Standard_Real normevec2 = Vec2.Magnitude();
-       Standard_Real angle1,angle2;
-       if (normevec1 >= gp::Resolution() && normetan1 >= gp::Resolution()) {
-	 angle1 = Vec1.Angle(Tan1);
-       }
-       else { angle1 = 0.; }
+       Standard_Real angle2;
        if (normevec2 >= gp::Resolution() && normetan2 >= gp::Resolution()) {
 	 angle2 = Vec2.Angle(Tan2);
        }
@@ -501,11 +469,6 @@ GccIter_Circ2d2TanOn::
    Ufirst(4) = (point3.Distance(point2)+point3.Distance(point1))/2.;
    GccIter_FuncTCuCuOnCu Func(C1,Cu2,OnCirc,Ufirst(4));
    math_FunctionSetRoot Root(Func,Ufirst,tol,Umin,Umax);
-#ifdef DEB
-   Standard_Boolean Ok = Func.Value(Ufirst,Umin);
-#else
-   Func.Value(Ufirst,Umin);
-#endif
    if (Root.IsDone()) {
      Root.Root(Ufirst);
 //     gp_Vec2d Tan1,Tan2,Nor1;
@@ -520,17 +483,11 @@ GccIter_Circ2d2TanOn::
      Standard_Real dist2 = point3.Distance(point2);
      if ( Abs(dist1-dist2)/2. <= Tol) {
        cirsol = gp_Circ2d(gp_Ax2d(point3,dirx),(dist1+dist2)/2.);
-       Standard_Real normetan1 = Tan1.Magnitude();
        Standard_Real normetan2 = Tan2.Magnitude();
        gp_Vec2d Vec1(point1,point3);
        gp_Vec2d Vec2(point2,point3);
-       Standard_Real normevec1 = Vec1.Magnitude();
        Standard_Real normevec2 = Vec2.Magnitude();
-       Standard_Real angle1,angle2;
-       if (normevec1 >= gp::Resolution() && normetan1 >= gp::Resolution()) {
-	 angle1 = Vec1.Angle(Tan1);
-       }
-       else { angle1 = 0.; }
+       Standard_Real angle2;
        if (normevec2 >= gp::Resolution() && normetan2 >= gp::Resolution()) {
 	 angle2 = Vec2.Angle(Tan2);
        }
@@ -615,11 +572,6 @@ GccIter_Circ2d2TanOn::
    Ufirst(4) = (point3.Distance(point2)+point3.Distance(point1))/2.;
    GccIter_FuncTCuCuOnCu Func(L1,Cu2,OnCirc,Ufirst(4));
    math_FunctionSetRoot Root(Func,Ufirst,tol,Umin,Umax);
-#ifdef DEB
-   Standard_Boolean Ok = Func.Value(Ufirst,Umin);
-#else
-   Func.Value(Ufirst,Umin);
-#endif
    if (Root.IsDone()) {
      Root.Root(Ufirst);
      gp_Pnt2d point1,point2;
@@ -634,17 +586,11 @@ GccIter_Circ2d2TanOn::
      Standard_Real dist2 = point3.Distance(point2);
      if ( Abs(dist1-dist2)/2. <= Tol) {
        cirsol = gp_Circ2d(gp_Ax2d(point3,dirx),(dist1+dist2)/2.);
-       Standard_Real normetan1 = Tan1.Magnitude();
        Standard_Real normetan2 = Tan2.Magnitude();
        gp_Vec2d Vec1(point1,point3);
        gp_Vec2d Vec2(point2,point3);
-       Standard_Real normevec1 = Vec1.Magnitude();
        Standard_Real normevec2 = Vec2.Magnitude();
-       Standard_Real angle1,angle2;
-       if (normevec1 >= gp::Resolution() && normetan1 >= gp::Resolution()) {
-	 angle1 = Vec1.Angle(Tan1);
-       }
-       else { angle1 = 0.; }
+       Standard_Real angle2;
        if (normevec2 >= gp::Resolution() && normetan2 >= gp::Resolution()) {
 	 angle2 = Vec2.Angle(Tan2);
        }
@@ -729,11 +675,6 @@ GccIter_Circ2d2TanOn::
    Ufirst(4) = (point3.Distance(point2)+point3.Distance(point1))/2.;
    GccIter_FuncTCuCuOnCu Func(Cu1,Cu2,OnCirc,Ufirst(4));
    math_FunctionSetRoot Root(Func,Ufirst,tol,Umin,Umax);
-#ifdef DEB
-   Standard_Boolean Ok = Func.Value(Ufirst,Umin);
-#else
-   Func.Value(Ufirst,Umin);
-#endif
    if (Root.IsDone()) {
      Root.Root(Ufirst);
 //     gp_Vec2d Tan1,Tan2,Nor1;
@@ -833,11 +774,6 @@ GccIter_Circ2d2TanOn::
    Ufirst(3) = (point3.Distance(Point2)+point3.Distance(point1))/2.;
    GccIter_FuncTCuCuOnCu Func(Cu1,Point2,OnCirc,Ufirst(3));
    math_FunctionSetRoot Root(Func,Ufirst,tol,Umin,Umax);
-#ifdef DEB
-   Standard_Boolean Ok = Func.Value(Ufirst,Umin);
-#else
-   Func.Value(Ufirst,Umin);
-#endif
    if (Root.IsDone()) {
      Root.Root(Ufirst);
      gp_Pnt2d point1,point3;
@@ -930,11 +866,6 @@ GccIter_Circ2d2TanOn::
    Ufirst(4) = (point3.Distance(point2)+point3.Distance(point1))/2.;
    GccIter_FuncTCuCuOnCu Func(Cu1,Cu2,OnCurv,Ufirst(4));
    math_FunctionSetRoot Root(Func,Ufirst,tol,Umin,Umax);
-#ifdef DEB
-   Standard_Boolean Ok = Func.Value(Ufirst,Umin);
-#else
-   Func.Value(Ufirst,Umin);
-#endif
    if (Root.IsDone()) {
      Root.Root(Ufirst);
      gp_Vec2d Tan1,Tan2,Tan3;
@@ -1039,11 +970,6 @@ GccIter_Circ2d2TanOn::
    Ufirst(4) = (point3.Distance(point2)+point3.Distance(point1))/2.;
    GccIter_FuncTCuCuOnCu Func(C1,Cu2,OnCurv,Ufirst(4));
    math_FunctionSetRoot Root(Func,Ufirst,tol,Umin,Umax);
-#ifdef DEB
-   Standard_Boolean Ok = Func.Value(Ufirst,Umin);
-#else
-   Func.Value(Ufirst,Umin);
-#endif
    if (Root.IsDone()) {
      Root.Root(Ufirst);
      gp_Vec2d Tan1,Tan2,Tan3;
@@ -1055,17 +981,11 @@ GccIter_Circ2d2TanOn::
      if ( Abs(dist1-dist2)/2. <= Tol) {
        gp_Dir2d dirx(1.,0.);
        cirsol = gp_Circ2d(gp_Ax2d(point3,dirx),(dist1+dist2)/2.);
-       Standard_Real normetan1 = Tan1.Magnitude();
        Standard_Real normetan2 = Tan2.Magnitude();
        gp_Vec2d Vec1(point1.XY(),point3.XY());
        gp_Vec2d Vec2(point2.XY(),point3.XY());
-       Standard_Real normevec1 = Vec1.Magnitude();
        Standard_Real normevec2 = Vec2.Magnitude();
-       Standard_Real angle1,angle2;
-       if (normevec1 >= gp::Resolution() && normetan1 >= gp::Resolution()) {
-	 angle1 = Vec1.Angle(Tan1);
-       }
-       else { angle1 = 0.; }
+       Standard_Real angle2;
        if (normevec2 >= gp::Resolution() && normetan2 >= gp::Resolution()) {
 	 angle2 = Vec2.Angle(Tan2);
        }
@@ -1150,11 +1070,6 @@ GccIter_Circ2d2TanOn::
    Ufirst(4) = (point3.Distance(point2)+point3.Distance(point1))/2.;
    GccIter_FuncTCuCuOnCu Func(L1,Cu2,OnCurv,Ufirst(4));
    math_FunctionSetRoot Root(Func,Ufirst,tol,Umin,Umax);
-#ifdef DEB
-   Standard_Boolean Ok = Func.Value(Ufirst,Umin);
-#else
-   Func.Value(Ufirst,Umin);
-#endif
    if (Root.IsDone()) {
      Root.Root(Ufirst);
      gp_Vec2d Tan1,Tan2,Tan3;
@@ -1165,17 +1080,11 @@ GccIter_Circ2d2TanOn::
      Standard_Real dist2 = point3.Distance(point2);
      if ( Abs(dist1-dist2)/2. <= Tol) {
        cirsol = gp_Circ2d(gp_Ax2d(point3,dirx),(dist1+dist2)/2.);
-       Standard_Real normetan1 = Tan1.Magnitude();
        Standard_Real normetan2 = Tan2.Magnitude();
        gp_Vec2d Vec1(point1,point3);
        gp_Vec2d Vec2(point2,point3);
-       Standard_Real normevec1 = Vec1.Magnitude();
        Standard_Real normevec2 = Vec2.Magnitude();
-       Standard_Real angle1,angle2;
-       if (normevec1 >= gp::Resolution() && normetan1 >= gp::Resolution()) {
-	 angle1 = Vec1.Angle(Tan1);
-       }
-       else { angle1 = 0.; }
+       Standard_Real angle2;
        if (normevec2 >= gp::Resolution() && normetan2 >= gp::Resolution()) {
 	 angle2 = Vec2.Angle(Tan2);
        }
@@ -1251,11 +1160,6 @@ GccIter_Circ2d2TanOn::
   Ufirst(3) = (point3.Distance(Point2)+point3.Distance(point1))/2.;
   GccIter_FuncTCuCuOnCu Func(Cu1,Point2,OnCurv,Ufirst(3));
   math_FunctionSetRoot Root(Func,Ufirst,tol,Umin,Umax);
-#ifdef DEB
-  Standard_Boolean Ok = Func.Value(Ufirst,Umin);
-#else
-  Func.Value(Ufirst,Umin);
-#endif
   if (Root.IsDone()) {
     Root.Root(Ufirst);
 //    gp_Vec2d Tan1,Tan2,Tan3;
Index: oce/inc/GccIter_Circ2d3Tan.gxx
===================================================================
--- oce.orig/inc/GccIter_Circ2d3Tan.gxx
+++ oce/inc/GccIter_Circ2d3Tan.gxx
@@ -76,11 +76,6 @@ GccIter_Circ2d3Tan::
    math_FunctionSetRoot Root(Func,Ufirst,tol,Umin,Umax);
    if (Root.IsDone()) {
      Root.Root(Ufirst);
-#ifdef DEB
-     Standard_Boolean Ok = Func.Value(Ufirst,Umin);
-#else
-     Func.Value(Ufirst,Umin);
-#endif
      gp_Pnt2d point1,point2,point3;
      gp_Vec2d Tan1,Tan2,Tan3;
      TheCurveTool::D1(Cu1,Ufirst(1),point1,Tan1);
@@ -203,11 +198,6 @@ GccIter_Circ2d3Tan::
    math_FunctionSetRoot Root(Func,Ufirst,tol,Umin,Umax);
    if (Root.IsDone()) {
      Root.Root(Ufirst);
-#ifdef DEB
-     Standard_Boolean Ok = Func.Value(Ufirst,Umin);
-#else
-     Func.Value(Ufirst,Umin);
-#endif
      gp_Pnt2d centre1(C1.Location());
      Standard_Real R1 = C1.Radius();
      gp_Pnt2d point1(centre1.XY()+R1*gp_XY(Cos(Ufirst(1)),Sin(Ufirst(1))));
@@ -335,11 +325,6 @@ GccIter_Circ2d3Tan::
    math_FunctionSetRoot Root(Func,Ufirst,tol,Umin,Umax);
    if (Root.IsDone()) {
      Root.Root(Ufirst);
-#ifdef DEB
-     Standard_Boolean Ok = Func.Value(Ufirst,Umin);
-#else
-     Func.Value(Ufirst,Umin);
-#endif
      gp_Pnt2d centre1(C1.Location());
      Standard_Real R1 = C1.Radius();
      gp_Pnt2d point1(centre1.XY()+R1*gp_XY(Cos(Ufirst(1)),Sin(Ufirst(1))));
@@ -470,11 +455,6 @@ GccIter_Circ2d3Tan::
    math_FunctionSetRoot Root(Func,Ufirst,tol,Umin,Umax);
    if (Root.IsDone()) {
      Root.Root(Ufirst);
-#ifdef DEB
-     Standard_Boolean Ok = Func.Value(Ufirst,Umin);
-#else
-     Func.Value(Ufirst,Umin);
-#endif
      gp_Pnt2d centre1(L1.Location());
      gp_Pnt2d point1(centre1.XY()+Ufirst(1)*L1.Direction().XY());
      gp_Pnt2d point2,point3;
@@ -605,11 +585,6 @@ GccIter_Circ2d3Tan::
    math_FunctionSetRoot Root(Func,Ufirst,tol,Umin,Umax);
    if (Root.IsDone()) {
      Root.Root(Ufirst);
-#ifdef DEB
-     Standard_Boolean Ok = Func.Value(Ufirst,Umin);
-#else
-     Func.Value(Ufirst,Umin);
-#endif
      gp_Pnt2d centre1(L1.Location());
      gp_Pnt2d point1(centre1.XY()+Ufirst(1)*L1.Direction().XY());
      gp_Pnt2d centre2(L2.Location());
@@ -733,11 +708,6 @@ GccIter_Circ2d3Tan::
    math_FunctionSetRoot Root(Func,Ufirst,tol,Umin,Umax);
    if (Root.IsDone()) {
      Root.Root(Ufirst);
-#ifdef DEB
-     Standard_Boolean Ok = Func.Value(Ufirst,Umin);
-#else
-     Func.Value(Ufirst,Umin);
-#endif
      gp_Pnt2d point1,point2;
 //     gp_Vec2d Tan1,Tan2,Nor1,Nor2;
      gp_Vec2d Tan1,Tan2;
@@ -850,11 +820,6 @@ GccIter_Circ2d3Tan::
    math_FunctionSetRoot Root(Func,Ufirst,tol,Umin,Umax);
    if (Root.IsDone()) {
      Root.Root(Ufirst);
-#ifdef DEB
-     Standard_Boolean Ok = Func.Value(Ufirst,Umin);
-#else
-     Func.Value(Ufirst,Umin);
-#endif
      gp_Pnt2d point3;
 //     gp_Vec2d Tan3,Nor3;
      gp_Vec2d Tan3;
@@ -964,11 +929,6 @@ GccIter_Circ2d3Tan::
    math_FunctionSetRoot Root(Func,Ufirst,tol,Umin,Umax);
    if (Root.IsDone()) {
      Root.Root(Ufirst);
-#ifdef DEB
-     Standard_Boolean Ok = Func.Value(Ufirst,Umin);
-#else
-     Func.Value(Ufirst,Umin);
-#endif
      gp_Pnt2d centre1(L1.Location());
      gp_Pnt2d point1(centre1.XY()+Ufirst(2)*L1.Direction().XY());
      gp_Pnt2d point2;
@@ -1086,11 +1046,6 @@ GccIter_Circ2d3Tan::
    tol(3) = TheCurveTool::EpsX(Cu3,Abs(Tolerance));
    math_FunctionSetRoot Root(Func,Ufirst,tol,Umin,Umax);
    if (Root.IsDone()) {
-#ifdef DEB
-     Standard_Boolean Ok = Func.Value(Ufirst,Umin);
-#else
-     Func.Value(Ufirst,Umin);
-#endif
      Root.Root(Ufirst);
      gp_Pnt2d centre1(C1.Location());
      Standard_Real R1 = C1.Radius();
@@ -1218,11 +1173,6 @@ GccIter_Circ2d3Tan::
    math_FunctionSetRoot Root(Func,Ufirst,tol,Umin,Umax);
    if (Root.IsDone()) {
      Root.Root(Ufirst);
-#ifdef DEB
-     Standard_Boolean Ok = Func.Value(Ufirst,Umin);
-#else
-     Func.Value(Ufirst,Umin);
-#endif
      gp_Pnt2d centre1(C1.Location());
      Standard_Real R1 = C1.Radius();
      gp_Pnt2d point1(centre1.XY()+R1*gp_XY(Cos(Ufirst(1)),Sin(Ufirst(1))));
Index: oce/inc/GccIter_FunctionTanCirCu.gxx
===================================================================
--- oce.orig/inc/GccIter_FunctionTanCirCu.gxx
+++ oce/inc/GccIter_FunctionTanCirCu.gxx
@@ -87,11 +87,6 @@ Standard_Boolean GccIter_FunctionTanCirC
   TheCurveTool::D2(Curve,X,Point,Vect1,Vect2);
   Standard_Real NormeD1 = Vect1.SquareMagnitude();
   gp_Vec2d TheDirection(TheCirc.Location(),Point);
-#ifdef DEB
-  Standard_Real squaredir = TheDirection.SquareMagnitude();
-#else
-  TheDirection.SquareMagnitude();
-#endif
   Standard_Real cp1dott = TheDirection.Dot(Vect1);
   Deriv = -2.*(cp1dott/NormeD1)*
     ((TheDirection.Dot(Vect2))-cp1dott*Vect1.Dot(Vect2)/NormeD1);
Index: oce/inc/GccIter_FunctionTanCuCuOnCu.gxx
===================================================================
--- oce.orig/inc/GccIter_FunctionTanCuCuOnCu.gxx
+++ oce/inc/GccIter_FunctionTanCuCuOnCu.gxx
@@ -290,11 +290,6 @@ Standard_Boolean GccIter_FunctionTanCuCu
 //norme des Tani.
   Standard_Real nnor1 = Tan1.Magnitude();
   Standard_Real nnor2 = Tan2.Magnitude();
-#ifdef DEB
-  Standard_Real nnor3 = Tan3.Magnitude();
-#else
-  Tan3.Magnitude();
-#endif
 // Fonctions Fui.
 // ==============
   Fval(1) = (P3P1.Dot(P3P1)-X(4)*X(4))/(FirstRad*FirstRad);
@@ -323,11 +318,6 @@ Standard_Boolean GccIter_FunctionTanCuCu
 //normales au courbes normees Nori et non nromees nori et norme des nori.
   Standard_Real nnor1 = Tan1.Magnitude();
   Standard_Real nnor2 = Tan2.Magnitude();
-#ifdef DEB
-  Standard_Real nnor3 = Tan3.Magnitude();
-#else
-  Tan3.Magnitude();
-#endif
 // Derivees dFui/uj  1 <= ui <= 3 , 1 <= uj <= 3
 // =============================================
   Deriv(1,1) = 2.*Tan1.Dot(P3P1)/(FirstRad*FirstRad);
@@ -374,11 +364,6 @@ Standard_Boolean GccIter_FunctionTanCuCu
 //normales au courbes normees Nori et non nromees nori et norme des nori.
   Standard_Real nnor1 = Tan1.Magnitude();
   Standard_Real nnor2 = Tan2.Magnitude();
-#ifdef DEB
-  Standard_Real nnor3 = Tan3.Magnitude();
-#else
-  Tan3.Magnitude();
-#endif
 // Fonctions Fui.
 // ==============
   Fval(1) = (P3P1.Dot(P3P1)-X(4)*X(4))/(FirstRad*FirstRad);
Index: oce/inc/GccIter_Lin2d2Tan.gxx
===================================================================
--- oce.orig/inc/GccIter_Lin2d2Tan.gxx
+++ oce/inc/GccIter_Lin2d2Tan.gxx
@@ -26,9 +26,6 @@ GccIter_Lin2d2Tan::
      
    par1sol = 0.;
    pararg1 = 0.;
-#ifdef DEB
-   Standard_Real Tol = Abs(Tolang);
-#endif
    WellDone = Standard_False;
    if (Qualified1.IsEnclosed()) { GccEnt_BadQualifier::Raise(); }
    gp_Circ2d C1 = Qualified1.Qualified();
Index: oce/inc/Graphic3d_ArrayOfPrimitives.lxx
===================================================================
--- oce.orig/inc/Graphic3d_ArrayOfPrimitives.lxx
+++ oce/inc/Graphic3d_ArrayOfPrimitives.lxx
@@ -177,13 +177,9 @@ inline void Graphic3d_ArrayOfPrimitives:
   Standard_Integer aColor;
   VertexColor(anIndex, aColor);
   if( myPrimitiveArray->vcolours ) { 
-    Standard_Integer r,g,b,a;  
+    Standard_Integer r,g,b;  
     Standard_Integer aColor;
     VertexColor(anIndex, aColor);
-    Standard_Real A;
-    a = aColor & 0xff000000;
-    a >>= 24;
-    A = ((Standard_Real) a) / 255.;
 
     b = aColor & 0x00ff0000;
     b >>= 16;
Index: oce/inc/HatchGen_Hatcher.gxx
===================================================================
--- oce.orig/inc/HatchGen_Hatcher.gxx
+++ oce/inc/HatchGen_Hatcher.gxx
@@ -753,10 +753,6 @@ Standard_Boolean HatchGen_Hatcher::Globa
   printf("\n       P:%+10.5g  Tg2d:%+10.5g , %+10.5g  N2d:%+10.5g , %+10.5g  Crv:%+10.5g\n\n",
 	 Point.Parameter(),Tangente.X(),Tangente.Y(),Normale.X(),Normale.Y(),Courbure);
 #endif
-#ifdef DEB
-  Standard_Real ParamAtIntersection = 
-#endif
-    Point.Parameter();
   for (Standard_Integer IPntE = 1 ; IPntE <= Point.NbPoints() ; IPntE++) {
 
     const HatchGen_PointOnElement& PntE = Point.Point (IPntE) ;
Index: oce/inc/Image_GImage.gxx
===================================================================
--- oce.orig/inc/Image_GImage.gxx
+++ oce/inc/Image_GImage.gxx
@@ -300,10 +300,9 @@ void Image_GImage::Rotate180()
 void Image_GImage::FlipHorizontal()
 
 { anyPixel P ;
-  Standard_Integer x, y, HalfX, HalfY ;
+  Standard_Integer x, y, HalfY ;
   Standard_Integer UpX = UpperX() ;
 
-  HalfX = Width()  / 2 ;
   HalfY = Height() / 2 ;
 
 	for ( x = LowerX() ; x <= UpX ; x++ ){
@@ -318,11 +317,10 @@ void Image_GImage::FlipHorizontal()
 void Image_GImage::FlipVertical()
 
 { anyPixel P ;
-  Standard_Integer x, y, HalfX, HalfY ;
+  Standard_Integer x, y, HalfX ;
   Standard_Integer UpY = UpperY() ;
 
   HalfX = Width()  / 2 ;
-  HalfY = Height() / 2 ;
 
 	for ( y = LowerY() ; y <= UpY ; y++ ){
           for ( x = 0 ; x < HalfX ; x++ ) {
Index: oce/inc/IntCurveSurface_Inter.gxx
===================================================================
--- oce.orig/inc/IntCurveSurface_Inter.gxx
+++ oce/inc/IntCurveSurface_Inter.gxx
@@ -419,11 +419,6 @@ void IntCurveSurface_Inter::Perform(cons
   done = Standard_True;
   Standard_Integer NbUOnS = TheSurfaceTool::NbUIntervals(surface,GeomAbs_C2);
   Standard_Integer NbVOnS = TheSurfaceTool::NbVIntervals(surface,GeomAbs_C2);
-#ifdef DEB
-  Standard_Integer NbOnC  = TheCurveTool::NbIntervals(curve,GeomAbs_C2);
-#else
-  TheCurveTool::NbIntervals(curve,GeomAbs_C2);
-#endif
   Standard_Real U0,U1,V0,V1; 
   
   if(NbUOnS > 1) { 
@@ -1069,11 +1064,6 @@ void IntCurveSurface_Inter::InternalPerf
   IntCurveSurface_TheQuadCurvExactInter QuadCurv(surface,curve);  
   if(QuadCurv.IsDone()) { 
     Standard_Integer NbRoots = QuadCurv.NbRoots();
-#ifdef DEB
-    Standard_Integer NbInter = QuadCurv.NbIntervals();
-#else
-    QuadCurv.NbIntervals();
-#endif
     Standard_Real u,v,w;
     for(Standard_Integer i = 1; i<= NbRoots; i++) { 
       w = QuadCurv.Root(i); 
@@ -1127,11 +1117,6 @@ void IntCurveSurface_Inter::InternalPerf
     IntCurveSurface_TheQuadCurvExactInter QuadCurv(surface,curve);  
     if(QuadCurv.IsDone()) { 
       Standard_Integer NbRoots = QuadCurv.NbRoots();
-#ifdef DEB
-      Standard_Integer NbInter = QuadCurv.NbIntervals();
-#else
-      QuadCurv.NbIntervals();
-#endif
       Standard_Real u,v,w;
       for(Standard_Integer i = 1; i<= NbRoots; i++) { 
 	w = QuadCurv.Root(i); 
Index: oce/inc/IntCurveSurface_Polygon.gxx
===================================================================
--- oce.orig/inc/IntCurveSurface_Polygon.gxx
+++ oce/inc/IntCurveSurface_Polygon.gxx
@@ -126,7 +126,6 @@ void IntCurveSurface_Polygon::Init(const
 
   //ddout << "IntCurveSurface_Polygon::Init" << endl;
   Standard_Real u=Binf; 
-  Standard_Real u1=Bsup;
   Standard_Integer i=1, i0 = Upars.Lower()-1;
   gp_Pnt P;
 
Index: oce/inc/IntCurveSurface_Polyhedron.gxx
===================================================================
--- oce.orig/inc/IntCurveSurface_Polyhedron.gxx
+++ oce/inc/IntCurveSurface_Polyhedron.gxx
@@ -420,10 +420,6 @@ Standard_Integer IntCurveSurface_Polyhed
    Standard_Integer&      TriCon,
    Standard_Integer&      OtherP) const
 {
-#ifdef DEB
-  Standard_Integer nbdeltaUp1 = nbdeltaU + 1;
-  Standard_Integer nbdeltaUm2 = nbdeltaU + nbdeltaU;
-#endif
   Standard_Integer Pivotm1    = Pivot-1;
   Standard_Integer nbdeltaVp1 = nbdeltaV+1;
   Standard_Integer nbdeltaVm2 = nbdeltaV + nbdeltaV;
Index: oce/inc/IntCurve_IntPolyPolyGen.gxx
===================================================================
--- oce.orig/inc/IntCurve_IntPolyPolyGen.gxx
+++ oce/inc/IntCurve_IntPolyPolyGen.gxx
@@ -257,13 +257,6 @@ void IntCurve_IntPolyPolyGen::Perform( c
   Standard_Real Tl=(TheTol < TOL_MINI)? TOL_MINI : TheTol;
   Standard_Real TlConf=(TheTolConf < TOL_CONF_MINI)? TOL_CONF_MINI : TheTolConf;
   Perform(C1,D1,TlConf,Tl,0,DU,DU);
-  //----------------------------------------------------------------------
-  //-- Traitement des points en bouts 
-  //----------------------------------------------------------------------
-  Standard_Boolean HeadOn1 = Standard_False;
-  Standard_Boolean HeadOn2 = Standard_False;
-  Standard_Boolean EndOn1  = Standard_False;
-  Standard_Boolean EndOn2  = Standard_False;
   Standard_Integer i;
   Standard_Integer n=this->NbPoints();
 
@@ -284,12 +277,7 @@ void IntCurve_IntPolyPolyGen::Perform( c
 
   for(i=1;i<=n;i++) { 
     IntRes2d_Position Pos1 = this->Point(i).TransitionOfFirst().PositionOnCurve();
-    if(Pos1 == IntRes2d_Head) HeadOn1 = Standard_True;
-    else if(Pos1 == IntRes2d_End) EndOn1 = Standard_True;
-
     IntRes2d_Position Pos2 =  this->Point(i).TransitionOfSecond().PositionOnCurve();
-    if(Pos2 == IntRes2d_Head) HeadOn2 = Standard_True;
-    else if(Pos2 == IntRes2d_End) EndOn2 = Standard_True;
 
     if(Pos1 == IntRes2d_Head) { 
       if(Pos2 == IntRes2d_Head)     PosSegment|=1;
@@ -304,12 +292,7 @@ void IntCurve_IntPolyPolyGen::Perform( c
   n=this->NbSegments();
   for(i=1;i<=n;i++) { 
     IntRes2d_Position Pos1 = this->Segment(i).FirstPoint().TransitionOfFirst().PositionOnCurve();
-    if(Pos1 == IntRes2d_Head)     HeadOn1 = Standard_True;
-    else if(Pos1 == IntRes2d_End) EndOn1  = Standard_True;
-    
     IntRes2d_Position Pos2 =  this->Segment(i).FirstPoint().TransitionOfSecond().PositionOnCurve();
-    if(Pos2 == IntRes2d_Head)      HeadOn2 = Standard_True;
-    else if(Pos2 == IntRes2d_End)  EndOn2  = Standard_True;
 
     if(Pos1 == IntRes2d_Head) { 
       if(Pos2 == IntRes2d_Head)     PosSegment|=1;
@@ -321,12 +304,7 @@ void IntCurve_IntPolyPolyGen::Perform( c
     }
 
     Pos1 = this->Segment(i).LastPoint().TransitionOfFirst().PositionOnCurve();
-    if(Pos1 == IntRes2d_Head)     HeadOn1 = Standard_True;
-    else if(Pos1 == IntRes2d_End) EndOn1  = Standard_True;
-    
     Pos2 =  this->Segment(i).LastPoint().TransitionOfSecond().PositionOnCurve();
-    if(Pos2 == IntRes2d_Head)     HeadOn2 = Standard_True;
-    else if(Pos2 == IntRes2d_End) EndOn2  = Standard_True;
 
     if(Pos1 == IntRes2d_Head) { 
       if(Pos2 == IntRes2d_Head)     PosSegment|=1;
Index: oce/inc/IntCurve_Polygon2dGen.gxx
===================================================================
--- oce.orig/inc/IntCurve_Polygon2dGen.gxx
+++ oce/inc/IntCurve_Polygon2dGen.gxx
@@ -312,17 +312,9 @@ void IntCurve_Polygon2dGen::ComputeWithB
 		Standard_Real u1m = 0.5*(u+TheParams.Value(TheIndex.Value(i-1)));
 		Standard_Real um2 = 0.5*(u+TheParams.Value(TheIndex.Value(i+1)));
 		gp_Pnt2d P1m = TheCurveTool::Value(C,u1m);
-#ifdef DEB
-		gp_Pnt2d Pm2 = TheCurveTool::Value(C,um2);
-#else
-                TheCurveTool::Value(C,um2);
-#endif
+        TheCurveTool::Value(C,um2);
 		gp_Lin2d L1m(P1,gp_Dir2d(gp_Vec2d(P1,Pm)));
-#ifdef DEB
-		gp_Lin2d Lm2(Pm,gp_Dir2d(gp_Vec2d(Pm,ThePnts.Value(TheIndex.Value(i+1)))));
-#else
-                ThePnts.Value(TheIndex.Value(i+1));
-#endif
+        ThePnts.Value(TheIndex.Value(i+1));
 		t = L1m.Distance(P1m);
 		i--; 
 	      }
Index: oce/inc/IntImpParGen_Intersector.gxx
===================================================================
--- oce.orig/inc/IntImpParGen_Intersector.gxx
+++ oce/inc/IntImpParGen_Intersector.gxx
@@ -50,7 +50,6 @@ void IntImpParGen_Intersector::And_Domai
   NbResultats=0;
   
   for(Standard_Integer i=1; i<=Nb_Bornes_Intersection; i+=2) {
-    Standard_Boolean reverse=Standard_False;
     
     Standard_Real param1=Inter1.Value(i);
     Standard_Real param2=Inter1.Value(i+1);
@@ -62,7 +61,6 @@ void IntImpParGen_Intersector::And_Domai
       Standard_Real t=param1; param1=param2; param2=t;
       indice_1=i+1;
       indice_2=i;
-      reverse=Standard_True;
     }
 
     gp_Pnt2d Pt1=TheImpTool.Value(param1);
@@ -70,10 +68,8 @@ void IntImpParGen_Intersector::And_Domai
     gp_Pnt2d Pt;
 
     Standard_Boolean IsOnTheImpCurveDomain1=Standard_True;
-    Standard_Boolean IsOnABoundary1=Standard_False;
 
     Standard_Boolean IsOnTheImpCurveDomain2=Standard_True;
-    Standard_Boolean IsOnABoundary2=Standard_False;
     //--------------------------------------------------------------------
     if(TheImpCurveDomain.HasFirstPoint()) { 
       if(param1<TheImpCurveDomain.FirstParameter()) {             
@@ -81,7 +77,6 @@ void IntImpParGen_Intersector::And_Domai
 	   > TheImpCurveDomain.FirstTolerance()) {
 	  IsOnTheImpCurveDomain1=Standard_False; 
 	}
-	else { 	  IsOnABoundary1=Standard_True; 	}
       }
     }
     if(IsOnTheImpCurveDomain1 && TheImpCurveDomain.HasLastPoint()) {
@@ -90,7 +85,6 @@ void IntImpParGen_Intersector::And_Domai
 	   > TheImpCurveDomain.FirstTolerance()) {
 	  IsOnTheImpCurveDomain1=Standard_False; 
 	}
-	else {	  IsOnABoundary1=Standard_True; 	}
       }
     }
     //--------------------------------------------------------------------
@@ -100,7 +94,6 @@ void IntImpParGen_Intersector::And_Domai
 	   > TheImpCurveDomain.FirstTolerance()) {
 	  IsOnTheImpCurveDomain2=Standard_False; 
 	}
-	else { 	  IsOnABoundary2=Standard_True; 	}
       }
     }
     if(IsOnTheImpCurveDomain2 && TheImpCurveDomain.HasLastPoint()) {
@@ -109,7 +102,6 @@ void IntImpParGen_Intersector::And_Domai
 	   > TheImpCurveDomain.FirstTolerance()) {
 	  IsOnTheImpCurveDomain2=Standard_False; 
 	}
-	else {	  IsOnABoundary2=Standard_True; 	}
       }
     }
 
Index: oce/inc/IntPatch_ImpImpIntersection_0.gxx
===================================================================
--- oce.orig/inc/IntPatch_ImpImpIntersection_0.gxx
+++ oce/inc/IntPatch_ImpImpIntersection_0.gxx
@@ -1075,9 +1075,6 @@ Standard_Boolean FindLine (gp_Pnt& Psurf
 	  //-- le point n a pas ete trouve par bete projection.
 	  //-- on essaie l intersection avec la restriction en 2d
 	  Standard_Real theparamonarc = theparameteronarc;
-#ifdef DEB
-	  Standard_Real anpara=para;
-#endif
 	  gp_Pnt CopiePsurf=Psurf;
 	  Standard_Boolean ok=IntersectionWithAnArc(CopiePsurf,alin,para,thearc,theparamonarc,thepointonarc,QuadSurf,lower,upper,dist);
 
Index: oce/inc/IntPatch_ImpImpIntersection_2.gxx
===================================================================
--- oce.orig/inc/IntPatch_ImpImpIntersection_2.gxx
+++ oce/inc/IntPatch_ImpImpIntersection_2.gxx
@@ -539,10 +539,8 @@ void IntPatch_ImpImpIntersection::Perfor
     gp_Pnt P;
     IntPatch_Point point;
     Standard_Real u1,v1,u2,v2; 
-    Standard_Integer nbv;
     if(slin.Value(i)->ArcType() == IntPatch_Circle) { 
       const Handle(IntPatch_GLine)& glin = *((Handle(IntPatch_GLine)*)&slin.Value(i));
-      nbv = glin->NbVertex();
       if(glin->NbVertex() == 0) { 
 	gp_Circ Circ = glin->Circle();
 	P=ElCLib::Value(0.0,Circ);
@@ -565,7 +563,6 @@ void IntPatch_ImpImpIntersection::Perfor
     
     else if(slin.Value(i)->ArcType() == IntPatch_Ellipse) { 
       const Handle(IntPatch_GLine)& glin = *((Handle(IntPatch_GLine)*)&slin.Value(i));
-      nbv = glin->NbVertex();
       if(glin->NbVertex() == 0) { 
 	gp_Elips Elips = glin->Ellipse();
 	P=ElCLib::Value(0.0,Elips);
Index: oce/inc/IntPatch_ImpImpIntersection_4.gxx
===================================================================
--- oce.orig/inc/IntPatch_ImpImpIntersection_4.gxx
+++ oce/inc/IntPatch_ImpImpIntersection_4.gxx
@@ -875,7 +875,6 @@ Standard_Boolean IntCyCo(const IntSurf_Q
       IntAna_Curve aC;
       IntAna_ListOfCurve aLC;
       IntAna_ListIteratorOfListOfCurve aIt;
-      Standard_Boolean bToSplit;
       
       //
       NbSol = anaint.NbCurve();
@@ -884,7 +883,7 @@ Standard_Boolean IntCyCo(const IntSurf_Q
 	//curvsol = anaint.Curve(i);
 	aC=anaint.Curve(i);
 	aLC.Clear();
-	bToSplit=ExploreCurve(Cy, Co, aC, 10.*Tol, aLC);
+	ExploreCurve(Cy, Co, aC, 10.*Tol, aLC);
 	//
 	aIt.Initialize(aLC);
 	for (; aIt.More(); aIt.Next()) {
Index: oce/inc/IntPatch_ImpImpIntersection_5.gxx
===================================================================
--- oce.orig/inc/IntPatch_ImpImpIntersection_5.gxx
+++ oce/inc/IntPatch_ImpImpIntersection_5.gxx
@@ -84,12 +84,11 @@ Standard_Boolean IntCoCo(const IntSurf_Q
 	situC2=IntSurf_Outside;
       }
       else {
-	Standard_Real aR1, aR2;
+	Standard_Real aR1;
 	gp_Lin aLAx1(aPApex1, Co1.Axis().Direction());
 	gp_Lin aLAx2(aPApex2, Co2.Axis().Direction());
 	//
 	aR1=aLAx1.Distance(ptbid);
-	aR2=aLAx2.Distance(ptbid);
 	//
 	situC1=IntSurf_Inside;
 	situC2=IntSurf_Outside;
@@ -191,7 +190,6 @@ Standard_Boolean IntCoCo(const IntSurf_Q
 
   case IntAna_Circle:
     {
-      Standard_Real para;
       IntPatch_Point aPtsol;
       gp_Vec Tgt;
       gp_Pnt ptref;
@@ -217,7 +215,7 @@ Standard_Boolean IntCoCo(const IntSurf_Q
 	  Quad2.Parameters(aPChar, U2, V2);
 	  aPtsol.SetValue(aPChar, Tol, Standard_False);
 	  aPtsol.SetParameters(U1, V1, U2, V2);
-	  para = ElCLib::Parameter(cirsol, aPChar);
+	  ElCLib::Parameter(cirsol, aPChar);
 	  aPtsol.SetParameter(0.);
 	  glig->AddVertex(aPtsol);
 	}
@@ -229,7 +227,6 @@ Standard_Boolean IntCoCo(const IntSurf_Q
 
   case IntAna_Ellipse:
     {
-      Standard_Real para;
       IntPatch_Point aPtsol;
       gp_Elips elipsol = inter.Ellipse(1);
       
@@ -256,7 +253,7 @@ Standard_Boolean IntCoCo(const IntSurf_Q
 	Quad2.Parameters(aPChar, U2, V2);
 	aPtsol.SetValue(aPChar, Tol, Standard_False);
 	aPtsol.SetParameters(U1, V1, U2, V2);
-	para = ElCLib::Parameter(elipsol, aPChar);
+	ElCLib::Parameter(elipsol, aPChar);
 	aPtsol.SetParameter(0.);
 	glig->AddVertex(aPtsol);
       }
@@ -268,7 +265,6 @@ Standard_Boolean IntCoCo(const IntSurf_Q
 
   case IntAna_Hyperbola:
     {
-      Standard_Real para;
       IntPatch_Point aPtsol;
       gp_Vec Tgt;
       gp_Pnt ptref;
@@ -294,7 +290,7 @@ Standard_Boolean IntCoCo(const IntSurf_Q
 	  Quad2.Parameters(aPChar, U2, V2);
 	  aPtsol.SetValue(aPChar, Tol, Standard_False);
 	  aPtsol.SetParameters(U1, V1, U2, V2);
-	  para = ElCLib::Parameter(hyprsol, aPChar);
+	  ElCLib::Parameter(hyprsol, aPChar);
 	  aPtsol.SetParameter(0.);
 	  glig->AddVertex(aPtsol);
 	}
@@ -305,7 +301,6 @@ Standard_Boolean IntCoCo(const IntSurf_Q
     
   case IntAna_Parabola:
     {
-      Standard_Real para;
       IntPatch_Point aPtsol;
       gp_Parab parabsol = inter.Parabola(1);
       
@@ -331,7 +326,7 @@ Standard_Boolean IntCoCo(const IntSurf_Q
 	Quad2.Parameters(aPChar, U2, V2);
 	aPtsol.SetValue(aPChar, Tol, Standard_False);
 	aPtsol.SetParameters(U1, V1, U2, V2);
-	para = ElCLib::Parameter(parabsol, aPChar);
+	ElCLib::Parameter(parabsol, aPChar);
 	aPtsol.SetParameter(0.);
 	glig->AddVertex(aPtsol);
       }
@@ -551,13 +546,6 @@ Standard_Boolean IntCoSp(const IntSurf_Q
     {
       gp_Vec Tgt;
       gp_Pnt ptref;
-#ifndef DEB
-      Co.Apex();
-#else
-      gp_Pnt apex(Co.Apex());
-      //Standard_Real param;
-      Standard_Real paramapex   =  ElCLib::LineParameter(Co.Axis(),apex);
-#endif
 
       for (i=1; i<=NbSol; i++) {
 	gp_Circ cirsol = inter.Circle(i);
@@ -652,11 +640,6 @@ Standard_Boolean IntCoSp(const IntSurf_Q
 
 	gp_Pnt ptvalid, ptf, ptl;
 	gp_Vec tgvalid;
-#ifdef DEB
-	Standard_Real paramapex   = 
-#endif
-	  ElCLib::LineParameter(Co.Axis(),
-				Co.Apex());
 	Standard_Real first,last,para;
 	Standard_Boolean tgfound,firstp,lastp,kept;
 	Standard_Integer kount;
Index: oce/inc/IntStart_SearchOnBoundaries_1.gxx
===================================================================
--- oce.orig/inc/IntStart_SearchOnBoundaries_1.gxx
+++ oce/inc/IntStart_SearchOnBoundaries_1.gxx
@@ -304,7 +304,6 @@ void BoundedArc (const TheArc& A,
 	      //Standard_Integer aNbNodes = 23;
 	      Standard_Real    aDelta   = (parap1 - para)/(aNbNodes + 1.);
 	      Standard_Integer ii;
-	      Standard_Real    aMinPar  = Pdeb - 1.;
 	      Standard_Real    aCurPar;
 	      Standard_Real    aCurVal;
 
@@ -755,7 +754,7 @@ Standard_Integer TreatLC (const TheArc&
     return anExitCode;
   }
   
-  Standard_Real f, l, U1f, U1l, U2f, U2l, U1, UEgde, TOL, aDist, aR, aRRel, Tol;
+  Standard_Real f, l, U1f, U1l, U2f, U2l, UEgde, TOL, aDist, aR, aRRel, Tol;
   Handle(Geom_Curve) aCEdge=BRep_Tool::Curve(*anE, f, l);
   
   gp_Cylinder aCyl=aQuadric.Cylinder();
@@ -793,7 +792,6 @@ Standard_Integer TreatLC (const TheArc&
   P1   =PC1.Value();
   PEdge=PC2.Value();
   
-  U1=PC1.Parameter();
   UEgde=PC2.Parameter();
   
   aDist=PEdge.Distance(P1);
Index: oce/inc/IntWalk_IWalking_1.gxx
===================================================================
--- oce.orig/inc/IntWalk_IWalking_1.gxx
+++ oce/inc/IntWalk_IWalking_1.gxx
@@ -79,9 +79,6 @@ void IntWalk_IWalking::Perform(const The
       etat1(I) = etat1(I) + 1;
 
     Standard_Integer etat1I=etat1(I);
-#ifdef DEB
-    Standard_Integer multi=0;
-#endif
     //-- cout<<" \n Etat1("<<I<<") = "<<etat1I<<endl;
     if(etat1I==2) {  //-- lbr le 15 fev 99 
       etat1(I)=11;      
Index: oce/inc/IntWalk_IWalking_2.gxx
===================================================================
--- oce.orig/inc/IntWalk_IWalking_2.gxx
+++ oce/inc/IntWalk_IWalking_2.gxx
@@ -222,7 +222,6 @@ Standard_Boolean IntWalk_IWalking::TestA
       //IFV for OCC20285
 
 
-      Standard_Real tolustolv=tolu/tolv;
  
       if ((Abs(Du) < tolu2 && Abs(Dv) < tolv2) ||
 	  (Abs(Dup) < tolu2 && Abs(Dvp) < tolv2)) { 
@@ -315,10 +314,7 @@ Standard_Boolean IntWalk_IWalking::TestA
 	  if (Arrive) {
 	    static math_Vector bidF(1,1);
 	    static math_Matrix bidD(1,1,1,2);
-#ifdef DEB
-	    Standard_Boolean bidB = 
-#endif
-	      sp.Values(UV,bidF,bidD);
+	    sp.Values(UV,bidF,bidD);
 	    break;
 	  }
 	}
@@ -560,10 +556,7 @@ Standard_Boolean IntWalk_IWalking::TestA
 	UV(2) = V1;
 	static math_Vector bidF(1,1);
 	static math_Matrix bidD(1,1,1,2);
-#ifdef DEB
-	Standard_Boolean bidB = 
-#endif
-	  sp.Values(UV,bidF,bidD);
+	sp.Values(UV,bidF,bidD);
 	break;
       }
     }
@@ -660,10 +653,7 @@ void IntWalk_IWalking::TestArretCadre
 	if (Found) {
 	  static math_Vector bidF(1,1);
 	  static math_Matrix bidD(1,1,1,2);
-#ifdef DEB
-	  Standard_Boolean bidB = 
-#endif
-	    sp.Values(UV,bidF,bidD);
+	  sp.Values(UV,bidF,bidD);
 	  Standard_Integer NBP =  Line->NbPoints();
 	  Standard_Integer Indextg;	  
 	  Line->TangentVector(Indextg);
@@ -738,10 +728,7 @@ void IntWalk_IWalking::TestArretCadre
 	Irang = -Irang; // jag 941017
 	static math_Vector bidF(1,1);
 	static math_Matrix bidD(1,1,1,2);
-#ifdef DEB
-	Standard_Boolean bidB = 
-#endif
-	  sp.Values(UV,bidF,bidD);
+	sp.Values(UV,bidF,bidD);
 	return;
       }
     }
Index: oce/inc/IntWalk_IWalking_3.gxx
===================================================================
--- oce.orig/inc/IntWalk_IWalking_3.gxx
+++ oce/inc/IntWalk_IWalking_3.gxx
@@ -484,10 +484,7 @@ static Standard_Boolean TestPassedSoluti
 	if (Arrive) {
 	  static math_Vector bidF(1,1);
 	  static math_Matrix bidD(1,1,1,2);
-#ifdef DEB
-	  Standard_Boolean bidB = 
-#endif
-	    sp.Values(UV,bidF,bidD);
+	  sp.Values(UV,bidF,bidD);
 	  break;
 	}
       }
Index: oce/inc/IntWalk_IWalking_6.gxx
===================================================================
--- oce.orig/inc/IntWalk_IWalking_6.gxx
+++ oce/inc/IntWalk_IWalking_6.gxx
@@ -38,9 +38,6 @@ void IntWalk_IWalking::MakeWalkingPoint
   if (Case == 1) 
     Psol.SetValue(sp.Point(),reversed, U, V);
   else if (Case == 2) {
-#ifdef DEB
-    Standard_Boolean foo = sp.IsTangent(); 
-#endif
     Psol.SetValue(sp.Point(),reversed, U, V);
   }
   else if (Case == 11 || Case == 12 ) {
Index: oce/inc/IntWalk_PWalking_1.gxx
===================================================================
--- oce.orig/inc/IntWalk_PWalking_1.gxx
+++ oce/inc/IntWalk_PWalking_1.gxx
@@ -357,11 +357,9 @@ Standard_Boolean IntWalk_PWalking::Perfo
   close = Standard_False;
   //
   Standard_Integer i;
-  Standard_Real aTmp;
   TColStd_Array1OfReal Param(1,4);
   //
   for (i=1; i<=4; ++i) {
-    aTmp = ParDep(i);
     Param(i) = ParDep(i);
   }
   //-- calcul du premier point solution
@@ -400,10 +398,8 @@ void IntWalk_PWalking::Perform(const TCo
 			       const Standard_Real v2max)
 {
   //xf
-  Standard_Integer iCnt=0;
   Standard_Integer i, NbPasOKConseq;
   Standard_Real UFirst1, VFirst1, ULast1, VLast1, UFirst2, VFirst2, ULast2, VLast2;
-  Standard_Real pasMaxSV[4], aTmp;
   TColStd_Array1OfReal Param(1,4);
   IntImp_ConstIsoparametric ChoixIso;
   //xt
@@ -451,13 +447,12 @@ void IntWalk_PWalking::Perform(const TCo
   line = new IntSurf_LineOn2S ();
   //
   for (i=1; i<=4; ++i) {
-    aTmp=ParDep(i);
     Param(i)=ParDep(i);
   }
   //-- reprise des pas uv lies aux surfaces Caro1 et Caro2
   //-- pasuv[] et pasSav[] sont modifies lors du cheminement
   for(i = 0; i < 4; ++i) { 
-    pasMaxSV[i] = pasSav[i] = pasuv[i] = pasInit[i]; 
+    pasSav[i] = pasuv[i] = pasInit[i]; 
   }
 
   //-- calcul du premier point solution
Index: oce/inc/Intf_InterferencePolygonPolyhedron.gxx
===================================================================
--- oce.orig/inc/Intf_InterferencePolygonPolyhedron.gxx
+++ oce/inc/Intf_InterferencePolygonPolyhedron.gxx
@@ -17,9 +17,6 @@
 #include <Intf_SeqOfTangentZone.hxx>
 #include <Intf.hxx>
 
-#ifdef DEB
-static  Standard_Integer debug=0;
-#endif
 #if 0
 static  Standard_Real PRCANG=0.1;
 #endif
@@ -584,8 +581,7 @@ void Intf_InterferencePolygonPolyhedron:
     while (clt.More()) {
       indTri=clt.Value();
       //  Modified by MKK - Thu Oct  25 12:40:11 2007 Begin
-      Standard_Integer prevSize = mySPoins.Length();
-
+ 
       Standard_Integer pTri[3];
       ToolPolyh::Triangle(thePolyh, indTri, pTri[0], pTri[1], pTri[2]);
       gp_XYZ triNor;                                   // Vecteur normal.
@@ -791,7 +787,6 @@ void Intf_InterferencePolygonPolyhedron:
   Standard_Real angl=triNor*segO;
 #endif
   Standard_Boolean NoIntersectionWithTriangle = Standard_False;
-  Standard_Boolean PolygonCutsPlane           = Standard_True;
 
 
 #if 0 
@@ -822,7 +817,6 @@ void Intf_InterferencePolygonPolyhedron:
       NoIntersectionWithTriangle = Standard_False;
     }
     if (param<0. || param>1.) {
-      PolygonCutsPlane = Standard_False;
       NoIntersectionWithTriangle = Standard_True;
     }
   }
@@ -1103,14 +1097,12 @@ void Intf_InterferencePolygonPolyhedron:
   Standard_Integer pTri[3];
   ToolPolyh::Triangle(thePolyh, TTri, pTri[0], pTri[1], pTri[2]);
   gp_XYZ triNor = TriNormal;                                   // Vecteur normal.
-  Standard_Real triDp = TriDp;                             // Distance polaire.
 
 
 //   Standard_Real dBegTri=(triNor*BegO.XYZ())-triDp; // Distance <BegO> plan
 //   Standard_Real dEndTri=(triNor*EndO.XYZ())-triDp; // Distance <EndO> plan
 
   Standard_Boolean NoIntersectionWithTriangle = Standard_False;
-  Standard_Boolean PolygonCutsPlane           = Standard_True;
 
   Standard_Real param;
   t = dBegTri-dEndTri;
@@ -1130,7 +1122,6 @@ void Intf_InterferencePolygonPolyhedron:
       NoIntersectionWithTriangle = Standard_False;
     }
     if (param<0. || param>1.) {
-      PolygonCutsPlane = Standard_False;
       NoIntersectionWithTriangle = Standard_True;
     }
   }
Index: oce/inc/Intf_InterferencePolyhedron.gxx
===================================================================
--- oce.orig/inc/Intf_InterferencePolyhedron.gxx
+++ oce/inc/Intf_InterferencePolyhedron.gxx
@@ -761,8 +761,6 @@ Standard_Boolean Intf_InterferencePolyhe
     tOP[nou]= Intf_EXTERNAL;
     tTP[nou]= Intf_EXTERNAL;
   }
-  Standard_Integer iOP[4];
-  Standard_Integer iTP[4];
 
   Standard_Integer nbpInt=0;
   Intf_SeqOfSectionPoint Tpi;
@@ -777,8 +775,8 @@ Standard_Boolean Intf_InterferencePolyhe
 				     Intf_VERTEX, OI[nob], 0, 0., 
 				     Intf_VERTEX, TI[nou], 0, 0.,
 				     1.));
-	tOP[nob]=Intf_VERTEX; iOP[nob]=nbpInt;
-	tTP[nou]=Intf_VERTEX; iTP[nou]=nbpInt;
+	tOP[nob]=Intf_VERTEX;
+	tTP[nou]=Intf_VERTEX;
 	nbpInt++;
 	break;
       }
@@ -791,7 +789,7 @@ Standard_Boolean Intf_InterferencePolyhe
 					Intf_EDGE, Min(TI[nou], TI[nou2]),
 					Max(TI[nou], TI[nou2]), par,
 					1.));
-	  tOP[nob]=Intf_EDGE; iOP[nob]=nbpInt;
+	  tOP[nob]=Intf_EDGE;
 	  nbpInt++;
 	  break;
 	}
@@ -806,7 +804,7 @@ Standard_Boolean Intf_InterferencePolyhe
 				     Intf_VERTEX, OI[nob],  0, 0., 
 				     Intf_FACE,   Tri2, 0, 0.,
 				     1.));
-	tOP[nob]=Intf_FACE; iOP[nob]=nbpInt;
+	tOP[nob]=Intf_FACE;
 	nbpInt++;
       }
     }
@@ -829,7 +827,7 @@ Standard_Boolean Intf_InterferencePolyhe
 					   Intf_EDGE, Min(OI[nob], OI[nob2]),
 					   Max(OI[nob], OI[nob2]), par, 
 					   Intf_VERTEX, TI[nou], 0, 0., 1.));
-	      tTP[nou]=Intf_EDGE;iTP[nou]=nbpInt;
+	      tTP[nou]=Intf_EDGE;
 	      nbpInt++;
 	      break;
 	    }
@@ -844,7 +842,7 @@ Standard_Boolean Intf_InterferencePolyhe
 					 Intf_FACE,   Tri1, 0, 0.,
 					 Intf_VERTEX, TI[nou], 0, 0., 
 					 1.));
-	    tTP[nou]=Intf_FACE; iTP[nou]=nbpInt;
+	    tTP[nou]=Intf_FACE;
 	    nbpInt++;
 	  }
 	}
Index: oce/inc/Primitives_Wedge.gxx
===================================================================
--- oce.orig/inc/Primitives_Wedge.gxx
+++ oce/inc/Primitives_Wedge.gxx
@@ -668,26 +668,19 @@ gp_Lin Primitives_Wedge::Line
   gp_Vec VX = myAxes.XDirection();
   gp_Vec VY = myAxes.YDirection();
   gp_Vec VZ = myAxes.Direction();
-  Primitives_Direction dd1,dd2;
   
   switch (i/4) {
     
   case 0 :
     D = myAxes.Direction();
-    dd1 = Primitives_ZMin;
-    dd2 = Primitives_ZMax;
     break;
     
   case 1 :
     D = myAxes.XDirection();
-    dd1 = Primitives_XMin;
-    dd2 = Primitives_XMax;
     break;
     
   case 2 :
     D = myAxes.YDirection();
-    dd1 = Primitives_YMin;
-    dd2 = Primitives_YMax;
     break;
     
   };
Index: oce/inc/Prs3d_Datum.gxx
===================================================================
--- oce.orig/inc/Prs3d_Datum.gxx
+++ oce/inc/Prs3d_Datum.gxx
@@ -52,7 +52,6 @@ void Prs3d_Datum::Add( const Handle(Prs3
 
 #ifdef IMP120100
   Quantity_Length arrowAngle = aDrawer->ArrowAspect()->Angle();
-  Quantity_Length textHeight = aDrawer->TextAspect()->Height();
 #endif
 
   if (DA->DrawFirstAndSecondAxis()) {
Index: oce/inc/Prs3d_WFRestrictedFace.gxx
===================================================================
--- oce.orig/inc/Prs3d_WFRestrictedFace.gxx
+++ oce/inc/Prs3d_WFRestrictedFace.gxx
@@ -40,7 +40,6 @@ void Prs3d_WFRestrictedFace::Add
    Prs3d_NListOfSequenceOfPnt&         Curves)
 {
   Standard_Boolean isPA = Graphic3d_ArrayOfPrimitives::IsEnable();
-  Standard_Real aLimit = aDrawer->MaximalParameterValue();
   Standard_Integer nbPoints = aDrawer->Discretisation();
 
 #ifdef DEBUG
Index: oce/inc/TopOpeBRepBuild_SplitEdge.hxx
===================================================================
--- oce.orig/inc/TopOpeBRepBuild_SplitEdge.hxx
+++ oce/inc/TopOpeBRepBuild_SplitEdge.hxx
@@ -36,26 +36,6 @@ void TopOpeBRepBuild_Builder::SplitEdge1
 {
   // work on a FORWARD edge <Eforward>
 
-#ifdef DEB
-  TopAbs_Orientation Eori =
-#endif
-                            Eoriented.Orientation();
-#ifdef DEB
-  Standard_Integer io = 0;
-  if      ( Eori == TopAbs_FORWARD  ) {
-    io = 1;
-  }
-  else if ( Eori == TopAbs_REVERSED ) {
-    io = 2;
-  }
-  else if ( Eori == TopAbs_INTERNAL ) {
-    io = 3;
-  }
-  else if ( Eori == TopAbs_EXTERNAL ) {
-    io = 4;
-  }
-#endif
-
   TopoDS_Shape Eforward = Eoriented; 
   Eforward.Orientation(TopAbs_FORWARD);
 
@@ -72,8 +52,8 @@ void TopOpeBRepBuild_Builder::SplitEdge1
   
   if ( ! tosplit ) return;
 
-  Standard_Boolean RevOri1 = Reverse(ToBuild1,ToBuild2);
-  Standard_Boolean RevOri2 = Reverse(ToBuild2,ToBuild1);
+  Reverse(ToBuild1,ToBuild2);
+  Reverse(ToBuild2,ToBuild1);
   Standard_Boolean ConnectTo1 = Standard_True;
   Standard_Boolean ConnectTo2 = Standard_False;
   
@@ -81,8 +61,6 @@ void TopOpeBRepBuild_Builder::SplitEdge1
   TopTools_ListOfShape LE1,LE2;
   LE1.Append(Eforward);
   FindSameDomain(LE1,LE2);
-  Standard_Integer n1 = LE1.Extent();
-  Standard_Integer n2 = LE2.Extent();
 
 #ifdef DEB
   if(tSPS){GdumpSAMDOM(LE1, (char *) "1 : ");}
@@ -95,8 +73,6 @@ void TopOpeBRepBuild_Builder::SplitEdge1
   
   // SplitEdge on a edge having other same domained edges on the
   // other shape : do not reverse orientation of edges in FillEdge
-  if (!n2) RevOri1 = Standard_False;
-  if (!n1) RevOri2 = Standard_False;
     
   // Make a PaveSet <PVS> on edge <Eforward>
   TopOpeBRepBuild_PaveSet PVS(Eforward);
Index: oce/inc/Transfer_TransferProcess.gxx
===================================================================
--- oce.orig/inc/Transfer_TransferProcess.gxx
+++ oce/inc/Transfer_TransferProcess.gxx
@@ -1236,7 +1236,7 @@ void Transfer_TransferProcess::StartTrac
 
   if (!binder.IsNull()) {   // old: if IsNull sout <<endl<< "  ---  Not Bound";
     Handle(Transfer_Binder) bnd = binder;
-    Standard_Boolean hasres = Standard_False, isused = Standard_False;
+    Standard_Boolean hasres = Standard_False;
     while (!bnd.IsNull()) {
       if (bnd->Status() != Transfer_StatusVoid) {
 // ---  Result Type: binder->ResultType()  ---  Binder : binder->DynamicType();
@@ -1250,7 +1250,6 @@ void Transfer_TransferProcess::StartTrac
           Msg2075.AddString(bnd->ResultTypeName());
           Msg2075.TraceEver();  */
 	hasres = Standard_True;
-	if (bnd->Status() == Transfer_StatusUsed) isused = Standard_True;
       }
       bnd = bnd->NextResult();
     }
Index: oce/inc/math_DoubleTab.gxx
===================================================================
--- oce.orig/inc/math_DoubleTab.gxx
+++ oce/inc/math_DoubleTab.gxx
@@ -89,9 +89,6 @@ math_DoubleTab::math_DoubleTab(const mat
 
 void math_DoubleTab::Free()
 {
-  Standard_Integer RowNumber = UppR - LowR + 1;
-  Standard_Integer ColNumber = UppC - LowC + 1;
-
   // free the data
   if(isAllocated) {
     Standard_Address it = (Standard_Address)&Value(LowR,LowC);
Index: oce/src/AIS/AIS_AngleDimension.cxx
===================================================================
--- oce.orig/src/AIS/AIS_AngleDimension.cxx
+++ oce/src/AIS/AIS_AngleDimension.cxx
@@ -929,7 +929,6 @@ void AIS_AngleDimension::ComputeTwoEdges
   else d2 = l2->Lin().Direction();
   if (!isInfinite1) {
     Standard_Boolean In1(Standard_False);
-    Standard_Boolean In2(Standard_False);
     if ( !(Abs(d1.Angle(d2) - Abs(myVal)) <= Precision::Confusion())
 	 &&  (Abs(myVal) <  PI) ) {
       Standard_Real parcent1 = ElCLib::Parameter(l1->Lin(), myCenter);
@@ -948,7 +947,6 @@ void AIS_AngleDimension::ComputeTwoEdges
       }
       }
       if ( !In1) {
-	In2 = Standard_True;
 	d2.Reverse();
       }
     }
@@ -1267,11 +1265,6 @@ void AIS_AngleDimension::ComputeTwoEdges
       tabdist(3) = tabdist(4) = 0.;
     }
     if ( SameLines ) {
-      Standard_Real dist1(RealLast());
-      if (!isInfinite1) dist1 = Max(tabdist(1),tabdist(2));
-      Standard_Real dist2(RealLast());
-      if (!isInfinite2) dist2 = Max(tabdist(3),tabdist(4));      
-      
       myFAttach = myCenter;
       mySAttach = myCenter;
       P1 = myFAttach;
@@ -1953,9 +1946,6 @@ void AIS_AngleDimension::ComputeConeAngl
  
   Standard_Boolean IsArrowOut = Standard_True;    //Is arrows inside or outside of the cone
   //Standard_Real PntOnMainAxis = 0;   //Is projection of aPosition inside of the cone = 0, above = 1, or below = -1
-  Standard_Boolean IsConeTrimmed = Standard_False; 
-
-  if( CircVmin.Radius() > 0.01 ) IsConeTrimmed = Standard_True;
 
   gp_Pnt AttachmentPnt;
   gp_Pnt OppositePnt;
Index: oce/src/AIS/AIS_DiameterDimension.cxx
===================================================================
--- oce.orig/src/AIS/AIS_DiameterDimension.cxx
+++ oce/src/AIS/AIS_DiameterDimension.cxx
@@ -194,13 +194,11 @@ void AIS_DiameterDimension::ComputeSelec
     
     Standard_Real dist    = center.Distance(AttachmentPoint);
     Standard_Real aRadius = myCircle.Radius();
-    Standard_Real inside  = Standard_False;
     
     gp_Pnt pt1 = AttachmentPoint;
     if (dist < aRadius) {
       pt1 = ptoncirc;
       dist = aRadius;
-      inside = Standard_True;
     }
     vecrap.Normalize();
     vecrap *= (dist+aRadius);
Index: oce/src/AIS/AIS_EqualDistanceRelation.cxx
===================================================================
--- oce.orig/src/AIS/AIS_EqualDistanceRelation.cxx
+++ oce/src/AIS/AIS_EqualDistanceRelation.cxx
@@ -617,8 +617,6 @@ void AIS_EqualDistanceRelation::ComputeT
   AIS::ComputeGeometry( FirstVertex, FirstAttach, Plane, isOnPlane1);
   AIS::ComputeGeometry( SecondVertex, SecondAttach, Plane, isOnPlane2);
 
-  //Computation of Val
-  Standard_Real Val = FirstAttach.Distance( SecondAttach );
   Standard_Real confusion(Precision::Confusion());
   Standard_Boolean samePoint(FirstAttach.IsEqual(SecondAttach,confusion));
 
@@ -632,9 +630,6 @@ void AIS_EqualDistanceRelation::ComputeT
   }
   
   // size
-  Standard_Real arrsize = ArrowSize;
-  if (Abs(Val) <= confusion) arrsize =0.;
-
   if (AutomaticPos) {
    if (!samePoint) {
      gp_Pnt curpos((FirstAttach.XYZ()+SecondAttach.XYZ())*0.5);
Index: oce/src/AIS/AIS_InteractiveContext.cxx
===================================================================
--- oce.orig/src/AIS/AIS_InteractiveContext.cxx
+++ oce/src/AIS/AIS_InteractiveContext.cxx
@@ -273,15 +273,14 @@ void AIS_InteractiveContext::DisplayedOb
 #endif
 
     //balayons tous les contextes locaux...
+#ifdef DEBUG
     Standard_Integer NbDisp;
     for(AIS_DataMapIteratorOfDataMapOfILC it1(myLocalContexts);it1.More();it1.Next()){
       const Handle(AIS_LocalContext)& LC = it1.Value();
       NbDisp =  LC->DisplayedObjects(theMap);
-#ifdef DEBUG
       cout<<"\tIn Local Context "<<it1.Key()<<" : "<<NbDisp<<endl;
-#endif
-      
     }
+#endif
     Handle(AIS_InteractiveObject) curIO;
     Handle(Standard_Transient) Tr;
       for(TColStd_MapIteratorOfMapOfTransient it2(theMap);it2.More();it2.Next()){
@@ -960,11 +959,11 @@ void AIS_InteractiveContext::Remove(cons
   }
   else
     {
-      Standard_Boolean  WasInCtx = myLocalContexts(myCurLocalIndex)->Remove(anIObj);
+      myLocalContexts(myCurLocalIndex)->Remove(anIObj);
       AIS_DataMapIteratorOfDataMapOfILC It(myLocalContexts);
       for (;It.More() ;It.Next()){
         if(It.Value()->AcceptErase())
-          WasInCtx = It.Value()->Remove(anIObj);
+          It.Value()->Remove(anIObj);
         
       }
       //      if(!WasInCtx)
Index: oce/src/AIS/AIS_LocalContext.cxx
===================================================================
--- oce.orig/src/AIS/AIS_LocalContext.cxx
+++ oce/src/AIS/AIS_LocalContext.cxx
@@ -428,7 +428,6 @@ Standard_Boolean AIS_LocalContext::Remov
   const Handle(AIS_LocalStatus)& Att = myActiveObjects(aSelectable);
   
   TColStd_ListIteratorOfListOfInteger It;
-  Standard_Boolean jobdone(Standard_False);
   // it is checked which were the temporary attributes 
   // and they are set to 0
 
@@ -451,7 +450,6 @@ Standard_Boolean AIS_LocalContext::Remov
       if(myMainPM->IsDisplayed(aSelectable,Att->HilightMode()))
 	myMainPM->Erase(aSelectable,Att->HilightMode());
       //	myMainPM->Clear(aSelectable,Att->HilightMode());
-      jobdone = Standard_True;
     }
   // if below intensity
   else
Index: oce/src/AIS2D/AIS2D_InteractiveContext.cxx
===================================================================
--- oce.orig/src/AIS2D/AIS2D_InteractiveContext.cxx
+++ oce/src/AIS2D/AIS2D_InteractiveContext.cxx
@@ -245,9 +245,7 @@ void AIS2D_InteractiveContext::Display(
     	GStatus->AddDisplayMode( aDispMode );
 		if ( GStatus->IsSubIntensityOn() ) {
 #ifdef DEB
-		   Standard_Integer indCol = myMainVwr->InitializeColor(mySubIntensity);
-           //myMainPM->SetHighlightColor( indCol );
-	       //myMainPM->ColorHighlight( anIObj, indCol, aDispMode );
+		   myMainVwr->InitializeColor(mySubIntensity);
 #endif
 		}
       }
@@ -483,10 +481,6 @@ Standard_Integer AIS2D_InteractiveContex
                                                              const Standard_Boolean AcceptEraseOfObj ) {
   if ( !IsCurrent( myLastPicked ) ) 
     if ( !myLastPicked.IsNull() ) {
-#ifdef DEB
-      AIS2D_TypeOfDetection HiMod = myLastPicked -> HasHighlightMode() ? 
-		              myLastPicked->HighlightMode() : myLastPicked->DefaultHighlightMode();
-#endif
       myLastPicked->Unhighlight();
 	 }
   
@@ -545,9 +539,6 @@ void AIS2D_InteractiveContext::CloseLoca
    
    if ( GoodIndex == myCurLocalIndex ) {
      myCurLocalIndex = HighestIndex();
-#ifdef DEB
-     const Handle(AIS2D_LocalContext)& LocCtx = myLocalContexts(myCurLocalIndex);
-#endif
    }
    
  }
@@ -1140,11 +1131,10 @@ void AIS2D_InteractiveContext::Displayed
 	     theMap.Add(It.Key());
     }
     
-    Standard_Integer NbDisp;
     for ( AIS2D_DataMapIteratorOfDataMapOfLC it1(myLocalContexts);
 	      it1.More(); it1.Next() ) {
       const Handle(AIS2D_LocalContext)& LC = it1.Value();
-      NbDisp =  LC->DisplayedObjects(theMap);
+      LC->DisplayedObjects(theMap);
 	}
 		  
     Handle(AIS2D_InteractiveObject) curIO;
@@ -1747,22 +1737,18 @@ void AIS2D_InteractiveContext::Highlight
 	 Standard_Integer DispMode,SelMode;
      AIS2D_TypeOfDetection HiMode = AIS2D_TOD_NONE;
 	 GetDefModes( anIObj, DispMode, HiMode, SelMode );
-     Standard_Integer pInd;
      anIObj->Highlight(myMainVwr->InitializeColor( mySelectionColor ));
      switch( HiMode ) {
 	 default:
      case AIS2D_TOD_OBJECT:
        break;
      case AIS2D_TOD_PRIMITIVE:
-       pInd = anIObj->PickedIndex();
        anIObj->Unhighlight();
        break;
      case AIS2D_TOD_ELEMENT:
-       pInd = anIObj->PickedIndex();
        anIObj->Unhighlight();
        break;
      case AIS2D_TOD_VERTEX:
-       pInd = anIObj->PickedIndex();
        anIObj->Unhighlight();
        break;
      } //end switch
@@ -1772,10 +1758,6 @@ void AIS2D_InteractiveContext::Highlight
 	 break;
    }
    case AIS2D_DS_Erased:	{
-#ifdef DEB
-     Standard_Integer HiMode = anIObj->HasHighlightMode() ? 
-                      anIObj->HighlightMode() : anIObj->DefaultHighlightMode();
-#endif
      anIObj->Highlight(myCollectorVwr->InitializeColor( mySelectionColor ));
      if ( updateVwr ) myCollectorVwr->Update();
      break;
@@ -1820,10 +1802,6 @@ void AIS2D_InteractiveContext::Highlight
 	    break;
       }
       case AIS2D_DS_Erased: {
-#ifdef DEB
-	    Standard_Integer HiMode = anIObj->HasHighlightMode()? anIObj->HighlightMode():0;
-	    Standard_Integer indCol = myCollectorVwr->InitializeColor( aCol );
-#endif
 		if ( updateVwr) myCollectorVwr->Update();
 	    break;
       }
@@ -2165,9 +2143,6 @@ AIS2D_StatusOfPick AIS2D_InteractiveCont
 	  myLocalContexts( myCurLocalIndex )->SetSelected( myLastPicked, UpdateVwr );
 	  return AIS2D_SOP_OneSelected;
   }
-#ifdef DEB
-  AIS2D_StatusOfPick PS( AIS2D_SOP_NothingSelected );
-#endif
   
  if ( ! mySeqOfDetIO->IsEmpty() ) {
     Handle(AIS2D_InteractiveObject) theIO;
Index: oce/src/AIS2D/AIS2D_LocalContext.cxx
===================================================================
--- oce.orig/src/AIS2D/AIS2D_LocalContext.cxx
+++ oce/src/AIS2D/AIS2D_LocalContext.cxx
@@ -322,10 +322,6 @@ AIS2D_StatusOfDetection AIS2D_LocalConte
    }
    if ( !myLastPicked.IsNull() )
     if ( !myLastPicked->State() ) {
-#ifdef DEB
-        AIS2D_TypeOfDetection HiMod = myLastPicked->HasHighlightMode() ? 
-             myLastPicked->HighlightMode() : myLastPicked->DefaultHighlightMode();
-#endif
         myLastPicked->Unhighlight();
 	    UpdVwr = Standard_True;
     } // end if the last picked object isn't selected one
@@ -379,9 +375,6 @@ AIS2D_StatusOfDetection AIS2D_LocalConte
         }
         case AIS2D_TOD_VERTEX: {
 	     myLastPickPrim = myLastPicked->Primitive(myLastPicked->PickedIndex());
-#ifdef DEB
-         Standard_Integer pInd = myLastPicked->PickedIndex();
-#endif
          if ( myLastPickPrim != myLastSelPrim ||
             ( myLastPickPrim == myLastSelPrim && 
               myLastPickPrim->PickedIndex() != myLastSelElInd ) ||
Index: oce/src/Adaptor3d/Adaptor3d_CurveOnSurface.cxx
===================================================================
--- oce.orig/src/Adaptor3d/Adaptor3d_CurveOnSurface.cxx
+++ oce/src/Adaptor3d/Adaptor3d_CurveOnSurface.cxx
@@ -439,7 +439,6 @@ static void Locate2Coord(const Standard_
 {
   Standard_Real Tol=Precision::PConfusion()/10;
   Standard_Real Comp1=0,DComp1=0;
-  Standard_Boolean DIsNull = Standard_False;
   if(Index==1)   {   Comp1=UV.X();
 		     DComp1=DUV.X();} 
   else
@@ -466,10 +465,9 @@ static void Locate2Coord(const Standard_
 		 if(Index==2) { LeftBot.SetY(I1);
 				RightTop.SetY(I2);}
 	       }
-	   DIsNull=Standard_False;
 	 }
     else 
-      if(Abs(DComp1)<=Tol) {  DIsNull = Standard_True;
+      if(Abs(DComp1)<=Tol) {
 			      if(Index==1) { LeftBot.SetX(I1) ;
 					     RightTop.SetX(I2);}
 			      if(Index==2) { LeftBot.SetY(I1) ;
Index: oce/src/AdvApp2Var/AdvApp2Var_ApproxAFunc2Var.cxx
===================================================================
--- oce.orig/src/AdvApp2Var/AdvApp2Var_ApproxAFunc2Var.cxx
+++ oce/src/AdvApp2Var/AdvApp2Var_ApproxAFunc2Var.cxx
@@ -437,7 +437,7 @@ void AdvApp2Var_ApproxAFunc2Var::Compute
 					 const AdvApp2Var_EvaluatorFunc2Var& Func,
 					 const AdvApp2Var_Criterion& Crit)
 {
-  Standard_Real Udec, Vdec, CritValue, m0=0., m1=0.;
+  Standard_Real Udec, Vdec, CritValue, m1=0.;
   Standard_Boolean Umore, Vmore, CritAbs = (Crit.Type() == AdvApp2Var_Absolute);
   Standard_Integer NbPatch, NbU, NbV, NbInt, NumDec;
   Standard_Integer FirstNA, decision=0;
@@ -447,7 +447,6 @@ void AdvApp2Var_ApproxAFunc2Var::Compute
 // completude de l'ensemble des contraintes 
     ComputeConstraints(UChoice, VChoice, Func, Crit);
     if (decision>0) {
-      m0 = m1;
       m1 = 0.;
     }
 
Index: oce/src/AdvApp2Var/AdvApp2Var_ApproxF2var.cxx
===================================================================
--- oce.orig/src/AdvApp2Var/AdvApp2Var_ApproxF2var.cxx
+++ oce/src/AdvApp2Var/AdvApp2Var_ApproxF2var.cxx
@@ -1379,7 +1379,7 @@ int mma1jak_(integer *ndimen,
 {
   /* System generated locals */
   integer somtab_dim1, somtab_offset, diftab_dim1, diftab_offset, 
-  crvjac_dim1, crvjac_offset, cgauss_dim1;
+  crvjac_dim1, crvjac_offset;
   
   /* Local variables */
   static integer ibb;
@@ -1451,7 +1451,6 @@ int mma1jak_(integer *ndimen,
     crvjac_dim1 = *ndgjac + 1;
     crvjac_offset = crvjac_dim1;
     crvjac -= crvjac_offset;
-    cgauss_dim1 = *nbroot / 2 + 1;
 
     /* Function Body */
     ibb = AdvApp2Var_SysBase::mnfndeb_();
Index: oce/src/AdvApp2Var/AdvApp2Var_MathBase.cxx
===================================================================
--- oce.orig/src/AdvApp2Var/AdvApp2Var_MathBase.cxx
+++ oce/src/AdvApp2Var/AdvApp2Var_MathBase.cxx
@@ -7484,8 +7484,6 @@ int mmpojac_(doublereal *tparam,
   
     /* Initialized data */
 
-    static integer nbcof = -1;
-
     /* System generated locals */
     integer valjac_dim1, i__1, i__2;
 
@@ -7601,8 +7599,6 @@ int mmpojac_(doublereal *tparam,
 		c__2, &i__2));
     }
 
-    nbcof = *ncoeff;
-
 /*      END IF */
 
 /*  --- Positionements triviaux ----- */
@@ -10404,7 +10400,6 @@ E*/
   static logical colin;
   static doublereal valaux;
   static integer aux;
-  static logical nul;
  
 /* ***********************************************************************
  */
@@ -10478,7 +10473,6 @@ E*/
     if (*ndimen <= 1 || *ndimen > 3) {
 	goto L9101;
     }
-    nul = FALSE_;
     d__ = 1;
     aux = 0;
     while(d__ <= *ndimen) {
Index: oce/src/AdvApp2Var/AdvApp2Var_Patch.cxx
===================================================================
--- oce.orig/src/AdvApp2Var/AdvApp2Var_Patch.cxx
+++ oce/src/AdvApp2Var/AdvApp2Var_Patch.cxx
@@ -97,11 +97,9 @@ void AdvApp2Var_Patch::Discretise(const
 {
 
 // les donnees stockees dans le Context
-  Standard_Integer NDIMEN, NBSESP, NDIMSE, ISOFAV;
+  Standard_Integer NDIMEN, ISOFAV;
   NDIMEN = Conditions.TotalDimension();
-  NBSESP = Conditions.TotalNumberSSP();
 // Attention : ne marche que pour le 3D
-  NDIMSE = 3;
   ISOFAV = Conditions.FavorIso();
 
 // les donnees relatives au patch a discretiser
@@ -392,12 +390,10 @@ void AdvApp2Var_Patch::AddConstraints(co
 				      const AdvApp2Var_Framework& Constraints)
 {
 // les donnees stockees dans le Context
-  Standard_Integer NDIMEN, NBSESP, NDIMSE;
+  Standard_Integer NDIMEN;
   Standard_Integer IERCOD, NCFLMU, NCFLMV, NDegU, NDegV;
   NDIMEN = Conditions.TotalDimension();
-  NBSESP = Conditions.TotalNumberSSP();
 // Attention : ne marche que pour le 3D
-  NDIMSE = 3;
   NCFLMU = Conditions.ULimit();
   NCFLMV = Conditions.VLimit();
   NDegU = NCFLMU - 1;
Index: oce/src/AdvApp2Var/AdvApp2Var_SysBase.cxx
===================================================================
--- oce.orig/src/AdvApp2Var/AdvApp2Var_SysBase.cxx
+++ oce/src/AdvApp2Var/AdvApp2Var_SysBase.cxx
@@ -140,9 +140,6 @@ int AdvApp2Var_SysBase::macinit_(integer
 
 {
  
-  /* Fortran I/O blocks */
-  static cilist io______1 = { 0, 0, 0, (char*) "(' --- Debug-mode : ',I10,' ---')", 0 };
-  
   /* ************************************************************************/
   /*     FONCTION : */
   /*     ---------- */
@@ -210,13 +207,6 @@ int AdvApp2Var_SysBase::macinit_(integer
     mblank__.imp = *ival;
   } else if (*imode == 2) {
     mblank__.ibb = *ival;
-    io______1.ciunit = mblank__.imp;
-    /*
-    s__wsfe(&io______1);
-    */
-    /*
-    do__fio(&c____1, (char *)&mblank__.ibb, (ftnlen)sizeof(integer));
-    */
     AdvApp2Var_SysBase::e__wsfe();
   } else if (*imode == 3) {
     mblank__.lec = *ival;
@@ -792,7 +782,7 @@ int macrgfl_(long int *iadfld,
   static integer ibid, ienr;
   static doublereal t[1];
   static integer novfl;
-  static long int ioff,iadrfl, iadt;
+  static long int ioff,iadt;
   
   
   /* ***********************************************************************
@@ -926,7 +916,6 @@ int macrgfl_(long int *iadfld,
   t[ioff] = -134744073.;
   
   /*  APPEL BIDON POUR PERMETTRE L'ARRET AU DEBUGGER : */
-  iadrfl = *iadfld;
   macrbrk_();
   
   /*  MISE A JOUR DU FLAG DE DEBUT */
@@ -934,7 +923,6 @@ int macrgfl_(long int *iadfld,
   t[ioff] = -134744073.;
     
   /*  APPEL BIDON POUR PERMETTRE L'ARRET AU DEBUGGER : */
-  iadrfl = *iadflf;
   macrbrk_();
   
   return 0 ;
@@ -955,14 +943,9 @@ int macrmsg_(const char *,//crout,
 {
   
   /* Local variables */
-  static integer inum, iunite;
-  static char cfm[80], cln[3];
+  static integer inum;
+  static char cln[3];
   
-  /* Fortran I/O blocks */
-  static cilist io___5 = { 0, 0, 0, cfm, 0 };
-  static cilist io___6 = { 0, 0, 0, cfm, 0 };
-  static cilist io___7 = { 0, 0, 0, cfm, 0 };
- 
 
 /* ***********************************************************************
  */
@@ -1210,32 +1193,12 @@ t !! ')", 80L, 54L);
    */
   /*  REALISATION DU WRITE , AVEC OU SANS DONNEES : */
   
-  iunite = AdvApp2Var_SysBase::mnfnimp_();
   if (inum == 0) {
-    io___5.ciunit = iunite;
-    /*
-    s__wsfe(&io___5);
-    */
     AdvApp2Var_SysBase::e__wsfe();
   } else if (inum == 1) {
-    io___6.ciunit = iunite;
-    /*
-    s__wsfe(&io___6);
-    */
-    /*
-    do__fio(&c__1, (char *)&it[1], (ftnlen)sizeof(integer));
-    */
     AdvApp2Var_SysBase::e__wsfe();
   } else {
     /*  LE MESSAGE N'EXISTE PAS ... */
-    io___7.ciunit = iunite;
-    /*
-    s__wsfe(&io___7);
-    */
-    /*
-    do__fio(&c__1, (char *)&(*num), (ftnlen)sizeof(integer));
-    do__fio(&c__1, crout, crout_len);
-    */
     AdvApp2Var_SysBase::e__wsfe();
   }
   
@@ -3025,7 +2988,7 @@ int AdvApp2Var_SysBase::mcrrqst_(integer
   static doublereal dfmt;
   static integer ifmt, iver;
   static char subr[7];
-  static integer ksys , ibyte, irest, isyst, ier;
+  static integer ksys , ibyte, irest, ier;
   static long int iadfd, iadff, iaddr,lofset, loc;
   static integer izu;
 
@@ -3276,7 +3239,6 @@ int AdvApp2Var_SysBase::mcrrqst_(integer
 
 /* DEMANDE D'ALLOCATION */
 
-    isyst = 0;
 /* L1001: */
 /*      IF ( ISYST.EQ.0.AND.IBYTE .LE. 100 * 1024 ) THEN */
 /*        ALLOCATION SUR TABLE */
@@ -3465,8 +3427,6 @@ void AdvApp2Var_SysBase::miraz_(integer
 				char *adt)
 
 {
-  integer offset;
-  offset = *taille;
   memset(adt , '\0' , *taille) ;
 }
 //=======================================================================
@@ -3622,9 +3582,6 @@ int AdvApp2Var_SysBase::mswrdbg_(const c
 
 {
 
-  static cilist io___1 = { 0, 0, 0, 0, 0 };
-  
-
 /* ***********************************************************************
  */
 
@@ -3671,8 +3628,6 @@ int AdvApp2Var_SysBase::mswrdbg_(const c
  */
 
     if (AdvApp2Var_SysBase::mnfndeb_() >= 1) {
-	io___1.ciunit = AdvApp2Var_SysBase::mnfnimp_();
-	//s__wsle(&io___1);
 	//do__lio(&c__9, &c__1, "Dbg ", 4L);
 	//do__lio(&c__9, &c__1, ctexte, ctexte_len);
 	AdvApp2Var_SysBase::e__wsle();
Index: oce/src/AlienImage/AlienImage_SunRFAlienData.cxx
===================================================================
--- oce.orig/src/AlienImage/AlienImage_SunRFAlienData.cxx
+++ oce/src/AlienImage/AlienImage_SunRFAlienData.cxx
@@ -109,7 +109,7 @@ void AlienImage_SunRFAlienData::Clear()
 
 Standard_Boolean AlienImage_SunRFAlienData::Write( OSD_File& file ) const
 
-{ Standard_Integer  size;
+{
   AlienImage_SUNRFFileHeader TheHeader = myHeader ;
 
   // Write out TheHeader information
@@ -136,8 +136,6 @@ Standard_Boolean AlienImage_SunRFAlienDa
 	}
   }
 
-  size = ( Standard_Integer ) sizeof( TheHeader ) ;
-
   const Standard_Address pHeader = ( Standard_Address ) &TheHeader ;
 
   file.Write( pHeader,  sizeof( TheHeader ) ) ;
Index: oce/src/AlienImage/AlienImage_X11XWDAlienData.cxx
===================================================================
--- oce.orig/src/AlienImage/AlienImage_X11XWDAlienData.cxx
+++ oce/src/AlienImage/AlienImage_X11XWDAlienData.cxx
@@ -46,7 +46,7 @@ const TCollection_AsciiString&  AlienIma
 
 void AlienImage_X11XWDAlienData::Clear()
 
-{ Standard_Integer size ;
+{
 
   myHeader.header_size	= sizeof( myHeader ) ; 
 				/* Size of the entire file header (bytes).*/
@@ -84,8 +84,6 @@ void AlienImage_X11XWDAlienData::Clear()
   }
 
   if ( myColors ) {
-	size = ( Standard_Integer ) 
-			myHeader.ncolors * sizeof( AlienImage_X11XColor ) ;
 	//Free all allocated memory
 	Standard::Free(myColors);
 	myColors = NULL ;
@@ -340,10 +338,6 @@ Standard_Boolean AlienImage_X11XWDAlienD
 	    	}
 	}
 
-#ifdef DEB
-	AlienImage_X11XColor *p  = ( AlienImage_X11XColor * )myColors ;
-#endif
-
 #ifdef TRACE
 	if ( Verbose ) 	{ 
 	  AlienImage_X11XColor *p = ( AlienImage_X11XColor * )myColors;
Index: oce/src/AppParCurves/AppParCurves.cxx
===================================================================
--- oce.orig/src/AppParCurves/AppParCurves.cxx
+++ oce/src/AppParCurves/AppParCurves.cxx
@@ -92,8 +92,8 @@ void AppParCurves::SecondDerivativeBerns
 //  Standard_Real U1 = 1-U, Y0, Y1, Xs;
   Standard_Real Y0, Y1, Xs;
   Standard_Integer NbPoles = DDA.Length();
-  Standard_Integer id, j, N2, N3, N4, deg = NbPoles-1;
-  N2 = deg-1; N3 = deg-2, N4 = deg*(deg-1);
+  Standard_Integer id, j, N4, deg = NbPoles-1;
+  N4 = deg*(deg-1);
   math_Vector B(1, deg-1);
   B(1) = 1.;
   
Index: oce/src/Aspect/Aspect_ColorScale.cxx
===================================================================
--- oce.orig/src/Aspect/Aspect_ColorScale.cxx
+++ oce/src/Aspect/Aspect_ColorScale.cxx
@@ -422,7 +422,6 @@ void Aspect_ColorScale::DrawScale( const
 
   TCollection_ExtendedString aTitle = GetTitle();
 
-  Standard_Integer titleWidth = 0;
   Standard_Integer titleHeight = 0;
 
   Standard_Integer aGray = (Standard_Integer)(255 * ( aBgColor.Red() * 11 + aBgColor.Green() * 16 + aBgColor.Blue() * 5 ) / 32);
@@ -430,7 +429,6 @@ void Aspect_ColorScale::DrawScale( const
 
   // Draw title
   if ( aTitle.Length() ) {
-    titleWidth = TextWidth( aTitle );
     titleHeight = TextHeight( aTitle ) + 2 * spacer;
     PaintText( aTitle, X + spacer, Y + spacer, aFgColor );
   }
Index: oce/src/BOP/BOP_FaceBuilder.cxx
===================================================================
--- oce.orig/src/BOP/BOP_FaceBuilder.cxx
+++ oce/src/BOP/BOP_FaceBuilder.cxx
@@ -274,7 +274,6 @@ static void DoTopologicalVerification(To
 //=======================================================================
   void BOP_FaceBuilder::BuildNewFaces() 
 {
-  Standard_Integer nF, nW, nE;
   Standard_Real    aTol;
   TopLoc_Location aLoc;
   TopoDS_Face newFace;
@@ -288,19 +287,19 @@ static void DoTopologicalVerification(To
   myNewFaces.Clear();
   myNegatives.Clear();
 
-  nF=InitFace();
+  InitFace();
   for (; MoreFace(); NextFace()) {
     bValidFace=Standard_False;
     aBB.MakeFace (newFace, aSurface, aLoc, aTol);
 
-    nW=InitWire();
+    InitWire();
     for (; MoreWire(); NextWire()) {
       if (IsOldWire()) {
 	newWire=TopoDS::Wire(OldWire());
       }
       else {
 	aBB.MakeWire(newWire);
-	nE=InitEdge();
+	InitEdge();
 	for (; MoreEdge(); NextEdge()) {
 	  const TopoDS_Edge& newEdge=Edge();
 	  aBB.Add(newWire, newEdge);
Index: oce/src/BOP/BOP_SDFWESFiller.cxx
===================================================================
--- oce.orig/src/BOP/BOP_SDFWESFiller.cxx
+++ oce/src/BOP/BOP_SDFWESFiller.cxx
@@ -363,7 +363,7 @@ static void TreatSDSeams (const TopoDS_E
   BOPTools_PaveFiller* pPaveFiller=(BOPTools_PaveFiller*) &aPaveFiller;
   BOPTools_CommonBlockPool& aCBPool=pPaveFiller->ChangeCommonBlockPool();
   //
-  Standard_Integer aBid=0, nE1, nE2, aNbSpON, nSp1, nSp2, iRankF1;
+  Standard_Integer aBid=0, nE1, nE2, aNbSpON, nSp1, iRankF1;
   Standard_Real aT1, aT2, aT, aTs; /*, U, V;*/ 
   Standard_Boolean aFlag;
   TColStd_ListOfInteger aLs;
@@ -425,7 +425,6 @@ static void TreatSDSeams (const TopoDS_E
 	// aPB2
 	BOPTools_PaveBlock& aPB2=aCB.PaveBlock2(nE1);
 	nE2=aPB2.OriginalEdge();
-	nSp2=aPB2.Edge();
 	const TopoDS_Edge& anE2=TopoDS::Edge(aDS.GetShape(nE2));
 	//
 	IntTools_Context& aContext=pPaveFiller->ChangeContext();
@@ -1285,7 +1284,7 @@ void TreatSDSeams (const TopoDS_Edge& aS
 			 TopoDS_Edge& aSS)
 				      
 {
-  Standard_Real a, b, aD1121, aD1122, aTol=1.e-7;
+  Standard_Real a, b, aD1121, aTol=1.e-7;
   Handle(Geom2d_Curve) aC2DSeam11, aC2DSeam21, aC2DSeam22;
   gp_Pnt2d aP2D11, aP2D21, aP2D22;
 
@@ -1299,7 +1298,6 @@ void TreatSDSeams (const TopoDS_Edge& aS
   aC2DSeam22->D0(aT2, aP2D22);
 
   aD1121=aP2D11.Distance(aP2D21);
-  aD1122=aP2D11.Distance(aP2D22);
   
   aSS=aSpE1Seam22;
   if (aD1121<aTol) {
Index: oce/src/BOP/BOP_ShellShell.cxx
===================================================================
--- oce.orig/src/BOP/BOP_ShellShell.cxx
+++ oce/src/BOP/BOP_ShellShell.cxx
@@ -216,7 +216,7 @@
   //
   // vars
   Standard_Boolean bIsTouchCase, bIsTouch;
-  Standard_Integer i, aNb, j, aNbj, iFF, nF1, iRank;
+  Standard_Integer i, aNb, j, aNbj, iFF, nF1;
   TopTools_ListOfShape aListOfNewFaces;
   TopTools_IndexedMapOfShape anEMap;
   TopAbs_Orientation anOriF1;
@@ -234,7 +234,6 @@
     const TopoDS_Face& aF1=TopoDS::Face(aDS.Shape(nF1));
     
     anOriF1=aF1.Orientation();
-    iRank=aDS.Rank(nF1);
     
     myFace=aF1;
     myFace.Orientation(TopAbs_FORWARD);
@@ -273,8 +272,6 @@
 	BOPTools_SSInterference& aFF=aFFs(iFF);
 	bIsTouch=aFF.IsTangentFaces();
 	if (bIsTouch) {
-	  Standard_Integer nF2;
-	  nF2=aFF.OppositeIndex(nF1);
 	  AddINON2DPartsSh(nF1, iFF, aWES);
 	}
       }
Index: oce/src/BOP/BOP_ShellSolid.cxx
===================================================================
--- oce.orig/src/BOP/BOP_ShellSolid.cxx
+++ oce/src/BOP/BOP_ShellSolid.cxx
@@ -1249,7 +1249,7 @@ Standard_Boolean BOP_ShellSolid::CheckAr
 //=======================================================================
   void BOP_ShellSolid::FillSectionEdges()
 {
-  Standard_Integer i, j, nF1, nF2,  aNbFFs, aNbS, aNbCurves, nSect;
+  Standard_Integer i, j, aNbFFs, aNbS, aNbCurves, nSect;
   //
   const BooleanOperations_ShapesDataStructure& aDS=myDSFiller->DS();
   const BOPTools_InterferencePool& anInterfPool=myDSFiller->InterfPool();
@@ -1262,9 +1262,6 @@ Standard_Boolean BOP_ShellSolid::CheckAr
   for (i=1; i<=aNbFFs; ++i) {
     BOPTools_SSInterference& aFFi=aFFs(i);
     //
-    nF1=aFFi.Index1();
-    nF2=aFFi.Index2();
-    //
     // Old Section Edges
     const BOPTools_ListOfPaveBlock& aSectList=aFFi.PaveBlocks();
     aNbS=aSectList.Extent();
Index: oce/src/BOP/BOP_ShellSolid_1.cxx
===================================================================
--- oce.orig/src/BOP/BOP_ShellSolid_1.cxx
+++ oce/src/BOP/BOP_ShellSolid_1.cxx
@@ -81,12 +81,9 @@ static
   BOPTools_InterferencePool* pIntrPool=(BOPTools_InterferencePool*)&myDSFiller->InterfPool();
   BOPTools_CArray1OfSSInterference& aFFs=pIntrPool->SSInterferences();
   //
-  Standard_Integer i, aNbCurves, nF2,  nE, iRankF1;
-  //
-  iRankF1=aDS.Rank(nF1);
+  Standard_Integer i, aNbCurves, nE;
   //
   BOPTools_SSInterference& aFF=aFFs(iFF);
-  nF2=aFF.OppositeIndex(nF1);
   //
   BOPTools_SequenceOfCurves& aSC=aFF.Curves();
   aNbCurves=aSC.Length();
@@ -318,7 +315,7 @@ static
   BOPTools_PaveFiller* pPaveFiller=(BOPTools_PaveFiller*)&aPF;
   BOPTools_CommonBlockPool& aCBPool=pPaveFiller->ChangeCommonBlockPool();
   //
-  Standard_Integer iRankF1, iRankF2, nF2, nSpEF2, nEF2,  nFace;
+  Standard_Integer iRankF2, nF2, nSpEF2, nEF2,  nFace;
   TopExp_Explorer anExp2;
   TopAbs_Orientation anOrEF2;
   //
@@ -327,7 +324,6 @@ static
   //
   const TopoDS_Face& aF2=TopoDS::Face(aDS.Shape(nF2));
   //
-  iRankF1=aDS.Rank(nF1);
   iRankF2=aDS.Rank(nF2);
   //
   // EF2\F1 Processing
Index: oce/src/BOP/BOP_ShellSolid_2.cxx
===================================================================
--- oce.orig/src/BOP/BOP_ShellSolid_2.cxx
+++ oce/src/BOP/BOP_ShellSolid_2.cxx
@@ -1348,7 +1348,7 @@ void SecondInternal(TopoDS_Edge& aSS,
   //
   IntTools_Context& aContext=pPaveFiller->ChangeContext();
   //
-  Standard_Integer nEF1, nF2, nSpF1, nSpF2, nEF2, nSpTaken, iRankF1, nF2x, iRankF2, iSenseFlag;
+  Standard_Integer nEF1, nF2, nSpF1, nSpF2, nEF2, nSpTaken, iRankF1, nF2x, iSenseFlag;
   TopAbs_Orientation anOrEF1;
   TopExp_Explorer anExp;
   TopTools_IndexedMapOfShape aM;
@@ -1370,8 +1370,6 @@ void SecondInternal(TopoDS_Edge& aSS,
     return ;
   }
   //
-  iRankF2=aDS.Rank(nF2);
-  //
   pPaveFiller->SplitsOnFace(0, nF1, nF2, aSplitsOnF1);
   //
   anIt.Initialize(aSplitsOnF1);
Index: oce/src/BOP/BOP_ShellSplitter.cxx
===================================================================
--- oce.orig/src/BOP/BOP_ShellSplitter.cxx
+++ oce/src/BOP/BOP_ShellSplitter.cxx
@@ -441,7 +441,7 @@ Standard_Boolean GetShells(TopTools_Sequ
 			   TopTools_SequenceOfShape& ErrFaces) 
 {
   Standard_Boolean done = Standard_False;
-  Standard_Integer i, j, aNbLfaceLength;
+  Standard_Integer i, j;
 
   j=Lface.Length();
   if(!j) {
@@ -460,7 +460,6 @@ Standard_Boolean GetShells(TopTools_Sequ
   j=1;
   //
   for(; i<=Lface.Length(); i++)  {
-    aNbLfaceLength=Lface.Length();
     TopTools_MapOfShape dtemp, rtemp;
     Standard_Integer nbbe=0, nbe = 0;
     
@@ -523,7 +522,6 @@ Standard_Boolean GetShells(TopTools_Sequ
     if( nbe != 0 && nbbe != 0) {
       ErrFaces.Append(aF);
       Lface.Remove(i);
-      aNbLfaceLength=Lface.Length();
       j++;
       continue;
     }
@@ -560,7 +558,6 @@ Standard_Boolean GetShells(TopTools_Sequ
       B.Add(nshell, aF);
       aMapFaceShells.Bind(aF, nshell);
       Lface.Remove(i);
-      aNbLfaceLength=Lface.Length();
       if(isMultiConnex && BRep_Tool::IsClosed(nshell)) {
         aSeqShells.Append(nshell);
         TopoDS_Shell nshellnext;
@@ -835,7 +832,6 @@ void CreateClosedShell(TopTools_Sequence
     // 
     for(j=i+1; j<=OpenShells.Length(); j++)  {
       Standard_Integer nbedge =0;
-      Standard_Boolean isReversed = Standard_False;
       
       const TopoDS_Shape& anOpenShellj=OpenShells.Value(j);
 
@@ -866,13 +862,6 @@ void CreateClosedShell(TopTools_Sequence
 	  }
 
           isClosedShell = Standard_True;
-
-	  TopAbs_Orientation anOrE2;
-	  anOrE2=aE2.Orientation();
-          if((anOrE2 == TopAbs_FORWARD  && bDireContains) || 
-	     (anOrE2 == TopAbs_REVERSED && bReveContains)) {
-            isReversed = Standard_True;
-	  }
           nbedge++;
         }
       }// for(; aExpF2.More() && !nbedge; aExpF2.Next())
Index: oce/src/BOP/BOP_SolidSolid_1.cxx
===================================================================
--- oce.orig/src/BOP/BOP_SolidSolid_1.cxx
+++ oce/src/BOP/BOP_SolidSolid_1.cxx
@@ -95,7 +95,6 @@ void BOP_SolidSolid::PrepareFaceSplits()
   BOPTColStd_IndexedDataMapOfIntegerIndexedMapOfInteger aFFMap;
   BOP_BuilderTools::DoMap(aFFs, aFFMap);
   TopTools_ListOfShape aListOfNewFaces;
-  TopAbs_Orientation anOriF1 = TopAbs_FORWARD;
 
   TColStd_DataMapOfIntegerListOfInteger& aMapOfFaceSplits = myDSFiller->ChangeSplitFacePool();
   
@@ -107,7 +106,6 @@ void BOP_SolidSolid::PrepareFaceSplits()
     nF1 = aFFMap.FindKey(i);
     TopoDS_Face aF1 = TopoDS::Face(aDS.Shape(nF1));
     
-    anOriF1 = aF1.Orientation();
     iRank   = aDS.Rank(nF1);
 
     TopTools_DataMapOfShapeInteger aMapOfEdgeIndex;
Index: oce/src/BOP/BOP_WireShape.cxx
===================================================================
--- oce.orig/src/BOP/BOP_WireShape.cxx
+++ oce/src/BOP/BOP_WireShape.cxx
@@ -176,7 +176,7 @@ static
   const BOPTools_PaveFiller& aPaveFiller=myDSFiller->PaveFiller();
   const BOPTools_CommonBlockPool& aCommonBlockPool=aPaveFiller.CommonBlockPool();
 
-  Standard_Integer i, aNbCB, nSpTaken, iBeg, iEnd;
+  Standard_Integer i, nSpTaken, iBeg, iEnd;
   TopAbs_ShapeEnum aType, aTypeArg1, aTypeArg2;
   BOPTools_ListIteratorOfListOfCommonBlock anItCB;
   //
@@ -200,7 +200,6 @@ static
     }
     //
     const BOPTools_ListOfCommonBlock& aLCB=aCommonBlockPool(aDS.RefEdge(i));
-    aNbCB=aLCB.Extent();
 
     anItCB.Initialize(aLCB);
     for (; anItCB.More(); anItCB.Next()) {
Index: oce/src/BOPTest/BOPTest_BOPCommands.cxx
===================================================================
--- oce.orig/src/BOPTest/BOPTest_BOPCommands.cxx
+++ oce/src/BOPTest/BOPTest_BOPCommands.cxx
@@ -463,9 +463,8 @@ Standard_Integer boperationFiller (Stand
     return 1;
   }
 
-  Standard_Boolean aMFlag, anIsDone;
+  Standard_Boolean anIsDone;
 
-  aMFlag=Standard_False;
   //
   BRepAlgoAPI_BooleanOperation* pBuilder=NULL;
   // 
@@ -1374,7 +1373,7 @@ Standard_Integer bopscts (Draw_Interpret
     di << " Prepare BOPTools_DSFiller first >bop S1 S2\n";
     return 0;
   }
-  Standard_Integer i, nF1, nF2,  aNbFFs, aNbOldSects, aSectExist=0, nSect;
+  Standard_Integer i, nF1, aNbFFs, aNbOldSects, aSectExist=0, nSect;
   Standard_Integer j, aNbCurves, aNbPaveBlocks, nNewEdge;
   Draw_Color aTextColor(Draw_cyan);
   TCollection_AsciiString aNm("t");
@@ -1389,7 +1388,6 @@ Standard_Integer bopscts (Draw_Interpret
     BOPTools_SSInterference& aFFi=aFFs(i);
     //
     nF1=aFFi.Index1();
-    nF2=aFFi.Index2();
     TCollection_AsciiString aInd(nF1), anUnd("_");
     //
     // Old Section Edges
@@ -1777,7 +1775,7 @@ Standard_Integer bopwho (Draw_Interpreto
   // PaveBlocks 
   if (aTypeOfShapeToFind==TopAbs_EDGE) {
     //
-    Standard_Integer aNbPaveBlocks, nE, nOriginalEdge, aNbCommonBlocks;
+    Standard_Integer nE, nOriginalEdge;
     Standard_Integer nFace, nE2,  nOriginalEdge2;
     //
     const BOPTools_CommonBlockPool& aCommonBlockPool=pDF->CommonBlockPool();
@@ -1785,7 +1783,6 @@ Standard_Integer bopwho (Draw_Interpreto
     aNbLines=aSplitShapesPool.Extent();
     for (i=1; i<=aNbLines; ++i) {
       const BOPTools_ListOfPaveBlock& aSplitEdges=aSplitShapesPool(i);
-      aNbPaveBlocks=aSplitEdges.Extent();
       
       BOPTools_ListIteratorOfListOfPaveBlock aPBIt(aSplitEdges);
       for (; aPBIt.More(); aPBIt.Next()) {
@@ -1797,7 +1794,6 @@ Standard_Integer bopwho (Draw_Interpreto
 	  di << "  PaveBlock [Base Edge #" << nOriginalEdge << "]\n";
 	  const BOPTools_ListOfCommonBlock& aLCB=
 	    aCommonBlockPool(aDS.RefEdge(nOriginalEdge));
-	  aNbCommonBlocks=aLCB.Extent();
 	  
 	  BOPTools_ListIteratorOfListOfCommonBlock aCBIt(aLCB);
 	  for (; aCBIt.More(); aCBIt.Next()) {
Index: oce/src/BOPTest/BOPTest_TolerCommands.cxx
===================================================================
--- oce.orig/src/BOPTest/BOPTest_TolerCommands.cxx
+++ oce/src/BOPTest/BOPTest_TolerCommands.cxx
@@ -209,7 +209,7 @@ void ReduceVertexTolerance (const TopoDS
 void ProcessEdge(const TopoDS_Edge& aE, const Standard_Real aTolTreshold)
 {
   Standard_Integer i, aNb=23;
-  Standard_Real aTolE, aD2, aTolMax2, aT1, aT2, aT, dT;
+  Standard_Real aD2, aTolMax2, aT1, aT2, aT, dT;
   gp_Pnt aPC3D, aP3D;
   gp_Pnt2d aPC2D;
 
@@ -273,7 +273,6 @@ void ProcessEdge(const TopoDS_Edge& aE,
     return;
   }
   //
-  aTolE =BRep_Tool::Tolerance(aE);
   //
   aTolMax2=sqrt(aTolMax2); 
   
@@ -292,7 +291,7 @@ void ProcessVertex(const TopoDS_Vertex&
 		   const TopTools_ListOfShape& aLE,
 		   const TopTools_ListOfShape& aLF)
 {
-  Standard_Real aTol, aTol2, aD2, aTolMax2, aTolE, aParam;
+  Standard_Real aTol, aD2, aTolMax2, aTolE, aParam;
   gp_Pnt aPC3D;
   gp_Pnt2d aPC2D;
   TopAbs_Orientation anOrV;
@@ -308,7 +307,6 @@ void ProcessVertex(const TopoDS_Vertex&
   Handle(BRep_TVertex)& TV = *((Handle(BRep_TVertex)*) &aV.TShape());
   const gp_Pnt& aPV3D = TV->Pnt();
   aTol =BRep_Tool::Tolerance(aV);
-  aTol2=aTol*aTol;
   //
   anIt.Initialize(aLE);
   for (; anIt.More(); anIt.Next()) {
Index: oce/src/BOPTools/BOPTools_Checker.cxx
===================================================================
--- oce.orig/src/BOPTools/BOPTools_Checker.cxx
+++ oce/src/BOPTools/BOPTools_Checker.cxx
@@ -373,7 +373,7 @@ void BOPTools_Checker::PerformEE()
   myIsDone=Standard_False;
 
   Standard_Boolean justaddinterference;
-  Standard_Integer n1, n2, anIndexIn=0, nE1, nE2;
+  Standard_Integer n1, n2, nE1, nE2;
   Standard_Integer aTmp, aWhat, aWith;
   Standard_Integer i, aNbCPrts;
   //
@@ -459,7 +459,6 @@ void BOPTools_Checker::PerformEE()
 	  
 	aEE.Perform();
 	//
-	anIndexIn=0;
 	//
 	if (aEE.IsDone()) {
 	  //
@@ -483,7 +482,6 @@ void BOPTools_Checker::PerformEE()
 	  for (i=1; i<=aNbCPrts; i++) {
 	    const IntTools_CommonPrt& aCPart=aCPrts(i);
 	    //
-	    anIndexIn=0;
 	    //
 	    TopAbs_ShapeEnum aType=aCPart.Type();
 	    switch (aType) {
@@ -790,7 +788,7 @@ void BOPTools_Checker::PerformEF()
     //
     // FF
     Standard_Boolean bToApproxC3d, bToApproxC2dOnS1, bToApproxC2dOnS2;
-    Standard_Real anApproxTol, aTolR3D, aTolR2D;
+    Standard_Real anApproxTol, aTolR3D;
     //
     bToApproxC3d     = mySectionAttribute.Approximation();
     bToApproxC2dOnS1 = mySectionAttribute.PCurveOnS1();
@@ -809,7 +807,6 @@ void BOPTools_Checker::PerformEF()
     if (aFF.IsDone()) {
       // Add Interference to the Pool
       aTolR3D=aFF.TolReached3d();
-      aTolR2D=aFF.TolReached2d();
       if (aTolR3D < 1.e-7){
 	aTolR3D=1.e-7;
       } 
Index: oce/src/BOPTools/BOPTools_DEProcessor.cxx
===================================================================
--- oce.orig/src/BOPTools/BOPTools_DEProcessor.cxx
+++ oce/src/BOPTools/BOPTools_DEProcessor.cxx
@@ -629,7 +629,7 @@
   BOPTools_CArray1OfSSInterference& aFFs=(myFiller->InterfPool())->SSInterferences();
   
   BOPTools_ListIteratorOfListOfPaveBlock anIt;
-  Standard_Integer i, aNb, nF2, nSp, nV;
+  Standard_Integer i, aNb, nF2, nV;
 
   //ZZ const TopoDS_Edge& aDE=TopoDS::Edge(myDS->Shape(nED));
   
@@ -647,7 +647,6 @@
     anIt.Initialize(aLPBSplits);
     for (; anIt.More(); anIt.Next()) {
       const BOPTools_PaveBlock& aPBSp=anIt.Value();
-      nSp=aPBSp.Edge();
       
       const BOPTools_Pave& aPave1=aPBSp.Pave1();
       nV=aPave1.Index();
Index: oce/src/BOPTools/BOPTools_PaveFiller_1.cxx
===================================================================
--- oce.orig/src/BOPTools/BOPTools_PaveFiller_1.cxx
+++ oce/src/BOPTools/BOPTools_PaveFiller_1.cxx
@@ -343,14 +343,14 @@
 	      //
 	      BooleanOperations_AncestorsSeqAndSuccessorsSeq anASSeq; 
 	      //
-	      Standard_Integer nVF, iFlag;
+	      Standard_Integer nVF;
 	      nVF=CheckFacePaves(aNewVertex, nF);
 	      if (nVF) {
 		const TopoDS_Vertex& aVF=TopoDS::Vertex(myDS->Shape(nVF));
 		
 		Standard_Real aTNew;
 		//
-		iFlag=myContext.ComputeVE(aVF, aE, aTNew);
+		myContext.ComputeVE(aVF, aE, aTNew);
 		//
 		aT=aTNew;
 		aNewShape=nVF;
Index: oce/src/BOPTools/BOPTools_PaveFiller_2.cxx
===================================================================
--- oce.orig/src/BOPTools/BOPTools_PaveFiller_2.cxx
+++ oce/src/BOPTools/BOPTools_PaveFiller_2.cxx
@@ -252,7 +252,6 @@
   BOPTools_ListIteratorOfListOfCommonBlock anItCB(aLCB);
   for (; anItCB.More(); anItCB.Next()) {
     BOPTools_CommonBlock& aCB=anItCB.Value();
-    BOPTools_PaveBlock& aPB1=aCB.PaveBlock1(nE1);
     BOPTools_PaveBlock& aPB2=aCB.PaveBlock2(nE1);
     nE=aPB2.OriginalEdge();
     if (nE==nE2) {
Index: oce/src/BOPTools/BOPTools_PaveFiller_3.cxx
===================================================================
--- oce.orig/src/BOPTools/BOPTools_PaveFiller_3.cxx
+++ oce/src/BOPTools/BOPTools_PaveFiller_3.cxx
@@ -712,21 +712,18 @@ static
 							 const BOPTools_SSInterference& aFFi)
 							 
 {
-  Standard_Real aTolC, aTE, aT11, aT12;
+  Standard_Real aTE;
   Standard_Integer nV11, nV12, nV21, nV22, iVV, iVE, nE2, iCount=0, iCountExt=1;
   Standard_Integer iV;
 
-  aTolC=aFFi.TolR3D();
   // V11
   const BOPTools_Pave& aPave11=aPB.Pave1();
   nV11=aPave11.Index();
   const TopoDS_Vertex& aV11=TopoDS::Vertex(myDS->GetShape(nV11));
-  aT11=aPave11.Param();
   // V12
   const BOPTools_Pave& aPave12=aPB.Pave2();
   nV12=aPave12.Index();
   const TopoDS_Vertex& aV12=TopoDS::Vertex(myDS->GetShape(nV12));
-  aT12=aPave12.Param();
   //
   const BOPTools_ListOfPaveBlock& aLPB=aFFi.PaveBlocks();
   BOPTools_ListIteratorOfListOfPaveBlock anIt(aLPB);
@@ -1204,7 +1201,7 @@ static
 //=======================================================================
   void BOPTools_PaveFiller::MakeSectionEdges()
 {
-  Standard_Integer i, j, aNbCurves, aNbFFs, nF1, nF2, nV1, nV2, aNbPaveBlocks,
+  Standard_Integer i, j, aNbCurves, aNbFFs, nF1, nF2, nV1, nV2,
                    aNewShapeIndex ;
   Standard_Real    t1, t2;
   TopoDS_Edge aESect;
@@ -1237,7 +1234,6 @@ static
       const IntTools_Curve& aIC=aBC.Curve();
       //
       const BOPTools_ListOfPaveBlock& aSectEdges=aBC.NewPaveBlocks();
-      aNbPaveBlocks=aSectEdges.Extent();
       BOPTools_ListIteratorOfListOfPaveBlock aPBIt(aSectEdges);
       pbi = 0;
       for (; aPBIt.More(); aPBIt.Next()) {
@@ -3153,7 +3149,6 @@ Standard_Integer RejectBuildingEdge(cons
     return 0;
 
   Handle(Geom_Curve) aTCurve;
-  Standard_Real aTT;
   
   Standard_Integer eIndex = 0;
   Standard_Boolean edgeFound = Standard_False;
@@ -3187,7 +3182,6 @@ Standard_Integer RejectBuildingEdge(cons
     if(sameParam) {
       Standard_Real f,l;
       aTCurve = BRep_Tool::Curve(aE,f,l);
-      aTT = BRep_Tool::Tolerance(aE);
       edgeFound = Standard_True;
     }
     if(edgeFound)
Index: oce/src/BOPTools/BOPTools_PaveSet.cxx
===================================================================
--- oce.orig/src/BOPTools/BOPTools_PaveSet.cxx
+++ oce/src/BOPTools/BOPTools_PaveSet.cxx
@@ -64,9 +64,8 @@
       anArray1OfPave(i)=aPave;
     }
     
-    BOPTools_QuickSortPave aQuickSortPave;
     BOPTools_ComparePave   aComparePave;
-    aQuickSortPave.Sort (anArray1OfPave, aComparePave);
+    BOPTools_QuickSortPave::Sort (anArray1OfPave, aComparePave);
     
     myPaveList.Clear();
     for (i=1; i<=aNbPaves; i++){
Index: oce/src/BOPTools/BOPTools_SolidStateFiller.cxx
===================================================================
--- oce.orig/src/BOPTools/BOPTools_SolidStateFiller.cxx
+++ oce/src/BOPTools/BOPTools_SolidStateFiller.cxx
@@ -553,15 +553,13 @@ static
 //=======================================================================
   void BOPTools_SolidStateFiller::DoSections()
 {
-  Standard_Integer i, j, aNb, aNbCurves,  n1, n2, nE;
+  Standard_Integer i, j, aNb, aNbCurves,  nE;
   
   BOPTools_CArray1OfSSInterference& aFFs=myIntrPool->SSInterferences();
   
   aNb=aFFs.Extent();
   for (i=1; i<=aNb; i++) {
     BOPTools_SSInterference& aFF=aFFs(i);
-    n1=aFF.Index1();
-    n2=aFF.Index2();
     BOPTools_SequenceOfCurves& aSC=aFF.Curves();
     aNbCurves=aSC.Length();
     for (j=1; j<=aNbCurves; j++) {
Index: oce/src/BOPTools/BOPTools_Tools3D.cxx
===================================================================
--- oce.orig/src/BOPTools/BOPTools_Tools3D.cxx
+++ oce/src/BOPTools/BOPTools_Tools3D.cxx
@@ -1117,7 +1117,6 @@ static void GetApproxNormalToFaceOnEdgeE
       TopExp_Explorer anExp;
       Standard_Integer nbW = 0;
       for(anExp.Init(aF, TopAbs_WIRE); anExp.More(); anExp.Next()) {
-	const TopoDS_Wire& aW = TopoDS::Wire(anExp.Current());
 	nbW++;
       }
       if( nbW == 1 ) {
@@ -1129,7 +1128,6 @@ static void GetApproxNormalToFaceOnEdgeE
 	for( iKey = 1; iKey <= nbKeys; iKey++ ) {
 	  const TopoDS_Vertex& iV = TopoDS::Vertex(mapVE.FindKey(iKey));
 	  if( iV.IsNull() ) continue;
-	  Standard_Real TolV = BRep_Tool::Tolerance(iV);
 	  const TopTools_ListOfShape& iLE = mapVE.FindFromIndex(iKey);
 	  Standard_Integer nbE = iLE.Extent();
 	  if( nbE != 2 ) {
@@ -1251,7 +1249,7 @@ static Standard_Boolean PseudoSDFaces(co
 
 
   const TopoDS_Face& aF1 = BS1.Face();
-  Standard_Real maxTolE1 = 1.e-7, maxTolV1 = 1.e-7;
+  Standard_Real maxTolE1 = 1.e-7;
   Standard_Integer nbE1 = 0, nbOnE1 = 0;
   for(anExpE.Init(aF1, TopAbs_EDGE); anExpE.More(); anExpE.Next()) {
     const TopoDS_Edge& aE = TopoDS::Edge(anExpE.Current());
@@ -1307,7 +1305,7 @@ static Standard_Boolean PseudoSDFaces(co
     return Standard_False;
 
   const TopoDS_Face& aF2 = BS1.Face();
-  Standard_Real maxTolE2 = 1.e-7, maxTolV2 = 1.e-7;
+  Standard_Real maxTolE2 = 1.e-7;
   Standard_Integer nbE2 = 0, nbOnE2 = 0;
   for(anExpE.Init(aF2, TopAbs_EDGE); anExpE.More(); anExpE.Next()) {
     const TopoDS_Edge& aE = TopoDS::Edge(anExpE.Current());
Index: oce/src/BRep/BRep_Builder.cxx
===================================================================
--- oce.orig/src/BRep/BRep_Builder.cxx
+++ oce/src/BRep/BRep_Builder.cxx
@@ -98,12 +98,6 @@ static void UpdateCurves(BRep_ListOfCurv
     GC = Handle(BRep_GCurve)::DownCast(itcr.Value());
     if (!GC.IsNull()) {
       if (GC->IsCurve3D()) {
-#ifdef DEB
-        const Handle(Geom_Curve)& Crv =
-#endif
-                                      GC->Curve3D();
-//      if (!C.IsNull()) { //xpu031198, edge degeneree
-
         // xpu151298 : parameters can be setted for null curves
         //             see lbo & flo, to determine whether range is defined
         //             compare first and last parameters with default values.
@@ -168,12 +162,6 @@ static void UpdateCurves(BRep_ListOfCurv
     GC = Handle(BRep_GCurve)::DownCast(itcr.Value());
     if (!GC.IsNull()) {
       if (GC->IsCurve3D()) {
-#ifdef DEB
-        const Handle(Geom_Curve)& Crv =
-#endif
-                                      GC->Curve3D();
-//      if (!C.IsNull()) { //xpu031198, edge degeneree
-
         // xpu151298 : parameters can be setted for null curves
         //             see lbo & flo, to determine whether range is defined
         //             compare first and last parameters with default values.
Index: oce/src/BRepAdaptor/BRepAdaptor_CompCurve.cxx
===================================================================
--- oce.orig/src/BRepAdaptor/BRepAdaptor_CompCurve.cxx
+++ oce/src/BRepAdaptor/BRepAdaptor_CompCurve.cxx
@@ -77,9 +77,8 @@ BRepAdaptor_CompCurve::BRepAdaptor_CompC
                            // a rebourt.
   if((NbEdge > 2) || ((NbEdge==2) && (!myWire.Closed())) ) {
     TopAbs_Orientation Or = myCurves->Value(1).Edge().Orientation();
-    Standard_Boolean B;
     TopoDS_Vertex VI, VL;
-    B = TopExp::CommonVertex(myCurves->Value(1).Edge(),
+    TopExp::CommonVertex(myCurves->Value(1).Edge(),
 			     myCurves->Value(2).Edge(),
 			     VI);
     VL = TopExp::LastVertex(myCurves->Value(1).Edge());
Index: oce/src/BRepAlgo/BRepAlgo_Loop.cxx
===================================================================
--- oce.orig/src/BRepAlgo/BRepAlgo_Loop.cxx
+++ oce/src/BRepAlgo/BRepAlgo_Loop.cxx
@@ -494,26 +494,22 @@ void BRepAlgo_Loop::Perform()
 #ifdef DEB
   if (AffichLoop) {
     cout <<"NewLoop"<<endl;
-    Standard_Integer NbEdges = 1;
     NbLoops++;
 #ifdef DRAW
+    Standard_Integer NbEdges = 1;
     sprintf(name,"FLoop_%d",NbLoops);
     DBRep::Set(name,myFace);
-#endif
     for (Mapit.Initialize(myVerOnEdges); Mapit.More(); Mapit.Next()) { 
       const TopoDS_Edge& E = TopoDS::Edge(Mapit.Key());
-#ifdef DRAW
       sprintf(name,"EEE_%d_%d",NbLoops,NbEdges++);
       DBRep::Set(name,E);
-#endif
     }
     for (itl.Initialize(myConstEdges); itl.More(); itl.Next()) {
       const TopoDS_Edge& E = TopoDS::Edge(itl.Value());    
-#ifdef DRAW
       sprintf(name,"EEE_%d_%d",NbLoops,NbEdges++);
       DBRep::Set(name,E);
-#endif
     }
+#endif
   }
 #endif
   
Index: oce/src/BRepAlgo/BRepAlgo_TopOpe.cxx
===================================================================
--- oce.orig/src/BRepAlgo/BRepAlgo_TopOpe.cxx
+++ oce/src/BRepAlgo/BRepAlgo_TopOpe.cxx
@@ -254,7 +254,7 @@ const TopTools_ListOfShape& BRepAlgo_Top
   TopTools_MapOfShape ME;
   ME.Clear();
 
-  Standard_Integer i, j,  aNbFFs, aNbS, aNbCurves, nSect;
+  Standard_Integer i, j,  aNbFFs, aNbCurves, nSect;
     
   const BooleanOperations_ShapesDataStructure& aDS=myDSFiller->DS();
   const BOPTools_InterferencePool& anInterfPool=myDSFiller->InterfPool();
@@ -270,7 +270,6 @@ const TopTools_ListOfShape& BRepAlgo_Top
     //
     // Old Section Edges
     const BOPTools_ListOfPaveBlock& aSectList=aFFi.PaveBlocks();
-    aNbS=aSectList.Extent();
     BOPTools_ListIteratorOfListOfPaveBlock anIt(aSectList);
     for (; anIt.More();anIt.Next()) {
       const BOPTools_PaveBlock& aPB=anIt.Value();
@@ -291,7 +290,6 @@ const TopTools_ListOfShape& BRepAlgo_Top
     for (j=1; j<=aNbCurves; j++) {
       BOPTools_Curve& aBC=aBCurves(j);
       const BOPTools_ListOfPaveBlock& aSectEdges=aBC.NewPaveBlocks();
-      aNbS=aSectEdges.Extent();
       
       BOPTools_ListIteratorOfListOfPaveBlock aPBIt(aSectEdges);
       for (; aPBIt.More(); aPBIt.Next()) {
Index: oce/src/BRepBlend/BRepBlend_CurvPointRadInv.cxx
===================================================================
--- oce.orig/src/BRepBlend/BRepBlend_CurvPointRadInv.cxx
+++ oce/src/BRepBlend/BRepBlend_CurvPointRadInv.cxx
@@ -68,14 +68,13 @@ Standard_Boolean BRepBlend_CurvPointRadI
 {
   gp_Pnt ptcur1, ptcur2;
   gp_Vec d1cur1,d2cur1, d1cur2, nplan, dnplan;
-  Standard_Real theD, dtheD, normd1cur1, unsurnormd1cur1;
+  Standard_Real dtheD, normd1cur1, unsurnormd1cur1;
 
   curv1->D2(X(1), ptcur1, d1cur1, d2cur1);
 
   normd1cur1      = d1cur1.Magnitude();
   unsurnormd1cur1 = 1. / normd1cur1;
   nplan           = unsurnormd1cur1 * d1cur1;
-  theD            = -(nplan.XYZ().Dot(ptcur1.XYZ()));
   dnplan.SetLinearForm(-nplan.Dot(d2cur1), nplan, d2cur1);
   dnplan.Multiply(unsurnormd1cur1);
   dtheD  = - nplan.XYZ().Dot(d1cur1.XYZ()) - dnplan.XYZ().Dot(ptcur1.XYZ());
@@ -97,10 +96,8 @@ Standard_Boolean BRepBlend_CurvPointRadI
 						   math_Vector& F,
 						   math_Matrix& D) 
 {
-  Standard_Boolean Retour;
-
-  Retour = Value(X, F);
-  Retour = Derivatives(X, D);
+  Value(X, F);
+  Derivatives(X, D);
 
   return Standard_True;
 }
Index: oce/src/BRepBlend/BRepBlend_RstRstConstRad.cxx
===================================================================
--- oce.orig/src/BRepBlend/BRepBlend_RstRstConstRad.cxx
+++ oce/src/BRepBlend/BRepBlend_RstRstConstRad.cxx
@@ -122,10 +122,8 @@ Standard_Boolean BRepBlend_RstRstConstRa
 						  math_Vector&       F,
 						  math_Matrix&       D)
 {
-  Standard_Boolean Error;
-
-  Error = Value(X, F);  
-  Error = Derivatives(X, D);
+  Value(X, F);  
+  Derivatives(X, D);
  
   return Standard_True;
 }
@@ -453,9 +451,7 @@ Blend_DecrochStatus BRepBlend_RstRstCons
   // Normal to the reference surface 2
   NRst2     = d1u.Crossed(d1v);
 
-  Standard_Boolean IsCenter;
-
-  IsCenter = CenterCircleRst1Rst2(PtTmp1, PtTmp2, nplan, Center, NotUsed);
+  CenterCircleRst1Rst2(PtTmp1, PtTmp2, nplan, Center, NotUsed);
 
   norm      = nplan.Crossed(NRst1).Magnitude();
   unsurnorm = 1. / norm;
@@ -594,9 +590,7 @@ void BRepBlend_RstRstConstRad::Section(c
   ptrst1   = cons1.Value(U);
   ptrst2   = cons2.Value(V);
 
-  Standard_Boolean IsCenter;
-
-  IsCenter = CenterCircleRst1Rst2(ptrst1, ptrst2, np, Center, NotUsed);
+  CenterCircleRst1Rst2(ptrst1, ptrst2, np, Center, NotUsed);
 
   C.SetRadius(Abs(ray));
   ns = gp_Vec(Center, ptrst1).Normalized(); 
@@ -769,8 +763,7 @@ void BRepBlend_RstRstConstRad::Section(c
   }
 
   // Calculate the center of the circle
-  Standard_Boolean IsCenter;
-  IsCenter = CenterCircleRst1Rst2(ptrst1, ptrst2, nplan, Center, NotUsed);
+  CenterCircleRst1Rst2(ptrst1, ptrst2, nplan, Center, NotUsed);
 
   // normals to the section with points 
   ns  = gp_Vec(Center, ptrst1).Normalized();  
@@ -813,9 +806,6 @@ Standard_Boolean BRepBlend_RstRstConstRa
   math_Matrix gradsol(1, 2, 1, 2);
   
   Standard_Real prm       = P.Parameter();
-#ifdef DEB
-  Standard_Integer NbSpan = (Poles.Length() - 1) / 2;
-#endif
   Standard_Integer low    = Poles.Lower();
   Standard_Integer upp    = Poles.Upper();
   Standard_Boolean istgt;
Index: oce/src/BRepBlend/BRepBlend_RstRstEvolRad.cxx
===================================================================
--- oce.orig/src/BRepBlend/BRepBlend_RstRstEvolRad.cxx
+++ oce/src/BRepBlend/BRepBlend_RstRstEvolRad.cxx
@@ -184,10 +184,8 @@ Standard_Boolean BRepBlend_RstRstEvolRad
 						 math_Vector&       F,
 						 math_Matrix&       D)
 {
-  Standard_Boolean Error;
-
-  Error = Value(X, F);  
-  Error = Derivatives(X, D);
+  Value(X, F);  
+  Derivatives(X, D);
  
   return Standard_True;
 }
@@ -524,9 +522,7 @@ Blend_DecrochStatus BRepBlend_RstRstEvol
   // Normal to the reference surface 2
   NRst2     = d1u.Crossed(d1v);
 
-  Standard_Boolean IsCenter;
-
-  IsCenter = CenterCircleRst1Rst2(PtTmp1, PtTmp2, nplan, Center, NotUsed);
+  CenterCircleRst1Rst2(PtTmp1, PtTmp2, nplan, Center, NotUsed);
 
   norm      = nplan.Crossed(NRst1).Magnitude();
   unsurnorm = 1. / norm;
@@ -663,9 +659,7 @@ void BRepBlend_RstRstEvolRad::Section(co
   ptrst1   = cons1.Value(U);
   ptrst2   = cons2.Value(V);
 
-  Standard_Boolean IsCenter;
-
-  IsCenter = CenterCircleRst1Rst2(ptrst1, ptrst2, np, Center, NotUsed);
+  CenterCircleRst1Rst2(ptrst1, ptrst2, np, Center, NotUsed);
 
   C.SetRadius(Abs(ray));
   ns = gp_Vec(Center, ptrst1).Normalized(); 
@@ -872,8 +866,7 @@ void BRepBlend_RstRstEvolRad::Section(co
   }
 
   // Calculate the center of the circle
-  Standard_Boolean IsCenter;
-  IsCenter = CenterCircleRst1Rst2(ptrst1, ptrst2, nplan, Center, NotUsed);
+  CenterCircleRst1Rst2(ptrst1, ptrst2, nplan, Center, NotUsed);
 
   // normals to the section with points 
   n1  = gp_Vec(Center, ptrst1).Normalized();  
@@ -916,9 +909,6 @@ Standard_Boolean BRepBlend_RstRstEvolRad
   math_Matrix gradsol(1, 2, 1, 2);
   
   Standard_Real prm       = P.Parameter();
-#ifdef DEB
-  Standard_Integer NbSpan = (Poles.Length() - 1) / 2;
-#endif
   Standard_Integer low    = Poles.Lower();
   Standard_Integer upp    = Poles.Upper();
   Standard_Boolean istgt;
Index: oce/src/BRepBlend/BRepBlend_RstRstLineBuilder.cxx
===================================================================
--- oce.orig/src/BRepBlend/BRepBlend_RstRstLineBuilder.cxx
+++ oce/src/BRepBlend/BRepBlend_RstRstLineBuilder.cxx
@@ -1426,7 +1426,7 @@ Blend_Status BRepBlend_RstRstLineBuilder
   if(!prevpointistangent){
     prevTg = previousP.TangentOnC1();
   }
-  Standard_Real Norme, curNorme;
+  Standard_Real Norme;
 #ifndef DEB
   Standard_Real prevNorme = 0.;
 #else
@@ -1434,7 +1434,6 @@ Blend_Status BRepBlend_RstRstLineBuilder
 #endif
   gp_Vec Corde(prevP, Psurf);
   Norme = Corde.SquareMagnitude();
-  if (!curpointistangent) curNorme = Tgsurf.SquareMagnitude();
   if (!prevpointistangent) prevNorme = prevTg.SquareMagnitude();
 
   if (Norme <= tolesp * tolesp) {
@@ -1508,7 +1507,7 @@ Blend_Status BRepBlend_RstRstLineBuilder
   if (!prevpointistangent) {
     prevTg = previousP.TangentOnC2();
   }
-  Standard_Real Norme, curNorme;
+  Standard_Real Norme;
 #ifndef DEB
   Standard_Real prevNorme = 0.;
 #else
@@ -1516,7 +1515,6 @@ Blend_Status BRepBlend_RstRstLineBuilder
 #endif
   gp_Vec Corde(prevP, Psurf);
   Norme = Corde.SquareMagnitude();
-  if (!curpointistangent) curNorme   = Tgsurf.SquareMagnitude();
   if (!prevpointistangent) prevNorme = prevTg.SquareMagnitude();
 
   if (Norme <= tolesp * tolesp){
Index: oce/src/BRepBlend/BRepBlend_SurfCurvConstRadInv.cxx
===================================================================
--- oce.orig/src/BRepBlend/BRepBlend_SurfCurvConstRadInv.cxx
+++ oce/src/BRepBlend/BRepBlend_SurfCurvConstRadInv.cxx
@@ -102,9 +102,6 @@ Standard_Boolean BRepBlend_SurfCurvConst
   Standard_Real normd1gui = d1gui.Magnitude();
   Standard_Real unsurnormd1gui = 1./normd1gui;
   gp_Vec nplan = d1gui.Multiplied(unsurnormd1gui);
-#ifdef DEB
-  Standard_Real theD = -(nplan.XYZ().Dot(ptgui.XYZ()));
-#endif
   gp_Vec dnplan;
   dnplan.SetLinearForm(-nplan.Dot(d2gui),nplan,d2gui);
   dnplan.Multiply(unsurnormd1gui);
Index: oce/src/BRepBlend/BRepBlend_SurfCurvEvolRadInv.cxx
===================================================================
--- oce.orig/src/BRepBlend/BRepBlend_SurfCurvEvolRadInv.cxx
+++ oce/src/BRepBlend/BRepBlend_SurfCurvEvolRadInv.cxx
@@ -100,9 +100,6 @@ const Handle(Adaptor3d_HCurve)& Cg,
   ray=sg1*ray;
   dray=sg1*dray;
   gp_Vec nplan = d1gui.Multiplied(unsurnormd1gui);
-#ifdef DEB
-  Standard_Real theD = -(nplan.XYZ().Dot(ptgui.XYZ()));
-#endif
   gp_Vec dnplan;
   dnplan.SetLinearForm(-nplan.Dot(d2gui),nplan,d2gui);
   dnplan.Multiply(unsurnormd1gui);
Index: oce/src/BRepBlend/BRepBlend_SurfPointEvolRadInv.cxx
===================================================================
--- oce.orig/src/BRepBlend/BRepBlend_SurfPointEvolRadInv.cxx
+++ oce/src/BRepBlend/BRepBlend_SurfPointEvolRadInv.cxx
@@ -85,7 +85,7 @@ const Handle(Adaptor3d_HCurve)& C,
 {
   gp_Pnt ptcur,pts;
   gp_Vec d1cur,d2cur,nplan,dnplan,d1u,d1v,d2u,d2v,duv;
-  Standard_Real theD, dtheD, normd1cur, unsurnormd1cur,dray;
+  Standard_Real dtheD, normd1cur, unsurnormd1cur,dray;
 
   curv->D2(X(1),ptcur,d1cur,d2cur);
   tevol->D1(X(1),ray,dray);
@@ -94,7 +94,6 @@ const Handle(Adaptor3d_HCurve)& C,
   normd1cur = d1cur.Magnitude();
   unsurnormd1cur = 1./normd1cur;
   nplan = unsurnormd1cur * d1cur;
-  theD = -(nplan.XYZ().Dot(ptcur.XYZ()));
   dnplan.SetLinearForm(-nplan.Dot(d2cur),nplan,d2cur);
   dnplan.Multiply(unsurnormd1cur);
   dtheD = - nplan.XYZ().Dot(d1cur.XYZ()) - dnplan.XYZ().Dot(ptcur.XYZ());
Index: oce/src/BRepBlend/BRepBlend_SurfRstConstRad.cxx
===================================================================
--- oce.orig/src/BRepBlend/BRepBlend_SurfRstConstRad.cxx
+++ oce/src/BRepBlend/BRepBlend_SurfRstConstRad.cxx
@@ -870,9 +870,6 @@ Standard_Boolean BRepBlend_SurfRstConstR
   math_Matrix gradsol(1,3,1,3);
   
   Standard_Real prm = P.Parameter();
-#ifdef DEB
-  Standard_Integer NbSpan=(Poles.Length()-1)/2;
-#endif
   Standard_Integer low = Poles.Lower();
   Standard_Integer upp = Poles.Upper();
   Standard_Boolean istgt;
Index: oce/src/BRepBlend/BRepBlend_SurfRstEvolRad.cxx
===================================================================
--- oce.orig/src/BRepBlend/BRepBlend_SurfRstEvolRad.cxx
+++ oce/src/BRepBlend/BRepBlend_SurfRstEvolRad.cxx
@@ -877,9 +877,6 @@ TColStd_Array1OfReal& DWeigths)
   math_Matrix gradsol(1,3,1,3);
   
   Standard_Real prm = P.Parameter(),rayprim;
-#ifdef DEB
-  Standard_Integer NbSpan=(Poles.Length()-1)/2;
-#endif
   Standard_Integer low = Poles.Lower();
   Standard_Integer upp = Poles.Upper();
   Standard_Boolean istgt;
Index: oce/src/BRepBlend/BRepBlend_SurfRstLineBuilder.cxx
===================================================================
--- oce.orig/src/BRepBlend/BRepBlend_SurfRstLineBuilder.cxx
+++ oce/src/BRepBlend/BRepBlend_SurfRstLineBuilder.cxx
@@ -909,9 +909,6 @@ Standard_Boolean BRepBlend_SurfRstLineBu
 						       Handle(Adaptor3d_HVertex)&  Vtx) 
 {
   Standard_Boolean recadre = Standard_False;
-#ifdef DEB
-  Standard_Boolean byinter = (line->NbPoints() != 0);
-#endif
   gp_Pnt2d pt2d, lastpt2d;
   Standard_Integer IndexSol, nbarc;
   Standard_Real pmin;
Index: oce/src/BRepBuilderAPI/BRepBuilderAPI_Collect.cxx
===================================================================
--- oce.orig/src/BRepBuilderAPI/BRepBuilderAPI_Collect.cxx
+++ oce/src/BRepBuilderAPI/BRepBuilderAPI_Collect.cxx
@@ -157,6 +157,7 @@ static void Update (   TopTools_DataMapO
 
 static void DEBControl (const TopTools_DataMapOfShapeListOfShape& MG)
 {
+#ifdef DRAW
   char name[100];
   Standard_Integer IK = 0;
   
@@ -164,19 +165,16 @@ static void DEBControl (const TopTools_D
   for (; it.More(); it.Next()) {
     const TopoDS_Shape& OS = it.Key();
     sprintf(name, "SK_%d",++IK);
-#ifdef DRAW
     DBRep::Set(name,OS);
-#endif
     TopTools_ListIteratorOfListOfShape itl(MG(OS));
     Standard_Integer IV = 1;
     for (; itl.More(); itl.Next()) {
       const TopoDS_Shape& NS = itl.Value();
       sprintf(name, "SV_%d_%d",IK,IV++);
-#ifdef DRAW
       DBRep::Set(name,NS);
-#endif
     }
   }
+#endif
 }
 #endif
 //=======================================================================
Index: oce/src/BRepBuilderAPI/BRepBuilderAPI_Sewing.cxx
===================================================================
--- oce.orig/src/BRepBuilderAPI/BRepBuilderAPI_Sewing.cxx
+++ oce/src/BRepBuilderAPI/BRepBuilderAPI_Sewing.cxx
@@ -1420,7 +1420,6 @@ Standard_Boolean BRepBuilderAPI_Sewing::
         Standard_Boolean isInserted = Standard_False;
         Standard_Integer j, ori = (arrForward(i)? 1 : 0);
         for (j = 1; (j <= seqCandidates.Length()) && !isInserted; j++) {
-          Standard_Integer aInd = seqCandidates.Value(j);//debug
           Standard_Real aDelta = arrDistance(i) - arrDistance(seqCandidates.Value(j));
           //if (arrDistance(i) <= arrDistance(seqCandidates.Value(j))) {
           if( aDelta < Precision::Confusion()) {
Index: oce/src/BRepCheck/BRepCheck_Edge.cxx
===================================================================
--- oce.orig/src/BRepCheck/BRepCheck_Edge.cxx
+++ oce/src/BRepCheck/BRepCheck_Edge.cxx
@@ -519,7 +519,7 @@ Standard_Real BRepCheck_Edge::Tolerance(
 
   Standard_Real dist2, tol2, tolCal=0., prm;
   gp_Pnt center, othP;
-  Standard_Integer i, imax;
+  Standard_Integer i;
   for (i= 0; i< NCONTROL; i++) {
     prm = ((NCONTROL-1-i)*First + i*Last)/(NCONTROL-1);
     tol2=dist2=0.;
@@ -531,7 +531,6 @@ Standard_Real BRepCheck_Edge::Tolerance(
     }
     if (tol2>tolCal) {
       tolCal=tol2;
-      imax=i;
     }
   }
   // On prend 5% de marge car au dessus on crontrole severement
@@ -562,7 +561,7 @@ Standard_Boolean Validate(const Adaptor3
 	  fabs( Other.LastParameter()-Last) > aPC);
   if (!proj) {
     Standard_Integer i;
-    Standard_Real Tol2, prm, aD2, dD;
+    Standard_Real Tol2, prm, dD;
     gp_Pnt pref, pother;
     //modified by NIZNHY-PKV Thu May 05 09:06:41 2011f
     //OCC22428
Index: oce/src/BRepCheck/BRepCheck_Face.cxx
===================================================================
--- oce.orig/src/BRepCheck/BRepCheck_Face.cxx
+++ oce/src/BRepCheck/BRepCheck_Face.cxx
@@ -266,10 +266,6 @@ BRepCheck_Status BRepCheck_Face::Classif
     TopoDS_Shape aLocalShape = myShape.EmptyCopied();
     TopoDS_Face newFace = TopoDS::Face(aLocalShape);
 //    TopoDS_Face newFace = TopoDS::Face(myShape.EmptyCopied());
-#ifdef DEB
-    TopAbs_Orientation orWire = 
-#endif
-      wir1.Orientation();
     newFace.Orientation(TopAbs_FORWARD);
     B.Add(newFace,wir1);
 
Index: oce/src/BRepCheck/BRepCheck_Shell.cxx
===================================================================
--- oce.orig/src/BRepCheck/BRepCheck_Shell.cxx
+++ oce/src/BRepCheck/BRepCheck_Shell.cxx
@@ -433,7 +433,6 @@ BRepCheck_Status BRepCheck_Shell::Orient
   if (BRepCheck_Trace(0) > 1) {
     TopTools_DataMapIteratorOfDataMapOfShapeInteger itt(MapOfShapeOrientation);
     Standard_Integer upper = MapOfShapeOrientation.NbBuckets();
-    Standard_Integer code = 0;
     cout << "La map shape Orientation :" << endl;
     for (; itt.More(); itt.Next()) {
       PrintShape(itt.Key(), upper);
Index: oce/src/BRepCheck/BRepCheck_Wire.cxx
===================================================================
--- oce.orig/src/BRepCheck/BRepCheck_Wire.cxx
+++ oce/src/BRepCheck/BRepCheck_Wire.cxx
@@ -811,7 +811,6 @@ BRepCheck_Status BRepCheck_Wire::SelfInt
 {
 
 
-  Standard_Boolean ok;
   Standard_Integer i,j,Nbedges;
   Standard_Real first1,last1,first2,last2, tolint;
   gp_Pnt2d pfirst1,plast1,pfirst2,plast2;
@@ -823,7 +822,6 @@ BRepCheck_Status BRepCheck_Wire::SelfInt
   TopTools_IndexedMapOfOrientedShape EMap;
   TopTools_MapOfOrientedShape auxmape;
   //
-  ok=Standard_True;
   //-- on verifie plus loin avec les bonnes tolerances si on n a 
   //-- pas un point dans la tolerance d un vertex.
   tolint = 1.e-10; 
@@ -887,7 +885,6 @@ BRepCheck_Status BRepCheck_Wire::SelfInt
     //
     if(Inter.IsDone()) { 
       Standard_Integer nbp = Inter.NbPoints();
-      Standard_Integer nbs = Inter.NbSegments();
       //
       for(Standard_Integer p=1;p<=nbp;p++) {
 	const IntRes2d_IntersectionPoint& IP=Inter.Point(p);
@@ -930,7 +927,6 @@ BRepCheck_Status BRepCheck_Wire::SelfInt
 	    }
 	  }
 	  if(localok==Standard_False) { 
-	    ok=0;
 	    retE1=E1;
 	    if (Update) {
 	      BRepCheck::Add(myMap(myShape),BRepCheck_SelfIntersectingWire);
@@ -1096,23 +1092,20 @@ BRepCheck_Status BRepCheck_Wire::SelfInt
 	      cout << "\n--- BRepCheck Wire: AutoIntersection Phase1 -> Erreur \n" <<endl;
 	      
 #endif
-	      Standard_Boolean yaunvtxproche;
 	      Standard_Real distauvtxleplusproche,VParaOnEdge1,VParaOnEdge2;
 	      gp_Pnt VertexLePlusProche;
 	      //
-	      yaunvtxproche=Standard_False;
 	      VParaOnEdge1 =0.;
 	      VParaOnEdge2 =0.;
 	      distauvtxleplusproche=RealLast();
 	      //Find the nearest common vertex
 	      itl.Initialize( CommonVertices );
 	      for (; itl.More(); itl.Next())   {
-		Standard_Real tolvtt, disptvtx;
+		Standard_Real disptvtx;
 		gp_Pnt p3dvtt;
 		//
 		const TopoDS_Vertex& vtt = TopoDS::Vertex(itl.Value());
 		p3dvtt = BRep_Tool::Pnt(vtt);
-		tolvtt = BRep_Tool::Tolerance(vtt);
 		disptvtx = P3d.Distance(p3dvtt);
 		if (disptvtx < distauvtxleplusproche)	{
 		  VertexLePlusProche = p3dvtt; 
@@ -1219,7 +1212,6 @@ BRepCheck_Status BRepCheck_Wire::SelfInt
 	    } //end of if (localok == Standard_False && !CommonVertices.IsEmpty())
 	    //
 	    if(localok==Standard_False)	  { 
-	      ok=0;
 	      retE1=E1;
 	      retE2=E2;
 	      if (Update) {
@@ -1354,7 +1346,6 @@ BRepCheck_Status BRepCheck_Wire::SelfInt
 	    } //end of for (k = 0; k < 2; k++)
 	    //
 	    if(localok==Standard_False)	  { 
-	      ok=0;
 	      retE1=E1;
 	      retE2=E2;
 	      if (Update) {
Index: oce/src/BRepClass3d/BRepClass3d_SolidExplorer.cxx
===================================================================
--- oce.orig/src/BRepClass3d/BRepClass3d_SolidExplorer.cxx
+++ oce/src/BRepClass3d/BRepClass3d_SolidExplorer.cxx
@@ -89,10 +89,6 @@ Standard_Boolean BRepClass3d_SolidExplor
     if(numedg==0 || nedg++==numedg) { 
       TopoDS_Edge Edge = TopoDS::Edge(faceexplorer.Current());
       c.Initialize(Edge,face);
-#ifdef DEB
-      Standard_Integer nbinterval = 
-#endif
-	c.NbIntervals(GeomAbs_C1); 
       c.D1((c.LastParameter() - c.FirstParameter()) * param_ + c.FirstParameter(),P,T);
       
       Standard_Real x=T.X();
Index: oce/src/BRepExtrema/BRepExtrema_DistanceSS.cxx
===================================================================
--- oce.orig/src/BRepExtrema/BRepExtrema_DistanceSS.cxx
+++ oce/src/BRepExtrema/BRepExtrema_DistanceSS.cxx
@@ -773,7 +773,6 @@ void BRepExtrema_DistanceSS::Perform(con
         gp_Pnt Pt,P1=BRep_Tool::Pnt(S1);
         BRepClass_FaceClassifier classifier;
         const Standard_Real tol = BRep_Tool::Tolerance(S2);
-        const Standard_Real epsP = Precision::PConfusion();
  
         for (i = 1; i <= NbExtrema; i++)
         {
@@ -830,7 +829,6 @@ void BRepExtrema_DistanceSS::Perform(con
         gp_Pnt Pt,P1=BRep_Tool::Pnt(S2);
         BRepClass_FaceClassifier classifier;
         const Standard_Real tol = BRep_Tool::Tolerance(S1);
-        const Standard_Real epsP = Precision::PConfusion();
  
         for (i = 1; i <= NbExtrema; i++)
         {
@@ -1079,7 +1077,6 @@ void BRepExtrema_DistanceSS::Perform(con
 
       BRepExtrema_SeqOfSolution seqSol1;
       BRepExtrema_SeqOfSolution seqSol2;
-      Standard_Boolean bIsMini = Standard_False;
       if (SeqSolution1.Length() > 0 && SeqSolution2.Length() > 0)
         MIN_SOLUTION(SeqSolution1, SeqSolution2, myDstRef, myEps, seqSol1, seqSol2);
 	    
@@ -1225,7 +1222,6 @@ void BRepExtrema_DistanceSS::Perform(con
 
       BRepExtrema_SeqOfSolution seqSol1;
       BRepExtrema_SeqOfSolution seqSol2;
-      Standard_Boolean bIsMini = Standard_False;
       if (SeqSolution1.Length() > 0 && SeqSolution2.Length() > 0)
         MIN_SOLUTION(SeqSolution1, SeqSolution2, myDstRef, myEps, seqSol1, seqSol2);
 	    
@@ -1269,7 +1265,6 @@ void BRepExtrema_DistanceSS::Perform(con
         gp_Pnt2d PUV;
         Standard_Real U1,V1,U2,V2;
         BRepClass_FaceClassifier classifier;
-        const Standard_Real epsP=Precision::PConfusion();
  
         for (i = 1; i <= NbExtrema; i++)
         {
Index: oce/src/BRepFeat/BRepFeat.cxx
===================================================================
--- oce.orig/src/BRepFeat/BRepFeat.cxx
+++ oce/src/BRepFeat/BRepFeat.cxx
@@ -175,11 +175,7 @@ Standard_Real BRepFeat::ParametricBaryce
 	  }
 	}
 	nbp++;
-#ifdef DEB
-	Standard_Real prmp = extpc.Point(kmin).Parameter();
-#else
         extpc.Point(kmin).Parameter();
-#endif
       }	  
     }
   }
Index: oce/src/BRepFeat/BRepFeat_Form.cxx
===================================================================
--- oce.orig/src/BRepFeat/BRepFeat_Form.cxx
+++ oce/src/BRepFeat/BRepFeat_Form.cxx
@@ -179,7 +179,6 @@ static void Descendants(const TopoDS_Sha
   TColGeom_SequenceOfCurve scur;
   Curves(scur);
 
-  Standard_Integer tempo;
   Standard_Real locmin;
   Standard_Real locmax;
   Standard_Real mf, Mf, mu, Mu;
@@ -225,7 +224,6 @@ static void Descendants(const TopoDS_Sha
 #endif
   {
 //  Determination sens,locmin,locmax,FFrom,FUntil
-    tempo=0;
     locmin = RealFirst();
     locmax = RealLast();
     for (Standard_Integer jj=1; jj<=scur.Length(); jj++) {
Index: oce/src/BRepFeat/BRepFeat_MakeLinearForm.cxx
===================================================================
--- oce.orig/src/BRepFeat/BRepFeat_MakeLinearForm.cxx
+++ oce/src/BRepFeat/BRepFeat_MakeLinearForm.cxx
@@ -622,10 +622,6 @@ void BRepFeat_MakeLinearForm::Init(const
 	counter1++;
 	NewListOfEdges.Append(edg);
 	theEdge = eeee;
-#ifdef DEB
-	Standard_Real dist1 = 
-#endif
-	  theLastPnt.Distance(myLastPnt);
 
 	if(dist <= myTol) 
 	  theFEdge = edg;
@@ -1026,18 +1022,16 @@ void BRepFeat_MakeLinearForm::Perform()
 
   TopoDS_Vertex Vprevious;
   gp_Pnt ptprev;
-  Standard_Real tvp, dp;
+  Standard_Real dp;
 
   while (!(LastOK && FirstOK)) {
     if (v1OK) {
       Vprevious=v2;
       ptprev=p2;
-      tvp=t2;
     }
     else {
       Vprevious=v1;
       ptprev=p1;
-      tvp=t1;
     }
     
     // retrouver l'edge connexe a v1 ou v2:
@@ -1149,13 +1143,7 @@ void BRepFeat_MakeLinearForm::Perform()
       // on arrive pas a chainer la section
       return Standard_False;
     }
-// #ifdef DEB
-//     Standard_Boolean isnb=
-// #endif
     TopTools_ListOfShape thelist1;
-#ifdef DEB
-     Standard_Boolean isnb=
-#endif
     mySlface.Bind(CurrentFace, thelist1);
     mySlface(CurrentFace).Append(edg1);
     myListOfEdges.Append(edg1);
@@ -1198,10 +1186,6 @@ static void MajMap(const TopoDS_Shape& t
   
   for (exp.Init(theB,TopAbs_EDGE); exp.More(); exp.Next()) {
     if (!theMap.IsBound(exp.Current())) {
-#ifdef DEB
-      const TopoDS_Edge& e = 
-#endif
-      TopoDS::Edge(exp.Current());
       TopTools_ListOfShape thelist2; 
       theMap.Bind(exp.Current(), thelist2);
       theMap(exp.Current()) = theP.Shapes(exp.Current());
Index: oce/src/BRepFeat/BRepFeat_MakeRevolutionForm.cxx
===================================================================
--- oce.orig/src/BRepFeat/BRepFeat_MakeRevolutionForm.cxx
+++ oce/src/BRepFeat/BRepFeat_MakeRevolutionForm.cxx
@@ -438,14 +438,6 @@ void BRepFeat_MakeRevolutionForm::Init(c
     
     if(Sliding && !PtOnFirstEdge) {
       BRepExtrema_ExtCF ext1(TopoDS::Edge(ee1.Shape()), FirstFace);
-#ifdef DEB
-      Standard_Integer nb = 
-#endif
-                            ext1.NbExt();
-#ifdef DEB
-      Standard_Real dist =
-#endif
-                            ext1.SquareDistance(1);
       if(ext1.NbExt() < 1 || ext1.SquareDistance(1) > Precision::Confusion() * Precision::Confusion()) 
 	Sliding = Standard_False;
     }
@@ -755,10 +747,6 @@ void BRepFeat_MakeRevolutionForm::Init(c
 	counter1++;
 	NewListOfEdges.Append(edg);
 	theEdge = eeee;
-#ifdef DEB
-	Standard_Real dist1 = 
-#endif
-	  theLastPnt.Distance(myLastPnt);
 	if(dist <= myTol) 
 	  theFEdge = edg;
 	theLastPnt = BRep_Tool::Pnt(TopExp::LastVertex(theEdge,Standard_True));
@@ -1733,10 +1721,6 @@ static void MajMap(const TopoDS_Shape& t
 
   for (exp.Init(theB,TopAbs_EDGE); exp.More(); exp.Next()) {
     if (!theMap.IsBound(exp.Current())) {
-#ifdef DEB
-      const TopoDS_Edge& e = 
-#endif
-      TopoDS::Edge(exp.Current());
       TopTools_ListOfShape thelist2;
       theMap.Bind(exp.Current(), thelist2);
       theMap(exp.Current()) = theP.Shapes(exp.Current());
Index: oce/src/BRepFeat/BRepFeat_RibSlot.cxx
===================================================================
--- oce.orig/src/BRepFeat/BRepFeat_RibSlot.cxx
+++ oce/src/BRepFeat/BRepFeat_RibSlot.cxx
@@ -128,14 +128,12 @@ void BRepFeat_RibSlot::LFPerform()
 
   Standard_Boolean ChangeOpe = Standard_False;
       // On espere qu`il n`y a qu`un solide dans le resultat
-  Standard_Boolean UntilInShape = Standard_False;
 
   TopTools_MapOfShape M;
   TopTools_ListOfShape LShape;
   TopTools_ListOfShape LTool;
 
   if (!mySUntil.IsNull()) {
-    UntilInShape = Standard_True;
     for (exp2.Init(mySUntil,TopAbs_FACE); exp2.More(); exp2.Next()) {
       const TopoDS_Shape& funtil = exp2.Current();
       for (exp.Init(mySbase,TopAbs_FACE); exp.More(); exp.Next()) {
@@ -144,7 +142,6 @@ void BRepFeat_RibSlot::LFPerform()
 	}
       }
       if (!exp.More()) {
-	UntilInShape = Standard_False;
 	break;
       }
       else {
@@ -1367,9 +1364,6 @@ Standard_Boolean BRepFeat_RibSlot::Extre
       f = f - bnd/10000; l = l +bnd/10000;
       Handle(Geom_TrimmedCurve) curve;
       curve = new Geom_TrimmedCurve(Cur, f, l, Standard_True);
-#ifdef DEB
-      gp_Pnt P1 = 
-#endif
 	BRep_Tool::Pnt(TopExp::FirstVertex(E,Standard_True));
       gp_Pnt P2 = BRep_Tool::Pnt(TopExp::LastVertex(E,Standard_True));
       ex1.Init(mySbase, TopAbs_FACE);
Index: oce/src/BRepFill/BRepFill_CompatibleWires.cxx
===================================================================
--- oce.orig/src/BRepFill/BRepFill_CompatibleWires.cxx
+++ oce/src/BRepFill/BRepFill_CompatibleWires.cxx
@@ -436,10 +436,7 @@ static Standard_Boolean EdgeIntersectOnW
 	isol = iss;
       }
     }
-#ifdef DEB
-    gp_Pnt Psol = 
-#endif
-      DSS.PointOnShape2(isol);
+    DSS.PointOnShape2(isol);
     // la solution est-elle un nouveau vertex ?
     NewVertex = (DSS.SupportTypeShape2(isol) != BRepExtrema_IsVertex);
     if (NewVertex) {
@@ -476,10 +473,6 @@ static Standard_Boolean EdgeIntersectOnW
       TopoDS_Shape aLocalShape = DSS.SupportOnShape2(isol);
       TopoDS_Edge E = TopoDS::Edge(aLocalShape);
 //      TopoDS_Edge E = TopoDS::Edge(DSS.SupportOnShape2(isol));
-#ifdef DEB
-      Standard_Real tol = 
-#endif
-	Precision::PConfusion();
       Standard_Real first,last,param;
       DSS.ParOnEdgeS2(isol,param);
       BRep_Tool::Range(E,first,last);
@@ -918,11 +911,6 @@ void BRepFill_CompatibleWires::
     
     // extremite du premier wire
     V1 = TopoDS::Vertex(SeqV.Value(1));	
-    // wire precedent
-#ifdef DEB
-    const TopoDS_Wire& wire2 = 
-#endif
-      TopoDS::Wire(myWork(i-1));
     // boucle sur les vertex de wire1
     for (ii=1;ii<=SeqV.Length();ii++) {
       
Index: oce/src/BRepFill/BRepFill_Draft.cxx
===================================================================
--- oce.orig/src/BRepFill/BRepFill_Draft.cxx
+++ oce/src/BRepFill/BRepFill_Draft.cxx
@@ -388,9 +388,6 @@ static Standard_Boolean GoodOrientation(
 // boite englobant la shape d'arret
   Bnd_Box BSurf;//, TheBox;
   Standard_Real Umin, Umax, Vmin, Vmax;
-#ifdef DEB
-  Standard_Real Tol = Precision::Confusion()/10;
-#endif
 //  BRepTools B;
 //  BRep_Tool BT;
   Handle(Geom_Surface) Surf;
Index: oce/src/BRepFill/BRepFill_Evolved.cxx
===================================================================
--- oce.orig/src/BRepFill/BRepFill_Evolved.cxx
+++ oce/src/BRepFill/BRepFill_Evolved.cxx
@@ -116,9 +116,11 @@
 #include <stdio.h>
 #endif
 
-#ifdef DEB
-static Standard_Boolean AffichGeom = Standard_False;
+#if defined(DRAW) || defined(DEB)
 static Standard_Boolean AffichEdge = Standard_False;
+#endif
+#ifdef DRAW
+static Standard_Boolean AffichGeom = Standard_False;
 static Standard_Integer NbFACES       = 0;
 static Standard_Integer NbTRIMFACES   = 0;
 static Standard_Integer NbVEVOS       = 0;
@@ -327,10 +329,6 @@ static Standard_Boolean IsPlanar(const T
 static Standard_Integer Side(const TopoDS_Wire&  Profil,
 			     const Standard_Real Tol)
 {
-#ifdef DEB
-  Standard_Boolean OnLeft  = Standard_False;
-  Standard_Boolean OnRight = Standard_False;
-#endif
   TopoDS_Vertex    V1,V2;
   // Rem : il suffit de tester sur le premier edge du Wire.
   //       ( Correctement decoupe dans PrepareProfil)
@@ -1844,10 +1842,7 @@ void BRepFill_Evolved::Add(      BRepFil
 #else
     Standard_Boolean   Commun;
 #endif
-#ifdef DEB
-    TopAbs_Orientation OriSide = 
-#endif
-      Relative(myProfile,Prof,
+    Relative(myProfile,Prof,
 	       TopoDS::Vertex(VV),
 	       Commun);
 
@@ -2939,11 +2934,6 @@ TopAbs_Orientation OriEdgeInFace (const
 				  const TopoDS_Face& F )
 
 {
-#ifdef DEB
-  TopAbs_Orientation O = 
-#endif
-    F.Orientation();
-
   TopExp_Explorer Exp(F.Oriented(TopAbs_FORWARD),TopAbs_EDGE);
 
   for (; Exp.More() ;Exp.Next()) {
Index: oce/src/BRepFill/BRepFill_MultiLine.cxx
===================================================================
--- oce.orig/src/BRepFill/BRepFill_MultiLine.cxx
+++ oce/src/BRepFill/BRepFill_MultiLine.cxx
@@ -39,7 +39,7 @@
 #include <DrawTrSurf.hxx>
 #endif
 
-#ifdef DEB
+#ifdef DRAW
 static Standard_Boolean AffichCurve = Standard_False;
 static Standard_Integer NbProj = 1;
 #endif
Index: oce/src/BRepFill/BRepFill_OffsetWire.cxx
===================================================================
--- oce.orig/src/BRepFill/BRepFill_OffsetWire.cxx
+++ oce/src/BRepFill/BRepFill_OffsetWire.cxx
@@ -96,13 +96,14 @@
 #include <DBRep.hxx>
 #endif
 
-#ifdef DEB
+#if defined(DRAW) || defined(DEB)
+static Standard_Boolean AffichEdge  = Standard_False;
+#endif
+#ifdef DRAW
 static Standard_Boolean AffichGeom  = Standard_False;
 static Standard_Boolean Affich2d    = Standard_False;
-static Standard_Boolean AffichEdge  = Standard_False;
 static Standard_Integer NbTRIMEDGES = 0;
 static Standard_Integer NbOFFSET    = 0;
-static Standard_Integer NbEDGES     = 0;
 static Standard_Integer NbBISSEC    = 0;
 #ifndef WNT
 static char tname[100];
@@ -480,7 +481,6 @@ void BRepFill_OffsetWire::Perform (const
       BRepTools_Substitution aSubst;
       TopTools_ListIteratorOfListOfShape it(BadEdges);
       TopTools_ListOfShape aL;
-      Standard_Real aDefl = .01 * Abs(Offset);
       TColStd_SequenceOfReal Parameters;
       TColgp_SequenceOfPnt Points;
 
@@ -1834,10 +1834,6 @@ void MakeOffset (const TopoDS_Edge&
     // si l offset est superieur ou egal au rayon et du cote de la 
     // concavite du cercle => edge null.
     gp_Circ2d C1(AC.Circle());
-#ifdef DEB
-    Standard_Real radius = 
-#endif
-                           C1.Radius();
     gp_Ax22d axes( C1.Axis());
     gp_Dir2d Xd = axes.XDirection();
     gp_Dir2d Yd = axes.YDirection();
Index: oce/src/BRepFill/BRepFill_PipeShell.cxx
===================================================================
--- oce.orig/src/BRepFill/BRepFill_PipeShell.cxx
+++ oce/src/BRepFill/BRepFill_PipeShell.cxx
@@ -1043,7 +1043,6 @@ void BRepFill_PipeShell::BuildHistory(co
   }
 
   for(j = myLocation->NbLaw(); j >= 1; j--) {
-    Standard_Boolean ismodified = Standard_False;
     TopTools_ListOfShape aListOfFace;
 
     if(bPrevModified) {
Index: oce/src/BRepFill/BRepFill_Sweep.cxx
===================================================================
--- oce.orig/src/BRepFill/BRepFill_Sweep.cxx
+++ oce/src/BRepFill/BRepFill_Sweep.cxx
@@ -900,20 +900,16 @@ static Standard_Boolean Filling(const To
 		     f2, l2, C3);
   C2 = C3;
 
-  Standard_Boolean pointu_f,  pointu_l;
 //  P1 = BT.Pnt(Vf);
   P1 = BRep_Tool::Pnt(Vf);
 //  P2 = BT.Pnt(V1);
   P2 = BRep_Tool::Pnt(V1);
 //  pointu_f = Vf.IsSame(V1) || (P1.Distance(P2) < BT.Tolerance(Vf));
-  pointu_f = Vf.IsSame(V1) || (P1.Distance(P2) < BRep_Tool::Tolerance(Vf));
 //  P1 = BT.Pnt(Vl);
   P1 = BRep_Tool::Pnt(Vl);
 //  P2 = BT.Pnt(V2);
   P2 = BRep_Tool::Pnt(V2);
 //  pointu_l = Vl.IsSame(V2) || (P1.Distance(P2) < BT.Tolerance(Vl));
-  pointu_l = Vl.IsSame(V2) || (P1.Distance(P2) < BRep_Tool::Tolerance(Vl));
-
 
   P2d.SetCoord(0.,f1);
   L = new (Geom2d_Line) (P2d, gp::DX2d());
Index: oce/src/BRepFill/BRepFill_TrimShellCorner.cxx
===================================================================
--- oce.orig/src/BRepFill/BRepFill_TrimShellCorner.cxx
+++ oce/src/BRepFill/BRepFill_TrimShellCorner.cxx
@@ -553,16 +553,9 @@ Standard_Boolean MakeFacesNonSec(const S
     Standard_Integer aFaceIndex = (fit == 1) ? theFaceIndex1 : theFaceIndex2;
     TopoDS_Shape aFace          = aDS.Shape(aFaceIndex);
     TopAbs_Orientation aFaceOri = aFace.Orientation();
-    TopAbs_Orientation anEdgeOri = TopAbs_FORWARD;
     aFace.Orientation(TopAbs_FORWARD);
 
     TopExp_Explorer anExpE(aFace, TopAbs_EDGE);
-    const TopoDS_Shape& aCheckEdge = (fit == 1) ? aE1 : aE2;
-
-    for(; anExpE.More(); anExpE.Next()) {
-      if(aCheckEdge.IsSame(anExpE.Current()))
-	anEdgeOri = anExpE.Current().Orientation();
-    }
 
     if(bHasNewEdge) {
       aNewEdge.Orientation(TopAbs_FORWARD);
Index: oce/src/BRepFill/BRepFill_TrimSurfaceTool.cxx
===================================================================
--- oce.orig/src/BRepFill/BRepFill_TrimSurfaceTool.cxx
+++ oce/src/BRepFill/BRepFill_TrimSurfaceTool.cxx
@@ -491,9 +491,6 @@ void BRepFill_TrimSurfaceTool::Project
        Handle(Geom2d_Curve)& PCurve2,
        GeomAbs_Shape&        Cont) const 
 {
-  Standard_Integer Deg1, Deg2;
-  Deg1 = Deg2 = 8;
-
   Handle(Geom2d_TrimmedCurve) CT = 
     new Geom2d_TrimmedCurve(myBis,U1,U2);
   BRepFill_MultiLine ML(myFace1,myFace2,
Index: oce/src/BRepGProp/BRepGProp.cxx
===================================================================
--- oce.orig/src/BRepGProp/BRepGProp.cxx
+++ oce/src/BRepGProp/BRepGProp.cxx
@@ -134,14 +134,13 @@ void  BRepGProp::VolumeProperties(const
   // find the origin
   gp_Pnt P(0,0,0);  P.Transform(S.Location());
   Props = GProp_GProps(P);
-  Standard_Real Error = 0.0;
   if(OnlyClosed){
     TopExp_Explorer ex(S,TopAbs_SHELL);
     for (; ex.More(); ex.Next()) {
       const TopoDS_Shape& Sh = ex.Current();
-      if(BRep_Tool::IsClosed(Sh)) Error = volumeProperties(Sh,Props,1.0);
+      if(BRep_Tool::IsClosed(Sh)) volumeProperties(Sh,Props,1.0);
     }
-  } else Error = volumeProperties(S,Props,1.0);
+  } else volumeProperties(S,Props,1.0);
 }
 
 //=======================================================================
Index: oce/src/BRepGProp/BRepGProp_Face.cxx
===================================================================
--- oce.orig/src/BRepGProp/BRepGProp_Face.cxx
+++ oce/src/BRepGProp/BRepGProp_Face.cxx
@@ -365,8 +365,7 @@ void BRepGProp_Face::VKnots(TColStd_Arra
 Standard_Integer BRepGProp_Face::LIntOrder(const Standard_Real Eps) const
 {
   Bnd_Box2d aBox;
-  BndLib_Add2dCurve aB;
-  aB.Add(myCurve, 1.e-7, aBox);
+  BndLib_Add2dCurve::Add(myCurve, 1.e-7, aBox);
   Standard_Real aXmin, aXmax, aYmin, aYmax;
   aBox.Get(aXmin, aYmin, aXmax, aYmax);
   Standard_Real aVmin = mySurface.FirstVParameter();
Index: oce/src/BRepMesh/BRepMesh_FastDiscret.cxx
===================================================================
--- oce.orig/src/BRepMesh/BRepMesh_FastDiscret.cxx
+++ oce/src/BRepMesh/BRepMesh_FastDiscret.cxx
@@ -320,7 +320,6 @@ void BRepMesh_FastDiscret::Add(const Top
 
   gp_Pnt2d uvFirst, uvLast;
 
-  TopAbs_Orientation orFace = face.Orientation();
   Handle(Poly_Triangulation) T;
   TopLoc_Location loc;
 
Index: oce/src/BRepMesh/BRepMesh_FastDiscretFace.cxx
===================================================================
--- oce.orig/src/BRepMesh/BRepMesh_FastDiscretFace.cxx
+++ oce/src/BRepMesh/BRepMesh_FastDiscretFace.cxx
@@ -1187,7 +1187,6 @@ Standard_Real BRepMesh_FastDiscretFace::
   //IMPORTANT: Constants used in calculations
   const Standard_Real MinimalArea2d = 1.e-9;
   const Standard_Real MinimalSqLength3d = 1.e-12;
-  const Standard_Real aDef2 = theDefFace*theDefFace;
 
   // Define the number of iterations
   Standard_Integer myNbIterations = 11;
@@ -1213,8 +1212,6 @@ Standard_Real BRepMesh_FastDiscretFace::
   Standard_Boolean caninsert;
 
   Standard_Real sqdefface = theDefFace * theDefFace;
-  Standard_Real ddu = theCaro->UResolution(theDefFace);
-  Standard_Real ddv = theCaro->VResolution(theDefFace);
 
   GeomAbs_SurfaceType thetype = theCaro->GetType();
   Handle(Geom_Surface) BSpl;
@@ -1552,7 +1549,6 @@ void BRepMesh_FastDiscretFace::AddInShap
       
       const BRepMesh_Edge& ve1=myStructure->GetLink(e1);
       const BRepMesh_Edge& ve2=myStructure->GetLink(e2);
-      const BRepMesh_Edge& ve3=myStructure->GetLink(e3);
       
       if (o1) {
         v1=ve1.FirstNode();
Index: oce/src/BRepOffset/BRepOffset_Inter2d.cxx
===================================================================
--- oce.orig/src/BRepOffset/BRepOffset_Inter2d.cxx
+++ oce/src/BRepOffset/BRepOffset_Inter2d.cxx
@@ -37,8 +37,7 @@
 
 #ifdef DRAW 
 #include <DBRep.hxx>
-#endif
-#ifdef DEB
+
 #ifndef WNT
 extern Standard_Integer AffichInt2d;
 #else
@@ -279,7 +278,9 @@ static void EdgeInter(const TopoDS_Face&
     return;
 
   Standard_Real f[3],l[3];
+#ifdef DEB
   Standard_Real MilTol2 = 1000*Tol*Tol;
+#endif
   Standard_Real TolDub = 1.e-7;  // Faire un calcul plus malin !!! NYI
   Standard_Integer i;
 
@@ -550,7 +551,9 @@ static void RefEdgeInter(const TopoDS_Fa
     return;
 
   Standard_Real f[3],l[3];
+#ifdef DEB
   Standard_Real MilTol2 = 1000*Tol*Tol;
+#endif
   Standard_Real TolDub = 1.e-7;  // Faire un calcul plus malin !!! NYI
   Standard_Integer i;
 
@@ -1112,8 +1115,6 @@ static void ExtentEdge(const TopoDS_Edge
       MinLoc = E.Location() * MinLoc;
       if (!C3d.IsNull())
 	{
-	  Standard_Real FirstPar = C3d->FirstParameter();
-	  Standard_Real LastPar  = C3d->LastParameter();
 	  if (MinPC->IsClosed())
 	    {
 	      f = FirstParOnPC;
@@ -1400,7 +1401,7 @@ void BRepOffset_Inter2d::Compute (const
 				  const TopTools_MapOfShape&      NewEdges,
 				  const Standard_Real             Tol)
 {
-#ifdef DEB
+#ifdef DRAW
   NbF2d++;
   NbE2d = 0;
 #endif 
Index: oce/src/BRepOffset/BRepOffset_MakeLoops.cxx
===================================================================
--- oce.orig/src/BRepOffset/BRepOffset_MakeLoops.cxx
+++ oce/src/BRepOffset/BRepOffset_MakeLoops.cxx
@@ -25,7 +25,7 @@
 #ifdef DRAW
 #include <DBRep.hxx>
 #endif
-#ifdef DEB
+#ifdef DRAW
 Standard_Integer NbF = 1;
 static Standard_Boolean Affich = Standard_False;
 //POP pour NT
Index: oce/src/BRepOffset/BRepOffset_MakeOffset.cxx
===================================================================
--- oce.orig/src/BRepOffset/BRepOffset_MakeOffset.cxx
+++ oce/src/BRepOffset/BRepOffset_MakeOffset.cxx
@@ -130,9 +130,11 @@
 static void DEBVerticesControl (const TopTools_MapOfShape&    NewEdges,
 				      Handle(BRepAlgo_AsDes)  AsDes)
 {
+#ifdef DRAW
   Standard_Integer NVP = 0;
   Standard_Integer NVM = 0;
   Standard_Integer NVN = 0;
+#endif
 
   TopTools_ListOfShape               LVP;
   TopTools_MapIteratorOfMapOfShape   it;
@@ -1011,9 +1013,6 @@ void BRepOffset_MakeOffset::BuildOffsetB
   TopoDS_Shape    NE;
   TopoDS_Edge     TNE;
   TopoDS_Face     NF;
-#ifdef DEB
-  TopAbs_Orientation Or;
-#endif
   
   for (Exp.Init(myShape,TopAbs_FACE) ; Exp.More(); Exp.Next()) {
     const TopoDS_Face& FI = TopoDS::Face(Exp.Current());
@@ -1540,9 +1539,6 @@ void BRepOffset_MakeOffset::BuildOffsetB
   BRepOffset_Type    RT = BRepOffset_Concave;
   if (myOffset < 0.) RT = BRepOffset_Convex;
   BRepOffset_DataMapIteratorOfDataMapOfShapeOffset It(MapSF);
-#ifdef DEB
-  Standard_Integer MapSFNb = MapSF.Extent();
-#endif
   for ( ; It.More(); It.Next()) {
     const TopoDS_Shape& SI = It.Key(); 
     const BRepOffset_Offset& SF = It.Value();
Index: oce/src/BRepOffset/BRepOffset_Offset.cxx
===================================================================
--- oce.orig/src/BRepOffset/BRepOffset_Offset.cxx
+++ oce/src/BRepOffset/BRepOffset_Offset.cxx
@@ -1300,9 +1300,9 @@ void BRepOffset_Offset::Init(const TopoD
 #endif
     Standard_Integer NbEdges = 1;
     for (it.Initialize(LEdge); it.More(); it.Next()) {
-      const TopoDS_Edge& CurE = TopoDS::Edge(it.Value());
       sprintf(name,"EOnSph_%d_%d",NbOFFSET,NbEdges++);
 #ifdef DRAW
+      const TopoDS_Edge& CurE = TopoDS::Edge(it.Value());
       DBRep::Set(name, CurE);
 #endif
     }
Index: oce/src/BRepOffset/BRepOffset_Tool.cxx
===================================================================
--- oce.orig/src/BRepOffset/BRepOffset_Tool.cxx
+++ oce/src/BRepOffset/BRepOffset_Tool.cxx
@@ -146,9 +146,11 @@
 #include <DBRep.hxx>
 #endif
 
-#ifdef DEB       
-Standard_Boolean AffichInter  = Standard_False;
+#if defined(DRAW) || defined(DEB)
 static Standard_Boolean AffichExtent = Standard_False;
+#endif
+#ifdef DRAW
+Standard_Boolean AffichInter  = Standard_False;
 static Standard_Integer NbNewEdges  = 1;
 static Standard_Integer NbFaces     = 1;
 static Standard_Integer NbFOB       = 1;
@@ -185,10 +187,6 @@ TopAbs_Orientation BRepOffset_Tool::OriE
 						   const TopoDS_Face& F )
 
 {
-#ifdef DEB
-  TopAbs_Orientation O = 
-#endif
-    F.Orientation();
   TopExp_Explorer Exp;
   Exp.Init(F.Oriented(TopAbs_FORWARD),TopAbs_EDGE);
 
Index: oce/src/BRepSweep/BRepSweep_Rotation.cxx
===================================================================
--- oce.orig/src/BRepSweep/BRepSweep_Rotation.cxx
+++ oce/src/BRepSweep/BRepSweep_Rotation.cxx
@@ -335,11 +335,6 @@ TopoDS_Shape  BRepSweep_Rotation::MakeEm
       break;
     case GeomAbs_Cylinder :
       {
-#ifdef DEB
-	gp_Cylinder c = AS.Cylinder();
-	gp_Ax3 b = AS.Axis();
-	gp_Ax3 a = c.Position();
-#endif
 	Handle(Geom_CylindricalSurface) Cy = 
 	  new Geom_CylindricalSurface(AS.Cylinder());
 	S = Cy;
Index: oce/src/BRepTest/BRepTest_BasicCommands.cxx
===================================================================
--- oce.orig/src/BRepTest/BRepTest_BasicCommands.cxx
+++ oce/src/BRepTest/BRepTest_BasicCommands.cxx
@@ -265,8 +265,6 @@ static Standard_Integer nurbsconvert(Dra
 static Standard_Integer mkedgecurve (Draw_Interpretor& ,Standard_Integer n,const char** a)
 {
 
-  Standard_Boolean CurveDone ;
-
   if (n < 3) return 1;
   Standard_Real Tolerance = atof(a[2]) ;
 
@@ -274,7 +272,6 @@ static Standard_Integer mkedgecurve (Dra
   
   if (S.IsNull()) return 1;
   
-   CurveDone = 
    BRepLib::BuildCurves3d(S,
 			  Tolerance) ;
    return 0 ;
Index: oce/src/BRepTest/BRepTest_CurveCommands.cxx
===================================================================
--- oce.orig/src/BRepTest/BRepTest_CurveCommands.cxx
+++ oce/src/BRepTest/BRepTest_CurveCommands.cxx
@@ -937,7 +937,6 @@ static Standard_Integer bsplineprof(Draw
   Standard_Boolean face  = Standard_True;
   Standard_Boolean close = Standard_True;
 //  Standard_Boolean first = Standard_True;
-  Standard_Boolean stayfirst = Standard_False;
   Standard_Boolean isplanar  = Standard_True;
   Standard_Real  length ; 
   TopoDS_Shape S;
@@ -967,7 +966,6 @@ static Standard_Integer bsplineprof(Draw
 	  else 
 	    P = Plane->Pln();
 	}
-	stayfirst = Standard_True;
         i += 1 ;
 	break;
 	
Index: oce/src/BRepTest/BRepTest_FillingCommands.cxx
===================================================================
--- oce.orig/src/BRepTest/BRepTest_FillingCommands.cxx
+++ oce/src/BRepTest/BRepTest_FillingCommands.cxx
@@ -193,10 +193,7 @@ static Standard_Integer plate (Draw_Inte
     DBRep::Set(name, E);
     MW.Add(E);
     if (MW.IsDone()==Standard_False) {
-#if DEB
-      BRepBuilderAPI_WireError err =
-#endif
-                                     MW.Error();
+      MW.Error();
       Standard_Failure::Raise("mkWire is over ");
     }
       
@@ -429,10 +426,7 @@ static Standard_Integer approxplate (Dra
     BRepLib::BuildCurve3d(E);
     MW.Add(E);
     if (MW.IsDone()==Standard_False) {
-#ifdef DEB
-      BRepBuilderAPI_WireError err =
-#endif
-                                     MW.Error();
+      MW.Error();
       Standard_Failure::Raise("mkWire is over ");
     }
   }
Index: oce/src/BRepTest/BRepTest_SurfaceCommands.cxx
===================================================================
--- oce.orig/src/BRepTest/BRepTest_SurfaceCommands.cxx
+++ oce/src/BRepTest/BRepTest_SurfaceCommands.cxx
@@ -338,21 +338,11 @@ static Standard_Integer continuity (Draw
   aFind.Dump();
 
   for (i=1; i<=aFind.NbContigousEdges(); i++) {
-#ifdef DEB
-    const TopoDS_Edge& edge =
-#endif
-                              aFind.ContigousEdge(i);
     const TopTools_ListOfShape& list = aFind.ContigousEdgeCouple(i);
     const TopoDS_Edge& sec1 = TopoDS::Edge(list.First());
     const TopoDS_Edge& sec2 = TopoDS::Edge(list.Last());
-#ifdef DEB
-    const TopoDS_Edge& bound1 =
-#endif
-                                aFind.SectionToBoundary(sec1);
-#ifdef DEB
-    const TopoDS_Edge& bound2 =
-#endif
-                                aFind.SectionToBoundary(sec2);
+    aFind.SectionToBoundary(sec1);
+    aFind.SectionToBoundary(sec2);
   }
 
   return 0;
Index: oce/src/BRepTools/BRepTools_Quilt.cxx
===================================================================
--- oce.orig/src/BRepTools/BRepTools_Quilt.cxx
+++ oce/src/BRepTools/BRepTools_Quilt.cxx
@@ -194,11 +194,6 @@ void BRepTools_Quilt::Add(const TopoDS_S
 	  TopoDS_Wire NW;
 	  B.MakeWire(NW);
 	  TopoDS_Iterator ite(W,Standard_False);
-#ifdef DEB
-	  Standard_Real   Tol = BRep_Tool::Tolerance(F);
-#else
-          BRep_Tool::Tolerance(F);
-#endif
 	  Standard_Real   UFirst,ULast;
 	  
 	  // Reconstruction des wires.
@@ -444,8 +439,6 @@ TopoDS_Shape BRepTools_Quilt::Shells() c
               TopoDS_Shape arefShape = SH.Oriented(TopAbs_FORWARD) ;
 	      B.Add  ( arefShape ,Fo.Oriented(NewO));
 	    }
-            Standard_Integer kk =1;
-            Standard_Integer p =0;
 	    // Rebind the free edges of the old shell to the new shell
             //gka BUG 6491
             TopExp_Explorer aexp(SH,TopAbs_EDGE);
Index: oce/src/BRepTopAdaptor/BRepTopAdaptor_FClass2d.cxx
===================================================================
--- oce.orig/src/BRepTopAdaptor/BRepTopAdaptor_FClass2d.cxx
+++ oce/src/BRepTopAdaptor/BRepTopAdaptor_FClass2d.cxx
@@ -180,9 +180,6 @@ BRepTopAdaptor_FClass2d::BRepTopAdaptor_
 	      //-- et le dernier point enregistre dans SeqPnt2d
 	      //-- On cherche a eloigner le premier point de l edge courant 
 	      //-- du dernier point enregistre
-#ifdef DEB
-	      gp_Pnt2d Pnt2dDebutEdgeCourant=
-#endif
 	      C.Value(u);
 
 	      //Standard_Real Baillement2dU=0;
@@ -269,7 +266,7 @@ BRepTopAdaptor_FClass2d::BRepTopAdaptor_
 	{
 	  //Standard_Real anglep=0,anglem=0;
 	  TColgp_Array1OfPnt2d PClass(1,nbpnts);
-	  Standard_Real angle = 0.0, square = 0.0;
+	  Standard_Real square = 0.0;
 
 	  //-------------------------------------------------------------------
 	  //-- ** Le mode de calcul a ete un peu change 
Index: oce/src/BiTgte/BiTgte_Blend.cxx
===================================================================
--- oce.orig/src/BiTgte/BiTgte_Blend.cxx
+++ oce/src/BiTgte/BiTgte_Blend.cxx
@@ -221,8 +221,6 @@ static void KPartCurve3d(TopoDS_Edge
   TopLoc_Location Loc;
   Standard_Real Tol = Precision::Confusion();
 
-  Standard_Boolean IsComputed = Standard_False;
-
   // Seach only isos on analytiques surfaces.
   Geom2dAdaptor_Curve C(Curve);
   GeomAdaptor_Surface S(Surf);
@@ -253,7 +251,6 @@ static void KPartCurve3d(TopoDS_Edge
 	      Circle->Reverse();
 	    TheBuilder.UpdateEdge(Edge, Circle, Loc, Tol);
 	  }
-	  IsComputed = Standard_True;
 	}
 	else if ( STy == GeomAbs_Cylinder) {
 	  gp_Cylinder Cyl  = S.Cylinder();
@@ -269,7 +266,6 @@ static void KPartCurve3d(TopoDS_Edge
 	  if ( D.IsOpposite(gp::DX2d(),Precision::Angular())) 
 	    Circle->Reverse();
 	  TheBuilder.UpdateEdge(Edge, Circle, Loc, Tol);
-	  IsComputed = Standard_True;
 	}
 	else if ( STy == GeomAbs_Cone) {
 	  gp_Cone  Cone = S.Cone();
@@ -286,7 +282,6 @@ static void KPartCurve3d(TopoDS_Edge
 	  if ( D.IsOpposite(gp::DX2d(),Precision::Angular())) 
 	    Circle->Reverse();
 	  TheBuilder.UpdateEdge(Edge, Circle, Loc, Tol);
-	  IsComputed = Standard_True;
 	}
 	else if ( STy == GeomAbs_Torus) {
 	  gp_Torus Tore = S.Torus();
@@ -303,7 +298,6 @@ static void KPartCurve3d(TopoDS_Edge
 	  if ( D.IsOpposite(gp::DX2d(),Precision::Angular())) 
 	    Circle->Reverse();
 	  TheBuilder.UpdateEdge(Edge, Circle, Loc, Tol);
-	  IsComputed = Standard_True;
 	}
       }
       else if ( D.IsParallel(gp::DY2d(),Precision::Angular())) { // Iso U.
@@ -328,7 +322,6 @@ static void KPartCurve3d(TopoDS_Edge
 	  if ( D.IsOpposite(gp::DY2d(),Precision::Angular())) 
 	    Circle->Reverse();
 	  TheBuilder.UpdateEdge(Edge, Circle, Loc, Tol);
-	  IsComputed = Standard_True;
 	}
 	else if ( STy == GeomAbs_Cylinder) {
 	  gp_Cylinder Cyl = S.Cylinder();
@@ -343,7 +336,6 @@ static void KPartCurve3d(TopoDS_Edge
 	  if ( D.IsOpposite(gp::DY2d(),Precision::Angular()))
 	    Line->Reverse();
 	  TheBuilder.UpdateEdge(Edge, Line, Loc, Tol);
-	  IsComputed = Standard_True;
 	}
 	else if ( STy == GeomAbs_Cone) {
 	  gp_Cone  Cone = S.Cone();
@@ -358,7 +350,6 @@ static void KPartCurve3d(TopoDS_Edge
 	  if ( D.IsOpposite(gp::DY2d(),Precision::Angular()))
 	    Line->Reverse();
 	  TheBuilder.UpdateEdge(Edge, Line, Loc, Tol);
-	  IsComputed = Standard_True;
 	}
 	else if ( STy == GeomAbs_Torus) {
 	}
@@ -368,7 +359,6 @@ static void KPartCurve3d(TopoDS_Edge
   else { // Cas Plan
     Handle(Geom_Curve) C3d = GeomAPI::To3d(Curve,S.Plane());
     TheBuilder.UpdateEdge(Edge, C3d, Loc, Tol);
-    IsComputed = Standard_True;
   }
 }
 
@@ -1885,9 +1875,6 @@ void BiTgte_Blend::ComputeSurfaces()
   // Iteration sur les les edges lignes de centre
   // et On prend leur partie valide apres decoupe, et construction tuyau.
   // --------------------------------------------------------------------
-  BRepOffset_Type    OT = BRepOffset_Concave;
-  if (myRadius < 0.) OT = BRepOffset_Convex; 
-
   TopTools_MapIteratorOfMapOfShape ic(myEdges);
   for ( ; ic.More(); ic.Next()) {
     const TopoDS_Edge& CurE = TopoDS::Edge(ic.Key());
Index: oce/src/BinMDataStd/BinMDataStd_ExtStringArrayDriver.cxx
===================================================================
--- oce.orig/src/BinMDataStd/BinMDataStd_ExtStringArrayDriver.cxx
+++ oce/src/BinMDataStd/BinMDataStd_ExtStringArrayDriver.cxx
@@ -95,7 +95,6 @@ void BinMDataStd_ExtStringArrayDriver::P
   const TColStd_Array1OfExtendedString& aSourceArray = anAtt->Array()->Array1();
   const Standard_Integer aFirstInd = aSourceArray.Lower();
   const Standard_Integer aLastInd  = aSourceArray.Upper();
-  const Standard_Integer aLength   = aLastInd - aFirstInd + 1;
   theTarget << aFirstInd << aLastInd;
   for (Standard_Integer i = aFirstInd; i <= aLastInd; i ++)
     theTarget << anAtt->Value( i );
Index: oce/src/BinMDataStd/BinMDataStd_ExtStringListDriver.cxx
===================================================================
--- oce.orig/src/BinMDataStd/BinMDataStd_ExtStringListDriver.cxx
+++ oce/src/BinMDataStd/BinMDataStd_ExtStringListDriver.cxx
@@ -68,7 +68,6 @@ void BinMDataStd_ExtStringListDriver::Pa
   Handle(TDataStd_ExtStringList) anAtt = Handle(TDataStd_ExtStringList)::DownCast(theSource);
   const Standard_Integer aFirstInd = 1;
   const Standard_Integer aLastInd  = anAtt->Extent();
-  const Standard_Integer aLength   = aLastInd - aFirstInd + 1;
   theTarget << aFirstInd << aLastInd;
   TDataStd_ListIteratorOfListOfExtendedString itr(anAtt->List());
   for (; itr.More(); itr.Next())
Index: oce/src/Bisector/Bisector_BisecAna.cxx
===================================================================
--- oce.orig/src/Bisector/Bisector_BisecAna.cxx
+++ oce/src/Bisector/Bisector_BisecAna.cxx
@@ -193,7 +193,7 @@ void Bisector_BisecAna::Perform(const Ha
 
   Standard_Boolean ok;
   Standard_Real    distanceptsol,parameter,firstparameter =0.;
-  Standard_Boolean thesense = Standard_False,sense,theSense;
+  Standard_Boolean thesense = Standard_False,sense;
   Standard_Real    distancemini;
   Standard_Integer nbsolution;
   Standard_Real    PreConf = Precision::Confusion();
@@ -397,7 +397,6 @@ void Bisector_BisecAna::Perform(const Ha
 	}
 	else {ok = Standard_True;}
 
-	theSense = sense;
 	if (ok) {
 	  sense = Standard_False;
 //  Modified by skv - Tue Feb 15 17:51:29 2005 Integration Begin
@@ -551,7 +550,6 @@ void Bisector_BisecAna::Perform(const Ha
 	sense = Standard_True;
 	distanceptsol = Distance(apoint,solution,tan1,tan2,
 				 adirection,parameter,sense,ok);
-	theSense = sense;
 	if (ok || !oncurve) {
 	  sense = Standard_False;
 //  Modified by skv - Tue Feb 15 17:51:29 2005 Integration Begin
@@ -758,7 +756,7 @@ void Bisector_BisecAna::Perform(const Ha
 				const Standard_Boolean      oncurve       )
 {
   Standard_Boolean ok;
-  Standard_Boolean thesense = Standard_False,sense,theSense;
+  Standard_Boolean thesense = Standard_False,sense;
   Standard_Real    distanceptsol,parameter,firstparameter =0.,secondparameter;
   Handle(Geom2d_Curve) curve;
   Handle(GccInt_Bisec) TheSol;
@@ -912,7 +910,6 @@ void Bisector_BisecAna::Perform(const Ha
     case 2 : {
       GccAna_LinPnt2dBisec Bisector(line,asecondpoint->Pnt2d());
       
-      theSense = Standard_True;
 #ifdef DEB
       gp_Vec2d V(line.Direction());
 #else
@@ -1017,14 +1014,14 @@ void Bisector_BisecAna::Perform(const Ha
 				const Standard_Boolean      oncurve       )
 {
   Standard_Boolean sense,ok;
-  Standard_Real distanceptsol,parameter;
+  Standard_Real parameter;
 
   GccAna_Pnt2dBisec bisector(afirstpoint->Pnt2d(),asecondpoint->Pnt2d());
   gp_Lin2d line = bisector.ThisSolution();
   Handle(GccInt_Bisec) solution = new GccInt_BLine(line);
 
   sense = Standard_False;
-  distanceptsol = Distance(apoint,solution,
+  Distance(apoint,solution,
 			   afirstvector,asecondvector,
 			   adirection,parameter,sense,ok);
   if (ok || !oncurve) {
Index: oce/src/Bisector/Bisector_BisecPC.cxx
===================================================================
--- oce.orig/src/Bisector/Bisector_BisecPC.cxx
+++ oce/src/Bisector/Bisector_BisecPC.cxx
@@ -588,7 +588,7 @@ gp_Vec2d Bisector_BisecPC::DN (const Sta
 Standard_Real Bisector_BisecPC::SearchBound (const Standard_Real U1,
 					     const Standard_Real U2) const
 {
-  Standard_Real Dist1,Dist2,DistMid,U11,U22; 
+  Standard_Real Dist1,DistMid,U11,U22; 
 #ifndef DEB
   Standard_Real UMid = 0.;
 #else
@@ -598,7 +598,6 @@ Standard_Real Bisector_BisecPC::SearchBo
   Standard_Real DistMax2 = distMax*distMax;
   U11 = U1; U22 = U2;
   Dist1 = Distance(U11);
-  Dist2 = Distance(U22);
   
   while ((U22 - U11) > Tol) {
     UMid    = 0.5*( U22 + U11);
@@ -609,7 +608,6 @@ Standard_Real Bisector_BisecPC::SearchBo
     }
     else {
       U22    = UMid;
-      Dist2 = DistMid;
     }
   }
   return UMid;
Index: oce/src/Bisector/Bisector_Inter.cxx
===================================================================
--- oce.orig/src/Bisector/Bisector_Inter.cxx
+++ oce/src/Bisector/Bisector_Inter.cxx
@@ -27,8 +27,7 @@
 #include <Draw_Appli.hxx>
 #include <DrawTrSurf_Curve2d.hxx>
 #include <Draw_Marker2D.hxx>
-#endif
-#ifdef DEB
+
 static Standard_Boolean Affich = Standard_False;
 #endif
 
@@ -328,13 +327,8 @@ void Bisector_Inter::NeighbourPerform(co
   // Changement ligne guide sur Bis2.
   BisTemp      = Bis2->ChangeGuide();
   Guide        = Bis2->Curve(2);
-#ifdef DEB
-  gp_Pnt2d P2S = Bis2->ValueAndDist(D2.FirstParameter(),U1,UMax,Dist);
-  gp_Pnt2d P2E = Bis2->ValueAndDist(D2.LastParameter() ,U1,UMin,Dist);
-#else
   Bis2->ValueAndDist(D2.FirstParameter(),U1,UMax,Dist);
   Bis2->ValueAndDist(D2.LastParameter() ,U1,UMin,Dist);
-#endif
   // Calcul du domaine d intersection sur la ligne guide.
   UMin = Max (D1.FirstParameter(),UMin);
   UMax = Min (D1.LastParameter() ,UMax);
Index: oce/src/BlendFunc/BlendFunc_CSConstRad.cxx
===================================================================
--- oce.orig/src/BlendFunc/BlendFunc_CSConstRad.cxx
+++ oce/src/BlendFunc/BlendFunc_CSConstRad.cxx
@@ -871,9 +871,6 @@ Standard_Boolean BlendFunc_CSConstRad::S
   math_Matrix gradsol(1,3,1,3);
 
   Standard_Real prm = P.Parameter();
-#ifdef DEB
-  Standard_Integer NbSpan=(Poles.Length()-1)/2;
-#endif
   Standard_Integer low = Poles.Lower();
   Standard_Integer upp = Poles.Upper();
   Standard_Boolean istgt;
Index: oce/src/BlendFunc/BlendFunc_Chamfer.cxx
===================================================================
--- oce.orig/src/BlendFunc/BlendFunc_Chamfer.cxx
+++ oce/src/BlendFunc/BlendFunc_Chamfer.cxx
@@ -12,9 +12,6 @@
 #include <ElCLib.hxx>
 #include <Precision.hxx>
 #include <Standard_NotImplemented.hxx>
-#ifdef DEB
-static Standard_Boolean putsderivatives = 0;
-#endif
 
 //=======================================================================
 //function : BlendFunc_Chamfer
Index: oce/src/BlendFunc/BlendFunc_ConstRad.cxx
===================================================================
--- oce.orig/src/BlendFunc/BlendFunc_ConstRad.cxx
+++ oce/src/BlendFunc/BlendFunc_ConstRad.cxx
@@ -1148,9 +1148,8 @@ void BlendFunc_ConstRad::Section(const S
   math_Vector X(1,4);
   X(1) = U1; X(2) = V1; X(3) = U2; X(4) = V2; 
   Standard_Real prm = Param;
-  Standard_Boolean Ok;
 
-  Ok = ComputeValues(X, 0, Standard_True, prm);
+  ComputeValues(X, 0, Standard_True, prm);
 
   ns1 = nsurf1;
   np = nplan;
@@ -1307,7 +1306,6 @@ void BlendFunc_ConstRad::Section(const B
 
   math_Vector X(1,4);
   Standard_Real prm = P.Parameter();
-  Standard_Boolean Ok;
 
   Standard_Integer low = Poles.Lower();
   Standard_Integer upp = Poles.Upper();
@@ -1315,7 +1313,7 @@ void BlendFunc_ConstRad::Section(const B
   P.ParametersOnS1(X(1), X(2));
   P.ParametersOnS2(X(3), X(4));
 
-  Ok = ComputeValues(X, 0, Standard_True, prm);
+  ComputeValues(X, 0, Standard_True, prm);
   distmin = Min (distmin, pts1.Distance(pts2));
 
   // ns1, ns2, np are copied locally to avoid crushing the fields !
Index: oce/src/BlendFunc/BlendFunc_EvolRad.cxx
===================================================================
--- oce.orig/src/BlendFunc/BlendFunc_EvolRad.cxx
+++ oce/src/BlendFunc/BlendFunc_EvolRad.cxx
@@ -1132,9 +1132,8 @@ void BlendFunc_EvolRad::Section(const St
   math_Vector X(1,4);
   X(1) = U1; X(2) = V1; X(3) = U2; X(4) = V2; 
   Standard_Real prm = Param;
-  Standard_Boolean Ok;
 
-  Ok = ComputeValues(X, 0, Standard_True, prm);
+  ComputeValues(X, 0, Standard_True, prm);
 
   ns1 = nsurf1;
   np = nplan;
@@ -1405,7 +1404,6 @@ void BlendFunc_EvolRad::Section(const Bl
 
   math_Vector X(1,4);
   Standard_Real prm = P.Parameter();
-  Standard_Boolean Ok;
 
   Standard_Integer low = Poles.Lower();
   Standard_Integer upp = Poles.Upper();
@@ -1414,7 +1412,7 @@ void BlendFunc_EvolRad::Section(const Bl
   P.ParametersOnS2(X(3), X(4));
 
   // Calculation and storage of distmin
-  Ok = ComputeValues(X, 0, Standard_True, prm);
+  ComputeValues(X, 0, Standard_True, prm);
   distmin = Min (distmin, pts1.Distance(pts2));
 
   // ns1, ns2, np are copied locally to avoid crashing the fields !
Index: oce/src/BlendFunc/BlendFunc_RuledInv.cxx
===================================================================
--- oce.orig/src/BlendFunc/BlendFunc_RuledInv.cxx
+++ oce/src/BlendFunc/BlendFunc_RuledInv.cxx
@@ -152,7 +152,6 @@ Standard_Boolean BlendFunc_RuledInv::Der
 
   const Standard_Real normtgcur = d1cur.Magnitude();
   const gp_Vec nplan = d1cur.Normalized();
-  const Standard_Real theD = -(nplan.XYZ().Dot(ptcur.XYZ()));
 
   gp_Vec dnplan;
   dnplan.SetLinearForm(-nplan.Dot(d2cur),nplan,d2cur);
Index: oce/src/Bnd/Bnd_BoundSortBox.cxx
===================================================================
--- oce.orig/src/Bnd/Bnd_BoundSortBox.cxx
+++ oce/src/Bnd/Bnd_BoundSortBox.cxx
@@ -627,11 +627,10 @@ const TColStd_ListOfInteger& Bnd_BoundSo
   //-- Rejection avec le tableau de bits
   Standard_Boolean touch = Standard_True;
   touch = Standard_False;
-  Standard_Real _Xmin,_Ymin,_Zmin,_Xmax,_Ymax,_Zmax;
+  Standard_Real _Xmax,_Ymax,_Zmax;
   BSB_T3Bits* Map = (BSB_T3Bits *)TabBits;
   Standard_Real xmin, ymin, zmin, xmax, ymax, zmax;
   _Xmax=Map->Xmax; _Ymax=Map->Ymax; _Zmax=Map->Zmax;
-  _Xmin=Map->Xmin; _Ymin=Map->Ymin; _Zmin=Map->Zmin;
   theBox.Get(xmin, ymin, zmin, xmax, ymax, zmax);
   Standard_Integer i0,i1,j0,j1,k0,k1;
   if(xmin>Xmin) i0=(Standard_Integer )((xmin-Xmin)*deltaX)-1; else  i0=1;
Index: oce/src/BndLib/BndLib_AddSurface.cxx
===================================================================
--- oce.orig/src/BndLib/BndLib_AddSurface.cxx
+++ oce/src/BndLib/BndLib_AddSurface.cxx
@@ -137,8 +137,6 @@ static void TreatInfinitePlane(const gp_
 {
   // Get 3 coordinate axes of the plane.
   const gp_Dir        &aNorm        = aPlane.Axis().Direction();
-  const gp_Dir        &aXDir        = aPlane.XAxis().Direction();
-  const gp_Dir        &aYDir        = aPlane.YAxis().Direction();
   const Standard_Real  anAngularTol = RealEpsilon();
 
   // Get location of the plane as its barycenter
Index: oce/src/CSLib/CSLib_Class2d.cxx
===================================================================
--- oce.orig/src/CSLib/CSLib_Class2d.cxx
+++ oce/src/CSLib/CSLib_Class2d.cxx
@@ -220,9 +220,8 @@ Standard_Integer CSLib_Class2d::Internal
   Standard_Integer nbc, i, ip1, SH, NH, iRet;
   Standard_Real *Pnts2dX, *Pnts2dY;
   Standard_Real x, y, nx, ny, aX;
-  Standard_Real aYmin, aTol;
+  Standard_Real aYmin;
   //
-  aTol=(Tolu>Tolv)? Tolu : Tolv;
   nbc = 0;
   i   = 0;
   ip1 = 1;
Index: oce/src/ChFi2d/ChFi2d_Builder.cxx
===================================================================
--- oce.orig/src/ChFi2d/ChFi2d_Builder.cxx
+++ oce/src/ChFi2d/ChFi2d_Builder.cxx
@@ -623,10 +623,7 @@ TopoDS_Edge ChFi2d_Builder::BuildNewEdge
   TopoDS_Edge anEdge = makeEdge;
   anEdge.Orientation(E1.Orientation());
 //  anEdge.Location(E1.Location());
-#ifdef DEB
-  BRepLib_EdgeError error = 
-#endif
-    makeEdge.Error();
+  makeEdge.Error();
   return anEdge;
 }
 
@@ -768,10 +765,9 @@ TopoDS_Edge ChFi2d_Builder::BuildFilletE
   //    The first arc is found.                                        +
   //========================================================================
 
-  TopAbs_Orientation O1,O2;
-  TopAbs_Orientation OE1,OE2;
+  TopAbs_Orientation O1;
+  TopAbs_Orientation OE1;
   OE1 = E1.Orientation();
-  OE2 = E2.Orientation();
   E1.Orientation(TopAbs_FORWARD);
   E2.Orientation(TopAbs_FORWARD);
   TopoDS_Shape aLocalShape = E1.EmptyCopied();
@@ -799,12 +795,10 @@ TopoDS_Edge ChFi2d_Builder::BuildFilletE
   if (V3.IsSame(V)) {
     param3 = BRep_Tool::Parameter(V3,E2);
     param4 = BRep_Tool::Parameter(V4,E2);
-    O2 = V4.Orientation();
   }
   else {
     param3 = BRep_Tool::Parameter(V4,E2);
     param4 = BRep_Tool::Parameter(V3,E2);
-    O2 = V3.Orientation();
   }
   
   //========================================================================
Index: oce/src/ChFi3d/ChFi3d_Builder_2.cxx
===================================================================
--- oce.orig/src/ChFi3d/ChFi3d_Builder_2.cxx
+++ oce/src/ChFi3d/ChFi3d_Builder_2.cxx
@@ -2294,7 +2294,7 @@ void ChFi3d_Builder::PerformSetOfKPart(H
   Handle(ChFiDS_Spine)&        Spine = Stripe->ChangeSpine();
   Handle(BRepAdaptor_HSurface) HS1,HS2;
   TopAbs_Orientation           Or1,Or2,RefOr1,RefOr2;
-  Standard_Integer             Choix,RefChoix;
+  Standard_Integer             RefChoix;
   
   // initialization of the stripe.
   Stripe->Reset();
@@ -2338,7 +2338,7 @@ void ChFi3d_Builder::PerformSetOfKPart(H
       intl = ((iedge == Spine->NbEdges()) && !Spine->IsPeriodic());
       Or1   = HS1->ChangeSurface().Face().Orientation();
       Or2   = HS2->ChangeSurface().Face().Orientation();
-      Choix = ChFi3d::NextSide(Or1,Or2,RefOr1,RefOr2,RefChoix);      
+      ChFi3d::NextSide(Or1,Or2,RefOr1,RefOr2,RefChoix);      
       It1->Initialize(HS1);
       It2->Initialize(HS2);
       
Index: oce/src/ChFi3d/ChFi3d_Builder_C1.cxx
===================================================================
--- oce.orig/src/ChFi3d/ChFi3d_Builder_C1.cxx
+++ oce/src/ChFi3d/ChFi3d_Builder_C1.cxx
@@ -3814,10 +3814,9 @@ void ChFi3d_Builder::IntersectMoreCorner
     if(!CV1.IsOnArc() && !CV2.IsOnArc())
       Standard_Failure::Raise("Corner intersmore : no point on arc");
     else if(CV1.IsOnArc() && CV2.IsOnArc()){
-      Standard_Boolean sur1 = 0, sur2 = 0;
+      Standard_Boolean sur2 = 0;
       for(ex.Init(CV1.Arc(),TopAbs_VERTEX); ex.More(); ex.Next()){
 	if(Vtx.IsSame(ex.Current())) {
-	  sur1 = 1;
 	  break;
 	}
       }
Index: oce/src/ChFi3d/ChFi3d_Builder_C2.cxx
===================================================================
--- oce.orig/src/ChFi3d/ChFi3d_Builder_C2.cxx
+++ oce/src/ChFi3d/ChFi3d_Builder_C2.cxx
@@ -162,11 +162,8 @@ Standard_Integer ChFi3d_Builder::Perform
   // Otherwise the opposite face  
   // and the eventual intersection of 2 pcurves on this face are found.
 
-  ChFiDS_State Stat1,Stat2;
   Standard_Boolean isfirst1 = (Sens1 == 1);
   Standard_Boolean isfirst2 = (Sens2 == 1);
-  Stat1 = Corner1->Spine()->Status(isfirst1);
-  Stat2 = Corner2->Spine()->Status(isfirst2);
 /*#ifdef DEB
   Standard_Boolean evolcoin = ((Stat1 == ChFiDS_OnSame && Stat2 == ChFiDS_OnDiff) || 
 			       (Stat2 == ChFiDS_OnSame && Stat1 == ChFiDS_OnDiff));
Index: oce/src/ChFi3d/ChFi3d_FilBuilder.cxx
===================================================================
--- oce.orig/src/ChFi3d/ChFi3d_FilBuilder.cxx
+++ oce/src/ChFi3d/ChFi3d_FilBuilder.cxx
@@ -1400,8 +1400,6 @@ void  ChFi3d_FilBuilder::PerformSurf(ChF
     maybesingular = (func.GetMinimalDistance()<=100*tolapp3d); 
   }
   else {
-   Standard_Real SpFirst = HGuide->FirstParameter();
-  Standard_Real SpLast =  HGuide->LastParameter();
     BRepBlend_SurfRstEvolRad func(HS2,HS1,PC1,HGuide,fsp->Law(HGuide));
     func.Set(HSref1,PCref1);
     Handle(Adaptor3d_HCurveOnSurface) HC = new Adaptor3d_HCurveOnSurface();
@@ -1419,7 +1417,6 @@ void  ChFi3d_FilBuilder::PerformSurf(ChF
     finvp.Set(petitchoix);
     func.Set(petitchoix);
     func.Set(myShape);
-    SpFirst = HGuide->FirstParameter();SpLast =  HGuide->LastParameter();
     done = ComputeData(Data,HGuide,lin,HS2,I2,HS1,PC1,I1,Decroch1,
 		       func,finv,finvp,finvc,
 		       PFirst,MaxStep,Fleche,TolGuide,First,Last,
@@ -1885,7 +1882,6 @@ void ChFi3d_FilBuilder::ExtentTwoCorner(
   // to faces and tangents to the guideline.
   Standard_Integer Sens;
   Standard_Real    Coeff = 0.3, Eval=0.0, dU, rad;
-  Standard_Integer IE;
   ChFiDS_ListIteratorOfListOfStripe itel(LS);
   Standard_Boolean FF = Standard_True;
   Handle(ChFiDS_Stripe) Stripe;
@@ -1915,7 +1911,7 @@ void ChFi3d_FilBuilder::ExtentTwoCorner(
 
   // One applies
   for (itel.Initialize(LS) ; itel.More(); itel.Next()) {    
-    IE = ChFi3d_IndexOfSurfData(V,itel.Value(),Sens);
+    ChFi3d_IndexOfSurfData(V,itel.Value(),Sens);
     if (!FF && Stripe == itel.Value()) Sens = -Sens;
     Stripe = itel.Value();
     Spine = Stripe->Spine();
Index: oce/src/ChFiDS/ChFiDS_FilSpine.cxx
===================================================================
--- oce.orig/src/ChFiDS/ChFiDS_FilSpine.cxx
+++ oce/src/ChFiDS/ChFiDS_FilSpine.cxx
@@ -171,9 +171,6 @@ void  ChFiDS_FilSpine::SetRadius(const g
     Handle(ChFiDS_HElSpine) Els = It.Value();
     if (Els->IsPeriodic()) Itl.Value() = ComputeLaw(Els);
     else{
-      Standard_Real nW = W;
-      if(IsPeriodic())
-	nW = ElCLib::InPeriod(W,FirstParameter(),LastParameter());
       for (; It.More(); It.Next(), Itl.Next()) {
 	Els = It.Value();
 	Standard_Real uf = Els->FirstParameter();
Index: oce/src/ChFiKPart/ChFiKPart_ComputeData_FilPlnCyl.cxx
===================================================================
--- oce.orig/src/ChFiKPart/ChFiKPart_ComputeData_FilPlnCyl.cxx
+++ oce/src/ChFiKPart/ChFiKPart_ComputeData_FilPlnCyl.cxx
@@ -66,13 +66,12 @@ Standard_Boolean ChFiKPart_MakeFillet(To
 
   // Parallel cylinder
   Standard_Real    ROff = Cyl.Radius();
-  Standard_Boolean dedans = Standard_False;
 
   if ((Or2 == TopAbs_FORWARD  &&  Cyl.Direct()) ||
       (Or2 == TopAbs_REVERSED && !Cyl.Direct()))
       ROff+=Radius;
   else if (Radius < ROff)  {
-    ROff-=Radius;dedans = Standard_True;
+    ROff-=Radius;
   }
   else {
 #ifdef DEB
Index: oce/src/DBRep/DBRep_IsoBuilder.cxx
===================================================================
--- oce.orig/src/DBRep/DBRep_IsoBuilder.cxx
+++ oce/src/DBRep/DBRep_IsoBuilder.cxx
@@ -112,10 +112,7 @@ DBRep_IsoBuilder::DBRep_IsoBuilder (cons
     //-- Test if a TrimmedCurve is necessary
     if(   Abs(PCurve->FirstParameter()-U1)<= Precision::PConfusion() 
        && Abs(PCurve->LastParameter()-U2)<= Precision::PConfusion()) { 
-#ifdef DEB
-      Standard_Integer IndE =
-#endif
-                              AddElement (PCurve, TopologicalEdge.Orientation()) ;      
+      AddElement (PCurve, TopologicalEdge.Orientation());
     }
     else { 
       if (!PCurve->IsPeriodic()) {
@@ -123,10 +120,7 @@ DBRep_IsoBuilder::DBRep_IsoBuilder (cons
 	if (!TrimPCurve.IsNull()) {
 	  if (TrimPCurve->BasisCurve()->FirstParameter()-U1 > Precision::PConfusion() ||
 	      U2-TrimPCurve->BasisCurve()->LastParameter()  > Precision::PConfusion()) {
-#ifdef DEB
-	    Standard_Integer IndE =
-#endif
-                                    AddElement (PCurve, TopologicalEdge.Orientation()) ;      
+	    AddElement (PCurve, TopologicalEdge.Orientation()) ;      
 #ifdef DEB
 	    cout<<"DBRep_IsoBuilder TrimPCurve : parameters out of range "<<endl;
 	    cout<<"    U1("<<U1<<"), Umin("<<PCurve->FirstParameter()
@@ -157,10 +151,7 @@ DBRep_IsoBuilder::DBRep_IsoBuilder (cons
       if (Abs(U1-U2) <= Precision::PConfusion()) continue;
       
       Handle (Geom2d_TrimmedCurve) TrimPCurve = new Geom2d_TrimmedCurve (PCurve, U1, U2) ;
-#ifdef DEB
-      Standard_Integer IndE =
-#endif
-                              AddElement (TrimPCurve, TopologicalEdge.Orientation()) ;
+      AddElement (TrimPCurve, TopologicalEdge.Orientation()) ;
     }
   }
 
Index: oce/src/DDataStd/DDataStd_DrawDriver.cxx
===================================================================
--- oce.orig/src/DDataStd/DDataStd_DrawDriver.cxx
+++ oce/src/DDataStd/DDataStd_DrawDriver.cxx
@@ -62,12 +62,6 @@ static Standard_Integer DISCRET    = 100
 static Standard_Integer NBISOS     = 10;
 static Standard_Real    THESIZE       = 1000.;
 
-// Unused
-#ifdef DEB
-static Standard_Real    PLANETHESIZE  = 100.;
-static Standard_Real    DEFLECTION = 0.0;
-#endif
-
 static Handle(DDataStd_DrawDriver) DrawDriver;
 
 
Index: oce/src/DDataStd/DDataStd_Sample.cxx
===================================================================
--- oce.orig/src/DDataStd/DDataStd_Sample.cxx
+++ oce/src/DDataStd/DDataStd_Sample.cxx
@@ -57,12 +57,6 @@ static void Sample()
 
   Handle(TDataStd_Integer) I = TDataStd_Integer::Set(aLabel, i);
 
-  // Getting the value stored in TDataStd_Integer attribute
-
-  Standard_Integer aValue;
-
-  aValue = I->Get();
-
   // Setting the new value in the attribute 
     
   I->Set( 25 );
@@ -221,11 +215,6 @@ static void Sample()
   
   Handle(TDF_Reference) reference = TDF_Reference::Set(aLabel, referencedlabel);
 
-  // Getting a label to TDF_Reference attribute refers to
-   
-  TDF_Label refLabel = reference->Get();
-
-
   //------------------------- TDataXtd_Point ----------------
   //---------------------------------------------------------
   gp_Pnt Pnt;
@@ -362,7 +351,7 @@ static void Sample()
 
   // Creating a new label in directory
 
-  TDF_Label newlabel = TDataStd_Directory::MakeObjectLabel(newdirectory);
+  TDataStd_Directory::MakeObjectLabel(newdirectory);
 
    
   //------------------------- TDataStd_TreeNode ---------------
Index: oce/src/DDocStd/DDocStd.cxx
===================================================================
--- oce.orig/src/DDocStd/DDocStd.cxx
+++ oce/src/DDocStd/DDocStd.cxx
@@ -77,9 +77,6 @@ Standard_Boolean DDocStd::Find (const Ha
 				const Standard_Boolean  Complain)
 {
   Label.Nullify();
-#ifdef DEB
-  Standard_Boolean Found;
-#endif
   TDF_Tool::Label(D->GetData(),Entry,Label,Standard_False);
   if (Label.IsNull() && Complain) cout<<"No label for entry "<<Entry<<endl;
   return !Label.IsNull();
@@ -96,9 +93,6 @@ Standard_Boolean DDocStd::Find (const Ha
 				Handle(TDF_Attribute)&  A,
 				const Standard_Boolean  Complain) 
 {
-#ifdef DEB
-  Standard_Boolean found;
-#endif
   TDF_Label L;
   if (Find(D,Entry,L,Complain)) {
     if (L.FindAttribute(ID,A)) return Standard_True;
Index: oce/src/DNaming/DNaming_BooleanOperationDriver.cxx
===================================================================
--- oce.orig/src/DNaming/DNaming_BooleanOperationDriver.cxx
+++ oce/src/DNaming/DNaming_BooleanOperationDriver.cxx
@@ -336,7 +336,6 @@ Standard_Boolean DNaming_BooleanOperatio
     if(!aCheck.IsValid(theMkOpe.Shape())) 
       aResIsValid = FixSameParameter(theMkOpe.Shape(), aCheck);
     if (aResIsValid) {
-      const TDF_Label& aResultLabel = RESPOSITION(theFunction);
       if(theFunction->GetDriverGUID() == FUSE_GUID) {
 	LoadNamingDS(RESPOSITION(theFunction), theMkOpe);
       }
Index: oce/src/DNaming/DNaming_ModelingCommands.cxx
===================================================================
--- oce.orig/src/DNaming/DNaming_ModelingCommands.cxx
+++ oce/src/DNaming/DNaming_ModelingCommands.cxx
@@ -976,7 +976,6 @@ static Standard_Integer DNaming_AddFille
 
   TDF_Reference::Set(anObject->Label(), aFun->Label().FindChild(FUNCTION_RESULT_LABEL)); //result is here 
 
-  Standard_Integer aSurfaceType = 0;
 
   Standard_Real aRadius = atof(theArg[3]);
   DNaming::GetReal(aFun,FILLET_RADIUS)->Set(aRadius);  
@@ -1643,7 +1642,6 @@ static Standard_Boolean MakeSelection (c
 	TDF_Label aResultLabel =  aFun->Label().FindChild(FUNCTION_RESULT_LABEL, Standard_True); 
 	TDF_Reference::Set(Obj->Label(), aResultLabel ); //result of the object
 	aResultLabel.ForgetAllAttributes(Standard_True);
-	Standard_Boolean aKeepOrientation(Standard_False);
 	Handle(TNaming_NamedShape) aNS = DNaming::GetObjectValue( ContextObj);	
 	try{
 	  const TopoDS_Shape& aContext = aNS->Get();
@@ -1702,7 +1700,6 @@ static Standard_Boolean MakeXSelection (
 	TDF_Reference::Set(Obj->Label(), aResultLabel ); //result of the object
 	aResultLabel.ForgetAllAttributes(Standard_True);
 
-	Standard_Boolean aKeepOrientation(Standard_False);
 	Handle(TNaming_NamedShape) aNS = DNaming::GetObjectValue( ContextObj);	
 	try{
 	  const TopoDS_Shape& aContext = aNS->Get();
@@ -1866,7 +1863,6 @@ static Standard_Integer DNaming_TestSing
 
     if(!aNS.IsNull() && !aNS->IsEmpty()) {
       const TopoDS_Shape&  aRootShape = aNS->Get();
-      TopAbs_ShapeEnum aType = aRootShape.ShapeType();
       //TopTools_MapOfOrientedShape aMap0;
       //MapOfOrientedShapes(aRootShape, aMap0);
       TopTools_ListOfShape aList, aFailedList;
@@ -2005,7 +2001,6 @@ static Standard_Integer DNaming_Multiple
 
     if(!aNS.IsNull() && !aNS->IsEmpty()) {
       const TopoDS_Shape&  aRootShape = aNS->Get();
-      TopAbs_ShapeEnum aType = aRootShape.ShapeType();
       TopTools_MapOfOrientedShape aMap0;
       MapOfOrientedShapes(aRootShape, aMap0);
       TopTools_ListOfShape aList, aFailedList;
Index: oce/src/DNaming/DNaming_ToolsCommands.cxx
===================================================================
--- oce.orig/src/DNaming/DNaming_ToolsCommands.cxx
+++ oce/src/DNaming/DNaming_ToolsCommands.cxx
@@ -142,7 +142,6 @@ void DNaming::ToolsCommands (Draw_Interp
   if (done) return;
   done = Standard_True;
   const char* g = "Naming data commands " ;
-  const char* g2 = "Naming modeling commands" ;
 
   theCommands.Add ("CopyShape", 
                    "CopyShape (Shape1 [Shape2] ...)",
Index: oce/src/DPrsStd/DPrsStd_Sample.cxx
===================================================================
--- oce.orig/src/DPrsStd/DPrsStd_Sample.cxx
+++ oce/src/DPrsStd/DPrsStd_Sample.cxx
@@ -177,10 +177,6 @@ static void Sample()
     P->Display(Standard_True); 
     TPrsStd_AISViewer::Update(ShapeLabel);  //Update presenation of the attribute in a viewer's window
 
-    //Getting Standard_GUID of attribute with which TPrsStd_AISPresentation attribute is associeted
-
-    Standard_GUID guid = P->GetDriverGUID();
-
     //Setting a color to the displayd attribute
 
     P->SetColor(Quantity_NOC_RED);
Index: oce/src/Draw/Draw_VariableCommands.cxx
===================================================================
--- oce.orig/src/Draw/Draw_VariableCommands.cxx
+++ oce/src/Draw/Draw_VariableCommands.cxx
@@ -791,9 +791,10 @@ void Draw::Set(const Standard_CString Na
 Handle(Draw_Drawable3D) Draw::Get(Standard_CString& name, 
 			          const Standard_Boolean )
 {
+#if !((TCL_MAJOR_VERSION > 8) || ((TCL_MAJOR_VERSION == 8) && (TCL_MINOR_VERSION >= 4))) || defined(USE_NON_CONST)
   Standard_PCharacter pName;
-  //
   pName=(Standard_PCharacter)name;
+#endif
   //
   Standard_Boolean pick = ((name[0] == '.') && (name[1] == '\0'));
   Handle(Draw_Drawable3D) D;
Index: oce/src/Draw/Draw_Viewer.cxx
===================================================================
--- oce.orig/src/Draw/Draw_Viewer.cxx
+++ oce/src/Draw/Draw_Viewer.cxx
@@ -498,9 +498,6 @@ void   Draw_Viewer::RotateView  (const S
   if (Draw_Batch) return;
   if (myViews[id]) {
     gp_Trsf T = myViews[id]->Matrix;
-#ifdef DEB
-    Standard_Real z = myViews[id]->Zoom;
-#endif
 
     T.Invert();
     gp_Pnt PP(0,0,0);
Index: oce/src/Draw/Draw_Window.cxx
===================================================================
--- oce.orig/src/Draw/Draw_Window.cxx
+++ oce/src/Draw/Draw_Window.cxx
@@ -751,8 +751,7 @@ Standard_Boolean Draw_Window::Save (cons
 
 void ProcessEvent(Draw_Window& win, XEvent& xev)
 {
-  Standard_Integer X,Y,button,lenk;
-  char c;
+  Standard_Integer X,Y,button;
   KeySym keysym;
   XComposeStatus stat;
   char chainekey[10];
@@ -779,17 +778,11 @@ void ProcessEvent(Draw_Window& win, XEve
     break;
 
   case KeyPress :
-    lenk = XLookupString(&(xev.xkey),
+    XLookupString(&(xev.xkey),
                          chainekey,
                          10,
                          &keysym,
                          &stat);
-    if (lenk==1)
-      c = chainekey[0];
-    else
-      c = '\0';
-
-    //WKeyPress(c,keysym);
     break;
 
   case MotionNotify :
@@ -1681,7 +1674,6 @@ void DrawWindow::Clear()
   HDC hDC = GetDC(win);
   HDC aWorkDC = myUseBuffer ? GetMemDC(hDC) : hDC;
 
-  int debug = GetROP2(aWorkDC);
   SaveDC(aWorkDC);
   SelectObject(aWorkDC,GetStockObject(BLACK_PEN));
   Rectangle(aWorkDC, 0, 0, WidthWin(), HeightWin());
Index: oce/src/DrawDim/DrawDim_Angle.cxx
===================================================================
--- oce.orig/src/DrawDim/DrawDim_Angle.cxx
+++ oce/src/DrawDim/DrawDim_Angle.cxx
@@ -110,10 +110,7 @@ void DrawDim_Angle::DrawOn(Draw_Display&
   if (!DrawDim::Pln(myPlane2,pln2)) return; 
   IntAna_QuadQuadGeo ip (pln1,pln2,Precision::Confusion(), Precision::Angular());
   if (!ip.IsDone()) return;
-#ifdef DEB
-  gp_Lin linter =
-#endif
-                  ip.Line(1);
+  ip.Line(1);
   
   //Handle(Geom_Surface) curve1 = BRep_Tool::Surface(myPlane1);
   //Handle(Geom_PlaneLine) line1 = Handle(Geom_Line)::DownCast(curve1);    
@@ -168,10 +165,6 @@ void DrawDim_Angle::DrawOn(Draw_Display&
       gp_Vec curvec (AxePosition, curpt);
       gp_XYZ curXYZ = curvec.XYZ();
       gp_XYZ Norm (curXYZ.Crossed(AxeXYZ));
-#ifdef DEB
-      Standard_Real NormMod =
-#endif
-                              Norm.Modulus();
       if (Norm.Modulus() > gp::Resolution()) {
 	Standard_Real curdist = curpos.Distance (curpt);
 	if (curdist < dist) {
Index: oce/src/DrawDim/DrawDim_PlanarAngle.cxx
===================================================================
--- oce.orig/src/DrawDim/DrawDim_PlanarAngle.cxx
+++ oce/src/DrawDim/DrawDim_PlanarAngle.cxx
@@ -39,14 +39,6 @@
 #include <DBRep_DrawableShape.hxx>
 #include <TopoDS.hxx>
 
-#ifdef DEB
-static Standard_Integer DISCRET    = 100;
-static Standard_Integer NBISOS     = 2;
-static Standard_Real    SIZE       = 100.;
-static Standard_Real    DEFLECTION = 0.0;
-static Standard_Real    RAP        = 0.4;
-#endif
-
 //=======================================================================
 //function : DrawDim_PlanarAngle
 //purpose  : 
Index: oce/src/DrawFairCurve/DrawFairCurve_Batten.cxx
===================================================================
--- oce.orig/src/DrawFairCurve/DrawFairCurve_Batten.cxx
+++ oce/src/DrawFairCurve/DrawFairCurve_Batten.cxx
@@ -22,10 +22,7 @@ DrawFairCurve_Batten::DrawFairCurve_Batt
 void DrawFairCurve_Batten::Compute()
 {
   FairCurve_AnalysisCode Iana;
-#ifdef DEB
-  Standard_Boolean Ok =
-#endif
-                        ((FairCurve_Batten*)MyBatten)->Compute(Iana, 50, 1.0e-2);
+  ((FairCurve_Batten*)MyBatten)->Compute(Iana, 50, 1.0e-2);
   curv = ((FairCurve_Batten*)MyBatten)->Curve();
 }
 void DrawFairCurve_Batten::SetPoint(const Standard_Integer Side, const gp_Pnt2d& Point)
Index: oce/src/DrawTrSurf/DrawTrSurf.cxx
===================================================================
--- oce.orig/src/DrawTrSurf/DrawTrSurf.cxx
+++ oce/src/DrawTrSurf/DrawTrSurf.cxx
@@ -350,8 +350,6 @@ static Standard_Integer draw (Draw_Inter
   if (n <= 2) {
 	if (!strcmp(a[0],"dmode")) {
 	  if (n == 2) {
-	    Standard_Integer mod = 0;
-	    if ((*a[n-1] == 'U')||(*a[n-1] == 'u')) mod = 1;
 	    DrawMode = 1;
 	  }
 	  if (DrawMode)
Index: oce/src/DsgPrs/DsgPrs.cxx
===================================================================
--- oce.orig/src/DsgPrs/DsgPrs.cxx
+++ oce/src/DsgPrs/DsgPrs.cxx
@@ -588,16 +588,8 @@ void DsgPrs::ComputeFilletRadiusPresenta
       FilletCirc.SetRadius( Center.Distance( FirstPoint ) ); //***
       gp_Vec vec1( dir1 );
       vec1 *= FilletCirc.Radius();
-#ifdef DEB
-      gp_Pnt p1 =
-#endif
-                  Center.Translated( vec1 );
       gp_Vec vec2( dir2 );
       vec2 *= FilletCirc.Radius();
-#ifdef DEB
-      gp_Pnt p2 =
-#endif
-                  Center.Translated( vec2 );
       gp_Vec PosVec;
       if(! Center.IsEqual( Position, Precision::Confusion() ))
 	PosVec.SetXYZ( gp_Vec(Center, Position).XYZ() );
Index: oce/src/DsgPrs/DsgPrs_AnglePresentation.cxx
===================================================================
--- oce.orig/src/DsgPrs/DsgPrs_AnglePresentation.cxx
+++ oce/src/DsgPrs/DsgPrs_AnglePresentation.cxx
@@ -277,10 +277,7 @@ void DsgPrs_AnglePresentation::Add (cons
   gp_Circ cer(ax,CenterPoint.Distance(OffsetPoint));
   gp_Vec vec1(dir1);
   vec1 *= cer.Radius();
-#ifdef DEB
-  gp_Pnt p1 =
-#endif
-              CenterPoint.Translated(vec1);
+  CenterPoint.Translated(vec1);
   gp_Vec vec2(dir2);
   vec2 *= cer.Radius();
   gp_Pnt p2 = CenterPoint.Translated(vec2);
@@ -542,10 +539,7 @@ void DsgPrs_AnglePresentation::Add (cons
   gp_Circ cer(ax,CenterPoint.Distance(OffsetPoint));
   gp_Vec vec1(dir1);
   vec1 *= cer.Radius();
-#ifdef DEB
-  gp_Pnt p1 =
-#endif
-              CenterPoint.Translated(vec1);
+  CenterPoint.Translated(vec1);
   gp_Vec vec2(dir2);
   vec2 *= cer.Radius();
   gp_Pnt p2 = CenterPoint.Translated(vec2);
@@ -666,10 +660,7 @@ void DsgPrs_AnglePresentation::Add (cons
   gp_Circ cer(ax,CenterPoint.Distance(OffsetPoint));
   gp_Vec vec1(dir1);
   vec1 *= cer.Radius();
-#ifdef DEB
-  gp_Pnt p1 =
-#endif
-              CenterPoint.Translated(vec1);
+  CenterPoint.Translated(vec1);
   gp_Vec vec2(dir2);
   vec2 *= cer.Radius();
   gp_Pnt p2 = CenterPoint.Translated(vec2);
@@ -794,10 +785,7 @@ void DsgPrs_AnglePresentation::Add (cons
   gp_Circ cer(ax,CenterPoint.Distance(OffsetPoint));
   gp_Vec vec1(dir1);
   vec1 *= cer.Radius();
-#ifdef DEB
-  gp_Pnt p1 =
-#endif
-              CenterPoint.Translated(vec1);
+  CenterPoint.Translated(vec1);
   gp_Vec vec2(dir2);
   vec2 *= cer.Radius();
   gp_Pnt p2 = CenterPoint.Translated(vec2);
Index: oce/src/DsgPrs/DsgPrs_DiameterPresentation.cxx
===================================================================
--- oce.orig/src/DsgPrs/DsgPrs_DiameterPresentation.cxx
+++ oce/src/DsgPrs/DsgPrs_DiameterPresentation.cxx
@@ -160,7 +160,6 @@ void DsgPrs_DiameterPresentation::Add (c
   Standard_Real parEndOfArrow = ElCLib::Parameter(aCircle,AttachmentPoint); //
   gp_Pnt EndOfArrow;
   gp_Pnt DrawPosition = AttachmentPoint;// point of attachment
-  Standard_Boolean otherside = Standard_False;
 
   gp_Pnt Center = aCircle.Location();
   gp_Pnt FirstPoint = ElCLib::Value(uFirst, aCircle);
@@ -172,7 +171,6 @@ void DsgPrs_DiameterPresentation::Add (c
     if (DsgPrs_InDomain(fpara,lpara,otherpar)) {
       parEndOfArrow = otherpar; // parameter on circle
       EndOfArrow = ElCLib::Value(parEndOfArrow, aCircle);
-      otherside = Standard_True;
     }
     else {
       gp_Dir dir1(gp_Vec(Center, FirstPoint));
Index: oce/src/DsgPrs/DsgPrs_ShapeDirPresentation.cxx
===================================================================
--- oce.orig/src/DsgPrs/DsgPrs_ShapeDirPresentation.cxx
+++ oce/src/DsgPrs/DsgPrs_ShapeDirPresentation.cxx
@@ -118,10 +118,6 @@ static Standard_Boolean FindPointOnFace(
   // verify that (upar vpar) is a point on the face
 
   BRepClass_FaceClassifier fClass(face, pt2d, gp::Resolution());
-#ifdef DEB
-  TopAbs_State state =
-#endif
-                       fClass.State();
   if ((fClass.State() == TopAbs_OUT) || (fClass.State() == TopAbs_UNKNOWN)) {
     // try to find a point on face
     pt2d=points(1);
Index: oce/src/DsgPrs/DsgPrs_SymmetricPresentation.cxx
===================================================================
--- oce.orig/src/DsgPrs/DsgPrs_SymmetricPresentation.cxx
+++ oce/src/DsgPrs/DsgPrs_SymmetricPresentation.cxx
@@ -537,10 +537,6 @@ void DsgPrs_SymmetricPresentation::Add (
   if (parcur < parmin) parmin = parcur;
   if (parcur > parmax) parmax = parcur;
   parcur = ElCLib::Parameter(L3,OffsetPnt);
-#ifdef DEB
-  gp_Pnt offp =
-#endif
-                ElCLib::Value(parcur,L3);
 
   Standard_Boolean outside = Standard_False;
   if (parcur < parmin) {
@@ -890,10 +886,6 @@ void DsgPrs_SymmetricPresentation::Add (
     if (parcur < parmin) parmin = parcur;
     if (parcur > parmax) parmax = parcur;
     parcur = ElCLib::Parameter(L3,OffsetPoint);
-#ifdef DEB
-    gp_Pnt offp =
-#endif
-                  ElCLib::Value(parcur,L3);
     
     Standard_Boolean outside = Standard_False;
     if (parcur < parmin) {
Index: oce/src/DsgPrs/DsgPrs_XYZAxisPresentation.cxx
===================================================================
--- oce.orig/src/DsgPrs/DsgPrs_XYZAxisPresentation.cxx
+++ oce/src/DsgPrs/DsgPrs_XYZAxisPresentation.cxx
@@ -71,11 +71,6 @@ void DsgPrs_XYZAxisPresentation::Add(con
   A(1).SetCoord(xo,yo,zo);
   A(2).SetCoord(x,y,z);
  
-#ifdef DEB
-  Quantity_Length arrowAngle = anArrowAspect->Angle();
-  Quantity_Length textHeight = aTextAspect->Height();
-#endif
-
   G->SetPrimitivesAspect(aLineAspect->Aspect());
   G->Polyline(A);
   G->SetPrimitivesAspect( anArrowAspect->Aspect() );
Index: oce/src/Dynamic/Dynamic_FuzzyDefinitionsDictionary.cxx
===================================================================
--- oce.orig/src/Dynamic/Dynamic_FuzzyDefinitionsDictionary.cxx
+++ oce/src/Dynamic/Dynamic_FuzzyDefinitionsDictionary.cxx
@@ -60,7 +60,7 @@ void Dynamic_FuzzyDefinitionsDictionary:
   char line[255];
   char name[80];
   char type[80];
-  char value[80],value1[80],value2[80],value3[80];
+  char value[80];
   Handle(Dynamic_FuzzyDefinition) fuzzydefinition;
   Handle(Dynamic_Parameter) parameter;
   
@@ -122,9 +122,6 @@ void Dynamic_FuzzyDefinitionsDictionary:
 
 	  for(i=0; i<80; i++)type   [i] = 0;
 	  for(i=0; i<80; i++)value  [i] = 0;
-	  for(i=0; i<80; i++)value1 [i] = 0;
-	  for(i=0; i<80; i++)value2 [i] = 0;
-	  for(i=0; i<80; i++)value3 [i] = 0;
 
 //	  fr = sscanf(&line[end+1],"%s%80c",&type,&value);
 	  fr = sscanf(&line[end+1],"%s%80c",type,value);
Index: oce/src/Dynamic/Dynamic_MethodDefinitionsDictionary.cxx
===================================================================
--- oce.orig/src/Dynamic/Dynamic_MethodDefinitionsDictionary.cxx
+++ oce/src/Dynamic/Dynamic_MethodDefinitionsDictionary.cxx
@@ -62,7 +62,7 @@ void Dynamic_MethodDefinitionsDictionary
   char name[80];
   char mode[80];
   char type[80];
-  char value[80],value1[80],value2[80],value3[80];
+  char value[80];
   Handle(Dynamic_CompiledMethod) methoddefinition;
   Handle(Dynamic_Parameter) parameter;
   
@@ -125,9 +125,6 @@ void Dynamic_MethodDefinitionsDictionary
 	  for(i=0; i<80; i++)mode   [i] = 0;
 	  for(i=0; i<80; i++)type   [i] = 0;
 	  for(i=0; i<80; i++)value  [i] = 0;
-	  for(i=0; i<80; i++)value1 [i] = 0;
-	  for(i=0; i<80; i++)value2 [i] = 0;
-	  for(i=0; i<80; i++)value3 [i] = 0;
 
 	  //	  fr = sscanf(&line[end+1],"%s%s%80c",&mode,&type,&value);
 	  fr = sscanf(&line[end+1],"%s%s%80c",mode,type,value);
Index: oce/src/ExprIntrp/ExprIntrp_yaccintrf.cxx
===================================================================
--- oce.orig/src/ExprIntrp/ExprIntrp_yaccintrf.cxx
+++ oce/src/ExprIntrp/ExprIntrp_yaccintrf.cxx
@@ -58,9 +58,8 @@ static Standard_Integer ExprIntrp_nbdiff
 
 extern "C" void ExprIntrp_StartFunction()
 {
-  int nbcar;
   char funcname[100];
-  nbcar = ExprIntrp_GetResult(funcname);
+  ExprIntrp_GetResult(funcname);
   TCollection_AsciiString name(funcname);
   ExprIntrp_Recept.PushName(name);
   ExprIntrp_nbargs = 0;
@@ -68,9 +67,8 @@ extern "C" void ExprIntrp_StartFunction(
 
 extern "C" void ExprIntrp_StartDerivate()
 {
-  int nbcar;
   char funcname[100];
-  nbcar = ExprIntrp_GetResult(funcname);
+  ExprIntrp_GetResult(funcname);
   TCollection_AsciiString name(funcname);
   ExprIntrp_Recept.PushName(name);
 }
@@ -86,9 +84,6 @@ extern "C" void ExprIntrp_Derivation()
 {
   ExprIntrp_Recept.PushValue(1);
   char name[100];
-#ifdef DEB
-  Standard_Integer nbcar = 
-#endif
     ExprIntrp_GetResult(name);
   TCollection_AsciiString thename(name);
   Handle(Expr_NamedExpression) namexp = ExprIntrp_Recept.GetNamed(thename);
@@ -104,8 +99,7 @@ extern "C" void ExprIntrp_Derivation()
 extern "C" void ExprIntrp_DerivationValue()
 {
   char num[30];
-  int nbcar;
-  nbcar = ExprIntrp_GetResult(num);
+  ExprIntrp_GetResult(num);
   Standard_Integer degree = ExprIntrp_Recept.PopValue();
   degree = atoi(num);
   ExprIntrp_Recept.PushValue(degree);
@@ -129,9 +123,6 @@ extern "C" void ExprIntrp_StartDifferent
 extern "C" void ExprIntrp_DiffDegreeVar()
 {
   char name[100];
-#ifdef DEB
-  Standard_Integer nbcar = 
-#endif
     ExprIntrp_GetResult(name);
 #ifndef WNT 
   if (strncasecmp(name,"X",1)) {
@@ -156,9 +147,6 @@ extern "C" void ExprIntrp_DiffVar()
 extern "C" void ExprIntrp_DiffDegree()
 {
   char name[100];
-#ifdef DEB
-  Standard_Integer nbcar = 
-#endif
     ExprIntrp_GetResult(name);
   Standard_Integer deg = atoi(name);
   ExprIntrp_Recept.PushValue(deg);
@@ -167,9 +155,6 @@ extern "C" void ExprIntrp_DiffDegree()
 extern "C" void ExprIntrp_VerDiffDegree()
 {
   char name[100];
-#ifdef DEB
-  Standard_Integer nbcar = 
-#endif
     ExprIntrp_GetResult(name);
   Standard_Integer deg = atoi(name);
   Standard_Integer thedeg = ExprIntrp_Recept.PopValue();
@@ -461,8 +446,7 @@ extern "C" void ExprIntrp_UnaryMinusOper
 extern "C" void ExprIntrp_VariableIdentifier()
 {
   char name[30];
-  int nbcar;
-  nbcar = ExprIntrp_GetResult(name);
+  ExprIntrp_GetResult(name);
   TCollection_AsciiString thename(name);
   Handle(Expr_NamedExpression) nameexp = ExprIntrp_Recept.GetNamed(thename);
   if (nameexp.IsNull()) {
@@ -475,8 +459,7 @@ extern "C" void ExprIntrp_VariableIdenti
 extern "C" void ExprIntrp_NumValue()
 {
   char num[30];
-  int nbcar;
-  nbcar = ExprIntrp_GetResult(num);
+  ExprIntrp_GetResult(num);
   Standard_Real value = atof(num);
   Handle(Expr_NumericValue) nval = new Expr_NumericValue(value);
   ExprIntrp_Recept.Push(nval);
@@ -484,15 +467,13 @@ extern "C" void ExprIntrp_NumValue()
 
 extern "C" void ExprIntrp_AssignVariable()
 {
-  int nbcar;
-  nbcar = ExprIntrp_GetResult(ExprIntrp_assname);
+  ExprIntrp_GetResult(ExprIntrp_assname);
 }
 
 extern "C" void ExprIntrp_Deassign()
 {
-  int nbcar;
   char name[100];
-  nbcar = ExprIntrp_GetResult(name);
+  ExprIntrp_GetResult(name);
   TCollection_AsciiString thename(name);
   Handle(Expr_NamedExpression) nameexp = ExprIntrp_Recept.GetNamed(thename);
   if (nameexp.IsNull()) {
@@ -606,9 +587,6 @@ extern "C" void ExprIntrp_EndOfFuncDef()
 extern "C" void ExprIntrp_ConstantIdentifier()
 {
   char name[100];
-#ifdef DEB
-  Standard_Integer nbcar = 
-#endif
     ExprIntrp_GetResult(name);
   TCollection_AsciiString thename(name);
   ExprIntrp_Recept.PushName(thename);
@@ -618,8 +596,7 @@ extern "C" void ExprIntrp_ConstantDefini
 {
   TCollection_AsciiString name = ExprIntrp_Recept.PopName();
   char num[30];
-  int nbcar;
-  nbcar = ExprIntrp_GetResult(num);
+  ExprIntrp_GetResult(num);
   Standard_Real val = atof(num);
   Handle(Expr_NamedConstant) theconst = new Expr_NamedConstant(name,val);
   ExprIntrp_Recept.Use(theconst);
Index: oce/src/Extrema/Extrema_ExtCS.cxx
===================================================================
--- oce.orig/src/Extrema/Extrema_ExtCS.cxx
+++ oce/src/Extrema/Extrema_ExtCS.cxx
@@ -130,8 +130,7 @@ void Extrema_ExtCS::Perform(const Adapto
 	  if(Precision::IsInfinite(Abs(cfirst)) || Precision::IsInfinite(Abs(clast))) {
 
 	    Bnd_Box aSurfBox;
-	    BndLib_AddSurface anAddSurf;
-	    anAddSurf.Add(*myS, ufirst, ulast, vfirst, vlast, Precision::Confusion(), aSurfBox);
+	    BndLib_AddSurface::Add(*myS, ufirst, ulast, vfirst, vlast, Precision::Confusion(), aSurfBox);
 	    Standard_Real xmin, ymin, zmin, xmax, ymax, zmax;
 	    aSurfBox.Get(xmin, ymin, zmin, xmax, ymax, zmax);
 	    Standard_Real tmin = Precision::Infinite(), tmax = -tmin;
Index: oce/src/Extrema/Extrema_ExtElC.cxx
===================================================================
--- oce.orig/src/Extrema/Extrema_ExtElC.cxx
+++ oce/src/Extrema/Extrema_ExtElC.cxx
@@ -53,7 +53,6 @@ class ExtremaExtElC_TrigonometricRoots {
   }
   //
   Standard_Boolean IsARoot(Standard_Real u) {
-    Standard_Integer i;
     Standard_Real PIpPI, aEps;
     //
     aEps=RealEpsilon();
Index: oce/src/Extrema/Extrema_ExtElC2d.cxx
===================================================================
--- oce.orig/src/Extrema/Extrema_ExtElC2d.cxx
+++ oce/src/Extrema/Extrema_ExtElC2d.cxx
@@ -85,13 +85,8 @@ Methode:
   Standard_Real Dy = D.Dot(y2);
   Standard_Real U1, teta[2];
   gp_Pnt2d O1=C1.Location();
-#ifdef DEB
-  gp_Pnt2d O2= C2.Location();
-  gp_Pnt2d P1, P2;
-#else
   C2.Location();
   gp_Pnt2d P1, P2;
-#endif
   
   if (Abs(Dy) <= RealEpsilon()) {
     teta[0] = PI/2.0;
@@ -137,11 +132,7 @@ Extrema_ExtElC2d::Extrema_ExtElC2d (cons
   Standard_Real Dx = D.Dot(x2);
   Standard_Real Dy = D.Dot(y2);
   Standard_Real U1, teta[2], r1 = C2.MajorRadius(), r2 = C2.MinorRadius();
-#ifdef DEB
-  gp_Pnt2d O1=C1.Location(), O2= C2.Location(), P1, P2;
-#else
   gp_Pnt2d O1=C1.Location(), P1, P2;
-#endif
   
   if (Abs(Dy) <= RealEpsilon()) {
     teta[0] = PI/2.0;
Index: oce/src/Extrema/Extrema_ExtElCS.cxx
===================================================================
--- oce.orig/src/Extrema/Extrema_ExtElCS.cxx
+++ oce/src/Extrema/Extrema_ExtElCS.cxx
@@ -65,11 +65,7 @@ void Extrema_ExtElCS::Perform(const gp_L
   myIsPar = Standard_False;
 
   gp_Ax3 Pos = S.Position();
-#ifdef DEB
-  gp_Pnt O = Pos.Location();
-#else
   Pos.Location();
-#endif
   Standard_Real radius = S.Radius();
   Extrema_ExtElC Extrem(gp_Lin(Pos.Axis()), C, Precision::Angular());
   if (Extrem.IsParallel()) {
Index: oce/src/Extrema/Extrema_ExtPElC.cxx
===================================================================
--- oce.orig/src/Extrema/Extrema_ExtPElC.cxx
+++ oce/src/Extrema/Extrema_ExtPElC.cxx
@@ -280,11 +280,6 @@ Methode:
   Standard_Real R = C.MajorRadius();
   Standard_Real r = C.MinorRadius();
   gp_Vec OPp (O,Pp);
-#ifdef DEB
-  Standard_Real OPpMagn = OPp.Magnitude();
-#else
-  OPp.Magnitude();
-#endif
   Standard_Real X = OPp.Dot(gp_Vec(C.XAxis().Direction()));
   Standard_Real Y = OPp.Dot(gp_Vec(C.YAxis().Direction()));
 
@@ -374,11 +369,6 @@ Methode:
 
   Standard_Real F = C.Focal();
   gp_Vec OPp (O,Pp);
-#ifdef DEB
-  Standard_Real OPpMagn = OPp.Magnitude();
-#else
-  OPp.Magnitude();
-#endif
   Standard_Real X = OPp.Dot(gp_Vec(C.XAxis().Direction()));
 //  Standard_Real Y = Sqrt(OPpMagn*OPpMagn-X*X);
   Standard_Real Y = OPp.Dot(gp_Vec(C.YAxis().Direction()));
Index: oce/src/Extrema/Extrema_ExtPElC2d.cxx
===================================================================
--- oce.orig/src/Extrema/Extrema_ExtPElC2d.cxx
+++ oce/src/Extrema/Extrema_ExtPElC2d.cxx
@@ -144,11 +144,6 @@ void Extrema_ExtPElC2d::Perform (const g
     myDone = Standard_False;
   }
   else {
-#ifdef DEB
-    Standard_Real VMagn = V.Magnitude();
-#else
-    V.Magnitude();
-#endif
     Standard_Real X = V.Dot(gp_Vec2d(E.XAxis().Direction()));
     Standard_Real Y = V.Dot(gp_Vec2d(E.YAxis().Direction()));
 
@@ -195,11 +190,6 @@ void Extrema_ExtPElC2d::Perform(const gp
   Standard_Real R = H.MajorRadius();
   Standard_Real r = H.MinorRadius();
   gp_Vec2d OPp(O,P);
-#ifdef DEB
-  Standard_Real OPpMagn = OPp.Magnitude();
-#else
-  OPp.Magnitude();
-#endif
   Standard_Real Tol2 = Tol * Tol;
   Standard_Real X = OPp.Dot(gp_Vec2d(H.XAxis().Direction()));
   Standard_Real Y = OPp.Dot(gp_Vec2d(H.YAxis().Direction()));
@@ -263,11 +253,6 @@ void Extrema_ExtPElC2d::Perform(const gp
   Standard_Real Tol2 = Tol * Tol;
   Standard_Real F = C.Focal();
   gp_Vec2d OPp (O,P);
-#ifdef DEB
-  Standard_Real OPpMagn = OPp.Magnitude();
-#else
-  OPp.Magnitude();
-#endif
   Standard_Real X = OPp.Dot(gp_Vec2d(C.MirrorAxis().Direction()));
   Standard_Real Y = OPp.Dot(gp_Vec2d(C.Axis().YAxis().Direction()));
 
Index: oce/src/Extrema/Extrema_ExtPElS.cxx
===================================================================
--- oce.orig/src/Extrema/Extrema_ExtPElS.cxx
+++ oce/src/Extrema/Extrema_ExtPElS.cxx
@@ -124,11 +124,6 @@ void Extrema_ExtPElS::Perform(const gp_P
 
   Standard_Real L2 = MP.SquareMagnitude();
   Standard_Real Vm = -(S.RefRadius() / Sin(A));
-#ifdef DEB
-  Standard_Real Zm = gp_Vec(O, M).Dot(OZ);
-#else
-  gp_Vec(O, M).Dot(OZ);
-#endif
 
 // Cas ou P est confondu avec S ...
   if (L2 < Tol * Tol) {
Index: oce/src/Extrema/Extrema_GenExtPS.cxx
===================================================================
--- oce.orig/src/Extrema/Extrema_GenExtPS.cxx
+++ oce/src/Extrema/Extrema_GenExtPS.cxx
@@ -615,7 +615,7 @@ void Extrema_GenExtPS::Perform(const gp_
       Bnd_SphereUBTreeSelectorMin aSelector(mySphereArray, aSol);
       //aSelector.SetMaxDist( RealLast() );
       aSelector.DefineCheckPoint( P );
-      Standard_Integer aNbSel = mySphereUBTree->Select( aSelector );
+      mySphereUBTree->Select( aSelector );
       //TODO: check if no solution in binary tree
       Bnd_Sphere& aSph = aSelector.Sphere();
 
@@ -630,7 +630,7 @@ void Extrema_GenExtPS::Perform(const gp_
       Bnd_SphereUBTreeSelectorMax aSelector(mySphereArray, aSol);
       //aSelector.SetMaxDist( RealLast() );
       aSelector.DefineCheckPoint( P );
-      Standard_Integer aNbSel = mySphereUBTree->Select( aSelector );
+      mySphereUBTree->Select( aSelector );
       //TODO: check if no solution in binary tree
       Bnd_Sphere& aSph = aSelector.Sphere();
 
Index: oce/src/FEmTool/FEmTool_Assembly.cxx
===================================================================
--- oce.orig/src/FEmTool/FEmTool_Assembly.cxx
+++ oce/src/FEmTool/FEmTool_Assembly.cxx
@@ -80,11 +80,7 @@ FEmTool_Assembly::FEmTool_Assembly(const
 
   TColStd_Array1OfInteger FirstIndexes(1, B.Length()); FirstIndexes.Init(B.Length());
 
-#ifdef DEB
-  Standard_Integer dim, el, nvar, Imax, Imin, I0 = 1 - B.Lower(), i;
-#else
   Standard_Integer dim, el, nvar, Imin, I0 = 1 - B.Lower(), i;
-#endif
   Standard_Integer diml = Table->LowerRow(), dimu = Table->UpperRow(),
                    ell = Table->LowerCol(), elu = Table->UpperCol(), nvarl, nvaru;
 
@@ -137,11 +133,7 @@ void FEmTool_Assembly::AddMatrix(const S
 
   Standard_Integer nvarl = T1.Lower(), nvaru = Min(T1.Upper(), nvarl + Mat.RowNumber() - 1);
 
-#ifdef DEB
-  Standard_Integer I, J, I0 = 1 - B.Lower(), i, ii, j, jj, 
-#else
   Standard_Integer I, J, I0 = 1 - B.Lower(), i, ii, j,
-#endif
                    i0 = Mat.LowerRow() - nvarl, j0 = Mat.LowerCol() - nvarl;
 
   for(i = nvarl; i <= nvaru; i++) {
Index: oce/src/GccAna/GccAna_Circ2d2TanOn.cxx
===================================================================
--- oce.orig/src/GccAna/GccAna_Circ2d2TanOn.cxx
+++ oce/src/GccAna/GccAna_Circ2d2TanOn.cxx
@@ -73,11 +73,6 @@ GccAna_Circ2d2TanOn::
   gp_Pnt2d center1(C1.Location());
   gp_Pnt2d center2(C2.Location());
   TColStd_Array1OfReal Radius(1,2);
-#ifdef DEB
-  Standard_Real distance = center1.Distance(center2);
-#else
-  center1.Distance(center2);
-#endif
   Standard_Real dist1 = OnLine.Distance(center1);
   Standard_Real dist2 = OnLine.Distance(center2);
   Standard_Real d1 = dist1+R1;
Index: oce/src/GccAna/GccAna_Circ2d2TanOn_10.cxx
===================================================================
--- oce.orig/src/GccAna/GccAna_Circ2d2TanOn_10.cxx
+++ oce/src/GccAna/GccAna_Circ2d2TanOn_10.cxx
@@ -77,12 +77,6 @@
   gp_Dir2d dir(OnCirc.Location().XY()-Point2.XY());
   gp_Pnt2d pinterm(Point2.XY()+(distpc+Ron)*dir.XY());
   Standard_Real dist1 = L1.Distance(pinterm);
-  if (Abs(dist1-distpc-Ron) > Tol) {
-#ifdef DEB
-    gp_Pnt2d pinterm(Point2.XY()+(distpc-Ron)*dir.XY()); // Unused ! BUG ???
-    Standard_Real dist1 = L1.Distance(pinterm); // Unused ! BUG ???
-#endif
-  }
   if (Abs(dist1-distpc+Ron) <= Tol) {
     dir = gp_Dir2d(-dirL1.Y(),dirL1.X());
     gp_Dir2d direc(originL1.XY()-pinterm.XY());
Index: oce/src/GccAna/GccAna_Circ2d2TanOn_6.cxx
===================================================================
--- oce.orig/src/GccAna/GccAna_Circ2d2TanOn_6.cxx
+++ oce/src/GccAna/GccAna_Circ2d2TanOn_6.cxx
@@ -71,11 +71,6 @@ GccAna_Circ2d2TanOn::
   TColStd_Array1OfReal Rradius(1,2);
   gp_Pnt2d center1(C1.Location());
   gp_Pnt2d center2(C2.Location());
-#ifdef DEB
-  Standard_Real distance = center1.Distance(center2);
-#else
-  center1.Distance(center2);
-#endif
   Standard_Real R1 = C1.Radius();
   Standard_Real R2 = C2.Radius();
 
Index: oce/src/GccAna/GccAna_Circ2d2TanOn_9.cxx
===================================================================
--- oce.orig/src/GccAna/GccAna_Circ2d2TanOn_9.cxx
+++ oce/src/GccAna/GccAna_Circ2d2TanOn_9.cxx
@@ -43,9 +43,6 @@ GccAna_Circ2d2TanOn::
   NbrSol = 0;
   
   gp_Dir2d dirx(1.,0.);
-#ifdef DEB
-  Standard_Real Tol = Abs(Tolerance);
-#endif
   if (!(Qualified1.IsEnclosed() ||
 	Qualified1.IsOutside() || Qualified1.IsUnqualified()) ||
       !(Qualified2.IsEnclosed() ||
Index: oce/src/GccAna/GccAna_Circ2d2TanRad_4.cxx
===================================================================
--- oce.orig/src/GccAna/GccAna_Circ2d2TanRad_4.cxx
+++ oce/src/GccAna/GccAna_Circ2d2TanRad_4.cxx
@@ -53,9 +53,6 @@ GccAna_Circ2d2TanRad::
 {
 
   gp_Dir2d dirx(1.0,0.0);
-#ifdef DEB
-  Standard_Real Tol = Abs(Tolerance);
-#endif
   TColStd_Array1OfReal cote1(1,2);
   TColStd_Array1OfReal cote2(1,2);
   Standard_Integer nbrcote1=0;
Index: oce/src/GccAna/GccAna_Circ2d3Tan_2.cxx
===================================================================
--- oce.orig/src/GccAna/GccAna_Circ2d3Tan_2.cxx
+++ oce/src/GccAna/GccAna_Circ2d3Tan_2.cxx
@@ -106,7 +106,6 @@ pararg3(1,8)
 	       Standard_Real dist2 = L2.Distance(Center);
 	       Standard_Real dist3 = L3.Distance(Center);
 	       Standard_Integer nbsol1 = 0;
-	       Standard_Integer nbsol2 = 0;
 	       Standard_Integer nbsol3 = 0;
 	       Standard_Boolean ok = Standard_False;
 	       if (Qualified1.IsEnclosed()) {
@@ -140,7 +139,6 @@ pararg3(1,8)
 		   for (Standard_Integer ii = 1 ; ii <= nbsol1 ; ii++) {
 		     if (Abs(dist2-Radius(ii)) < Tol) { 
 		       ok = Standard_True;
-		       nbsol2 = 1;
 		       Radius(1) = Radius(ii);
 		     }
 		   }
@@ -152,7 +150,6 @@ pararg3(1,8)
 		   for (Standard_Integer ii = 1 ; ii <= nbsol1 ; ii++) {
 		     if (Abs(dist2-Radius(ii)) < Tol) { 
 		       ok = Standard_True;
-		       nbsol2 = 1;
 		       Radius(1) = Radius(ii);
 		     }
 		   }
@@ -162,7 +159,6 @@ pararg3(1,8)
 		 for (Standard_Integer ii = 1 ; ii <= nbsol1 ; ii++) {
 		   if (Abs(dist2-Radius(ii)) < Tol) { 
 		     ok = Standard_True;
-		     nbsol2 = 1;
 		     Radius(1) = Radius(ii);
 		   }
 		 }
Index: oce/src/GccAna/GccAna_Circ2d3Tan_3.cxx
===================================================================
--- oce.orig/src/GccAna/GccAna_Circ2d3Tan_3.cxx
+++ oce/src/GccAna/GccAna_Circ2d3Tan_3.cxx
@@ -57,9 +57,6 @@ GccAna_Circ2d3Tan::
    TheSame2.Init(0);
    TheSame3.Init(0);
    gp_Dir2d dirx(1.0,0.0);
-#ifdef DEB
-   Standard_Real Tol = Abs(Tolerance);
-#endif
    WellDone = Standard_False;
    NbrSol = 0;
    if (!(Qualified1.IsEnclosed() ||
Index: oce/src/GccAna/GccAna_Circ2d3Tan_5.cxx
===================================================================
--- oce.orig/src/GccAna/GccAna_Circ2d3Tan_5.cxx
+++ oce/src/GccAna/GccAna_Circ2d3Tan_5.cxx
@@ -110,7 +110,6 @@ GccAna_Circ2d3Tan::
 	     Standard_Real dist2 = L2.Distance(Center);
 	     Standard_Real dist3 = Center.Distance(Point3);
 	     Standard_Integer nbsol1 = 0;
-	     Standard_Integer nbsol2 = 0;
 	     Standard_Integer nbsol3 = 0;
 	     Standard_Boolean ok = Standard_False;
 	     if (Qualified1.IsEnclosed()) {
@@ -144,7 +143,6 @@ GccAna_Circ2d3Tan::
 		 for (Standard_Integer ii = 1 ; ii <= nbsol1 ; ii++) {
 		   if (Abs(dist2-Radius(ii)) < Tol) { 
 		     ok = Standard_True;
-		     nbsol2 = 1;
 		     Radius(1) = Radius(ii);
 		   }
 		 }
@@ -156,7 +154,6 @@ GccAna_Circ2d3Tan::
 		 for (Standard_Integer ii = 1 ; ii <= nbsol1 ; ii++) {
 		   if (Abs(dist2-Radius(ii)) < Tol) { 
 		     ok = Standard_True;
-		     nbsol2 = 1;
 		     Radius(1) = Radius(ii);
 		   }
 		 }
@@ -166,7 +163,6 @@ GccAna_Circ2d3Tan::
 	       for (Standard_Integer ii = 1 ; ii <= nbsol1 ; ii++) {
 		 if (Abs(dist2-Radius(ii)) < Tol) { 
 		   ok = Standard_True;
-		   nbsol2 = 1;
 		   Radius(1) = Radius(ii);
 		 }
 	       }
Index: oce/src/GccAna/GccAna_Circ2d3Tan_6.cxx
===================================================================
--- oce.orig/src/GccAna/GccAna_Circ2d3Tan_6.cxx
+++ oce/src/GccAna/GccAna_Circ2d3Tan_6.cxx
@@ -98,15 +98,12 @@ GccAna_Circ2d3Tan::
 	     Standard_Real dist2 = L2.Distance(Center);
 	     Standard_Real dist3 = Center.Distance(Point3);
 	     Standard_Real Radius=0;
-	     Standard_Integer nbsol1 = 0;
-	     Standard_Integer nbsol2 = 0;
 	     Standard_Integer nbsol3 = 0;
 	     Standard_Boolean ok = Standard_False;
 	     if (Qualified1.IsEnclosed()) {
 	       if ((((origin1.X()-Center.X())*(-dir1.Y()))+
 		    ((origin1.Y()-Center.Y())*(dir1.X())))<=0){
 		 ok = Standard_True;
-		 nbsol1 = 1;
 		 Radius = dist1;
 	       }
 	     }
@@ -114,31 +111,29 @@ GccAna_Circ2d3Tan::
 	       if ((((origin1.X()-Center.X())*(-dir1.Y()))+
 		    ((origin1.Y()-Center.Y())*(dir1.X())))>=0){
 		 ok = Standard_True;
-		 nbsol1 = 1;
 		 Radius = dist1;
 	       }
 	     }
 	     else if (Qualified1.IsUnqualified()) {
 	       ok = Standard_True;
-	       nbsol1 = 1;
 	       Radius = dist1;
 	     }
 	     if (Qualified2.IsEnclosed()) {
 	       if ((((origin2.X()-Center.X())*(-dir2.Y()))+
 		    ((origin2.Y()-Center.Y())*(dir2.X())))<=0){
-		 if (Abs(dist2-Radius) < Tol) { nbsol2 = 1; }
+		 if (Abs(dist2-Radius) < Tol) { }
 		 else { ok = Standard_False; }
 	       }
 	     }
 	     else if (Qualified2.IsOutside() && ok) {
 	       if ((((origin2.X()-Center.X())*(-dir2.Y()))+
 		    ((origin2.Y()-Center.Y())*(dir2.X())))>=0){
-		 if (Abs(dist2-Radius) < Tol) { nbsol2 = 1; }
+		 if (Abs(dist2-Radius) < Tol) { }
 		 else { ok = Standard_False; }
 	       }
 	     }
 	     else if (Qualified2.IsUnqualified() && ok) {
-	       if (Abs(dist2-Radius) < Tol) { nbsol2 = 1; }
+	       if (Abs(dist2-Radius) < Tol) { }
 	       else { ok = Standard_False; }
 	     }
 	     if (ok) {
Index: oce/src/GccAna/GccAna_Circ2d3Tan_8.cxx
===================================================================
--- oce.orig/src/GccAna/GccAna_Circ2d3Tan_8.cxx
+++ oce/src/GccAna/GccAna_Circ2d3Tan_8.cxx
@@ -95,13 +95,7 @@ GccAna_Circ2d3Tan::
 	   gp_Pnt2d Center(Intp.Point(j).Value());
 	   Standard_Real dist1 = L1.Distance(Center);
 	   Standard_Real dist2 = Center.Distance(Point2);
-#ifdef DEB
-	   Standard_Real dist3 = Center.Distance(Point3);
-#else
-           Center.Distance(Point3);
-#endif
 	   Standard_Real Radius=0;
-	   Standard_Integer nbsol1 = 0;
 //	   Standard_Integer nbsol2 = 0;
 	   Standard_Integer nbsol3 = 0;
 	   Standard_Boolean ok = Standard_False;
@@ -109,7 +103,6 @@ GccAna_Circ2d3Tan::
 	     if ((((origin1.X()-Center.X())*(-dir1.Y()))+
 		  ((origin1.Y()-Center.Y())*(dir1.X())))<=0){
 	       ok = Standard_True;
-	       nbsol1 = 1;
 	       Radius = dist1;
 	     }
 	   }
@@ -117,13 +110,11 @@ GccAna_Circ2d3Tan::
 	     if ((((origin1.X()-Center.X())*(-dir1.Y()))+
 		  ((origin1.Y()-Center.Y())*(dir1.X())))>=0){
 	       ok = Standard_True;
-	       nbsol1 = 1;
 	       Radius = dist1;
 	     }
 	   }
 	   else if (Qualified1.IsUnqualified()) {
 	     ok = Standard_True;
-	     nbsol1 = 1;
 	     Radius = dist1;
 	   }
 	   if (ok) {
Index: oce/src/GccAna/GccAna_Circ2dTanOnRad.cxx
===================================================================
--- oce.orig/src/GccAna/GccAna_Circ2dTanOnRad.cxx
+++ oce/src/GccAna/GccAna_Circ2dTanOnRad.cxx
@@ -84,7 +84,6 @@ GccAna_Circ2dTanOnRad::
      gp_Pnt2d center1(C1.Location());
      Standard_Real x1 = center1.X();
      Standard_Real y1 = center1.Y();
-     Standard_Real xbid = 0.;
      if (Qualified1.IsEnclosed()) {
 //   ============================
        if (Tol < Radius-R1+dist) { WellDone = Standard_True; }
@@ -184,7 +183,6 @@ GccAna_Circ2dTanOnRad::
 	 if ( Abs(D) <= Tol ) {
 	   A = B;
 	   B = D;
-	   xbid = x1;
 	   x0 = y1;
 	   y0 = x1;
 	 }
Index: oce/src/GccAna/GccAna_Circ2dTanOnRad_1.cxx
===================================================================
--- oce.orig/src/GccAna/GccAna_Circ2dTanOnRad_1.cxx
+++ oce/src/GccAna/GccAna_Circ2dTanOnRad_1.cxx
@@ -96,11 +96,6 @@ GccAna_Circ2dTanOnRad::
              cirsol(NbrSol)=gp_Circ2d(gp_Ax2d(Center,dirx),Radius);
 //           =====================================================
 	     gp_Dir2d dc1(origin1.XY()-Center.XY());
-#ifdef DEB
-	     Standard_Real sign = dc1.Dot(normL1);
-#else
-             dc1.Dot(normL1);
-#endif
 	     if (!Qualified1.IsUnqualified()) { 
 	       qualifier1(NbrSol) = Qualified1.Qualifier();
 	     }
Index: oce/src/GccAna/GccAna_Lin2dTanPer.cxx
===================================================================
--- oce.orig/src/GccAna/GccAna_Lin2dTanPer.cxx
+++ oce/src/GccAna/GccAna_Lin2dTanPer.cxx
@@ -196,7 +196,6 @@ GccAna_Lin2dTanPer::
 
    WellDone = Standard_False;
    NbrSol = 0;
-   Standard_Integer nbsol = 0;
    Standard_Integer signe = 0;
    gp_Circ2d C1 = Qualified1.Qualified();
 
@@ -206,19 +205,16 @@ GccAna_Lin2dTanPer::
    }
    else if (Qualified1.IsEnclosing()) {
 // ==================================
-     nbsol = 1;
      signe = -1;
      qualifier1(1) = GccEnt_enclosing;
    }
    else if (Qualified1.IsOutside()) {
 // ================================
-     nbsol = 1;
      signe = 1;
      qualifier1(1) = GccEnt_outside;
    }
    else if (Qualified1.IsUnqualified()) {
 // ====================================
-     nbsol = 2;
      signe = -1;
      qualifier1(1) = GccEnt_enclosing;
      qualifier1(2) = GccEnt_outside;
Index: oce/src/Geom/Geom_BSplineSurface.cxx
===================================================================
--- oce.orig/src/Geom/Geom_BSplineSurface.cxx
+++ oce/src/Geom/Geom_BSplineSurface.cxx
@@ -1071,15 +1071,12 @@ void Geom_BSplineSurface::SetUKnots (con
       Upper < 1 || Upper > uknots->Length() ) {
     Standard_OutOfRange::Raise();
   }
-  Standard_Real Eps;
   if (Lower > 1) {
-    Eps = Abs (Epsilon (uknots->Value (Lower-1)));
     if (Abs (UK (Lower) - uknots->Value (Lower-1)) <= gp::Resolution()) {
       Standard_ConstructionError::Raise();
     }
   }
   if (Upper < uknots->Length ()) {
-    Eps = Abs (Epsilon (uknots->Value (Upper+1)));
     if (Abs (UK (Upper) - uknots->Value (Upper+1)) <= gp::Resolution()) {
       Standard_ConstructionError::Raise();
     }
@@ -1088,7 +1085,6 @@ void Geom_BSplineSurface::SetUKnots (con
   for (Standard_Integer i = Lower; i <= Upper; i++) {
     uknots->SetValue (i, UK(i));
     if (i != Lower) {
-      Eps = Abs (Epsilon (K1));
       if (Abs (UK(i) - K1) <= gp::Resolution()) {
         Standard_ConstructionError::Raise();
       }
@@ -1160,15 +1156,12 @@ void Geom_BSplineSurface::SetVKnots (con
       Upper < 1 || Upper > vknots->Length() ) {
     Standard_OutOfRange::Raise();
   }
-  Standard_Real Eps;
   if (Lower > 1) {
-    Eps = Abs (Epsilon (vknots->Value (Lower-1)));
     if (Abs (VK (Lower) - vknots->Value (Lower-1)) <= gp::Resolution()) {
       Standard_ConstructionError::Raise();
     }
   }
   if (Upper < vknots->Length ()) {
-    Eps = Abs (Epsilon (vknots->Value (Upper+1)));
     if (Abs (VK (Upper) - vknots->Value (Upper+1)) <= gp::Resolution()) {
       Standard_ConstructionError::Raise();
     }
@@ -1177,7 +1170,6 @@ void Geom_BSplineSurface::SetVKnots (con
   for (Standard_Integer i = Lower; i <= Upper; i++) {
     vknots->SetValue (i, VK(i));
     if (i != Lower) {
-      Eps = Abs (Epsilon (K1));
       if (Abs (VK(i) - K1) <= gp::Resolution()) {
         Standard_ConstructionError::Raise();
       }
Index: oce/src/Geom/Geom_CylindricalSurface.cxx
===================================================================
--- oce.orig/src/Geom/Geom_CylindricalSurface.cxx
+++ oce/src/Geom/Geom_CylindricalSurface.cxx
@@ -191,17 +191,6 @@ void Geom_CylindricalSurface::Coefficien
   Standard_Real T22 = T.Value (2, 2);
   Standard_Real T23 = T.Value (2, 3);
   Standard_Real T24 = T.Value (2, 4);
-#ifdef DEB
-  Standard_Real T31 = T.Value (3, 1);
-  Standard_Real T32 = T.Value (3, 2);
-  Standard_Real T33 = T.Value (3, 3);
-  Standard_Real T34 = T.Value (3, 4);
-#else
-  T.Value (3, 1);
-  T.Value (3, 2);
-  T.Value (3, 3);
-  T.Value (3, 4);
-#endif
   A1 = T11 * T11 + T21 * T21;
   A2 = T12 * T12 + T22 * T22;
   A3 = T13 * T13 + T23 * T23;
Index: oce/src/Geom/Geom_OffsetCurve.cxx
===================================================================
--- oce.orig/src/Geom/Geom_OffsetCurve.cxx
+++ oce/src/Geom/Geom_OffsetCurve.cxx
@@ -529,12 +529,6 @@ void Geom_OffsetCurve::D1 ( const Standa
 
    // P'(u) = p'(u) + (Offset / R**2) * (DNdir/DU * R -  Ndir * (DR/R))
 
-
-#ifdef DEB
-  GeomAbs_Shape Continuity = basisCurve->Continuity();
-#else
-  basisCurve->Continuity();
-#endif
   basisCurve->D2 (U, PBasis, V1basis, V2basis);
   V1 = V1basis;
   Vec V2 = V2basis;
@@ -590,12 +584,6 @@ void Geom_OffsetCurve::D2 (const Standar
    // P"(u) = p"(u) + (Offset / R) * (D2Ndir/DU - DNdir * (2.0 * Dr/ R**2) +
    //         Ndir * ( (3.0 * Dr**2 / R**4) - (D2r / R**2)))
 
-#ifdef DEB
-  GeomAbs_Shape Continuity = basisCurve->Continuity();
-#else
-  basisCurve->Continuity();
-#endif
-
   basisCurve->D3 (U, PBasis, V1basis, V2basis, V3basis);
   Standard_Integer Index = 2;
   V1     = V1basis;
Index: oce/src/Geom2d/Geom2d_OffsetCurve.cxx
===================================================================
--- oce.orig/src/Geom2d/Geom2d_OffsetCurve.cxx
+++ oce/src/Geom2d/Geom2d_OffsetCurve.cxx
@@ -191,12 +191,6 @@ void Geom2d_OffsetCurve::D1 (const Stand
 
    // P'(u) = p'(u) + (Offset / R**2) * (DNdir/DU * R -  Ndir * (DR/R))
 
-
-#ifdef DEB
-  GeomAbs_Shape Continuity = basisCurve->Continuity();
-#else
-  basisCurve->Continuity();
-#endif
   Vec2d V2;
   basisCurve->D2 (U, P, V1, V2);
   Standard_Integer Index = 2;
@@ -248,11 +242,6 @@ void Geom2d_OffsetCurve::D2 (const Stand
    // P"(u) = p"(u) + (Offset / R) * (D2Ndir/DU - DNdir * (2.0 * Dr/ R**2) +
    //         Ndir * ( (3.0 * Dr**2 / R**4) - (D2r / R**2)))
 
-#ifdef DEB
-  GeomAbs_Shape Continuity = basisCurve->Continuity();
-#else
-  basisCurve->Continuity();
-#endif
   Vec2d V3;
   basisCurve->D3 (U, P, V1, V2, V3);
   Standard_Integer Index = 2;
@@ -483,12 +472,6 @@ void Geom2d_OffsetCurve::D1 (const Stand
 
    // P'(u) = p'(u) + (Offset / R**2) * (DNdir/DU * R -  Ndir * (DR/R))
 
-#ifdef DEB
-   GeomAbs_Shape Continuity = basisCurve->Continuity();
-#else
-   basisCurve->Continuity();
-#endif
-
    basisCurve->D2 (U, Pbasis, V1basis, V2basis);
    V1 = V1basis;
    Vec2d V2 = V2basis;
@@ -546,12 +529,6 @@ void Geom2d_OffsetCurve::D2 (const Stand
    // P"(u) = p"(u) + (Offset / R) * (D2Ndir/DU - DNdir * (2.0 * Dr/ R**2) +
    //         Ndir * ( (3.0 * Dr**2 / R**4) - (D2r / R**2)))
 
-#ifdef DEB
-  GeomAbs_Shape Continuity = basisCurve->Continuity();
-#else
-  basisCurve->Continuity();
-#endif
-
   basisCurve->D3 (U, Pbasis, V1basis, V2basis, V3basis);
   Standard_Integer Index = 2;
   V1 = V1basis;
Index: oce/src/Geom2dConvert/Geom2dConvert.cxx
===================================================================
--- oce.orig/src/Geom2dConvert/Geom2dConvert.cxx
+++ oce/src/Geom2dConvert/Geom2dConvert.cxx
@@ -1107,9 +1107,8 @@ void  Geom2dConvert::ConcatG1(TColGeom2d
        Standard_ConstructionError::Raise("Geom2dConvert Concatenation Error") ;
      Curve2=C.BSplineCurve();
    }
-   Standard_Boolean   rm;
    Curve2->SetPeriodic();      //1 seule courbe C1
-   rm=Curve2->RemoveKnot(Curve2->LastUKnotIndex(),
+   Curve2->RemoveKnot(Curve2->LastUKnotIndex(),
 			 Curve2->Multiplicity(Curve2->LastUKnotIndex())-1,
 			 Precision::Confusion());
    ArrayOfConcatenated->SetValue(0,Curve2);
@@ -1347,9 +1346,8 @@ void  Geom2dConvert::ConcatC1(TColGeom2d
        Curve2=C.BSplineCurve();
      }
    }
-   Standard_Boolean   rm;
    Curve2->SetPeriodic();      //1 seule courbe C1
-   rm=Curve2->RemoveKnot(Curve2->LastUKnotIndex(),
+   Curve2->RemoveKnot(Curve2->LastUKnotIndex(),
 			 Curve2->Multiplicity(Curve2->LastUKnotIndex())-1,
 			 Precision::Confusion());
    ArrayOfConcatenated->SetValue(0,Curve2);
Index: oce/src/GeomConvert/GeomConvert.cxx
===================================================================
--- oce.orig/src/GeomConvert/GeomConvert.cxx
+++ oce/src/GeomConvert/GeomConvert.cxx
@@ -915,9 +915,8 @@ static void reparameterise_evaluator(
        Standard_ConstructionError::Raise("GeomConvert Concatenation Error") ;
      Curve2=C.BSplineCurve();
    }
-   Standard_Boolean   rm;
    Curve2->SetPeriodic();      
-   rm=Curve2->RemoveKnot(Curve2->LastUKnotIndex(),
+   Curve2->RemoveKnot(Curve2->LastUKnotIndex(),
 			 Curve2->Multiplicity(Curve2->LastUKnotIndex())-1,
 			 Precision::Confusion());
    ArrayOfConcatenated->SetValue(0,Curve2);
@@ -1151,9 +1150,8 @@ void  GeomConvert::ConcatC1(TColGeom_Arr
        Curve2=C.BSplineCurve();
      }
    }
-   Standard_Boolean   rm;
    Curve2->SetPeriodic();                               //only one C1 curve
-   rm=Curve2->RemoveKnot(Curve2->LastUKnotIndex(),
+   Curve2->RemoveKnot(Curve2->LastUKnotIndex(),
 			 Curve2->Multiplicity(Curve2->LastUKnotIndex())-1,
 			 Precision::Confusion());
    ArrayOfConcatenated->SetValue(0,Curve2);
Index: oce/src/GeomConvert/GeomConvert_1.cxx
===================================================================
--- oce.orig/src/GeomConvert/GeomConvert_1.cxx
+++ oce/src/GeomConvert/GeomConvert_1.cxx
@@ -752,10 +752,8 @@ Handle(BSplineSurface) GeomConvert::Spli
       Weights.Init(1.);
       if ( C->IsRational()) C->Weights(Weights);
 
-      Standard_Integer nbUSpans;
       Standard_Real AlfaU;
       NbUKnots = 4;
-      nbUSpans = 3;
       AlfaU    = PI / 3.;
       NbUPoles = 6;
 
Index: oce/src/GeomFill/GeomFill_ConstrainedFilling.cxx
===================================================================
--- oce.orig/src/GeomFill/GeomFill_ConstrainedFilling.cxx
+++ oce/src/GeomFill/GeomFill_ConstrainedFilling.cxx
@@ -1410,8 +1410,10 @@ void GeomFill_ConstrainedFilling::CheckR
   }
   gp_Pnt pbound[31],pres[31];
   gp_Vec vbound[31],vres[31];
+#ifdef DRAW
   Standard_Real ang[31];
   Standard_Boolean hasang[31];
+#endif
   Handle(GeomFill_Boundary) bou = ptch->Bound(I);
   Standard_Integer k ;
   for ( k = 0; k <= 30; k++){
@@ -1426,10 +1428,14 @@ void GeomFill_ConstrainedFilling::CheckR
 	Standard_Real alpha = Abs(vres[k].Angle(vbound[k]));
 	alpha = Min(alpha,Abs(PI-alpha));
 	if(alpha > maxang) maxang = alpha;
+#ifdef DRAW
 	ang[k] = alpha;
 	hasang[k] = 1;
+#endif
       }
+#ifdef DRAW
       else hasang[k] = 0;
+#endif
     }
     if(pres[k].Distance(pbound[k]) > maxdist) maxdist = pres[k].Distance(pbound[k]);
     uu += duu;
Index: oce/src/GeomFill/GeomFill_CorrectedFrenet.cxx
===================================================================
--- oce.orig/src/GeomFill/GeomFill_CorrectedFrenet.cxx
+++ oce/src/GeomFill/GeomFill_CorrectedFrenet.cxx
@@ -592,10 +592,6 @@ Standard_Real GeomFill_CorrectedFrenet::
     };
     if(HArrPoles->Value(iC) == Param || Param == HArrPoles->Value(iC+1)) return TLaw->Value(Param);
   };
-#ifdef DEB
-  Standard_Real Po = 
-#endif
-    HArrPoles->Value(iC);
   //  Calculate differenciation between apporoximated and local values of AngleAT
   Standard_Real AngP = TLaw->Value(Param), AngPo = HArrAngle->Value(iC), dAng = AngP - AngPo;
   gp_Vec Tangent, Normal, BN;
Index: oce/src/GeomFill/GeomFill_Curved.cxx
===================================================================
--- oce.orig/src/GeomFill/GeomFill_Curved.cxx
+++ oce/src/GeomFill/GeomFill_Curved.cxx
@@ -268,10 +268,6 @@ void  GeomFill_Curved::Init(const TColgp
   
   IsRational = Standard_False;
   
-#ifdef DEB
-  Standard_Real NU = NPolU - 1;
-  Standard_Real NV = NPolV - 1;
-#endif
   myPoles = new TColgp_HArray2OfPnt( 1, NPolU, 1, NPolV);
   
   Standard_Integer i,j;
Index: oce/src/GeomFill/GeomFill_DraftTrihedron.cxx
===================================================================
--- oce.orig/src/GeomFill/GeomFill_DraftTrihedron.cxx
+++ oce/src/GeomFill/GeomFill_DraftTrihedron.cxx
@@ -17,11 +17,6 @@
 static gp_Vec DDeriv(const gp_Vec& F, const gp_Vec& DF, const gp_Vec& D2F)
 {
   Standard_Real Norma = F.Magnitude();
-#ifdef DEB
-  Standard_Real dot = F.Dot(DF);
-#else
-  F.Dot(DF);
-#endif
   gp_Vec Result = (D2F - 2*DF*(F*DF)/(Norma*Norma))/Norma - 
      F*((DF.SquareMagnitude() + F*D2F 
         - 3*(F*DF)*(F*DF)/(Norma*Norma))/(Norma*Norma*Norma));
Index: oce/src/GeomFill/GeomFill_EvolvedSection.cxx
===================================================================
--- oce.orig/src/GeomFill/GeomFill_EvolvedSection.cxx
+++ oce/src/GeomFill/GeomFill_EvolvedSection.cxx
@@ -31,7 +31,6 @@ static Standard_Boolean Affich = 0;
 GeomFill_EvolvedSection::GeomFill_EvolvedSection(const Handle(Geom_Curve)& C,
 						 const Handle(Law_Function)& L)
 {
-  Standard_Boolean Bof;
   L->Bounds(First, Last);
   mySection = Handle(Geom_Curve)::DownCast(C->Copy());
   myLaw =  L->Trim(First, Last, 1.e-20);
@@ -41,7 +40,7 @@ GeomFill_EvolvedSection::GeomFill_Evolve
     myCurve = GeomConvert::CurveToBSplineCurve(C, Convert_QuasiAngular);
     if (myCurve->IsPeriodic()) {
       Standard_Integer M = myCurve->Degree()/2+1;
-      Bof = myCurve->RemoveKnot(1, M, Precision::Confusion());
+      myCurve->RemoveKnot(1, M, Precision::Confusion());
     }
   }
 
Index: oce/src/GeomFill/GeomFill_GuideTrihedronAC.cxx
===================================================================
--- oce.orig/src/GeomFill/GeomFill_GuideTrihedronAC.cxx
+++ oce/src/GeomFill/GeomFill_GuideTrihedronAC.cxx
@@ -182,11 +182,6 @@
 
   gp_Vec n(P, PG); // vecteur definissant la normale
   Standard_Real Norm = n.Magnitude(), ndn;
-#ifdef DEB
-  Standard_Real Norm2 = n.SquareMagnitude();
-#else
-  n.SquareMagnitude();
-#endif
   //derivee de n par rapport a Param
   gp_Vec dn, d2n;
   dn.SetLinearForm(dtg_dt, TG, -1, To);
@@ -236,11 +231,7 @@
 
 
 //derivee seconde du triedre
-#ifdef DEB
-  gp_Vec DTDN = DTo.Crossed(DNormal);
-#else
   DTo.Crossed(DNormal);
-#endif
   Standard_Real TN2 = TN.SquareMagnitude();
 
   D2Normal.SetLinearForm(-2*ndn, dn, 
Index: oce/src/GeomFill/GeomFill_LocationGuide.cxx
===================================================================
--- oce.orig/src/GeomFill/GeomFill_LocationGuide.cxx
+++ oce/src/GeomFill/GeomFill_LocationGuide.cxx
@@ -67,11 +67,10 @@ static void TraceRevol(const Standard_Re
 {
   gp_Vec T, N, B;
   gp_Pnt P;
-  Standard_Boolean Ok;
   gp_Ax3 Rep(gp::Origin(), gp::DZ(), gp::DX());
 
   Curve->D0(t, P);
-  Ok = Law->D0(t, T, N, B);
+  Law->D0(t, T, N, B);
 
   gp_Mat M(N.XYZ(), B.XYZ(), T.XYZ());
   M *= Trans;
@@ -629,12 +628,6 @@ static void InGoodPeriod(const Standard_
   gp_Vec T, N, B;
   gp_Pnt P;
   Standard_Boolean Ok;
-#ifdef DEB
-  Standard_Real U = myFirstS + ratio*(Param-myCurve->FirstParameter());
-#else
-  myCurve->FirstParameter() ;
-#endif
-    
 
   myCurve->D0(Param, P);
   V.SetXYZ(P.XYZ());
@@ -739,12 +732,6 @@ static void InGoodPeriod(const Standard_
   if (rotation) {  
     return Standard_False;
     
-#ifdef DEB
-    Standard_Real U = myFirstS + ratio*(Param-myCurve->FirstParameter());
-#else
-    myCurve->FirstParameter() ;
-#endif
-      
     // initialisation du germe 
     InitX(Param);      
     
Index: oce/src/GeomFill/GeomFill_Pipe.cxx
===================================================================
--- oce.orig/src/GeomFill/GeomFill_Pipe.cxx
+++ oce/src/GeomFill/GeomFill_Pipe.cxx
@@ -602,13 +602,11 @@ void GeomFill_Pipe::Init(const Handle(Ge
     new Adaptor3d_HCurveOnSurface(Adaptor3d_CurveOnSurface(
 		       new Geom2dAdaptor_HCurve(Path), 
 		       new GeomAdaptor_HSurface(Support)));
-  Standard_Real param =  Path->FirstParameter();
  
   myLoc = new (GeomFill_CurveAndTrihedron) (TLaw);
   myLoc->SetCurve(myAdpPath);
   GeomFill_SectionPlacement Place(myLoc, FirstSect);
   Place.Perform(myAdpPath, Precision::Confusion());
-  param =  Place.ParameterOnPath();
   Sect = Place.Section(Standard_False);
   
 #ifdef DRAW
@@ -638,7 +636,6 @@ void GeomFill_Pipe::Init(const Handle(Ge
   Handle(Geom_Curve) Sect;
   myAdpPath = new (GeomAdaptor_HCurve) 
     (Handle(Geom_Curve)::DownCast(Path->Copy()));
-  Standard_Real param =  Path->FirstParameter();
   gp_Vec V;
   V.SetXYZ(Direction.XYZ());
   Handle (GeomFill_ConstantBiNormal) TLaw = 
@@ -648,7 +645,6 @@ void GeomFill_Pipe::Init(const Handle(Ge
   myLoc->SetCurve(myAdpPath);
   GeomFill_SectionPlacement Place(myLoc, FirstSect);
   Place.Perform(Precision::Confusion());
-  param =  Place.ParameterOnPath();
   Sect = Place.Section(Standard_False);
 
 #ifdef DRAW
Index: oce/src/GeomFill/GeomFill_PolynomialConvertor.cxx
===================================================================
--- oce.orig/src/GeomFill/GeomFill_PolynomialConvertor.cxx
+++ oce/src/GeomFill/GeomFill_PolynomialConvertor.cxx
@@ -110,11 +110,6 @@ void GeomFill_PolynomialConvertor::Secti
   gp_Mat M(V1.X(), V2.X(), 0, 
 	   V1.Y(), V2.Y(), 0,
 	   V1.Z(), V2.Z(), 0);
-#ifdef DEB
-  Standard_Real r = FirstPnt.Distance(Center); 	 
-#else
-  FirstPnt.Distance(Center);
-#endif
 
   // Calcul des contraintes  -----------
   Vx(1) = 1;                   Vy(1) = 0;
Index: oce/src/GeomFill/GeomFill_QuasiAngularConvertor.cxx
===================================================================
--- oce.orig/src/GeomFill/GeomFill_QuasiAngularConvertor.cxx
+++ oce/src/GeomFill/GeomFill_QuasiAngularConvertor.cxx
@@ -131,11 +131,6 @@ void GeomFill_QuasiAngularConvertor::Sec
   gp_Mat M(V1.X(), V2.X(), 0, 
 	   V1.Y(), V2.Y(), 0,
 	   V1.Z(), V2.Z(), 0);
-#ifdef DEB
-  Standard_Real r = FirstPnt.Distance(Center);
-#else
-  FirstPnt.Distance(Center);
-#endif
 
   // Calcul des coeffs  -----------
   beta = Angle/4;
Index: oce/src/GeomFill/GeomFill_Sweep.cxx
===================================================================
--- oce.orig/src/GeomFill/GeomFill_Sweep.cxx
+++ oce/src/GeomFill/GeomFill_Sweep.cxx
@@ -241,8 +241,6 @@ GeomFill_Sweep::GeomFill_Sweep(const Han
 					   const Standard_Integer Segmax) 
 {
   Standard_Boolean Ok = Standard_False;
-  Standard_Integer nbsegmax = Segmax, nbspan = myLoc->NbIntervals(GeomAbs_C1);
-  if (Segmax < nbspan)  nbsegmax = nbspan;
 
   Handle(GeomFill_SweepFunction) Func 
     = new (GeomFill_SweepFunction) (mySec, myLoc, First, SFirst,
Index: oce/src/GeomFill/GeomFill_SweepSectionGenerator.cxx
===================================================================
--- oce.orig/src/GeomFill/GeomFill_SweepSectionGenerator.cxx
+++ oce/src/GeomFill/GeomFill_SweepSectionGenerator.cxx
@@ -27,8 +27,7 @@
 
 #ifdef DRAW
 #include <DrawTrSurf.hxx>
-#endif
-#ifdef DEB
+
 static Standard_Boolean Affich     = Standard_False;
 static Standard_Integer NbSECTIONS = 0;
 #endif
@@ -256,11 +255,6 @@ void GeomFill_SweepSectionGenerator::Per
   myPolynomial = Polynomial;
 
   // eval myNbSections.
-#ifdef DEB
-  Standard_Integer Deg = myPath->Degree();
-#else
-  myPath->Degree();
-#endif
   Standard_Integer NSpans = myPath->NbKnots()-1;
 
   myNbSections = 21 * NSpans;
Index: oce/src/GeomFill/GeomFill_TgtOnCoons.cxx
===================================================================
--- oce.orig/src/GeomFill/GeomFill_TgtOnCoons.cxx
+++ oce/src/GeomFill/GeomFill_TgtOnCoons.cxx
@@ -109,11 +109,7 @@ gp_Vec GeomFill_TgtOnCoons::D1(const Sta
 
   Standard_Real scal = tgsc.Dot(n);
   gp_Vec scaln = n.Multiplied(-scal);
-#ifdef DEB
-  gp_Vec tpur = tgsc.Added(scaln);
-#else
   tgsc.Added(scaln);
-#endif
 
   gp_Vec scaldn = dn.Multiplied(-scal);
 
Index: oce/src/GeomFill/GeomFill_UniformSection.cxx
===================================================================
--- oce.orig/src/GeomFill/GeomFill_UniformSection.cxx
+++ oce/src/GeomFill/GeomFill_UniformSection.cxx
@@ -38,9 +38,8 @@ GeomFill_UniformSection::GeomFill_Unifor
  if (myCurve.IsNull()) {
    myCurve = GeomConvert::CurveToBSplineCurve(C, Convert_QuasiAngular);
    if (myCurve->IsPeriodic()) {
-     Standard_Boolean B;
      Standard_Integer M = myCurve->Degree()/2+1;
-     B = myCurve->RemoveKnot(1, M, Precision::Confusion());
+     myCurve->RemoveKnot(1, M, Precision::Confusion());
    }
  }
 
Index: oce/src/GeomInt/GeomInt_IntSS_1.cxx
===================================================================
--- oce.orig/src/GeomInt/GeomInt_IntSS_1.cxx
+++ oce/src/GeomInt/GeomInt_IntSS_1.cxx
@@ -391,10 +391,9 @@ Standard_Real ProjectPointOnSurf::LowerD
 	(Handle(IntPatch_GLine)::DownCast(L)->Ellipse());
     }
     //
-    Standard_Real aPeriod, aNul, aRealEpsilon;
+    Standard_Real aPeriod, aRealEpsilon;
     //
     aRealEpsilon=RealEpsilon();
-    aNul=0.;
     aPeriod=PI+PI;
     //
     aNbParts=myLConstruct.NbParts();
Index: oce/src/GeomPlate/GeomPlate_BuildPlateSurface.cxx
===================================================================
--- oce.orig/src/GeomPlate/GeomPlate_BuildPlateSurface.cxx
+++ oce/src/GeomPlate/GeomPlate_BuildPlateSurface.cxx
@@ -60,7 +60,9 @@
 // pour mes tests
 #ifdef DEB
 #include <OSD_Chronometer.hxx>
+#endif
 
+#ifdef DRAW
 static Standard_Integer Affich=0;
 // 0 : Pas de display
 // 1 : Display des Geometries et controle intermediaire
@@ -2353,11 +2355,6 @@ VerifSurface(const Standard_Integer NbBo
 	new TColStd_HArray1OfReal(1,NbPts_i-1);
       Handle(TColStd_HArray1OfReal) tcourb = 
 	new TColStd_HArray1OfReal(1,NbPts_i-1);
-#ifdef DEB
-      Standard_Integer Cont_i=myLinCont->Value(i)->Order();
-#else
-      myLinCont->Value(i)->Order();
-#endif
 
       EcartContraintesMil (i,tdist,tang,tcourb);
 
Index: oce/src/GeomPlate/GeomPlate_PlateG0Criterion.cxx
===================================================================
--- oce.orig/src/GeomPlate/GeomPlate_PlateG0Criterion.cxx
+++ oce/src/GeomPlate/GeomPlate_PlateG0Criterion.cxx
@@ -71,10 +71,6 @@ void GeomPlate_PlateG0Criterion::Value(A
   TColStd_Array1OfReal Curve(1, dimension);
   TColStd_Array1OfReal Point(1, 3); 
   Standard_Real * Coeffs =  (Standard_Real *) &Patch.ChangeValue(1);
-#ifdef DEB
-  Standard_Real * Result =  
-#endif
-    (Standard_Real *) &Curve.ChangeValue(1);
   Standard_Real * Digit  =  (Standard_Real *) &Point.ChangeValue(1);
   
   Standard_Integer k1, k2, pos, ll=1;
Index: oce/src/GeomPlate/GeomPlate_PlateG1Criterion.cxx
===================================================================
--- oce.orig/src/GeomPlate/GeomPlate_PlateG1Criterion.cxx
+++ oce/src/GeomPlate/GeomPlate_PlateG1Criterion.cxx
@@ -68,11 +68,6 @@ void GeomPlate_PlateG1Criterion::Value(A
   TColStd_Array1OfReal Curve(1, 2*dimension);
   TColStd_Array1OfReal Point(1, 3); 
   Standard_Real * Coeffs =  (Standard_Real *) &Patch.ChangeValue(1);
-#ifdef DEB
-  Standard_Real * Result =  (Standard_Real *) &Curve.ChangeValue(1);
-#else
-  Curve.ChangeValue(1);
-#endif
   Standard_Real * Digit  =  (Standard_Real *) &Point.ChangeValue(1);
   
   Standard_Integer k1, k2, pos, ll=1;
Index: oce/src/GeomProjLib/GeomProjLib.cxx
===================================================================
--- oce.orig/src/GeomProjLib/GeomProjLib.cxx
+++ oce/src/GeomProjLib/GeomProjLib.cxx
@@ -48,8 +48,7 @@
 
 #ifdef DRAW
 #include <DrawTrSurf.hxx>
-#endif
-#ifdef DEB
+
 static Standard_Boolean Affich = Standard_False;
 static Standard_Integer NBPROJ = 1;
 #endif
@@ -326,12 +325,6 @@ Handle(Geom_Curve) GeomProjLib::Project(
     Standard_Real TolU = Pow(Tol, 2./3);
     Standard_Real TolV = Pow(Tol, 2./3);
     ProjLib_CompProjectedCurve Proj(HS,HC,TolU,TolV,-1.);
-    
-#ifdef DEB
-    Standard_Integer NbCurves = Proj.NbCurves();
-#else
-    Proj.NbCurves();
-#endif
     Standard_Real f,l;
     Proj.Bounds(1,f,l);
     Handle(Adaptor2d_HCurve2d) HC2d = Proj.Trim(f,l,TolU);
Index: oce/src/GeomToIGES/GeomToIGES_GeomSurface.cxx
===================================================================
--- oce.orig/src/GeomToIGES/GeomToIGES_GeomSurface.cxx
+++ oce/src/GeomToIGES/GeomToIGES_GeomSurface.cxx
@@ -785,12 +785,6 @@ Handle(IGESData_IGESEntity) GeomToIGES_G
   Standard_Real V1 = Vdeb;
   Standard_Real V2 = Vfin;
 
-  // debug mjm du 28/03/96
-#ifdef DEB
-  Standard_Boolean IsDirect = 
-#endif
-    start->Torus().Direct();
-
   // creation de la generatrice : Generatrix (cercle)
   gp_Ax2 Axe = gp_Ax2(gp_Pnt((start->Torus().MajorRadius()), 0., 0.),
 		      -gp::DY(), gp::DX());
Index: oce/src/GeometryTest/GeometryTest_APICommands.cxx
===================================================================
--- oce.orig/src/GeometryTest/GeometryTest_APICommands.cxx
+++ oce/src/GeometryTest/GeometryTest_APICommands.cxx
@@ -472,14 +472,9 @@ void GeometryTest::APICommands(Draw_Inte
   if (done) return;
 
   done = Standard_True;
-  const char* g;
-
-  g = "GEOMETRY curves and surfaces analysis";
 
   theCommands.Add("proj", "proj curve/surf x y z",__FILE__, proj);
 
-  g = "GEOMETRY approximations";
-
   theCommands.Add("appro", "appro result nbpoint [curve]",__FILE__, appro);
   theCommands.Add("surfapp","surfapp result nbupoint nbvpoint x y z ....",
 		  __FILE__,
@@ -488,8 +483,6 @@ void GeometryTest::APICommands(Draw_Inte
        "grilapp result nbupoint nbvpoint X0 dX Y0 dY z11 z12 .. z1nu ....  ",
         __FILE__,grilapp);
 
-  g = "GEOMETRY curves and surfaces analysis";
-
   theCommands.Add("extrema", "extrema curve/surface curve/surface",__FILE__,extrema);
   theCommands.Add("totalextcc", "totalextcc curve curve",__FILE__,totalextcc);
 }
Index: oce/src/GeometryTest/GeometryTest_ConstraintCommands.cxx
===================================================================
--- oce.orig/src/GeometryTest/GeometryTest_ConstraintCommands.cxx
+++ oce/src/GeometryTest/GeometryTest_ConstraintCommands.cxx
@@ -757,10 +757,6 @@ static Standard_Integer gcarc (Draw_Inte
 	  if (DrawTrSurf::GetPoint(a[5], P3)) {
 //	    if (DrawTrSurf::GetPoint(a[6], P4)) {
 	    if (n>6) {
-#ifdef DEB
-	      Standard_Boolean ip4 =
-#endif
-                                     DrawTrSurf::GetPoint(a[6], P4);
 	      gp_Vec V1 = gp_Vec(P2,P3);                                                    
 	      Handle(Geom_Curve)thearc = GC_MakeArcOfCircle(P1,V1,P4).Value();
 	      DrawTrSurf::Set(a[1], thearc);
Index: oce/src/GeometryTest/GeometryTest_CurveCommands.cxx
===================================================================
--- oce.orig/src/GeometryTest/GeometryTest_CurveCommands.cxx
+++ oce/src/GeometryTest/GeometryTest_CurveCommands.cxx
@@ -406,7 +406,7 @@ static Standard_Integer project (Draw_In
   Standard_Real U1,U2,V1,V2;
   GS->Bounds(U1,U2,V1,V2);
 
-  Standard_Boolean Verif = Standard_False, Extent = Standard_False;
+  Standard_Boolean Verif = Standard_False;
   Standard_Integer NbPoints=0;
 
   Standard_Integer index = 4;
@@ -418,7 +418,6 @@ static Standard_Integer project (Draw_In
       Standard_Real dU = p * (U2 - U1) / 100.;
       Standard_Real dV = p * (V2 - V1) / 100.;
       U1 -= dU; U2 += dU; V1 -= dV; V2 += dV;
-      Extent = Standard_True;
     }
     else if ( a[index][1] == 'v') {
       Verif = Standard_True;
@@ -750,7 +749,7 @@ static Standard_Integer bisec (Draw_Inte
 
 static Standard_Integer movelaw (Draw_Interpretor& di, Standard_Integer n, const char** a)
 {
-  Standard_Integer dimension,
+  Standard_Integer 
   ii,
   condition=0,
   error_status ;
@@ -762,7 +761,6 @@ static Standard_Integer movelaw (Draw_In
   u = atof(a[2]);
   x = atof(a[3]);
   tolerance = 1.0e-5 ;
-  dimension = 2 ;
   if (n < 5) {
       return 1 ;
   }
@@ -872,7 +870,6 @@ static Standard_Integer crvpoints (Draw_
   Draw::Set(a[1], aDrCrv);
 
   Standard_Real dmax = 0., ufmax = 0., ulmax = 0.;
-  Standard_Integer imax = 0;
 
   for(i = 1; i < nbp; ++i) {
     Standard_Real uf = aKnots(i);
@@ -892,7 +889,6 @@ static Standard_Integer crvpoints (Draw_
 	dmax = d;
 	ufmax = uf;
 	ulmax = ul;
-	imax = i;
       }
     }
   }
Index: oce/src/GeometryTest/GeometryTest_FairCurveCommands.cxx
===================================================================
--- oce.orig/src/GeometryTest/GeometryTest_FairCurveCommands.cxx
+++ oce/src/GeometryTest/GeometryTest_FairCurveCommands.cxx
@@ -46,7 +46,6 @@ BattenCurve(Draw_Interpretor& di, Standa
   const char *cheigth = argv[5];
   const char *BattenName = argv[6];
 
-  Standard_Boolean Ok;
   FairCurve_AnalysisCode Iana;
   Standard_Real a1 = atof(cangle1),
                 a2 = atof(cangle2),
@@ -61,7 +60,7 @@ BattenCurve(Draw_Interpretor& di, Standa
   Bat->SetAngle1(a1*PI/180);
   Bat->SetAngle2(a2*PI/180);
   
-  Ok = Bat->Compute(Iana);
+  Bat->Compute(Iana);
   
   Handle(DrawFairCurve_Batten) aBatten = new DrawFairCurve_Batten(Bat);
 
@@ -90,7 +89,6 @@ MVCurve(Draw_Interpretor& di, Standard_I
   const char *cheigth = argv[5];
   const char *MVCName = argv[6];
 
-  Standard_Boolean Ok;
   FairCurve_AnalysisCode Iana;
   Standard_Real a1 = atof(cangle1),
                 a2 = atof(cangle2),
@@ -105,7 +103,7 @@ MVCurve(Draw_Interpretor& di, Standard_I
   MVC->SetAngle1(a1*PI/180);
   MVC->SetAngle2(a2*PI/180);
   
-  Ok = MVC->Compute(Iana);
+  MVC->Compute(Iana);
   
   Handle(DrawFairCurve_MinimalVariation) aMVC = new DrawFairCurve_MinimalVariation(MVC);
 
Index: oce/src/GeometryTest/GeometryTest_SurfaceCommands.cxx
===================================================================
--- oce.orig/src/GeometryTest/GeometryTest_SurfaceCommands.cxx
+++ oce/src/GeometryTest/GeometryTest_SurfaceCommands.cxx
@@ -71,9 +71,6 @@ static Standard_Integer sweep (Draw_Inte
   GeomFill_Trihedron Option = GeomFill_IsCorrectedFrenet;
   Standard_Integer ipath =2, isection =4 , NbSeg=30, MaxDegree = 10;
   Standard_Real Tol = 1.e-4;
-#if DEB
-  static Standard_Boolean AdvApprox_Debug = 1; 
-#endif
 
   if (n < 4 ) return 1;
   
@@ -151,9 +148,6 @@ static Standard_Integer tuyau (Draw_Inte
                                Standard_Integer n, const char** a)
 {
   if ( n < 4) return 1;
-#if DEB
-  static Standard_Boolean AdvApprox_Debug = 1;
-#endif 
 
   GeomAbs_Shape Cont = GeomAbs_C2;
   GeomFill_Pipe Pipe;
Index: oce/src/GeomliteTest/GeomliteTest_ApproxCommands.cxx
===================================================================
--- oce.orig/src/GeomliteTest/GeomliteTest_ApproxCommands.cxx
+++ oce/src/GeomliteTest/GeomliteTest_ApproxCommands.cxx
@@ -585,11 +585,6 @@ static Standard_Integer smoothingbybezie
       Standard_Boolean mySquare = (methode == 2);
       Standard_Integer degmin = 4;
       Standard_Integer NbIteration = 5;
-#ifdef DEB
-      Standard_Integer NbConst =
-#endif
-                                 NbConstraint(TABofCC->Value(1).Constraint(),
-					      TABofCC->Value(NbPoints).Constraint());
       
       if (Degree < 4) degmin = Max(1, Degree -1);
       degmin = Max(degmin, NbConstraint(TABofCC->Value(1).Constraint(),  
Index: oce/src/GeomliteTest/GeomliteTest_SurfaceCommands.cxx
===================================================================
--- oce.orig/src/GeomliteTest/GeomliteTest_SurfaceCommands.cxx
+++ oce/src/GeomliteTest/GeomliteTest_SurfaceCommands.cxx
@@ -1187,20 +1187,6 @@ static Standard_Integer rempole (Draw_In
     BSpline = Standard_True;
   }
   
-  Standard_Integer Index;
-  if ( !strcasecmp(a[0],"remrowpole")) {
-    if (BSpline)
-      Index = GBs->UDegree();
-    else 
-      Index = GBz->UDegree();
-  }  
-  else if ( !strcasecmp(a[0],"remcolpole")) {
-    if (BSpline) 
-      Index = GBs->VDegree();
-    else
-      Index = GBz->VDegree();
-  }
-  
   if ( !strcasecmp(a[0],"remrowpole")) {
     if ( BSpline) {
       di << " Error : Cannot remove a polerow on a BSplineSurface " << "\n";
Index: oce/src/Graphic2d/Graphic2d_Image.cxx
===================================================================
--- oce.orig/src/Graphic2d/Graphic2d_Image.cxx
+++ oce/src/Graphic2d/Graphic2d_Image.cxx
@@ -201,8 +201,8 @@ void Graphic2d_Image::FillAndDraw (const
 
 Standard_ShortReal a,b;
 
-Standard_Integer LowerX, LowerY;
-Standard_Integer UpperX, UpperY;
+Standard_Integer LowerY;
+Standard_Integer UpperY;
 Standard_Integer Width, Height;
 Aspect_RGBPixel *pixels;
 
@@ -217,10 +217,7 @@ Standard_Real R, G, B;
         Width   = myImage->Width ();
         Height  = myImage->Height ();
 
-        LowerX  = myImage->LowerX ();
         LowerY  = myImage->LowerY ();
-
-        UpperX  = myImage->UpperX ();
         UpperY  = myImage->UpperY ();
 
         if (Height*Width <= Graphic2d_Image::SmallSize ()) {
@@ -275,9 +272,6 @@ Standard_Real R, G, B;
 void Graphic2d_Image::ComputeCenter(const Handle(Graphic2d_Drawer)& aDrawer,
                                     Standard_ShortReal& cx,
                                     Standard_ShortReal& cy) const {
-     Standard_Integer Width, Height;
-     Width = myImage->Width ();
-     Height = myImage->Height ();
      Standard_ShortReal dx = aDrawer->Convert(myImage->Width());
      Standard_ShortReal dy = aDrawer->Convert(myImage->Height());
 
Index: oce/src/Graphic2d/Graphic2d_Paragraph.cxx
===================================================================
--- oce.orig/src/Graphic2d/Graphic2d_Paragraph.cxx
+++ oce/src/Graphic2d/Graphic2d_Paragraph.cxx
@@ -298,10 +298,6 @@ void Graphic2d_Paragraph::ChangeText (co
                                    const Standard_Integer aRow,
                                    const Standard_Integer aColumn) {
 Standard_Integer i,length = myTextDescriptorList.Length() ;
-#ifdef DEB
-Standard_Integer row = (aRow > 0) ? Min(aRow,MAXROW-1) : MAXROW-1 ;
-Standard_Integer column = (aColumn > 0) ? Min(aColumn,MAXCOLUMN-1) : MAXCOLUMN-1 ;
-#endif
 Standard_Integer descriptor = TEXT_DESCRIPTOR(aRow,aColumn,0,0,0,0) ;
 Standard_Integer the_position = TEXT_POSITION(descriptor) ;
 
@@ -533,10 +529,6 @@ Standard_Boolean Graphic2d_Paragraph::Pi
                                        const Handle(Graphic2d_Drawer)& aDrawer) 
 {
 Standard_Boolean theStatus = Standard_False;
-#ifdef DEB
-Standard_ShortReal scale = 
-#endif
-  (myIsZoomable) ? myScale*aDrawer->Scale() : myScale;
 Standard_ShortReal TX = X, TY = Y;
 
   if (IsInMinMax (X, Y, aPrecision)) {
Index: oce/src/Graphic3d/Graphic3d_ArrayOfPrimitives.cxx
===================================================================
--- oce.orig/src/Graphic3d/Graphic3d_ArrayOfPrimitives.cxx
+++ oce/src/Graphic3d/Graphic3d_ArrayOfPrimitives.cxx
@@ -796,7 +796,7 @@ Standard_Boolean Graphic3d_ArrayOfPrimit
   Standard_Integer nvertexs = myPrimitiveArray->num_vertexs;
   Standard_Integer nbounds = myPrimitiveArray->num_bounds;
   Standard_Integer nedges = myPrimitiveArray->num_edges;
-  Standard_Integer i,j,k,n;
+  Standard_Integer i,n;
 
 #if TRACE > 0
   Standard_CString name = StringType();
Index: oce/src/Graphic3d/Graphic3d_GraphicDevice.cxx
===================================================================
--- oce.orig/src/Graphic3d/Graphic3d_GraphicDevice.cxx
+++ oce/src/Graphic3d/Graphic3d_GraphicDevice.cxx
@@ -187,13 +187,11 @@ OSD_Function new_GLGraphicDriver =
 
 Standard_Boolean Graphic3d_GraphicDevice::ShrIsDefined (Standard_CString& aShr) const {
 
-  char *glso, *glul, *pkno;
+  char *glso;
   const char *glshr, *casroot;
 
   casroot = getenv("CASROOT");
   glso = getenv("CSF_GraphicShr");
-  glul = getenv("GRAPHICHOME");
-  pkno = getenv("CSF_Graphic3dLib");
 
   if (! BAD(glso)) {
     glshr = getenv("CSF_GraphicShr");
Index: oce/src/HLRBRep/HLRBRep_Data.cxx
===================================================================
--- oce.orig/src/HLRBRep/HLRBRep_Data.cxx
+++ oce/src/HLRBRep/HLRBRep_Data.cxx
@@ -534,10 +534,6 @@ void HLRBRep_Data::Write (const Handle(H
 			  const Standard_Integer de,
 			  const Standard_Integer df)
 {
-#ifdef DEB
-  Standard_Integer n1vert = 
-#endif
-    DS->NbVertices();
   Standard_Integer n1edge = DS->NbEdges();
   Standard_Integer n1face = DS->NbFaces();
 
@@ -1575,10 +1571,7 @@ HLRBRep_Data::HidingStartLevel (const St
 #else
   Standard_Integer level;
 #endif
-#ifdef DEB
-  TopAbs_State st = 
-#endif
-    Classify(E,ED,Standard_True,level,param);
+  Classify(E,ED,Standard_True,level,param);
   Loop = Standard_True;
   It.Initialize(IL);
 
Index: oce/src/HLRBRep/HLRBRep_Hider.cxx
===================================================================
--- oce.orig/src/HLRBRep/HLRBRep_Hider.cxx
+++ oce/src/HLRBRep/HLRBRep_Hider.cxx
@@ -325,7 +325,6 @@ void HLRBRep_Hider::Hide(const Standard_
 
 	Standard_Boolean foundHidden = Standard_False;
 	
-	Standard_Integer aStartLevel;
 	if (!ILHidden.IsEmpty()) {    
 
 	  HLRBRep_EdgeIList::ProcessComplex // complex transition on ILHidden
@@ -335,7 +334,6 @@ void HLRBRep_Hider::Hide(const Standard_
 	    level = myDS->HidingStartLevel(E,ed,ILHidden);  // **************
 	  	  HLRAlgo_ListIteratorOfInterferenceList It(ILHidden); 
 	  
-	  aStartLevel = level;
 	  while(It.More()) {           // suppress multi-inside Intersections
 	                               // ***********************************
 	  
Index: oce/src/HLRBRep/HLRBRep_PolyAlgo.cxx
===================================================================
--- oce.orig/src/HLRBRep/HLRBRep_PolyAlgo.cxx
+++ oce/src/HLRBRep/HLRBRep_PolyAlgo.cxx
@@ -429,7 +429,6 @@
 #ifdef DEB
 static Standard_Integer DoTrace = Standard_False; 
 static Standard_Integer DoError = Standard_False; 
-static Standard_Integer IndexPlusOnePerCentThree [] = { 1 , 2 , 0 };
 #endif
 //=======================================================================
 //function : HLRBRep_PolyAlgo
@@ -3527,7 +3526,6 @@ UpdateEdgesBiPoints (HLRAlgo_ListOfBPoin
 		     const Standard_Boolean closed)
 {
   Standard_Integer itri1,itri2,tbid;
-  Standard_Boolean OK;
   HLRAlgo_ListIteratorOfListOfBPoint it;
   
   for (it.Initialize(List); it.More(); it.Next()) {      
@@ -3545,8 +3543,8 @@ UpdateEdgesBiPoints (HLRAlgo_ListOfBPoin
 	pid1->PINod().ChangeValue(F1Pt1Index)->Indices();
       Standard_Address Nod21Indices = 
 	pid2->PINod().ChangeValue(F2Pt1Index)->Indices();
-      OK = Triangles(F1Pt1Index,F1Pt2Index,Nod11Indices,PISeg1,itri1,tbid);
-      OK = Triangles(F2Pt1Index,F2Pt2Index,Nod21Indices,PISeg2,itri2,tbid);
+      Triangles(F1Pt1Index,F1Pt2Index,Nod11Indices,PISeg1,itri1,tbid);
+      Triangles(F2Pt1Index,F2Pt2Index,Nod21Indices,PISeg2,itri2,tbid);
 
       if (itri1 != 0 && itri2 != 0) {
 	if (F1Index != F2Index || itri1 != itri2) {
Index: oce/src/HLRBRep/HLRBRep_ShapeToHLR.cxx
===================================================================
--- oce.orig/src/HLRBRep/HLRBRep_ShapeToHLR.cxx
+++ oce/src/HLRBRep/HLRBRep_ShapeToHLR.cxx
@@ -86,10 +86,6 @@ HLRBRep_ShapeToHLR::Load(const Handle(HL
 
   // Create the data structure
   Handle(HLRBRep_Data) DS = new HLRBRep_Data (nbVert, nbEdge, nbFace);
-#ifdef DEB
-  HLRBRep_Array1OfEData& ED = 
-#endif
-    DS->EDataArray ();
   HLRBRep_EdgeData* ed = NULL; 
   if(nbEdge != 0) ed = &(DS->EDataArray().ChangeValue(1));
 //  ed++;
Index: oce/src/HLRTest/HLRTest.cxx
===================================================================
--- oce.orig/src/HLRTest/HLRTest.cxx
+++ oce/src/HLRTest/HLRTest.cxx
@@ -77,9 +77,7 @@ Handle(HLRTopoBRep_OutLiner) HLRTest::Ge
 static Standard_Integer
 hprj (Draw_Interpretor& , Standard_Integer n, const char** a)
 {
-  Standard_Integer id = 1;
   if (n < 2) return 1;
-  if (n > 2) id = atoi(a[2]);
   //
   gp_Ax2 anAx2 = gp::XOY();
   if (n == 11)
Index: oce/src/HLRTopoBRep/HLRTopoBRep_OutLiner.cxx
===================================================================
--- oce.orig/src/HLRTopoBRep/HLRTopoBRep_OutLiner.cxx
+++ oce/src/HLRTopoBRep/HLRTopoBRep_OutLiner.cxx
@@ -91,8 +91,7 @@ void HLRTopoBRep_OutLiner::ProcessFace(c
 {
   BRep_Builder B;
   TopExp_Explorer exE, exW;
-  Standard_Boolean splitted = Standard_False;
-
+ 
   TopTools_IndexedDataMapOfShapeListOfShape aVEMap;
   TopExp::MapShapesAndAncestors(F, TopAbs_VERTEX, TopAbs_EDGE, aVEMap);
 
@@ -138,7 +137,7 @@ void HLRTopoBRep_OutLiner::ProcessFace(c
   //}
   
 
-  TopTools_ListOfShape& IntL = myDS.AddIntL(F);
+  myDS.AddIntL(F);
   TopTools_ListOfShape& OutL = myDS.AddOutL(F);
 
   if (myDS.FaceHasIntL(F)) { // get the InternalOutLines on face F
Index: oce/src/IFGraph/IFGraph_Articulations.cxx
===================================================================
--- oce.orig/src/IFGraph/IFGraph_Articulations.cxx
+++ oce/src/IFGraph/IFGraph_Articulations.cxx
@@ -30,9 +30,8 @@
 //  Utilisation de Visit
   Standard_Integer nb = thegraph.Size();
   for (Standard_Integer i = 1; i <= nb; i ++) {
-    Standard_Integer visited;
     thenow = 0;
-    if (thegraph.IsPresent(i)) visited = Visit(i);
+    if (thegraph.IsPresent(i)) Visit(i);
   }
 //  Resultat dans thelist
   Reset();
Index: oce/src/IFSelect/IFSelect_BasicDumper.cxx
===================================================================
--- oce.orig/src/IFSelect/IFSelect_BasicDumper.cxx
+++ oce/src/IFSelect/IFSelect_BasicDumper.cxx
@@ -131,11 +131,10 @@
     return Standard_True;
   }
   if (type.IsEqual("IFSelect_SelectTextType")) {
-    Standard_Boolean exact;
     const TCollection_AsciiString exname = file.ParamValue(1);
     if (exname.Length() < FIRSTCHAR) return Standard_False;
-    if      (exname.Value(FIRSTCHAR) == 'e') exact = Standard_True;
-    else if (exname.Value(FIRSTCHAR) == 'c') exact = Standard_False;
+    if      (exname.Value(FIRSTCHAR) == 'e') {}
+    else if (exname.Value(FIRSTCHAR) == 'c') {}
     else  return Standard_False;
 //    item = new IFSelect_SelectTextType (file.TextValue(2).ToCString(),exact);
 //    return Standard_True;
Index: oce/src/IFSelect/IFSelect_ListEditor.cxx
===================================================================
--- oce.orig/src/IFSelect/IFSelect_ListEditor.cxx
+++ oce/src/IFSelect/IFSelect_ListEditor.cxx
@@ -60,11 +60,9 @@ Standard_Boolean  IFSelect_ListEditor::L
   if (list.IsNull()) return Standard_False;
   Standard_Integer i, nb = list->Length();
   if (nb > themax) return Standard_False;
-  Interface_ParamType pty = Interface_ParamText;
 
 //   check values
   if (!thedef.IsNull()) {
-    pty = thedef->Type();
     for (i = 1; i <= nb; i ++) {
       Handle(TCollection_HAsciiString) newval = list->Value(i);
       if (!CheckValue (newval,themodl,thedef)) return Standard_False;
Index: oce/src/IFSelect/IFSelect_WorkSession.cxx
===================================================================
--- oce.orig/src/IFSelect/IFSelect_WorkSession.cxx
+++ oce/src/IFSelect/IFSelect_WorkSession.cxx
@@ -963,10 +963,7 @@ Standard_Boolean IFSelect_WorkSession::R
 {
   Handle(Standard_Transient) item = NamedItem(name);
   if (item.IsNull()) return Standard_False;
-#ifdef DEB
-  Standard_Integer bid = 
-#endif
-    theitems.Add(item,item);    // reste mais sans nom
+  theitems.Add(item,item);    // reste mais sans nom
   return thenames->RemoveItem(name);
 }
 
@@ -3440,8 +3437,6 @@ void IFSelect_WorkSession::DumpModel
     if (level == 5 || level ==  8) mode = IFSelect_CountByItem;
     if (level == 6 || level ==  9) mode = IFSelect_ListByItem;
     if (level == 7 || level == 10) mode = IFSelect_EntitiesByItem;
-    Standard_Boolean failsonly = Standard_False;
-    if (level < 8 && level != 4) failsonly = Standard_True;
     PrintCheckList (ModelCheckList(),Standard_False, mode);
   } else {
     if (level == 3) S << "        ********  Check Model (Fails)  ********"<<endl;
Index: oce/src/IGESConvGeom/IGESConvGeom.cxx
===================================================================
--- oce.orig/src/IGESConvGeom/IGESConvGeom.cxx
+++ oce/src/IGESConvGeom/IGESConvGeom.cxx
@@ -561,10 +561,9 @@ Standard_Integer IGESConvGeom::IncreaseS
 {
   if (continuity < 1) return continuity;
   Standard_Boolean isC1 = Standard_True, isC2 = Standard_True;
-  Standard_Integer i,j;
+  Standard_Integer i;
 
   i = res->LastUKnotIndex();   //knots.Upper();
-  j = res->FirstUKnotIndex();  //knots.Lower();
   Standard_Integer DegreeU = res->UDegree();
   
   Standard_Boolean isModified;
Index: oce/src/Image/Image_BilinearPixelInterpolation.cxx
===================================================================
--- oce.orig/src/Image/Image_BilinearPixelInterpolation.cxx
+++ oce/src/Image/Image_BilinearPixelInterpolation.cxx
@@ -74,7 +74,6 @@ static Standard_Real DoInterpolation(	co
   }
   else {
   	Standard_Integer i;
-  	Standard_Boolean BResult;
   	TColStd_Array1OfReal V(1,4), R(1,4) ;
   	TColStd_Array2OfReal M( 1, 4, 1, 4 ) ;
   	TColStd_Array2OfReal MINV( 1, 4, 1, 4 ) ;
@@ -85,7 +84,7 @@ static Standard_Real DoInterpolation(	co
 		V(i)   = NZF(i) ;
   	}
 
-  	BResult = Aspect::Inverse (M, MINV);
+  	Aspect::Inverse (M, MINV);
 
   	// R = M * V ;
 	R (1)	= M (1, 1) * V (1) + M (1, 2) * V (2)
Index: oce/src/IntAna/IntAna_IntQuadQuad.cxx
===================================================================
--- oce.orig/src/IntAna/IntAna_IntQuadQuad.cxx
+++ oce/src/IntAna/IntAna_IntQuadQuad.cxx
@@ -570,13 +570,11 @@ void IntAna_IntQuadQuad::Perform(const g
 				 const Standard_Real)  
 { 
   //
-  Standard_Boolean UN_SEUL_Z_PAR_THETA, DEUX_Z_PAR_THETA, 
-                   Z_POSITIF, Z_INDIFFERENT, Z_NEGATIF;
+  Standard_Boolean UN_SEUL_Z_PAR_THETA,
+                   Z_POSITIF, Z_NEGATIF;
   //
   UN_SEUL_Z_PAR_THETA=Standard_False;
-  DEUX_Z_PAR_THETA=Standard_True;
   Z_POSITIF=Standard_True;
-  Z_INDIFFERENT=Standard_True;
   Z_NEGATIF=Standard_False;
   //
   Standard_Integer i;
Index: oce/src/IntAna/IntAna_QuadQuadGeo.cxx
===================================================================
--- oce.orig/src/IntAna/IntAna_QuadQuadGeo.cxx
+++ oce/src/IntAna/IntAna_QuadQuadGeo.cxx
@@ -838,9 +838,8 @@ gp_Ax2 DirToAx2(const gp_Pnt& P,const gp
   Standard_Real RmR, RmR_Relative;
   RmR=(R1>R2)? (R1-R2) : (R2-R1);
   {
-    Standard_Real Rmax, Rmin;
+    Standard_Real Rmax;
     Rmax=(R1>R2)? R1 : R2;
-    Rmin=(R1>R2)? R2 : R1;
     RmR_Relative=RmR/Rmax;
   }
 
Index: oce/src/IntAna/IntAna_Quadric.cxx
===================================================================
--- oce.orig/src/IntAna/IntAna_Quadric.cxx
+++ oce/src/IntAna/IntAna_Quadric.cxx
@@ -120,15 +120,9 @@ void IntAna_Quadric::NewCoefficients( St
   Standard_Real Cxx,Cyy,Czz,Cxy,Cxz,Cyz,Cx,Cy,Cz,Ccte;            
 
 
-#ifdef DEB  
-  gp_Dir DirX = Axis.XDirection();
-  gp_Dir DirY = Axis.YDirection();
-  gp_Dir DirZ = Axis.Direction();
-#else
   Axis.XDirection();
   Axis.YDirection();
   Axis.Direction();
-#endif
   
   gp_Trsf Trans;
   
Index: oce/src/IntPatch/IntPatch_ALine.cxx
===================================================================
--- oce.orig/src/IntPatch/IntPatch_ALine.cxx
+++ oce/src/IntPatch/IntPatch_ALine.cxx
@@ -488,11 +488,7 @@ void IntPatch_ALine::ComputeVertexParame
   nbvtx     = NbVertex();
   if(nbvtx>1) { 
     IntPatch_Point& VTX0   = svtx.ChangeValue(1);
-#ifdef DEB
-    //Standard_Real d;
-    IntPatch_Point& VTX1   = 
-#endif
-      svtx.ChangeValue(2);
+    svtx.ChangeValue(2);
     if(   (VTX0.IsOnDomS1() == Standard_False)
        && (VTX0.IsOnDomS2() == Standard_False)) { 
       svtx.Remove(1);
@@ -504,10 +500,7 @@ void IntPatch_ALine::ComputeVertexParame
   }
   if(nbvtx>1) { 
     IntPatch_Point& VTX0   = svtx.ChangeValue(nbvtx);
-#ifdef DEB
-    IntPatch_Point& VTX1   = 
-#endif
-      svtx.ChangeValue(nbvtx-1);
+    svtx.ChangeValue(nbvtx-1);
     if(   (VTX0.IsOnDomS1() == Standard_False)
        && (VTX0.IsOnDomS2() == Standard_False)) { 
       svtx.Remove(nbvtx);
Index: oce/src/IntPatch/IntPatch_ALineToWLine.cxx
===================================================================
--- oce.orig/src/IntPatch/IntPatch_ALineToWLine.cxx
+++ oce/src/IntPatch/IntPatch_ALineToWLine.cxx
@@ -621,7 +621,7 @@ static
   do { 
     Standard_Boolean RemoveVtxo, RemoveVtx;
     Standard_Integer vo, voo;
-    Standard_Real ponl, ponlo, ponloo, aDist13, aDist23;
+    Standard_Real ponl, ponlo, aDist13, aDist23;
     //
     APointHasBeenRemoved = Standard_False;
     RemoveVtxo = Standard_False;
@@ -647,7 +647,6 @@ static
 		  if(voo!=v && voo!=vo) {
 		    if(newparamvertex(voo)>=0.) { 
 		      const IntPatch_Point& Vtxoo = aline->Vertex(voo);
-		      ponloo = Vtxoo.ParameterOnLine();
 		      const gp_Pnt& aPoo=Vtxoo.Value();
 		      //
 		      aDist13=aP.Distance(aPoo);
@@ -920,12 +919,6 @@ void RecadreMemePeriode(const IntSurf_Qu
 			const Standard_Real anu1,
 			const Standard_Real anu2) 
 { 
-  Standard_Boolean bBothCylinders;
-  GeomAbs_SurfaceType aType1, aType2;
-  //
-  aType1=aQuad1.TypeQuadric();
-  aType2=aQuad2.TypeQuadric();
-  bBothCylinders=(aType1==GeomAbs_Cylinder && aType2==GeomAbs_Cylinder);
   //
   while(anu1-u1 > 5.0) {
     u1+=PI+PI;
Index: oce/src/IntPatch/IntPatch_ImpPrmIntersection.cxx
===================================================================
--- oce.orig/src/IntPatch/IntPatch_ImpPrmIntersection.cxx
+++ oce/src/IntPatch/IntPatch_ImpPrmIntersection.cxx
@@ -1813,7 +1813,6 @@ static void ToSmooth(Handle(IntSurf_Line
   Standard_Integer Index3 = (IsFirst) ? 3 : (Line->NbPoints()-2);
 
   Standard_Boolean doU = Standard_False;
-  Standard_Boolean doV = Standard_False;
 
   Standard_Real U1 = 0., U2 = 0., V1 = 0., V2 = 0., U3 = 0., V3 = 0.;
 
@@ -1853,8 +1852,6 @@ static void ToSmooth(Handle(IntSurf_Line
     }
   }
 
-  if(fabs(fabs(V1)-fabs(V2)) > DDV) doV = Standard_True;
-
   if(doU) {
     Standard_Real dU = Min((DDU/10.),5.e-8);
     Standard_Real U = (U2 > U3) ? (U2 + dU) : (U2 - dU);
@@ -2337,8 +2334,8 @@ void DecomposeResult(Handle(IntPatch_Lin
   Standard_Real BSEAM = 1.5*PI; // delta U crossing seam
   Standard_Real BAPEX = PI/16.;  // delta U crossing apex
   
-  Standard_Integer i = 0, k = 0;
-  Standard_Real U1 = 0., U2 = 0., V1 = 0., V2 = 0., AnU1 = 0., AnV1 = 0., DU1 = 0., DV1 = 0.;
+  Standard_Integer k = 0;
+  Standard_Real U1 = 0., U2 = 0., V1 = 0., V2 = 0., AnU1 = 0.;
   Standard_Integer Findex = 1, Lindex = NbPnts, Bindex = 0;
 
   gp_Pnt aPnt, aSPnt;
@@ -2357,8 +2354,7 @@ void DecomposeResult(Handle(IntPatch_Lin
 
   // reset variables
   Standard_Boolean isDecomposited = Standard_False;
-  Standard_Boolean is2PIDecomposed = Standard_False;
-  U1 = 0.; V1 = 0.; U2 = 0.; V2 = 0.; AnU1 = 0.; AnV1 = 0.; DU1 = 0.; DV1 = 0.;
+  U1 = 0.; V1 = 0.; U2 = 0.; V2 = 0.; AnU1 = 0.;
 
   // analyze other points
   for(k = Findex; k <= Lindex; k++) {
@@ -2372,7 +2368,6 @@ void DecomposeResult(Handle(IntPatch_Lin
 	SSLine->Value(k).ParametersOnS1(AnU1,V1);    // S1 - quadric, set U,V by Pnt3D
       }
       sline->Add(SSLine->Value(k));
-      AnV1 = V1;
       continue;
     }
 
@@ -2387,7 +2382,6 @@ void DecomposeResult(Handle(IntPatch_Lin
     if(DeltaU > BSEAM) {
       Bindex = k;
       isDecomposited = Standard_True;
-      is2PIDecomposed = Standard_True;
       break;
     }
     else if((DeltaU > BAPEX) && (k >= (Findex+10) && k <= (Lindex-10))) {
@@ -2399,7 +2393,6 @@ void DecomposeResult(Handle(IntPatch_Lin
 
     sline->Add(SSLine->Value(k));
     AnU1=U1;
-    AnV1=V1;
   }
  
   IntSurf_PntOn2S aVF,aVL;
Index: oce/src/IntPatch/IntPatch_LineConstructor.cxx
===================================================================
--- oce.orig/src/IntPatch/IntPatch_LineConstructor.cxx
+++ oce/src/IntPatch/IntPatch_LineConstructor.cxx
@@ -1395,10 +1395,6 @@ void IntPatch_LineConstructor::Perform(c
   }
   else if (typl != IntPatch_Restriction) { // JAG 01.07.96
     Standard_Real u1,v1,u2,v2;
-#ifdef DEB
-    Standard_Real paramminonvtx=RealLast();
-    Standard_Real parammaxonvtx=-paramminonvtx;
-#endif
     Handle(IntPatch_GLine)& GLine 
       =  *((Handle(IntPatch_GLine) *)&L);
     slin.Clear();
Index: oce/src/IntPatch/IntPatch_Polyhedron.cxx
===================================================================
--- oce.orig/src/IntPatch/IntPatch_Polyhedron.cxx
+++ oce/src/IntPatch/IntPatch_Polyhedron.cxx
@@ -194,9 +194,6 @@ Standard_Real IntPatch_Polyhedron::Defle
   gp_XYZ XYZ3=P1.XYZ()-P3.XYZ();
   gp_Vec NormalVector((XYZ1^XYZ2)+(XYZ2^XYZ3)+(XYZ3^XYZ1));
   NormalVector.Normalize();
-#ifdef DEB
-  Standard_Real PolarDistance = NormalVector * P1.XYZ();
-#endif
   //-- Calcul du point u,v  au centre du triangle
   Standard_Real u = (u1+u2+u3)/3.0;
   Standard_Real v = (v1+v2+v3)/3.0;
@@ -317,10 +314,6 @@ Standard_Integer IntPatch_Polyhedron::Tr
 						 Standard_Integer&      TriCon,
 						 Standard_Integer&      OtherP)   const {
 
-#ifdef DEB
-  Standard_Integer nbdeltaUp1 = nbdeltaU + 1;
-  Standard_Integer nbdeltaUm2 = nbdeltaU + nbdeltaU;
-#endif
   Standard_Integer Pivotm1    = Pivot-1;
   Standard_Integer nbdeltaVp1 = nbdeltaV+1;
   Standard_Integer nbdeltaVm2 = nbdeltaV + nbdeltaV;
@@ -513,9 +506,6 @@ Standard_Integer IntPatch_Polyhedron::Tr
 #if MSG_DEBUG
     cout<<" Probleme ds IntCurveSurface_Polyhedron : OtherP et PEdge Confondus "<<endl;
 #endif
-    Standard_Integer TempTri,TempOtherP;
-    TempTri = TriCon;
-    TempOtherP = OtherP;
 
     return(0); //-- BUG NON CORRIGE ( a revoir le role de nbdeltaU et nbdeltaV)
 
Index: oce/src/IntPatch/IntPatch_PrmPrmIntersection.cxx
===================================================================
--- oce.orig/src/IntPatch/IntPatch_PrmPrmIntersection.cxx
+++ oce/src/IntPatch/IntPatch_PrmPrmIntersection.cxx
@@ -2995,7 +2995,7 @@ void IntPatch_PrmPrmIntersection::PointD
   //modified by NIZNHY-PKV Wed May 25 06:47:12 2011t
   Standard_Integer iC15, SU1, SV1, SU2, SV2;
   Standard_Real U0, U1, V0, V1, U, V;
-  Standard_Real resu0,resu1,resv0,resv1;
+  Standard_Real resu0,resv0;
   Standard_Real  du1,du2,dv1,dv2, dmaxOn1, dmaxOn2;
   Standard_Real x0,y0,z0, x1,y1,z1,d;
   Bnd_Box Box1, Box2;
@@ -3025,8 +3025,6 @@ void IntPatch_PrmPrmIntersection::PointD
   V1 = S1->LastVParameter();
   //
   resu0=U0;
-  resu1=U1;
-  resv1=V1;
   resv0=V0;
   //
   dmaxOn1 = 0.0;
Index: oce/src/IntPatch/IntPatch_PrmPrmIntersection_T3Bits.cxx
===================================================================
--- oce.orig/src/IntPatch/IntPatch_PrmPrmIntersection_T3Bits.cxx
+++ oce/src/IntPatch/IntPatch_PrmPrmIntersection_T3Bits.cxx
@@ -28,7 +28,6 @@ Standard_Integer IntPatch_PrmPrmIntersec
                                                          Standard_Integer& indice)
 {
   int k=indice>>5;
-  Standard_Integer r=0;
   while(k<Isize)
   {
     Standard_Integer r=((Standard_Integer *) p)[k] & ((Standard_Integer *) Oth.p)[k];
Index: oce/src/IntPatch/IntPatch_RLine.cxx
===================================================================
--- oce.orig/src/IntPatch/IntPatch_RLine.cxx
+++ oce/src/IntPatch/IntPatch_RLine.cxx
@@ -93,9 +93,6 @@ void IntPatch_RLine::ComputeVertexParame
 {
   Standard_Integer i,j,nbvtx;//k;
   
-  Standard_Real ParamMinOnLine,ParamMaxOnLine;
-  if(fipt) { ParamMinOnLine = Vertex(indf).ParameterOnLine(); } else { ParamMinOnLine = -100000.0; } 
-  if(lapt) { ParamMaxOnLine = Vertex(indl).ParameterOnLine(); } else { ParamMaxOnLine =  100000.0; } 
   Standard_Boolean APointDeleted = Standard_False;
   //----------------------------------------------------------
   //--     F i l t r e   s u r   r e s t r i c t i o n s   --
Index: oce/src/IntPatch/IntPatch_RstInt.cxx
===================================================================
--- oce.orig/src/IntPatch/IntPatch_RstInt.cxx
+++ oce/src/IntPatch/IntPatch_RstInt.cxx
@@ -684,11 +684,10 @@ void IntPatch_RstInt::PutVertexOnLine (H
 	      (!Domain->Has3d() && Standard_Integer(nptCh)+1 < Nbptlin);
 	    if (!isNptLow && !IsSegment2dSmall(Brise,UMinAr,UMaxAr,tolU,tolV)) {
 	      // treat both ends
-	      Standard_Real UMinChP,UMaxChP,UMinArP,UMaxArP;
+	      Standard_Real UMinChP,UMinArP,UMaxArP;
 	      UMinChP = IntegerPart(UMinCh); UMinArP = IntegerPart(UMinAr);
-	      UMaxChP = IntegerPart(UMaxCh); UMaxArP = IntegerPart(UMaxAr);
-	      Standard_Integer irangCh1,irangCh2,irangAr1,irangAr2;
-	      irangCh1 = Standard_Integer(UMinChP)+1; irangCh2 = Standard_Integer(UMaxChP)+1;
+	                                     UMaxArP = IntegerPart(UMaxAr);
+	      Standard_Integer irangAr1,irangAr2;
 	      irangAr1 = Standard_Integer(UMinArP)+1; irangAr2 = Standard_Integer(UMaxArP)+1;
 	      UMinChP = UMinCh - UMinChP; UMinArP = UMinAr - UMinArP;
 	      //UMaxChP = UMaxCh - UMaxChP; UMaxArP = UMaxAr - UMaxArP;
Index: oce/src/IntPatch/IntPatch_WLine.cxx
===================================================================
--- oce.orig/src/IntPatch/IntPatch_WLine.cxx
+++ oce/src/IntPatch/IntPatch_WLine.cxx
@@ -236,9 +236,6 @@ void IntPatch_WLine::ComputeVertexParame
   Standard_Integer indicevertexonline;
   Standard_Real    indicevertex;
 
-  Standard_Real ParamMinOnLine,ParamMaxOnLine;
-  if(fipt) { ParamMinOnLine = Vertex(indf).ParameterOnLine(); } else { ParamMinOnLine = -100000.0; } 
-  if(lapt) { ParamMaxOnLine = Vertex(indl).ParameterOnLine(); } else { ParamMaxOnLine =  100000.0; } 
   Standard_Boolean APointDeleted = Standard_False;
   //----------------------------------------------------------
   //--     F i l t r e   s u r   r e s t r i c t i o n s   --
Index: oce/src/IntPolyh/IntPolyh_Intersection.cxx
===================================================================
--- oce.orig/src/IntPolyh/IntPolyh_Intersection.cxx
+++ oce/src/IntPolyh/IntPolyh_Intersection.cxx
@@ -70,8 +70,6 @@ void IntPolyh_Intersection::Perform() {
   Standard_Integer nbCouplesStd = 0;
   Standard_Integer nbCouplesAdv = 0;
   
-  GeomAbs_SurfaceType ST1 = mySurf1->GetType();
-  GeomAbs_SurfaceType ST2 = mySurf2->GetType();
 
 //   if(ST1 == GeomAbs_Torus || ST2 == GeomAbs_Torus)
 //     startFromAdvanced = Standard_True;
Index: oce/src/IntPolyh/IntPolyh_MaillageAffinage_1.cxx
===================================================================
--- oce.orig/src/IntPolyh/IntPolyh_MaillageAffinage_1.cxx
+++ oce/src/IntPolyh/IntPolyh_MaillageAffinage_1.cxx
@@ -82,10 +82,6 @@ void IntPolyh_MaillageAffinage::FillArra
 
   //cout << "Nb : " << NbSamplesU << " " << NbSamplesV << endl;
 
-  Standard_Real u0 = Upars(1);
-  Standard_Real v0 = Vpars(1);
-  Standard_Real u1 = Upars(NbSamplesU);
-  Standard_Real v1 = Vpars(NbSamplesV);
   IntCurveSurface_ThePolyhedronOfHInter polyhedron(MaSurface, Upars, Vpars);
   Tol=polyhedron.DeflectionOverEstimation();
 
@@ -135,10 +131,6 @@ void IntPolyh_MaillageAffinage::FillArra
   //cout << "FillArrayOfPnt 2" << endl;
   //cout << "??????????????" << endl;
   Standard_Real resol = gp::Resolution();
-  Standard_Real u0 = Upars(1);
-  Standard_Real v0 = Vpars(1);
-  Standard_Real u1 = Upars(NbSamplesU);
-  Standard_Real v1 = Vpars(NbSamplesV);
   IntCurveSurface_ThePolyhedronOfHInter polyhedron(MaSurface, Upars, Vpars);
   Tol=polyhedron.DeflectionOverEstimation();
 
Index: oce/src/IntRes2d/IntRes2d_Intersection.cxx
===================================================================
--- oce.orig/src/IntRes2d/IntRes2d_Intersection.cxx
+++ oce/src/IntRes2d/IntRes2d_Intersection.cxx
@@ -233,40 +233,16 @@ void IntRes2d_Intersection::Append( cons
 	const IntRes2d_IntersectionPoint& AnP1=lseg(j).FirstPoint();
 	Standard_Real AnP1PParamOnFirst=AnP1.ParamOnFirst();
 	Standard_Real AnP1PParamOnSecond=AnP1.ParamOnSecond();
-#if DEB
-	const IntRes2d_Transition& AnP1T1=AnP1.TransitionOfFirst();
-#else
-        AnP1.TransitionOfFirst();
-#endif
-#if DEB
-	const IntRes2d_Transition& AnP1T2=AnP1.TransitionOfSecond();
-#else
-        AnP1.TransitionOfSecond();
-#endif
-#if DEB
-	const gp_Pnt2d& AnPt1=AnP1.Value();
-#else
-        AnP1.Value();
-#endif
+    AnP1.TransitionOfFirst();
+    AnP1.TransitionOfSecond();
+    AnP1.Value();
 	
 	const IntRes2d_IntersectionPoint& AnP2=lseg(j).LastPoint();
 	Standard_Real AnP2PParamOnFirst=AnP2.ParamOnFirst();
 	Standard_Real AnP2PParamOnSecond=AnP2.ParamOnSecond();
-#if DEB
-	const IntRes2d_Transition& AnP2T1=AnP2.TransitionOfFirst();
-#else
-        AnP2.TransitionOfFirst();
-#endif
-#if DEB
-	const IntRes2d_Transition& AnP2T2=AnP2.TransitionOfSecond();
-#else
-        AnP2.TransitionOfSecond();
-#endif
-#if DEB
-	const gp_Pnt2d& AnPt2=AnP2.Value();
-#else
-        AnP2.Value();
-#endif
+    AnP2.TransitionOfFirst();
+    AnP2.TransitionOfSecond();
+    AnP2.Value();
 
 
 	if(Opposite == lseg(j).IsOpposite()) {
Index: oce/src/IntTools/IntTools.cxx
===================================================================
--- oce.orig/src/IntTools/IntTools.cxx
+++ oce/src/IntTools/IntTools.cxx
@@ -209,8 +209,7 @@
     anArray1OfRoots(j)=mySequenceOfRoots(j);
   }
   
-  IntTools_QuickSort aQS;
-  aQS.Sort(anArray1OfRoots, aComparator);
+  IntTools_QuickSort::Sort(anArray1OfRoots, aComparator);
   
   mySequenceOfRoots.Clear();
   for (j=1; j<=aNbRoots; j++) {
@@ -225,14 +224,13 @@
 				 const Standard_Real myEpsNull)
 {
   Standard_Integer aType, j, aNbRoots;
-  Standard_Real t, t1, t2, f1, f2, absf1, absf2;
+  Standard_Real t1, t2, f1, f2, absf2;
 
   aNbRoots=mySequenceOfRoots.Length();
 
   for (j=1; j<=aNbRoots; j++) {
     IntTools_Root& aR=mySequenceOfRoots.ChangeValue(j);
     
-    t=aR.Root();
     aR.Interval (t1, t2, f1, f2);
 
     aType=aR.Type();
@@ -254,7 +252,6 @@
       break;
       
     case 2: // Smart;
-      absf1=fabs(f1);
       absf2=fabs(f2);
       if (absf2 < myEpsNull) {
 	aR.SetStateAfter (TopAbs_ON);
Index: oce/src/IntTools/IntTools_Context.cxx
===================================================================
--- oce.orig/src/IntTools/IntTools_Context.cxx
+++ oce/src/IntTools/IntTools_Context.cxx
@@ -432,8 +432,7 @@
 							 const Standard_Real aTol) 
 {
   Standard_Boolean bFlag;
-  Standard_Real Umin, myEpsT, U, V;
-  myEpsT=1.e-12;
+  Standard_Real Umin, U, V;
 
   GeomAPI_ProjectPointOnSurf& aProjector=ProjPS(aF);
   aProjector.Perform(aP);
@@ -482,14 +481,12 @@
 							  const Standard_Real aTol) 
 {
   Standard_Boolean bFlag;
-  Standard_Real aTInterm, aFirst, aLast;
+  Standard_Real aTInterm;
   gp_Pnt aPInterm;
 
   aTInterm=IntTools_Tools::IntermediatePoint(aT1, aT2);
 
   Handle(Geom_Curve) aC3D=aC.Curve();
-  aFirst=aC3D->FirstParameter();
-  aLast =aC3D->LastParameter();
   // point 3D
   aC3D->D0(aTInterm, aPInterm);
   //
Index: oce/src/IntTools/IntTools_EdgeEdge.cxx
===================================================================
--- oce.orig/src/IntTools/IntTools_EdgeEdge.cxx
+++ oce/src/IntTools/IntTools_EdgeEdge.cxx
@@ -455,7 +455,7 @@
 					       Standard_Real& tRoot)
 {
   Standard_Real tm, t1, t2;
-  Standard_Integer anIsProj1, anIsProj2, anIsProjm;
+  Standard_Integer anIsProj1, anIsProjm;
   //
   // Root can be on the ends of [tt1, tt2]
   Standard_Integer anOldErrorStatus=myErrorStatus;
@@ -480,7 +480,6 @@
   t1=tt1;  
   t2=tt2;
   anIsProj1=ff1;
-  anIsProj2=ff2;
   
   while (1) {
     if (fabs(t1-t2) < myEpsT) {
@@ -492,7 +491,6 @@
     
     if (anIsProjm != anIsProj1) {
       t2=tm;
-      anIsProj2=anIsProjm;
     }
     else {
       t1=tm;
@@ -787,7 +785,7 @@
   //
   //
   Standard_Boolean aVFlag1, aVFlag2, aGeomFlag1, aGeomFlag2;
-  Standard_Real Df2m2, Dm2l2, Df2l2, df2m2, dm2l2, df2l2, df1m1, dm1l1, df1l1;
+  Standard_Real Df2m2, Dm2l2, Df2l2, df2m2, dm2l2, df2l2, df1l1;
   Standard_Real tV1, tV2;
   //
   // parametric differences for C2
@@ -823,8 +821,6 @@
   }
   //
   // geometric distances for C1
-  df1m1=aPf1.Distance(aPm1);
-  dm1l1=aPm1.Distance(aPl1);
   df1l1=aPf1.Distance(aPl1);
   //
   // if geometric distances between boundaries is less than myCriteria
@@ -950,7 +946,7 @@
   void IntTools_EdgeEdge::IsIntersection (const Standard_Real ta, 
 					  const Standard_Real tb) 
 {
-  Standard_Integer i, aNb, pri;
+  Standard_Integer i, aNb;
   Standard_Real t, f;
   GeomAbs_CurveType aCT1, aCT2;
   IntTools_CArray1OfReal anArgs, aFunc;
@@ -1006,7 +1002,7 @@
   }
   //
   // Prepare values of arguments for the interval [ta, tb]
-  pri=IntTools::PrepareArgs (myCFrom, tb, ta, myDiscret, myDeflection, anArgs);
+  IntTools::PrepareArgs (myCFrom, tb, ta, myDiscret, myDeflection, anArgs);
   aNb=anArgs.Length();
 
   aFunc.Resize(aNb);
@@ -1030,7 +1026,7 @@
 					     const IntTools_CArray1OfReal& f)  
 {
   Standard_Integer i, n, k;
-  Standard_Real fr, tr, anEpsNull;
+  Standard_Real tr, anEpsNull;
   IntTools_CArray1OfReal fd;
   TColStd_SequenceOfReal aTSeq, aFSeq;
   
@@ -1077,7 +1073,6 @@
     //aa
     if (fd1*fd2 < 0.) {
       tr=FindSimpleRoot(2, t1, t2, fd1);
-      fr=DistanceFunction(tr);
       myPar1=tr;
       myParallel=Standard_False;
       break;
@@ -1085,7 +1080,6 @@
     
     if (!bF1 && bF2) {
       tr=t2;
-      fr=fd2;
       myPar1=tr;
       myParallel=Standard_False;
       break;
@@ -1093,7 +1087,6 @@
     
     if (bF1 && !bF2) {
       tr=t1;
-      fr=fd1;
       myPar1=tr;
       myParallel=Standard_False;
       break;
@@ -1341,7 +1334,7 @@
   Standard_Real aTFR1, aTLR1, aTFR2, aTLR2;
   Standard_Real aTL1, aTL2, aTC1, aTC2;
   Standard_Real aRC, aDLC, aD2, aC2, aTLx, aTCx;
-  GeomAbs_CurveType aTFrom, aTTo;
+  GeomAbs_CurveType aTFrom;
   gp_Circ aCirc;
   gp_Lin  aLine;
   gp_Pnt aPC, aPLx, aPCx;
@@ -1351,7 +1344,6 @@
   (aCP.Ranges2())(1).Range(aTFR2, aTLR2);
   //
   aTFrom=myCFrom.GetType();
-  aTTo  =myCTo.GetType();
   //
   aTL1=aTFR1;
   aTL2=aTLR1;
@@ -1527,13 +1519,12 @@
      (myCFrom.GetType() == GeomAbs_Circle && myCTo.GetType() == GeomAbs_Line))
   {
     Standard_Real aRadius;
-    GeomAbs_CurveType aTFrom, aTTo;
+    GeomAbs_CurveType aTFrom;
     gp_Circ aCirc;
     gp_Lin  aLine;
     gp_Pnt aPCenter, aPOnLine;
 
     aTFrom=myCFrom.GetType();
-    aTTo  =myCTo.GetType();
     
     if (aTFrom==GeomAbs_Circle) {
       aCirc=myCFrom.Circle();
Index: oce/src/IntTools/IntTools_EdgeFace.cxx
===================================================================
--- oce.orig/src/IntTools/IntTools_EdgeFace.cxx
+++ oce/src/IntTools/IntTools_EdgeFace.cxx
@@ -355,14 +355,13 @@ static
 					       Standard_Real& tRoot)
 {
   Standard_Real tm, t1, t2, aEpsT;
-  Standard_Integer anIsProj1, anIsProj2, anIsProjm;
+  Standard_Integer anIsProj1, anIsProjm;
   aEpsT=0.5*myEpsT;
   //
   // Root is inside [tt1, tt2]
   t1=tt1;  
   t2=tt2;
   anIsProj1=ff1;
-  anIsProj2=ff2;
   
   while (1) {
     if (fabs(t1-t2) < aEpsT) {
@@ -374,7 +373,6 @@ static
     
     if (anIsProjm != anIsProj1) {
       t2=tm;
-      anIsProj2=anIsProjm;
     }
     else {
       t1=tm;
@@ -649,9 +647,6 @@ static
 
   k=n-1;
   for (i=1; i<k; i++) {
-    Standard_Real ti, ti1;
-    ti=t(i);
-    ti1=t(i-1);
     fd(i)=.5*(f(i+1)-f(i-1))/(t(i)-t(i-1));
     if (fabs(fd(i)) < dEpsNull){
       fd(i)=0.;
@@ -730,9 +725,8 @@ static
       anArray1OfRange(n+i).SetLast (aFSeq(i));
     }
     
-    IntTools_QuickSortRange aQuickSortRange;
     IntTools_CompareRange aComparator;
-    aQuickSortRange.Sort (anArray1OfRange, aComparator);
+    IntTools_QuickSortRange::Sort (anArray1OfRange, aComparator);
     
     // filling the  output arrays
     myArgsArray.Resize(k);
@@ -857,7 +851,7 @@ static
   Standard_Integer IntTools_EdgeFace::MakeType(IntTools_CommonPrt&  aCommonPrt)
 {
   Standard_Real  af1, al1;
-  Standard_Real dt, df1, df2, tm;
+  Standard_Real df1, tm;
   Standard_Boolean bAllNullFlag;
   //
   bAllNullFlag=aCommonPrt.AllNullFlag();
@@ -954,13 +948,13 @@ static
 					  const Standard_Real tb) 
 {
   IntTools_CArray1OfReal anArgs, aFunc;
-  Standard_Integer i, aNb, pri, aCnt=0;
+  Standard_Integer i, aNb, aCnt=0;
   //
   Standard_Integer aCntIncreasing=1, aCntDecreasing=1;
   Standard_Real t, f, f1;
   //
   // Prepare values of arguments for the interval [ta, tb]
-  pri=IntTools::PrepareArgs (myC, tb, ta, myDiscret, myDeflection, anArgs);
+  IntTools::PrepareArgs (myC, tb, ta, myDiscret, myDeflection, anArgs);
   aNb=anArgs.Length();
   
   aFunc.Resize(aNb);
@@ -1021,7 +1015,7 @@ static
 					     const IntTools_CArray1OfReal& f)  
 {
   Standard_Integer i, n, k;
-  Standard_Real fr, tr;
+  Standard_Real tr;
   IntTools_CArray1OfReal fd;
   TColStd_SequenceOfReal aTSeq, aFSeq;  
   
@@ -1068,7 +1062,7 @@ static
     //
     if (fd1*fd2 < 0.) {
       tr=FindSimpleRoot(2, t1, t2, fd1);
-      fr=DistanceFunction(tr);
+      DistanceFunction(tr);
       myPar1=tr;
       myParallel=Standard_False;
       break;
@@ -1076,7 +1070,6 @@ static
     
     if (!bF1 && bF2) {
       tr=t2;
-      fr=fd2;
       myPar1=tr;
       myParallel=Standard_False;
       break;
@@ -1084,7 +1077,6 @@ static
     
     if (bF1 && !bF2) {
       tr=t1;
-      fr=fd1;
       myPar1=tr;
       myParallel=Standard_False;
       break;
@@ -1567,17 +1559,14 @@ Standard_Integer AdaptiveDiscret (const
 
   iDiscretNew=iDiscret;
 
-  GeomAbs_CurveType   aCType;
   GeomAbs_SurfaceType aSType;
 
-  aCType=aCurve.GetType();
   aSType=aSurface.GetType();
     
   if (aSType==GeomAbs_Cylinder) {
-   Standard_Real aELength, aRadius, dL, dLR;
+   Standard_Real aELength, aRadius, dLR;
 
    aELength=IntTools::Length(aCurve.Edge());
-   dL=aELength/iDiscret;
    
    gp_Cylinder aCylinder=aSurface.Cylinder();
    aRadius=aCylinder.Radius();
Index: oce/src/IntTools/IntTools_FaceFace.cxx
===================================================================
--- oce.orig/src/IntTools/IntTools_FaceFace.cxx
+++ oce/src/IntTools/IntTools_FaceFace.cxx
@@ -388,7 +388,7 @@ void IntTools_FaceFace::SetList(IntSurf_
   void IntTools_FaceFace::Perform(const TopoDS_Face& aF1,
 				  const TopoDS_Face& aF2)
 {
-  Standard_Boolean hasCone, RestrictLine, bTwoPlanes, bReverse;
+  Standard_Boolean hasCone, RestrictLine, bReverse;
   Standard_Integer aNbLin, aNbPnts, i, NbLinPP;
   Standard_Real TolArc, TolTang, Deflection, UVMaxStep;
   Standard_Real umin, umax, vmin, vmax;
@@ -404,7 +404,6 @@ void IntTools_FaceFace::SetList(IntSurf_
   myIsDone = Standard_False;
   myNbrestr=0;//?
   hasCone = Standard_False;
-  bTwoPlanes = Standard_False;
   //
   myFace1=aF1;
   myFace2=aF2;
@@ -445,7 +444,6 @@ void IntTools_FaceFace::SetList(IntSurf_
   //
   NbLinPP = 0;
   if(aType1==GeomAbs_Plane && aType2==GeomAbs_Plane){
-    bTwoPlanes = Standard_True;
 
     BRepTools::UVBounds(myFace1, umin, umax, vmin, vmax);
     myHS1->ChangeSurface().Load(S1, umin, umax, vmin, vmax);
Index: oce/src/LDOM/LDOMParser.cxx
===================================================================
--- oce.orig/src/LDOM/LDOMParser.cxx
+++ oce/src/LDOM/LDOMParser.cxx
@@ -148,7 +148,6 @@ Standard_Boolean LDOMParser::ParseDocume
 {
   Standard_Boolean      isError   = Standard_False;
   Standard_Boolean      isElement = Standard_False;
-  Standard_Boolean      isHeader  = Standard_False;
   Standard_Boolean      isDoctype = Standard_False;
 
   while (1) {
@@ -160,7 +159,6 @@ Standard_Boolean LDOMParser::ParseDocume
         isError = Standard_True;
         break;
       }
-      isHeader = Standard_True;
       continue;
     case LDOM_XmlReader::XML_DOCTYPE:
       if (isElement) {
Index: oce/src/Law/Law_Interpol.cxx
===================================================================
--- oce.orig/src/Law/Law_Interpol.cxx
+++ oce/src/Law/Law_Interpol.cxx
@@ -91,10 +91,6 @@ void Law_Interpol::Set(const TColgp_Arra
 		       const Standard_Boolean Periodic)
 {
   Standard_Integer l = ParAndRad.Lower();
-#ifdef DEB
-  Standard_Integer u = 
-#endif
-    ParAndRad.Upper();
   Standard_Integer nbp = ParAndRad.Length();
 
   Handle(TColStd_HArray1OfReal) par = new TColStd_HArray1OfReal(1,nbp);
@@ -169,10 +165,6 @@ void Law_Interpol::Set(const TColgp_Arra
 		       const Standard_Boolean Periodic)
 {
   Standard_Integer l = ParAndRad.Lower();
-#ifdef DEB
-  Standard_Integer u = 
-#endif
-    ParAndRad.Upper();
   Standard_Integer nbp = ParAndRad.Length();
 
   Handle(TColStd_HArray1OfReal) par = new TColStd_HArray1OfReal(1,nbp);
Index: oce/src/LocOpe/LocOpe.cxx
===================================================================
--- oce.orig/src/LocOpe/LocOpe.cxx
+++ oce/src/LocOpe/LocOpe.cxx
@@ -155,7 +155,6 @@ Standard_Boolean LocOpe::TgtFaces(const
   gp_Vec d1,d2;
 
   Standard_Real uu, vv;
-  Standard_Real angle[21];
 
   Standard_Integer i;
   for(i = 0; i <= 20; i++){
@@ -170,7 +169,6 @@ Standard_Boolean LocOpe::TgtFaces(const
     d2 = (du.Crossed(dv)).Normalized();
     if(rev2) d2.Reverse();
     ang = d1.Angle(d2);
-    angle[i] = ang;
     if(ang <= angmin) angmin = ang;
     if(ang >= angmax) angmax = ang;
   }
Index: oce/src/LocOpe/LocOpe_BuildWires.cxx
===================================================================
--- oce.orig/src/LocOpe/LocOpe_BuildWires.cxx
+++ oce/src/LocOpe/LocOpe_BuildWires.cxx
@@ -150,7 +150,6 @@ void LocOpe_BuildWires::Perform(const To
 
     TopoDS_Wire newWire;
     B.MakeWire(newWire);
-    Standard_Integer BorneInf;
 
     if (mapV.Contains(VL)) { // on sort avec une boucle a recreer
       TopoDS_Vertex Vf;
@@ -169,14 +168,12 @@ void LocOpe_BuildWires::Perform(const To
 	}
 	mapV.Remove(Vf);
       }
-      BorneInf = j;
       for (; j<= mapE.Extent(); j++) {
 	B.Add(newWire,mapE(j));
       }
       newWire.Closed(Standard_True);
     }
     else { // on sort sur un bord : wire ouvert...
-      BorneInf = 1;
       mapV.Add(VL);
       for (Standard_Integer j = 1; j <= mapE.Extent(); j++) {
 	B.Add(newWire,mapE(j));
Index: oce/src/LocOpe/LocOpe_Builder.cxx
===================================================================
--- oce.orig/src/LocOpe/LocOpe_Builder.cxx
+++ oce/src/LocOpe/LocOpe_Builder.cxx
@@ -75,7 +75,7 @@ void RemoveFaces(const TopoDS_Shape& the
     aCompMap.Add(anExp.Current());
   }
 
-  Standard_Integer aNbFFs=aFFs.Extent(), i, j, aNbS, aNbCurves, nSect;
+  Standard_Integer aNbFFs=aFFs.Extent(), i, j, aNbCurves, nSect;
 
     for (i=1; i<=aNbFFs; ++i) {
       BOPTools_SSInterference& aFFi=aFFs(i);
@@ -83,7 +83,6 @@ void RemoveFaces(const TopoDS_Shape& the
       //
       // Old Section Edges
       const BOPTools_ListOfPaveBlock& aSectList=aFFi.PaveBlocks();
-      aNbS=aSectList.Extent();
       BOPTools_ListIteratorOfListOfPaveBlock anIt(aSectList);
       for (; anIt.More();anIt.Next()) {
 	const BOPTools_PaveBlock& aPB=anIt.Value();
@@ -112,7 +111,6 @@ void RemoveFaces(const TopoDS_Shape& the
       for (j=1; j<=aNbCurves; j++) {
 	BOPTools_Curve& aBC=aBCurves(j);
 	const BOPTools_ListOfPaveBlock& aSectEdges=aBC.NewPaveBlocks();
-	aNbS=aSectEdges.Extent();
 	
 	BOPTools_ListIteratorOfListOfPaveBlock aPBIt(aSectEdges);
 	for (; aPBIt.More(); aPBIt.Next()) {
Index: oce/src/LocOpe/LocOpe_CSIntersector.cxx
===================================================================
--- oce.orig/src/LocOpe/LocOpe_CSIntersector.cxx
+++ oce/src/LocOpe/LocOpe_CSIntersector.cxx
@@ -137,10 +137,6 @@ void LocOpe_CSIntersector::Perform(const
   for (; exp.More(); exp.Next()) {
     const TopoDS_Face& theface = TopoDS::Face(exp.Current());
     IntCurvesFace_Intersector theInt(theface,0.);
-#ifdef DEB
-    TopAbs_Orientation orface =
-#endif
-                                theface.Orientation();
     for (Standard_Integer i = 1; i<=myNbelem; i++) {
 
       HC->ChangeCurve().Load(new Geom_Circle(Scir(i)));
@@ -179,10 +175,6 @@ void LocOpe_CSIntersector::Perform(const
   for (; exp.More(); exp.Next()) {
     const TopoDS_Face& theface = TopoDS::Face(exp.Current());
     IntCurvesFace_Intersector theInt(theface,0.);
-#ifdef DEB
-    TopAbs_Orientation orface =
-#endif
-                                theface.Orientation();
     for (Standard_Integer i = 1; i<=myNbelem; i++) {
       if (Scur(i).IsNull()) {
 	continue;
@@ -599,10 +591,6 @@ static void AddPoints(IntCurvesFace_Inte
   Standard_Integer nbpoints = theSeq.Length();
   Standard_Integer newpnt = theInt.NbPnt();
   Standard_Real param,paramu,paramv;
-#ifdef DEB
-  TopAbs_Orientation orface =
-#endif
-                              theface.Orientation();
   for (Standard_Integer j = 1; j<=newpnt; j++) {
     const gp_Pnt& thept = theInt.Pnt(j);
     param = theInt.WParameter(j);
Index: oce/src/LocOpe/LocOpe_Generator.cxx
===================================================================
--- oce.orig/src/LocOpe/LocOpe_Generator.cxx
+++ oce/src/LocOpe/LocOpe_Generator.cxx
@@ -235,7 +235,7 @@ void LocOpe_Generator::Perform(const Han
   TopTools_ListOfShape RebuildFace;
   TopTools_MapOfShape mapTreated;
   TopTools_DataMapOfShapeShape DontFuse;
-  TopAbs_Orientation orient,orface,orsav;
+  TopAbs_Orientation orient,orface;
 
   for (itf.Reset(); itf.More(); itf.Next()) {
     const TopoDS_Face& fac = TopoDS::Face(itf.Key());
@@ -451,7 +451,6 @@ void LocOpe_Generator::Perform(const Han
   for (itf.Reset();itf.More(); itf.Next()) {
     const TopoDS_Face& fac = TopoDS::Face(itf.Key());
     Standard_Boolean ModFace = Standard_False;
-    Standard_Boolean HasWire = Standard_False;
     TopTools_ListOfShape listofedg;
 
     EdgAdded.Clear();
@@ -486,7 +485,6 @@ void LocOpe_Generator::Perform(const Han
 	for (exp2.Init(wir,TopAbs_EDGE); exp2.More(); exp2.Next()) {
 	  listofedg.Append(exp2.Current());
 	}
-	HasWire = Standard_True;
       }
       else {
 	if (!ModFace) { 
@@ -578,19 +576,16 @@ void LocOpe_Generator::Perform(const Han
 		  }
 		}
 //		B.Add(newface,theNew);
-		HasWire = Standard_True;
 	      }
 	    }
 	  }
 	  ModFace = Standard_True;
 	}
 	
-	orsav = wir.Orientation();
 	// reconstruction du wire
 	//B.MakeWire(newwire);
 
 	Handle(Geom2d_Curve) C2d,C2d1;
-	Standard_Boolean EmptyWire = Standard_True;
     
 //	for (exp2.Init(wir.Oriented(TopAbs_FORWARD),TopAbs_EDGE); 
 	for (exp2.Init(wir,TopAbs_EDGE); exp2.More(); exp2.Next()) {
@@ -600,7 +595,6 @@ void LocOpe_Generator::Perform(const Han
 //	    B.Add(newwire,edg.Oriented(or));
 //            listofedg.Append(edg.Oriented(or));
             listofedg.Append(edg);
-	    EmptyWire = Standard_False;
 	  }
 	  else if (myModShapes.IsBound(edg) || theEEMap.IsBound(edg)) {
 	    if (myModShapes.IsBound(edg)) {
@@ -611,7 +605,6 @@ void LocOpe_Generator::Perform(const Han
 	    }
 //	    B.Add(newwire,newedg.Oriented(or));
 	    listofedg.Append(newedg.Oriented(orient));
-	    EmptyWire = Standard_False;
 	    C = BRep_Tool::Curve(newedg,loc,f,l);
 	    if (!loc.IsIdentity()) {
 	      Handle(Geom_Geometry) GG = C->Transformed(loc.Transformation());
@@ -858,7 +851,6 @@ void LocOpe_Generator::Perform(const Han
 		orient = TopAbs::Compose(orface,edg.Orientation());
 		//		B.Add(newwire,edg.Oriented(or));
 		listofedg.Append(edg.Oriented(orient));
-		EmptyWire = Standard_False;
 		EdgAdded.Add(edg);
 		if (P.IsNull()) {  
 		  // on met les courbes 2d si on n`est pas sur un plan
@@ -910,10 +902,7 @@ void LocOpe_Generator::Perform(const Han
       L.AddConstEdges(listofedg);
       L.Perform();
       L.WiresToFaces();
-#ifdef DEB
-      const TopTools_ListOfShape& listofwires =
-#endif
-                                                L.NewWires();
+      L.NewWires();
       const TopTools_ListOfShape& listoffaces = L.NewFaces();
       toRemove.Add(fac);
       //      if (!HasWire) {
Index: oce/src/LocOpe/LocOpe_SplitDrafts.cxx
===================================================================
--- oce.orig/src/LocOpe/LocOpe_SplitDrafts.cxx
+++ oce/src/LocOpe/LocOpe_SplitDrafts.cxx
@@ -1139,10 +1139,6 @@ void LocOpe_SplitDrafts::Perform(const T
 
 		  TopoDS_Vertex Vf2,Vl2;
 		  TopExp::Vertices(TopoDS::Edge(Gvf),Vf2,Vl2);
-#ifdef DEB
-		  TopAbs_Orientation ornw =
-#endif
-                                            NewEdg.Orientation();
 
 		  // ici bug orientation : voir tspdrft6
 
@@ -1170,10 +1166,6 @@ void LocOpe_SplitDrafts::Perform(const T
 
 		  TopoDS_Vertex Vf2,Vl2;
 		  TopExp::Vertices(TopoDS::Edge(Gvl),Vf2,Vl2);
-#ifdef DEB
-		  TopAbs_Orientation ornw =
-#endif
-                                            NewEdg.Orientation();
 
 		  // ici bug orientation : voir tspdrft6
 
@@ -1602,10 +1594,9 @@ static TopoDS_Edge  NewEdge(const TopoDS
   Standard_Real prmf=0,prml=0;
   GeomAdaptor_Curve TheCurve;
 	
-  Standard_Integer i,imin,k;
+  Standard_Integer i,k;
   gp_Pnt pvf = BRep_Tool::Pnt(V1);
   gp_Pnt pvl = BRep_Tool::Pnt(V2);
-  imin = 0;
   for (i=1; i<= i2s.NbLines(); i++) {
     TheCurve.Load(i2s.Line(i));
     Extrema_ExtPC myExtPC(pvf,TheCurve);
Index: oce/src/LocOpe/LocOpe_SplitShape.cxx
===================================================================
--- oce.orig/src/LocOpe/LocOpe_SplitShape.cxx
+++ oce/src/LocOpe/LocOpe_SplitShape.cxx
@@ -950,10 +950,6 @@ static Standard_Boolean IsInside(const T
   TopoDS_Shape aLocalShape = F.EmptyCopied();
   TopoDS_Face newFace = TopoDS::Face(aLocalShape);
   //  TopoDS_Face newFace = TopoDS::Face(F.EmptyCopied());
-#ifdef DEB
-  TopAbs_Orientation orWire =
-#endif
-    W2.Orientation();
   newFace.Orientation(TopAbs_FORWARD);
   B.Add(newFace,W2);
   //  GProp_GProps GP;
Index: oce/src/MAT2d/MAT2d_Circuit.cxx
===================================================================
--- oce.orig/src/MAT2d/MAT2d_Circuit.cxx
+++ oce/src/MAT2d/MAT2d_Circuit.cxx
@@ -520,8 +520,8 @@ void  MAT2d_Circuit::InsertCorner (TColG
   if (AffichCircuit) {
     if (Insert) {
       Curve      = Handle(Geom2d_TrimmedCurve)::DownCast(Line.Value(isuiv));
-      gp_Pnt2d P = Curve->StartPoint();
 #ifdef DRAW
+      gp_Pnt2d P = Curve->StartPoint();
       Handle(Draw_Marker2D) dr = new Draw_Marker2D(P,Draw_Plus,Draw_vert); 
       dout << dr;
       dout.Flush();
@@ -787,22 +787,19 @@ static Standard_Boolean IsSharpCorner (c
 #ifdef DEB
   static Standard_Boolean Affich = 0;
   if (Affich) {
+#ifdef DRAW
     Standard_Real DU1 = (OC1.LastParameter() - OC1.FirstParameter())/9.;
     Standard_Real DU2 = (OC2.LastParameter() - OC2.FirstParameter())/9.;
     for (Standard_Integer ki = 0; ki <= 9; ki++) {
       gp_Pnt2d P1 = OC1.Value(OC1.FirstParameter()+ki*DU1);
       gp_Pnt2d P2 = OC2.Value(OC2.FirstParameter()+ki*DU2);
-#ifdef DRAW
       Handle(Draw_Marker2D) dr1 = new Draw_Marker2D(P1,Draw_Plus,Draw_vert);
       Handle(Draw_Marker2D) dr2 = new Draw_Marker2D(P2,Draw_Plus,Draw_rouge); 
       dout << dr1;
       dout << dr2;
     }
     dout.Flush();
-#else
-  }
 #endif
-  
   }
 #endif
   
Index: oce/src/MAT2d/MAT2d_Tool2d.cxx
===================================================================
--- oce.orig/src/MAT2d/MAT2d_Tool2d.cxx
+++ oce/src/MAT2d/MAT2d_Tool2d.cxx
@@ -396,11 +396,7 @@ void MAT2d_Tool2d::TrimBisec (      Bise
   
   //gp_Vec2d             Tan1,Tan2;
   gp_Pnt2d             Ori; //PEdge;
-  Standard_Integer     IPrec,INext;
-#ifdef DEB
-  Standard_Real        Tolerance = MAT2d_TOLCONF;
-#endif
-  IPrec = (IndexEdge == 1)  ? theCircuit->NumberOfItems() : (IndexEdge - 1);
+  Standard_Integer     INext;
   INext = (IndexEdge == theCircuit->NumberOfItems()) ? 1  : (IndexEdge + 1);
   
   Handle(Standard_Type) EdgeType = theCircuit->Value(IndexEdge)->DynamicType();
@@ -528,7 +524,6 @@ Standard_Boolean MAT2d_Tool2d::Projectio
   Handle(Standard_Type)       Type   = Elt->DynamicType();	
   Handle(Geom2d_TrimmedCurve) Curve; 
   Standard_Integer            INext;   
-  Standard_Real               ParameterOnC;
   Standard_Real               Eps = MAT2d_TOLCONF;//*10.;
 
   if (Type == STANDARD_TYPE(Geom2d_CartesianPoint)) {	
@@ -579,7 +574,6 @@ Standard_Boolean MAT2d_Tool2d::Projectio
       if (Extremas.NbExt() == 0 ) return Standard_False; // Pas de solution!
       for (Standard_Integer i = 1; i <= Extremas.NbExt(); i++) {
 	if (Extremas.SquareDistance(i) < Distance * Distance) {
-	  ParameterOnC  = Extremas.Point(i).Parameter();
 	  Distance      = sqrt (Extremas.SquareDistance(i));
 	}
       }
Index: oce/src/MFT/MFT_FontManager.cxx
===================================================================
--- oce.orig/src/MFT/MFT_FontManager.cxx
+++ oce/src/MFT/MFT_FontManager.cxx
@@ -1736,7 +1736,6 @@ TCollection_ExtendedString estring(aStri
 // =============================================================================
 
 void MFT_FontManager::DrawText(const Handle(MFT_TextManager)& aTextManager, const Standard_CString aString, const Quantity_Length anX, const Quantity_Length anY, const Quantity_PlaneAngle anOrientation) {
-Standard_Boolean vazy;
 
     this->SetTextAttribs(aString,anOrientation);
 
@@ -1751,7 +1750,7 @@ Standard_Boolean vazy;
 				Cwidth,Cheight,Cslant,myPaintType);
     while ( theCharCount < theStringLength ) {
       aPosition = Standard_Integer((unsigned char)theAsciiString.Value(theCharCount+1));
-      vazy = this->DrawChar(aTextManager,aPosition);
+      this->DrawChar(aTextManager,aPosition);
       theCharCount++;
     }
     aTextManager->EndString();
@@ -1768,7 +1767,6 @@ Standard_Boolean vazy;
 // =============================================================================
 
 void MFT_FontManager::DrawText(const Handle(MFT_TextManager)& aTextManager, const Standard_ExtString aString, const Quantity_Length anX, const Quantity_Length anY, const Quantity_PlaneAngle anOrientation) {
-Standard_Boolean vazy;
 
     this->SetTextAttribs(aString,anOrientation);
 
@@ -1786,7 +1784,7 @@ Standard_Boolean vazy;
         aPosition = Standard_Integer((unsigned char)theAsciiString.Value(theCharCount+1));
       else
         aPosition = Standard_Integer((unsigned short)theExtendedString.Value(theCharCount+1));
-      vazy = this->DrawChar(aTextManager,aPosition);
+      this->DrawChar(aTextManager,aPosition);
       theCharCount++;
     }
     aTextManager->EndString();
Index: oce/src/MXCAFDoc/MXCAFDoc_AreaRetrievalDriver.cxx
===================================================================
--- oce.orig/src/MXCAFDoc/MXCAFDoc_AreaRetrievalDriver.cxx
+++ oce/src/MXCAFDoc/MXCAFDoc_AreaRetrievalDriver.cxx
@@ -57,9 +57,5 @@ Standard_Integer MXCAFDoc_AreaRetrievalD
   Handle(PXCAFDoc_Area) S = Handle(PXCAFDoc_Area)::DownCast (Source);
   Handle(XCAFDoc_Area) T = Handle(XCAFDoc_Area)::DownCast (Target);
   
-#ifdef DEB
-  PTColStd_PersistentTransientMap& PTMap = 
-#endif
-    RelocTable->OtherTable();
   T->Set(S->Get());
 }
Index: oce/src/MXCAFDoc/MXCAFDoc_AreaStorageDriver.cxx
===================================================================
--- oce.orig/src/MXCAFDoc/MXCAFDoc_AreaStorageDriver.cxx
+++ oce/src/MXCAFDoc/MXCAFDoc_AreaStorageDriver.cxx
@@ -57,9 +57,5 @@ Standard_Integer MXCAFDoc_AreaStorageDri
   Handle(XCAFDoc_Area) S = Handle(XCAFDoc_Area)::DownCast (Source);
   Handle(PXCAFDoc_Area) T = Handle(PXCAFDoc_Area)::DownCast (Target);
   
-#ifdef DEB
-  PTColStd_TransientPersistentMap& TPMap = 
-#endif
-    RelocTable->OtherTable();
   T->Set(S->Get());
 }
Index: oce/src/MXCAFDoc/MXCAFDoc_CentroidRetrievalDriver.cxx
===================================================================
--- oce.orig/src/MXCAFDoc/MXCAFDoc_CentroidRetrievalDriver.cxx
+++ oce/src/MXCAFDoc/MXCAFDoc_CentroidRetrievalDriver.cxx
@@ -62,9 +62,5 @@ MXCAFDoc_CentroidRetrievalDriver::MXCAFD
   Handle(PXCAFDoc_Centroid) S = Handle(PXCAFDoc_Centroid)::DownCast (Source);
   Handle(XCAFDoc_Centroid) T = Handle(XCAFDoc_Centroid)::DownCast (Target);
 
-#ifdef DEB  
-  PTColStd_PersistentTransientMap& PTMap = 
-#endif
-    RelocTable->OtherTable();
   T->Set(S->Get());
 }
Index: oce/src/MXCAFDoc/MXCAFDoc_CentroidStorageDriver.cxx
===================================================================
--- oce.orig/src/MXCAFDoc/MXCAFDoc_CentroidStorageDriver.cxx
+++ oce/src/MXCAFDoc/MXCAFDoc_CentroidStorageDriver.cxx
@@ -60,9 +60,5 @@ MXCAFDoc_CentroidStorageDriver::MXCAFDoc
   Handle(XCAFDoc_Centroid) S = Handle(XCAFDoc_Centroid)::DownCast (Source);
   Handle(PXCAFDoc_Centroid) T = Handle(PXCAFDoc_Centroid)::DownCast (Target);
   
-#ifdef DEB
-  PTColStd_TransientPersistentMap& TPMap = 
-#endif
-    RelocTable->OtherTable();
   T->Set(S->Get());
 }
Index: oce/src/MXCAFDoc/MXCAFDoc_DatumRetrievalDriver.cxx
===================================================================
--- oce.orig/src/MXCAFDoc/MXCAFDoc_DatumRetrievalDriver.cxx
+++ oce/src/MXCAFDoc/MXCAFDoc_DatumRetrievalDriver.cxx
@@ -61,10 +61,6 @@ void MXCAFDoc_DatumRetrievalDriver::Past
   Handle(PXCAFDoc_Datum) S = Handle(PXCAFDoc_Datum)::DownCast (Source);
   Handle(XCAFDoc_Datum) T = Handle(XCAFDoc_Datum)::DownCast (Target);
   
-#ifdef DEB
-  PTColStd_PersistentTransientMap& PTMap = 
-#endif
-    RelocTable->OtherTable();
   Handle(TCollection_HAsciiString) aName, aDescr, anId;
   if ( !S->GetName().IsNull() )
     aName = new TCollection_HAsciiString( (S->GetName())->Convert() );
Index: oce/src/MXCAFDoc/MXCAFDoc_DatumStorageDriver.cxx
===================================================================
--- oce.orig/src/MXCAFDoc/MXCAFDoc_DatumStorageDriver.cxx
+++ oce/src/MXCAFDoc/MXCAFDoc_DatumStorageDriver.cxx
@@ -59,10 +59,6 @@ void MXCAFDoc_DatumStorageDriver::Paste(
 {
   Handle(XCAFDoc_Datum) S = Handle(XCAFDoc_Datum)::DownCast (Source);
   Handle(PXCAFDoc_Datum) T = Handle(PXCAFDoc_Datum)::DownCast (Target);
-#ifdef DEB
-  PTColStd_TransientPersistentMap& TPMap = 
-#endif
-    RelocTable->OtherTable();
   Handle(TCollection_HAsciiString) aNameStr = S->GetName();
   Handle(TCollection_HAsciiString) aDescrStr = S->GetDescription();
   Handle(TCollection_HAsciiString) anIdStr = S->GetIdentification();
Index: oce/src/MXCAFDoc/MXCAFDoc_DimTolRetrievalDriver.cxx
===================================================================
--- oce.orig/src/MXCAFDoc/MXCAFDoc_DimTolRetrievalDriver.cxx
+++ oce/src/MXCAFDoc/MXCAFDoc_DimTolRetrievalDriver.cxx
@@ -63,10 +63,6 @@ void MXCAFDoc_DimTolRetrievalDriver::Pas
   Handle(PXCAFDoc_DimTol) S = Handle(PXCAFDoc_DimTol)::DownCast (Source);
   Handle(XCAFDoc_DimTol) T = Handle(XCAFDoc_DimTol)::DownCast (Target);
   
-#ifdef DEB
-  PTColStd_PersistentTransientMap& PTMap = 
-#endif
-    RelocTable->OtherTable();
   Handle(TColStd_HArray1OfReal) aVals;
   Handle(PColStd_HArray1OfReal) aPArr = S->GetVal();
   if ( !aPArr.IsNull() )
Index: oce/src/MXCAFDoc/MXCAFDoc_DimTolStorageDriver.cxx
===================================================================
--- oce.orig/src/MXCAFDoc/MXCAFDoc_DimTolStorageDriver.cxx
+++ oce/src/MXCAFDoc/MXCAFDoc_DimTolStorageDriver.cxx
@@ -61,10 +61,6 @@ void MXCAFDoc_DimTolStorageDriver::Paste
 {
   Handle(XCAFDoc_DimTol) S = Handle(XCAFDoc_DimTol)::DownCast (Source);
   Handle(PXCAFDoc_DimTol) T = Handle(PXCAFDoc_DimTol)::DownCast (Target);
-#ifdef DEB
-  PTColStd_TransientPersistentMap& TPMap = 
-#endif
-    RelocTable->OtherTable();
   Handle(TColStd_HArray1OfReal) aHArr = S->GetVal();
   Handle(PColStd_HArray1OfReal) aVals;
   if ( !aHArr.IsNull() )
Index: oce/src/MXCAFDoc/MXCAFDoc_MaterialRetrievalDriver.cxx
===================================================================
--- oce.orig/src/MXCAFDoc/MXCAFDoc_MaterialRetrievalDriver.cxx
+++ oce/src/MXCAFDoc/MXCAFDoc_MaterialRetrievalDriver.cxx
@@ -61,10 +61,6 @@ void MXCAFDoc_MaterialRetrievalDriver::P
   Handle(PXCAFDoc_Material) S = Handle(PXCAFDoc_Material)::DownCast (Source);
   Handle(XCAFDoc_Material) T = Handle(XCAFDoc_Material)::DownCast (Target);
   
-#ifdef DEB
-  PTColStd_PersistentTransientMap& PTMap = 
-#endif
-    RelocTable->OtherTable();
   Handle(TCollection_HAsciiString) aName, aDescr, aDensName, aDensValType;
   if ( !S->GetName().IsNull() )
     aName = new TCollection_HAsciiString( (S->GetName())->Convert() );
Index: oce/src/MXCAFDoc/MXCAFDoc_MaterialStorageDriver.cxx
===================================================================
--- oce.orig/src/MXCAFDoc/MXCAFDoc_MaterialStorageDriver.cxx
+++ oce/src/MXCAFDoc/MXCAFDoc_MaterialStorageDriver.cxx
@@ -61,10 +61,6 @@ void MXCAFDoc_MaterialStorageDriver::Pas
 {
   Handle(XCAFDoc_Material) S = Handle(XCAFDoc_Material)::DownCast (Source);
   Handle(PXCAFDoc_Material) T = Handle(PXCAFDoc_Material)::DownCast (Target);
-#ifdef DEB
-  PTColStd_TransientPersistentMap& TPMap = 
-#endif
-    RelocTable->OtherTable();
   Handle(TCollection_HAsciiString) aNameStr = S->GetName();
   Handle(TCollection_HAsciiString) aDescrStr = S->GetDescription();
   Handle(TCollection_HAsciiString) aDensNameStr = S->GetDensName();
Index: oce/src/MXCAFDoc/MXCAFDoc_VolumeRetrievalDriver.cxx
===================================================================
--- oce.orig/src/MXCAFDoc/MXCAFDoc_VolumeRetrievalDriver.cxx
+++ oce/src/MXCAFDoc/MXCAFDoc_VolumeRetrievalDriver.cxx
@@ -56,9 +56,5 @@ Standard_Integer MXCAFDoc_VolumeRetrieva
   Handle(PXCAFDoc_Volume) S = Handle(PXCAFDoc_Volume)::DownCast (Source);
   Handle(XCAFDoc_Volume) T = Handle(XCAFDoc_Volume)::DownCast (Target);
   
-#ifdef DEB
-  PTColStd_PersistentTransientMap& PTMap = 
-#endif
-    RelocTable->OtherTable();
   T->Set(S->Get());
 }
Index: oce/src/MXCAFDoc/MXCAFDoc_VolumeStorageDriver.cxx
===================================================================
--- oce.orig/src/MXCAFDoc/MXCAFDoc_VolumeStorageDriver.cxx
+++ oce/src/MXCAFDoc/MXCAFDoc_VolumeStorageDriver.cxx
@@ -57,9 +57,5 @@ Standard_Integer MXCAFDoc_VolumeStorageD
   Handle(XCAFDoc_Volume) S = Handle(XCAFDoc_Volume)::DownCast (Source);
   Handle(PXCAFDoc_Volume) T = Handle(PXCAFDoc_Volume)::DownCast (Target);
   
-#ifdef DEB
-  PTColStd_TransientPersistentMap& TPMap = 
-#endif
-    RelocTable->OtherTable();
   T->Set(S->Get());
 }
Index: oce/src/Materials/Materials_MaterialDefinition.cxx
===================================================================
--- oce.orig/src/Materials/Materials_MaterialDefinition.cxx
+++ oce/src/Materials/Materials_MaterialDefinition.cxx
@@ -40,7 +40,7 @@ Handle(Dynamic_Parameter) Materials_Mate
   const Standard_CString atype,
   const Standard_CString avalue) const
 {
-  Standard_Integer fr,i;
+  Standard_Integer i;
   char value1[80],value2[80],value3[80];
   Handle(Dynamic_Parameter) parameter;
   Handle(Dynamic_ObjectParameter) objectparameter;
@@ -51,7 +51,7 @@ Handle(Dynamic_Parameter) Materials_Mate
       for(i=0; i<80; i++)value2[i] = 0;
       for(i=0; i<80; i++)value3[i] = 0;
       //      fr = sscanf(avalue,"%s%s%s",&value1,&value2,&value3);
-      fr = sscanf(avalue,"%s%s%s",value1,value2,value3);
+      sscanf(avalue,"%s%s%s",value1,value2,value3);
       
       Handle(Materials_Color) pcolor =
 	new Materials_Color(Quantity_Color(atof(value1),
Index: oce/src/MeshTest/MeshTest.cxx
===================================================================
--- oce.orig/src/MeshTest/MeshTest.cxx
+++ oce/src/MeshTest/MeshTest.cxx
@@ -1142,11 +1142,7 @@ Standard_Integer tri2d(Draw_Interpretor&
 
   T = BRep_Tool::Triangulation(F, L);
   if (!T.IsNull()) {
-#ifdef DEB
-    gp_Trsf tr  = L.Transformation();
-#else
     L.Transformation();
-#endif
 
     // Build the connect tool
     Poly_Connect pc(T);
Index: oce/src/MeshVS/MeshVS_ElementalColorPrsBuilder.cxx
===================================================================
--- oce.orig/src/MeshVS/MeshVS_ElementalColorPrsBuilder.cxx
+++ oce/src/MeshVS/MeshVS_ElementalColorPrsBuilder.cxx
@@ -168,8 +168,6 @@ void MeshVS_ElementalColorPrsBuilder::Bu
   }
 
   //Now we are ready to draw faces with equal colors
-  Aspect_InteriorStyle aStyle;
-  Standard_Integer     aStyleInt;
   Aspect_TypeOfLine    anEdgeType = Aspect_TOL_SOLID;
   Aspect_TypeOfLine    aLineType = Aspect_TOL_SOLID;
   Standard_Integer     anEdgeInt, aLineInt;
@@ -188,9 +186,6 @@ void MeshVS_ElementalColorPrsBuilder::Bu
   aDrawer->GetBoolean( MeshVS_DA_ColorReflection, IsReflect );
   aDrawer->GetBoolean( MeshVS_DA_SmoothShading, IsMeshSmoothShading );
 
-  if ( aDrawer->GetInteger ( MeshVS_DA_InteriorStyle, aStyleInt) )
-    aStyle = (Aspect_InteriorStyle) aStyleInt;
-
   if ( aDrawer->GetInteger ( MeshVS_DA_EdgeType, anEdgeInt) )
     anEdgeType = (Aspect_TypeOfLine) anEdgeInt;
 
Index: oce/src/MeshVS/MeshVS_TextPrsBuilder.cxx
===================================================================
--- oce.orig/src/MeshVS/MeshVS_TextPrsBuilder.cxx
+++ oce/src/MeshVS/MeshVS_TextPrsBuilder.cxx
@@ -162,7 +162,6 @@ void MeshVS_TextPrsBuilder::Build ( cons
   Aspect_TypeOfDisplayText ADisplayType     = Aspect_TODT_NORMAL;
   TCollection_AsciiString  AFontString;
   Standard_Integer         ADispInt;
-  Standard_Boolean         ATexFont;
   // Bold font is used by default for better text readability
   OSD_FontAspect           AFontAspectType  = OSD_FA_Bold;
   Standard_Integer         AAspect; 
Index: oce/src/NCollection/NCollection_BaseAllocator.cxx
===================================================================
--- oce.orig/src/NCollection/NCollection_BaseAllocator.cxx
+++ oce/src/NCollection/NCollection_BaseAllocator.cxx
@@ -199,7 +199,6 @@ void NCollection_BaseAllocator::Standard
     // statistics by alive objects
     NCollection_DataMap<Standard_Address, Standard_Size>& aStIDMap = StorageIDMap();
     NCollection_Map<Standard_Size>& aStIDSet = StorageIDSet();
-    int a;
     if (theIsAlloc)
     {
       aStIDMap.Bind(theStorage, ++CurrentID);
@@ -207,7 +206,6 @@ void NCollection_BaseAllocator::Standard
       if (CurrentID == StandardCallBack_CatchID())
       {
         // Place for break point for allocation of investigated ID
-        a = 1;
       }
     }
     else
@@ -219,7 +217,6 @@ void NCollection_BaseAllocator::Standard
         if (anID == StandardCallBack_CatchID())
         {
           // Place for break point for freeing of investigated ID
-          a = 0;
         }
       }
     }
Index: oce/src/NCollection/NCollection_IncAllocator.cxx
===================================================================
--- oce.orig/src/NCollection/NCollection_IncAllocator.cxx
+++ oce/src/NCollection/NCollection_IncAllocator.cxx
@@ -103,7 +103,6 @@ static void Debug_Create(Standard_Addres
   if (CurrentID == CATCH_ID)
   {
     // Place for break point for creation of investigated allocator
-    int a = 1;
   }
 }
 
Index: oce/src/NIS/NIS_View.cxx
===================================================================
--- oce.orig/src/NIS/NIS_View.cxx
+++ oce/src/NIS/NIS_View.cxx
@@ -538,7 +538,6 @@ void  NIS_View::Select (const NCollectio
   const gp_Ax3 anAx3 (anEye, aProj, anXdir);
   gp_Trsf aTrf;
   aTrf.SetTransformation (anAx3);
-  const gp_Trsf aTrfInv = aTrf.Inverted();
 
   // Prepare list of 2d points of selection polygon.
   NCollection_List<gp_XY>           aPoints;
Index: oce/src/OSD/OSD.cxx
===================================================================
--- oce.orig/src/OSD/OSD.cxx
+++ oce/src/OSD/OSD.cxx
@@ -141,13 +141,12 @@ void OSD::MilliSecSleep(const Standard_I
 
 void OSD::MilliSecSleep(const Standard_Integer aDelay)
 {
-  int fdn ;
   struct timeval timeout ;
 
   timeout.tv_sec = aDelay / 1000 ;
   timeout.tv_usec = (aDelay % 1000) * 1000 ;
 
-  fdn = select(0,NULL,NULL,NULL,&timeout) ;
+  select(0,NULL,NULL,NULL,&timeout) ;
 }
 
 #endif
Index: oce/src/OSD/OSD_MAllocHook.cxx
===================================================================
--- oce.orig/src/OSD/OSD_MAllocHook.cxx
+++ oce/src/OSD/OSD_MAllocHook.cxx
@@ -387,10 +387,12 @@ void OSD_MAllocHook::LogFileHandler::All
     myMutex.Lock();
     fprintf(myLogFile, "alloc %10lu %10"FMT_SZ_Q"u\n", theRequestNum, theSize);
     myMutex.Unlock();
+#ifdef DEBUG
     if (myBreakSize == theSize)
     {
       int a = 1;
     }
+#endif
   }
 }
 
@@ -514,10 +516,12 @@ void OSD_MAllocHook::CollectBySize::Allo
                    (size_t      theSize,
                     long        /*theRequestNum*/)
 {
+#ifdef DEBUG
   if (myBreakSize == theSize)
   {
     int a = 1;
   }
+#endif
   if (theSize > 0)
   {
     myMutex.Lock();
Index: oce/src/OSD/OSD_signal_WNT.cxx
===================================================================
--- oce.orig/src/OSD/OSD_signal_WNT.cxx
+++ oce/src/OSD/OSD_signal_WNT.cxx
@@ -428,7 +428,7 @@ void OSD :: SetSignal ( const Standard_B
 #ifdef _MSC_VER
  if (fSETranslator) {
    // use Structural Exception translator (one per thread)
-   _se_translator_function pOldSeFunc = _set_se_translator( TranslateSE );
+   _set_se_translator( TranslateSE );
  }
 #endif
 
Index: oce/src/OpenGl/OpenGl_GraphicDriver_703.cxx
===================================================================
--- oce.orig/src/OpenGl/OpenGl_GraphicDriver_703.cxx
+++ oce/src/OpenGl/OpenGl_GraphicDriver_703.cxx
@@ -44,14 +44,14 @@ void OpenGl_GraphicDriver::Marker (const
   amarker.y = float (APoint.Y ());
   amarker.z = float (APoint.Z ());
 
-  Standard_Real AMR, AMG, AMB, R, G, B;
+  Standard_Real AMR, R, G, B;
   Aspect_TypeOfMarker AMType;
   Standard_Real AMScale, AScale;
 
   // Sauvegarde des valeurs initiales
   AMR = R = Standard_Real (MyCGroup.ContextMarker.Color.r);
-  AMG = G = Standard_Real (MyCGroup.ContextMarker.Color.g);
-  AMB = B = Standard_Real (MyCGroup.ContextMarker.Color.b);
+  G = Standard_Real (MyCGroup.ContextMarker.Color.g);
+  B = Standard_Real (MyCGroup.ContextMarker.Color.b);
   AMType  = Aspect_TypeOfMarker (MyCGroup.ContextMarker.MarkerType);
   AMScale = AScale = Standard_Real (MyCGroup.ContextMarker.Scale);
 
@@ -295,14 +295,14 @@ void OpenGl_GraphicDriver::MarkerSet (co
   almarkers.NbMarkers = int (ListVertex.Length ());
   almarkers.Markers = (CALL_DEF_MARKER *) &ListVertex (Lower);
 
-  Standard_Real AMR, AMG, AMB, R, G, B;
+  Standard_Real AMR, R, G, B;
   Aspect_TypeOfMarker AMType;
   Standard_Real AMScale, AScale;
 
   // Sauvegarde des valeurs initiales
   AMR = R = Standard_Real (MyCGroup.ContextMarker.Color.r);
-  AMG = G = Standard_Real (MyCGroup.ContextMarker.Color.g);
-  AMB = B = Standard_Real (MyCGroup.ContextMarker.Color.b);
+  G = Standard_Real (MyCGroup.ContextMarker.Color.g);
+  B = Standard_Real (MyCGroup.ContextMarker.Color.b);
   AMType  = Aspect_TypeOfMarker (MyCGroup.ContextMarker.MarkerType);
   AMScale = AScale = Standard_Real (MyCGroup.ContextMarker.Scale);
 
Index: oce/src/OpenGl/OpenGl_TextRender.cxx
===================================================================
--- oce.orig/src/OpenGl/OpenGl_TextRender.cxx
+++ oce/src/OpenGl/OpenGl_TextRender.cxx
@@ -299,7 +299,8 @@ void OpenGl_TextRender::RenderText ( con
   TsmGetAttri( 1, &keyZoom );
   zoom = keyZoom.data.ldata;
 
-  OpenGl_TextRender* textRender = OpenGl_TextRender::instance(); 
+  OpenGl_TextRender::instance(); 
+
   int vh = 2 ;
   int vv = 2 ;
 
Index: oce/src/OpenGl/OpenGl_curve.cxx
===================================================================
--- oce.orig/src/OpenGl/OpenGl_curve.cxx
+++ oce/src/OpenGl/OpenGl_curve.cxx
@@ -106,8 +106,6 @@ CurveDisplay( TSM_ELEM_DATA data, Tint n
   tel_curve_data d;
   CMN_KEY        key;
   TEL_COLOUR     colour;
-  int            i, j;
-  GLfloat          reseau[4][3];
 
   d = (tel_curve_data)data.pdata;
 
@@ -134,11 +132,6 @@ CurveDisplay( TSM_ELEM_DATA data, Tint n
     TsmGetAttri( 1, &key );
   }
 
-  /* Recopie des points du reseau : Pb prototypage en c ansi */
-  for( i = 0; i < 4; i++ )
-    for( j = 0; i < 3; i++ )
-      reseau[i][j] = d->vertices[i].xyz[j];
-
   /* Determination du type de courbe */
   switch( d->type )
   {
Index: oce/src/OpenGl/OpenGl_execstruct.cxx
===================================================================
--- oce.orig/src/OpenGl/OpenGl_execstruct.cxx
+++ oce/src/OpenGl/OpenGl_execstruct.cxx
@@ -296,7 +296,6 @@ ExecuteStructureDisplay( TSM_ELEM_DATA d
   register Tint     display = 1;
   register Tint     highl = TOff;
   register TelType  elem;
-  Tint              vp;
   CMN_KEY           key;
 #ifdef G003
   static GLboolean s_fWire            = GL_FALSE;
@@ -353,7 +352,6 @@ ExecuteStructureDisplay( TSM_ELEM_DATA d
   }  /* end if */
 #endif  /* G003 */
 
-  vp = key.data.ldata;
   for( i = 0; i < num; i++, node = node->next )
   {
     elem = node->elem.el;
Index: oce/src/OpenGl/OpenGl_indexpolygons.cxx
===================================================================
--- oce.orig/src/OpenGl/OpenGl_indexpolygons.cxx
+++ oce/src/OpenGl/OpenGl_indexpolygons.cxx
@@ -1418,14 +1418,13 @@ doDraw:
 #ifdef G003
 static void draw_degenerates_as_points ( tel_indexpoly_data p ) {
 
-  Tint*      ind, *vis;
-  Tint       i, j, n, a, newList = 0;
+  Tint*      ind;
+  Tint       i, j, n, a;
   GLfloat    pt[ 3 ];
   tel_point  pv;
 
   pv  = p -> vertices;
   ind = p -> indices;
-  vis = p -> edge_vis;
 
   LightOff ();
 
@@ -1440,7 +1439,6 @@ static void draw_degenerates_as_points (
     p -> d.degMode   = 3;
     p -> d.skipRatio = g_fSkipRatio;
     glNewList ( p -> d.dlist, GL_COMPILE_AND_EXECUTE );
-    newList = 1;
 doDraw:
     if ( g_fSkipRatio == 0.0F ) {
 
@@ -1515,15 +1513,14 @@ doDraw:
 
 static void draw_degenerates_as_bboxs ( tel_indexpoly_data p ) {
 
-  Tint*     ind, *vis;
-  Tint      i, j, n, a, newList = 0;
+  Tint*     ind;
+  Tint      i, j, n, a;
   GLfloat   minp[ 3 ] = { FLT_MAX, FLT_MAX, FLT_MAX };
   GLfloat   maxp[ 3 ] = { FLT_MIN, FLT_MIN, FLT_MIN };
   tel_point pv;
 
   pv  = p -> vertices;
   ind = p -> indices;
-  vis = p -> edge_vis;
 
   LightOff ();
 
@@ -1538,7 +1535,6 @@ static void draw_degenerates_as_bboxs (
     p -> d.degMode = 4;
 
     glNewList ( p -> d.dlist, GL_COMPILE_AND_EXECUTE );
-    newList = 1;
 doDraw:
     for ( i = 0, j = 0, a = 0; i < p -> num_bounds; ++i ) {
 
Index: oce/src/OpenGl/OpenGl_initelem.cxx
===================================================================
--- oce.orig/src/OpenGl/OpenGl_initelem.cxx
+++ oce/src/OpenGl/OpenGl_initelem.cxx
@@ -2161,7 +2161,7 @@ InitPMFont(void)
 
   for( i = 0; i < TEL_NO_OF_SIZES*TEL_NB_OF_MARKERS; i++ )
   {           
-    GLsizei w, h, size, j;
+    GLsizei w, h;
 
     k1 = i / TEL_NO_OF_SIZES;
     k2 = i % TEL_NO_OF_SIZES;
Index: oce/src/OpenGl/OpenGl_lightstate.cxx
===================================================================
--- oce.orig/src/OpenGl/OpenGl_lightstate.cxx
+++ oce/src/OpenGl/OpenGl_lightstate.cxx
@@ -90,7 +90,6 @@ LightSrcStateAdd( TSM_ELEM_DATA d, Tint
 static  TStatus
 LightSrcStateDisplay( TSM_ELEM_DATA data, Tint n, cmn_key *k )
 {
-  tel_tint_data d = (tel_tint_data)data.pdata;
 
 #ifdef TRACE_LIGHT
   printf("OpenGl_lightstate::LightSrcStateDisplay:UpdateLight(%d)\n", TglActiveWs);
Index: oce/src/OpenGl/OpenGl_polygon.cxx
===================================================================
--- oce.orig/src/OpenGl/OpenGl_polygon.cxx
+++ oce/src/OpenGl/OpenGl_polygon.cxx
@@ -892,7 +892,7 @@ draw_polygon_concav( tel_polygon_data d,
 static void
 draw_tmesh( tel_polygon_data d, Tint v )
 {
-  Tint      i, j, k;
+  Tint      i, j;
   DISPLAY_ *dis;
   SEQ_     *s;
   extra_vertex b;
@@ -907,7 +907,7 @@ draw_tmesh( tel_polygon_data d, Tint v )
     {
     case 1:
       {
-        for( j = 0, k = 0; j < s->ts_num; j++ )
+        for( j = 0; j < s->ts_num; j++ )
         {
           if ( s->tmesh_sequence[j] < (void *)0xffff )
             glVertex3fv( d->vertices[ (long)s->tmesh_sequence[ j ] ].xyz );
@@ -921,7 +921,7 @@ draw_tmesh( tel_polygon_data d, Tint v )
       }
     case 2:
       {
-        for( j = 0, k = 0; j < s->ts_num; j++ )
+        for( j = 0; j < s->ts_num; j++ )
         {
           if ( s->tmesh_sequence[j] < (void *)0xffff ) {
             glColor3fv( d->vcolours[ (long) s->tmesh_sequence[ j ] ].rgb );
@@ -936,7 +936,7 @@ draw_tmesh( tel_polygon_data d, Tint v )
       }
     case 3:
       {
-        for( j = 0, k = 0; j < s->ts_num; j++ )
+        for( j = 0; j < s->ts_num; j++ )
         {
           if ( s->tmesh_sequence[j] < (void *)0xffff ) {
             glNormal3fv( d->vnormals[ (long) s->tmesh_sequence[ j ] ].xyz);
Index: oce/src/OpenGl/OpenGl_polygonholes.cxx
===================================================================
--- oce.orig/src/OpenGl/OpenGl_polygonholes.cxx
+++ oce/src/OpenGl/OpenGl_polygonholes.cxx
@@ -302,9 +302,7 @@ PolygonHolesDisplay( TSM_ELEM_DATA data,
   Tint           fl=0;
   Tint           front_lighting_model, back_lighting_model;
   Tint           front_lighting_model_preserve, back_lighting_model_preserve;
-  Tint           front_shading_method;
   Tint           interior_style;
-  Tint           interior_index;
   TEL_COLOUR     interior_colour, back_interior_colour;
   TEL_COLOUR     point_colour, edge_colour;
   TelCullMode    face_culling_mode;
@@ -334,12 +332,10 @@ PolygonHolesDisplay( TSM_ELEM_DATA data,
   face_distinguishing_mode = k11.data.ldata;
   front_lighting_model     = k12.data.ldata;
   front_lighting_model_preserve = k12.data.ldata;
-  front_shading_method     = k13.data.ldata;
   back_lighting_model      = k14.data.ldata;
   back_lighting_model_preserve = k14.data.ldata;
   face_culling_mode        = (TelCullMode)k16.data.ldata;
   interior_style           = k17.data.ldata;
-  interior_index           = k19.data.ldata;
 
   if( k[0]->id == TOn )
   {                          /* Use highlight colours */
@@ -546,7 +542,7 @@ draw_polygon_holes( tel_polygon_holes_da
 static void
 draw_tmesh( tel_polygon_holes_data d, Tint v )
 {
-  Tint     i, j, k;
+  Tint     i, j;
   DISPLAY_ *dis;
   SEQ_     *s;
 
@@ -560,7 +556,7 @@ draw_tmesh( tel_polygon_holes_data d, Ti
     {
     case 1:
       {
-        for( j = 0, k = 0; j < s->ts_num; j++ )
+        for( j = 0; j < s->ts_num; j++ )
         {
           if ( s->tmesh_sequence[j] < (void *)0xffff ) {
             glVertex3fv( d->vertices[ (long)s->tmesh_sequence[ j ] ].xyz );
@@ -574,7 +570,7 @@ draw_tmesh( tel_polygon_holes_data d, Ti
       }
     case 2:
       {
-        for( j = 0, k = 0; j < s->ts_num; j++ )
+        for( j = 0; j < s->ts_num; j++ )
         {
           if ( s->tmesh_sequence[j] < (void *)0xffff ) {
             glColor3fv( d->vcolours[ (long) s->tmesh_sequence[ j ] ].rgb );
@@ -589,7 +585,7 @@ draw_tmesh( tel_polygon_holes_data d, Ti
       }
     case 3:
       {
-        for( j = 0, k = 0; j < s->ts_num; j++ )
+        for( j = 0; j < s->ts_num; j++ )
         {
           if ( s->tmesh_sequence[j] < (void *)0xffff) {
             glNormal3fv( d->vnormals[ (long) s->tmesh_sequence[ j ] ].xyz );
Index: oce/src/OpenGl/OpenGl_qstrip.cxx
===================================================================
--- oce.orig/src/OpenGl/OpenGl_qstrip.cxx
+++ oce/src/OpenGl/OpenGl_qstrip.cxx
@@ -504,13 +504,12 @@ static void draw_qstrip (
 {
 
   Tint              i, m, newList = 0;
-  Tint              nf, nv, nr, nc;
+  Tint              nr, nc;
   Tint              lighting_model;
-  tel_point         pv, pfn, pvn;
+  tel_point         pv, pvn;
   tel_colour        pfc, pvc;
   tel_texture_coord pvt;
 
-  pfn = p -> fnormals;
   pfc = p -> fcolours;
   pv  = p -> vertices;
   pvc = p -> vcolours;
@@ -538,8 +537,6 @@ static void draw_qstrip (
     lighting_model = front_lighting_model;
     nr             = p -> num_rows;
     nc             = p -> num_columns;
-    nf             = nr * nc;
-    nv             = ( nr + 1 ) * ( nc + 1 );
 #ifdef G003
 #ifdef BUC60876
     if ( !g_fAnimation )
@@ -1079,7 +1076,6 @@ static void draw_edges (
   Tint      edge_type, line_type_preserve;
   Tfloat    edge_width, line_width_preserve;
   GLboolean texture_on;
-  tel_point pv;     
 #ifdef G003
   if ( interior_style != TSM_HIDDENLINE && !forceDraw ) 
   {
@@ -1094,8 +1090,6 @@ static void draw_edges (
 
   }  /* end if */
 
-  pv = p -> vertices;
-
   LightOff ();
   texture_on = IsTextureEnabled ();
 
Index: oce/src/OpenGl/OpenGl_text.cxx
===================================================================
--- oce.orig/src/OpenGl/OpenGl_text.cxx
+++ oce/src/OpenGl/OpenGl_text.cxx
@@ -187,7 +187,6 @@ TextDisplay( TSM_ELEM_DATA data, Tint n,
   GLdouble        obj3X, obj3Y, obj3Z;
   GLdouble        winx1, winy1, winz1;
   GLdouble        winx, winy, winz;
-  GLint           status;
 
 #ifdef TEXT_DEGENER
   if ( g_nDegenerateModel > 0 && g_fSkipRatio == 1. )
@@ -283,31 +282,31 @@ TextDisplay( TSM_ELEM_DATA data, Tint n,
       objrefX = (float)d->attach_pt.xyz[0];   
       objrefY = (float)d->attach_pt.xyz[1];   
       objrefZ = (float)d->attach_pt.xyz[2];
-      status = gluProject (objrefX, objrefY, objrefZ, modelMatrix, projMatrix, viewport,
+      gluProject (objrefX, objrefY, objrefZ, modelMatrix, projMatrix, viewport,
         &winx1, &winy1, &winz1);
 
       winx = winx1;
       winy = winy1-sDescent;
       winz = winz1+0.00001;     
-      status = gluUnProject (winx, winy, winz, modelMatrix, projMatrix, viewport,
+      gluUnProject (winx, winy, winz, modelMatrix, projMatrix, viewport,
         &objX, &objY, &objZ);
 
       winx = winx1 + sWidth;
       winy = winy1-sDescent;
       winz = winz1+0.00001; /* il vaut mieux F+B / 1000000 ? */     
-      status = gluUnProject (winx, winy, winz, modelMatrix, projMatrix, viewport,
+      gluUnProject (winx, winy, winz, modelMatrix, projMatrix, viewport,
         &obj1X, &obj1Y, &obj1Z);
 
       winx = winx1 + sWidth;
       winy = winy1 + sAscent;
       winz = winz1+0.00001;     
-      status = gluUnProject (winx, winy, winz, modelMatrix, projMatrix, viewport,
+      gluUnProject (winx, winy, winz, modelMatrix, projMatrix, viewport,
         &obj2X, &obj2Y, &obj2Z);
 
       winx = winx1;
       winy = winy1+ sAscent;
       winz = winz1+0.00001;   
-      status = gluUnProject (winx, winy, winz, modelMatrix, projMatrix, viewport,
+      gluUnProject (winx, winy, winz, modelMatrix, projMatrix, viewport,
         &obj3X, &obj3Y, &obj3Z);
 
       glColor3fv( colours.rgb );
@@ -323,32 +322,32 @@ TextDisplay( TSM_ELEM_DATA data, Tint n,
       objrefX = (float)d->attach_pt.xyz[0];   
       objrefY = (float)d->attach_pt.xyz[1];   
       objrefZ = (float)d->attach_pt.xyz[2];
-      status = gluProject (objrefX, objrefY, objrefZ, modelMatrix, projMatrix, viewport,
+      gluProject (objrefX, objrefY, objrefZ, modelMatrix, projMatrix, viewport,
         &winx1, &winy1, &winz1);
 
       winx = winx1+1;
       winy = winy1+1;
       winz = winz1+0.00001;     
-      status = gluUnProject (winx, winy, winz, modelMatrix, projMatrix, viewport,
+      gluUnProject (winx, winy, winz, modelMatrix, projMatrix, viewport,
         &objX, &objY, &objZ);
 
       glColor3fv( colours.rgb );
       textRender->RenderText( d->sdata, fontBase, 0, (float)objX, (float)objY,(float)objZ );
       winx = winx1-1;
       winy = winy1-1;
-      status = gluUnProject (winx, winy, winz, modelMatrix, projMatrix, viewport,
+      gluUnProject (winx, winy, winz, modelMatrix, projMatrix, viewport,
         &objX, &objY, &objZ);
 
       textRender->RenderText( d->sdata, fontBase, 0, (float)objX, (float)objY,(float)objZ );
       winx = winx1-1;
       winy = winy1+1;
-      status = gluUnProject (winx, winy, winz, modelMatrix, projMatrix, viewport,
+      gluUnProject (winx, winy, winz, modelMatrix, projMatrix, viewport,
         &objX, &objY, &objZ); 
 
       textRender->RenderText( d->sdata, fontBase, 0, (float)objX, (float)objY,(float)objZ );
       winx = winx1+1;
       winy = winy1-1;
-      status = gluUnProject (winx, winy, winz, modelMatrix, projMatrix, viewport,
+      gluUnProject (winx, winy, winz, modelMatrix, projMatrix, viewport,
         &objX, &objY, &objZ);
       textRender->RenderText( d->sdata, fontBase, 0, (float)objX, (float)objY,(float)objZ );
       break;
Index: oce/src/OpenGl/OpenGl_tmesh.cxx
===================================================================
--- oce.orig/src/OpenGl/OpenGl_tmesh.cxx
+++ oce/src/OpenGl/OpenGl_tmesh.cxx
@@ -434,11 +434,10 @@ static void draw_tmesh (
 {
 
   Tint              i, newList = 0;
-  tel_point         pv, pfn, pvn;
+  tel_point         pv, pvn;
   tel_colour        pfc, pvc;
   tel_texture_coord pvt;
 
-  pfn = p -> fnormals;
   pfc = p -> fcolours;
   pv  = p -> vertices;
   pvc = p -> vcolours;
Index: oce/src/OpenGl/OpenGl_togl_begin.cxx
===================================================================
--- oce.orig/src/OpenGl/OpenGl_togl_begin.cxx
+++ oce/src/OpenGl/OpenGl_togl_begin.cxx
@@ -114,12 +114,12 @@ call_togl_begin_display
  void *pdisplay
  )
 {
-  char *pvalue = NULL;
   int status;
 
   status = call_tox_set_display (pdisplay);
   if( status ) {
 #ifndef WNT
+    char *pvalue = NULL;
     if ((pvalue = getenv ("CSF_GraphicSync")) != NULL)
       XSynchronize (call_thedisplay, 1);
     InitExtensionGLX(call_thedisplay);
Index: oce/src/OpenGl/OpenGl_togl_begin_layer_mode.cxx
===================================================================
--- oce.orig/src/OpenGl/OpenGl_togl_begin_layer_mode.cxx
+++ oce/src/OpenGl/OpenGl_togl_begin_layer_mode.cxx
@@ -427,7 +427,6 @@ call_togl_begin_layer2d
   
   //abd
   glEnable(GL_TEXTURE_2D);
-  GLboolean stat = glIsEnabled( GL_TEXTURE_2D );
 
   glNewList (ptrLayer->listIndex, GL_COMPILE);
   layerOpen = GL_TRUE;
@@ -632,9 +631,6 @@ call_togl_text2d ( Techar *s,
                   float y,
                   float height )
 {
-#ifndef WNT
-  Tint dispWidth, dispHeight;
-#endif
   GLdouble objx1, objy1, objz1;
 
   call_def_ptrLayer ptrLayer = (call_def_ptrLayer) ACLayer.ptrLayer;
@@ -928,9 +924,6 @@ call_togl_textsize2d
  float *descent
  )
 {
-#ifndef WNT
-  Tint dispWidth, dispHeight;
-#endif
 
   call_def_ptrLayer ptrLayer = (call_def_ptrLayer) ACLayer.ptrLayer;
   if (!ptrLayer) return;
Index: oce/src/OpenGl/OpenGl_togl_markercontextgroup.cxx
===================================================================
--- oce.orig/src/OpenGl/OpenGl_togl_markercontextgroup.cxx
+++ oce/src/OpenGl/OpenGl_togl_markercontextgroup.cxx
@@ -62,7 +62,7 @@ int EXPORT GenerateMarkerBitmap( int the
 {
   int i = 0;
   int anIndex = -1;
-  GLint w, h, size, k, l;
+  GLint w, h;
 
   for( ; i < UDMS_Marker.Quantity; i++ )
   {
Index: oce/src/OpenGl/OpenGl_togl_set_environment.cxx
===================================================================
--- oce.orig/src/OpenGl/OpenGl_togl_set_environment.cxx
+++ oce/src/OpenGl/OpenGl_togl_set_environment.cxx
@@ -34,12 +34,10 @@ call_togl_set_environment
  char * adisplay
  )
 {
-  int status;
-
   if (call_thedisplay == NULL) {
     if (strlen (adisplay) != 0)
       call_util_osd_putenv ((Tchar*)"DISPLAY", (Tchar*)adisplay);
-    status = call_tox_open_display ();
+    call_tox_open_display ();
   }
   return;
 }
Index: oce/src/OpenGl/OpenGl_togl_setplane.cxx
===================================================================
--- oce.orig/src/OpenGl/OpenGl_togl_setplane.cxx
+++ oce/src/OpenGl/OpenGl_togl_setplane.cxx
@@ -31,7 +31,6 @@ call_togl_setplane
   CMN_KEY_DATA    key;
   tel_view_data   vptr;
   TEL_VIEW_REP   *call_viewrep;
-  CALL_DEF_PLANE *plane;
   int j;
   
   // return view representation 
Index: oce/src/OpenGl/OpenGl_togl_triedron.cxx
===================================================================
--- oce.orig/src/OpenGl/OpenGl_togl_triedron.cxx
+++ oce/src/OpenGl/OpenGl_togl_triedron.cxx
@@ -70,13 +70,12 @@ call_togl_triedron_display
 {
 
   CMN_KEY_DATA  data;
-  TStatus status;
 
 #ifdef PRINT
   printf("call_togl_triedron_display  r = %f, g = %f, b = %f", r, g, b);
   printf(", aScale = %f, aPosition = %d \n", aScale, aPosition );
 #endif
-  status = call_triedron_init (aview, aPosition, r, g, b, aScale, asWireframe);
+  call_triedron_init (aview, aPosition, r, g, b, aScale, asWireframe);
 
   /* Mise a jour de l'update_mode */
   data.ldata = TNotDone;
Index: oce/src/OpenGl/OpenGl_triedron.cxx
===================================================================
--- oce.orig/src/OpenGl/OpenGl_triedron.cxx
+++ oce/src/OpenGl/OpenGl_triedron.cxx
@@ -640,17 +640,15 @@ TStatus call_zbuffer_triedron_redraw (
 
   GLdouble TriedronAxeX[3] = { 1.0, 0.0, 0.0 };
   GLdouble TriedronAxeY[3] = { 0.0, 1.0, 0.0 };
-  GLdouble TriedronAxeZ[3] = { 0.0, 0.0, 1.0 };
   GLdouble TriedronOrigin[3] = { 0.0, 0.0, 0.0 };
   GLfloat TriedronColor[3] = { 1.0, 1.0, 1.0 }; /* def = blanc */
 
   GLfloat TriedronScale = (float)0.1 ;
   GLint   TriedronPosition = 0; /* def = Aspect_TOTP_CENTER */
 
-  GLdouble L, l, rayon ;
+  GLdouble L, rayon ;
   GLdouble minUV;
   int      NbFacettes = 12;
-  double   Angle;
   GLdouble TriedronCoord[3] = { 1.0, 0.0, 0.0 };
 
   GLuint fontBase = 0;
@@ -744,10 +742,6 @@ TStatus call_zbuffer_triedron_redraw (
   TriedronAxeY[1] = TriedronOrigin[1] + L ;
   TriedronAxeY[2] = TriedronOrigin[2] + 0.0;
 
-  TriedronAxeZ[0] = TriedronOrigin[0] + 0.0;
-  TriedronAxeZ[1] = TriedronOrigin[1] + 0.0;
-  TriedronAxeZ[2] = TriedronOrigin[2] + L ;
-
   /* Check position in the ViewPort */
   glGetDoublev( GL_MODELVIEW_MATRIX,  (GLdouble *) modelMatrix );
   glGetDoublev( GL_PROJECTION_MATRIX, (GLdouble *) projMatrix );
@@ -1070,9 +1064,7 @@ TStatus call_zbuffer_triedron_redraw (
   glPopAttrib();
 
   /* fleches au bout des axes (= cones de la couleur demandee) */
-  l = L - L/4. ; /* distance a l'origine */
   rayon = L/30. ; /* rayon de la base du cone */
-  Angle = 2. * M_PI/ NbFacettes;
 
   glDeleteLists(startList, 4); 
 
Index: oce/src/OpenGl/OpenGl_txgl.cxx
===================================================================
--- oce.orig/src/OpenGl/OpenGl_txgl.cxx
+++ oce/src/OpenGl/OpenGl_txgl.cxx
@@ -385,7 +385,6 @@ __declspec( dllexport ) int __fastcall _
 
     HTBL_ENTRY*           hte;
     PIXELFORMATDESCRIPTOR pfd;
-    BOOL                  DBuffer = TRUE;
     int                   iPixelFormat;
     char                  string[ CALL_DEF_STRING_LENGTH ];
 
@@ -577,7 +576,6 @@ __declspec( dllexport ) int __fastcall _
     cmn_htbl_elem         rec;*/
     HTBL_ENTRY*           hte;
     PIXELFORMATDESCRIPTOR pfd;
-    BOOL                  DBuffer = TRUE;
     int                   iPixelFormat;
     char                  string[ CALL_DEF_STRING_LENGTH ];
 
@@ -661,8 +659,6 @@ __declspec( dllexport ) int __fastcall _
 
     Bool  i;
     GLXContext ctx;
-    GLenum errorcode;
-    const GLubyte *errorstring;
 
     if ( !_Txgl_Map.IsBound( win ) )
       return TFailure;
@@ -693,8 +689,6 @@ __declspec( dllexport ) int __fastcall _
 #else /* WNT */
 
     HTBL_ENTRY*   hte;
-    HDC    hdc    = NULL;
-    HGLRC  hglrc  = NULL;
     TStatus       retVal = TFailure;
 
     bool Ret = true;
@@ -779,8 +773,7 @@ __declspec( dllexport ) int __fastcall _
 #ifndef WNT
 
     GLXContext ctx;
-    Tint dummy;
-
+ 
     if ( !_Txgl_Map.IsBound(win) )
       return;
     ctx = _Txgl_Map.ChangeFind(win);
Index: oce/src/OpenGl/OpenGl_ws.cxx
===================================================================
--- oce.orig/src/OpenGl/OpenGl_ws.cxx
+++ oce/src/OpenGl/OpenGl_ws.cxx
@@ -152,7 +152,6 @@ TsmSetWSAttri( Tint wsid, TWSAttri  attr
     return TFailure;
 
   if ( !ws_map.IsBound( wsid ) ) {
-    ws_rec rec = new WS_REC();
     ws_map.Bind( wsid, new WS_REC() );
   }
   ws_rec wsr = ws_map.ChangeFind( wsid );
Index: oce/src/PS/PS_Driver.cxx
===================================================================
--- oce.orig/src/PS/PS_Driver.cxx
+++ oce/src/PS/PS_Driver.cxx
@@ -574,7 +574,6 @@ void PS_Driver::InitializeFontMap (const
     TCollection_AsciiString aname;
     Aspect_FontStyle style;
     Standard_Boolean theCapsHeight;
-    Quantity_PlaneAngle theFontSlant;
     Quantity_Length theFontSize;
     Standard_ShortReal fsize;
 
@@ -583,7 +582,6 @@ void PS_Driver::InitializeFontMap (const
       iindex = entry.Index();
       style = entry.Type();
       theFontSize = TOMILLIMETER(style.Size());
-      theFontSlant = style.Slant();
       aname = style.AliasName();
       theCapsHeight = style.CapsHeight();
       fsize = theFontSize;
Index: oce/src/PlotMgt/PlotMgt_PlotterParameter.cxx
===================================================================
--- oce.orig/src/PlotMgt/PlotMgt_PlotterParameter.cxx
+++ oce/src/PlotMgt/PlotMgt_PlotterParameter.cxx
@@ -288,7 +288,6 @@ void PlotMgt_PlotterParameter::ProcessPa
                                TCollection_AsciiString& aValue)
 {
   Standard_Integer i, n = myDescription -> Length ();
-  Standard_Boolean fFound = Standard_False;
   TCollection_AsciiString searchStr = myName, aLine;
 //JR/Hp
   searchStr += (Standard_CString ) (aParamSign ? aParamSign : "");
@@ -304,7 +303,6 @@ void PlotMgt_PlotterParameter::ProcessPa
       STRING_TRIM(aLine);
       myFlags |= aFlag;
       aValue   = aLine;
-      fFound   = Standard_True;
       // Remove all other <aParamSign> strings
       Standard_Integer j = 1;
       while (j <= n) {
Index: oce/src/ProjLib/ProjLib_ComputeApproxOnPolarSurface.cxx
===================================================================
--- oce.orig/src/ProjLib/ProjLib_ComputeApproxOnPolarSurface.cxx
+++ oce/src/ProjLib/ProjLib_ComputeApproxOnPolarSurface.cxx
@@ -1475,16 +1475,16 @@ Handle(Geom2d_BSplineCurve)
   }
   Handle(Geom2d_BSplineCurve) DummyC2d =
     new Geom2d_BSplineCurve(DummyPoles, DummyKnots, DummyMults, 1);
-  Standard_CString Temp = "bs2d";
 #ifdef DRAW
+  Standard_CString Temp = "bs2d";
   DrawTrSurf::Set(Temp,DummyC2d);
 #endif
 //  DrawTrSurf::Set((Standard_CString ) "bs2d",DummyC2d);
   Handle(Geom2dAdaptor_HCurve) DDD = 
     Handle(Geom2dAdaptor_HCurve)::DownCast(InitCurve2d);
   
-  Temp = "initc2d";
 #ifdef DRAW
+  Temp = "initc2d";
   DrawTrSurf::Set(Temp,DDD->ChangeCurve2d().Curve());
 #endif
 //  DrawTrSurf::Set((Standard_CString ) "initc2d",DDD->ChangeCurve2d().Curve());
Index: oce/src/ProjLib/ProjLib_Cone.cxx
===================================================================
--- oce.orig/src/ProjLib/ProjLib_Cone.cxx
+++ oce/src/ProjLib/ProjLib_Cone.cxx
@@ -86,7 +86,7 @@ static gp_Pnt2d EvalPnt2d( const gp_Pnt&
   Standard_Real X = OP.Dot(gp_Vec(C.Position().XDirection()));
   Standard_Real Y = OP.Dot(gp_Vec(C.Position().YDirection()));
   Standard_Real Z = OP.Dot(gp_Vec(C.Position().Direction()));
-  Standard_Real U,V;
+  Standard_Real U;
 
   if ( Abs(X) > Precision::PConfusion() ||
        Abs(Y) > Precision::PConfusion() ) {
@@ -96,8 +96,6 @@ static gp_Pnt2d EvalPnt2d( const gp_Pnt&
     U = 0.;
   }
 
-  V = Z / Cos(C.SemiAngle());
-
   return gp_Pnt2d( U, Z);
 }
 #endif
Index: oce/src/ProjLib/ProjLib_PrjResolve.cxx
===================================================================
--- oce.orig/src/ProjLib/ProjLib_PrjResolve.cxx
+++ oce/src/ProjLib/ProjLib_PrjResolve.cxx
@@ -97,9 +97,6 @@
 
     
     F.Value(X, FVal);   
-#ifdef DEB
-    Standard_Real FuncVal= FVal(1)*FVal(1) + FVal(2)*FVal(2);
-#endif
 
     if ((FVal(1)*FVal(1) + FVal(2)*FVal(2)) > FuncTol) myDone = Standard_False;
   }
Index: oce/src/Prs2d/Prs2d_Angle.cxx
===================================================================
--- oce.orig/src/Prs2d/Prs2d_Angle.cxx
+++ oce/src/Prs2d/Prs2d_Angle.cxx
@@ -390,9 +390,6 @@ void Prs2d_Angle::DrawElement( const Han
     
     /////////////////////////////////////////
     Standard_ShortReal txtAngle=Standard_ShortReal(myAbsAngle);
-    Standard_Real theSmbX,theSmbY;
-    theSmbX=myAbsX;
-    theSmbY=myAbsY;
     /////////////////////////////////////////
     Standard_ShortReal a = myCentX, b = myCentY, c = myRad, e = myFAngle, 
                        f = mySAngle,t1 = Standard_ShortReal( myAbsX ),
Index: oce/src/Prs2d/Prs2d_Diameter.cxx
===================================================================
--- oce.orig/src/Prs2d/Prs2d_Diameter.cxx
+++ oce/src/Prs2d/Prs2d_Diameter.cxx
@@ -33,13 +33,11 @@ Prs2d_Diameter::Prs2d_Diameter( const Ha
    gp_Vec2d theVec( PTonCirc, aPnt2 );
    Standard_Real theDist = aPnt2.Distance( aPnt1 ),
                  theRad  = aCircle.Radius();
-   Standard_Boolean inside  = Standard_False;
    myInside=Standard_False;
    
    if ( theDist < theRad ) {
     aPnt1    = PTonCirc;
     theDist  = theRad;
-    inside   = Standard_True;
     myInside = Standard_True;
    }
 
Index: oce/src/Prs2d/Prs2d_Radius.cxx
===================================================================
--- oce.orig/src/Prs2d/Prs2d_Radius.cxx
+++ oce/src/Prs2d/Prs2d_Radius.cxx
@@ -33,12 +33,10 @@ Prs2d_Radius::Prs2d_Radius( const Handle
 //   gp_Vec2d theVec( PTonCirc, aPnt2 );
    Standard_Real theDist = aPnt2.Distance( aPnt1 );
    Standard_Real theRad  = aCircle.Radius();
-   Standard_Boolean inside  = Standard_False;
 
    if ( theDist < theRad ) {
     aPnt1 = PTonCirc;
     theDist = theRad;
-    inside = Standard_True;
    }
 
    Standard_Real X1, Y1, X2, Y2;
Index: oce/src/RWHeaderSection/RWHeaderSection_RWFileDescription.cxx
===================================================================
--- oce.orig/src/RWHeaderSection/RWHeaderSection_RWFileDescription.cxx
+++ oce/src/RWHeaderSection/RWHeaderSection_RWFileDescription.cxx
@@ -39,8 +39,7 @@ void RWHeaderSection_RWFileDescription::
 	// --- own field : implementationLevel ---
 
 	Handle(TCollection_HAsciiString) aImplementationLevel;
-	Standard_Boolean stat2;
-	stat2 = data->ReadString (num,2,"implementation_level",ach,aImplementationLevel);
+	data->ReadString (num,2,"implementation_level",ach,aImplementationLevel);
 
 	//--- Initialisation of the read entity ---
 
Index: oce/src/RWHeaderSection/RWHeaderSection_RWFileName.cxx
===================================================================
--- oce.orig/src/RWHeaderSection/RWHeaderSection_RWFileName.cxx
+++ oce/src/RWHeaderSection/RWHeaderSection_RWFileName.cxx
@@ -20,14 +20,12 @@ void RWHeaderSection_RWFileName::ReadSte
 	// --- own field : name ---
 
 	Handle(TCollection_HAsciiString) aName;
-	Standard_Boolean stat1;
-	stat1 = data->ReadString (num,1,"name",ach,aName);
+	data->ReadString (num,1,"name",ach,aName);
 
 	// --- own field : timeStamp ---
 
 	Handle(TCollection_HAsciiString) aTimeStamp;
-	Standard_Boolean stat2;
-	stat2 = data->ReadString (num,2,"time_stamp",ach,aTimeStamp);
+	data->ReadString (num,2,"time_stamp",ach,aTimeStamp);
 
 	// --- own field : author ---
 
@@ -70,20 +68,17 @@ void RWHeaderSection_RWFileName::ReadSte
 	// --- own field : preprocessorVersion ---
 
 	Handle(TCollection_HAsciiString) aPreprocessorVersion;
-	Standard_Boolean stat5;
-	stat5 = data->ReadString (num,5,"preprocessor_version",ach,aPreprocessorVersion);
+	data->ReadString (num,5,"preprocessor_version",ach,aPreprocessorVersion);
 
 	// --- own field : originatingSystem ---
 
 	Handle(TCollection_HAsciiString) aOriginatingSystem;
-	Standard_Boolean stat6;
-	stat6 = data->ReadString (num,6,"originating_system",ach,aOriginatingSystem);
+	data->ReadString (num,6,"originating_system",ach,aOriginatingSystem);
 
 	// --- own field : authorisation ---
 
 	Handle(TCollection_HAsciiString) aAuthorisation;
-	Standard_Boolean stat7;
-	stat7 = data->ReadString (num,7,"authorisation",ach,aAuthorisation);
+	data->ReadString (num,7,"authorisation",ach,aAuthorisation);
 
 	//--- Initialisation of the read entity ---
 
Index: oce/src/RWHeaderSection/RWHeaderSection_ReadWriteModule.cxx
===================================================================
--- oce.orig/src/RWHeaderSection/RWHeaderSection_ReadWriteModule.cxx
+++ oce/src/RWHeaderSection/RWHeaderSection_ReadWriteModule.cxx
@@ -50,8 +50,8 @@ Standard_Integer RWHeaderSection_ReadWri
 	(const TColStd_SequenceOfAsciiString& types) const
 {
 
-  Standard_Integer NbComp = types.Length();
 #ifdef DEB
+  Standard_Integer NbComp = types.Length();
   if (NbComp < 2) {
     cout << "Plex Instance illegal " << endl;
   }
Index: oce/src/RWStepAP214/RWStepAP214_RWAppliedApprovalAssignment.cxx
===================================================================
--- oce.orig/src/RWStepAP214/RWStepAP214_RWAppliedApprovalAssignment.cxx
+++ oce/src/RWStepAP214/RWStepAP214_RWAppliedApprovalAssignment.cxx
@@ -28,10 +28,7 @@ void RWStepAP214_RWAppliedApprovalAssign
   // --- inherited field : assignedApproval ---
   
   Handle(StepBasic_Approval) aAssignedApproval;
-#ifdef DEB
-  Standard_Boolean stat1 = 
-#endif
-    data->ReadEntity(num, 1,"assigned_approval", ach, STANDARD_TYPE(StepBasic_Approval), aAssignedApproval);
+  data->ReadEntity(num, 1,"assigned_approval", ach, STANDARD_TYPE(StepBasic_Approval), aAssignedApproval);
 
   // --- own field : items ---
   
Index: oce/src/RWStepAP214/RWStepAP214_RWAppliedDateAndTimeAssignment.cxx
===================================================================
--- oce.orig/src/RWStepAP214/RWStepAP214_RWAppliedDateAndTimeAssignment.cxx
+++ oce/src/RWStepAP214/RWStepAP214_RWAppliedDateAndTimeAssignment.cxx
@@ -29,18 +29,12 @@ void RWStepAP214_RWAppliedDateAndTimeAss
   // --- inherited field : assignedDateAndTime ---
   
   Handle(StepBasic_DateAndTime) aAssignedDateAndTime;
-#ifdef DEB
-  Standard_Boolean stat1 = 
-#endif
-    data->ReadEntity(num, 1,"assigned_date_and_time", ach, STANDARD_TYPE(StepBasic_DateAndTime), aAssignedDateAndTime);
+  data->ReadEntity(num, 1,"assigned_date_and_time", ach, STANDARD_TYPE(StepBasic_DateAndTime), aAssignedDateAndTime);
   
   // --- inherited field : role ---
   
   Handle(StepBasic_DateTimeRole) aRole;
-#ifdef DEB
-  Standard_Boolean stat2 = 
-#endif
-    data->ReadEntity(num, 2,"role", ach, STANDARD_TYPE(StepBasic_DateTimeRole), aRole);
+  data->ReadEntity(num, 2,"role", ach, STANDARD_TYPE(StepBasic_DateTimeRole), aRole);
   
   // --- own field : items ---
   
Index: oce/src/RWStepAP214/RWStepAP214_RWAppliedDateAssignment.cxx
===================================================================
--- oce.orig/src/RWStepAP214/RWStepAP214_RWAppliedDateAssignment.cxx
+++ oce/src/RWStepAP214/RWStepAP214_RWAppliedDateAssignment.cxx
@@ -29,18 +29,12 @@ void RWStepAP214_RWAppliedDateAssignment
   // --- inherited field : assignedDate ---
   
   Handle(StepBasic_Date) aAssignedDate;
-#ifdef DEB
-  Standard_Boolean stat1 = 
-#endif
-    data->ReadEntity(num, 1,"assigned_date", ach, STANDARD_TYPE(StepBasic_Date), aAssignedDate);
+  data->ReadEntity(num, 1,"assigned_date", ach, STANDARD_TYPE(StepBasic_Date), aAssignedDate);
   
   // --- inherited field : role ---
   
   Handle(StepBasic_DateRole) aRole;
-#ifdef DEB
-  Standard_Boolean stat2 = 
-#endif
-    data->ReadEntity(num, 2,"role", ach, STANDARD_TYPE(StepBasic_DateRole), aRole);
+  data->ReadEntity(num, 2,"role", ach, STANDARD_TYPE(StepBasic_DateRole), aRole);
 
   // --- own field : items ---
 
Index: oce/src/RWStepAP214/RWStepAP214_RWAppliedDocumentReference.cxx
===================================================================
--- oce.orig/src/RWStepAP214/RWStepAP214_RWAppliedDocumentReference.cxx
+++ oce/src/RWStepAP214/RWStepAP214_RWAppliedDocumentReference.cxx
@@ -21,17 +21,12 @@ void  RWStepAP214_RWAppliedDocumentRefer
   // --- inherited field : assigned_document
   
   Handle(StepBasic_Document) adoc;
-#ifdef DEB
-  Standard_Boolean stat1 = 
-#endif
-    data->ReadEntity
-      (num, 1,"assigned_document", ach, STANDARD_TYPE(StepBasic_Document), adoc);
+  data->ReadEntity(num, 1,"assigned_document", ach, STANDARD_TYPE(StepBasic_Document), adoc);
   
   // --- inherited field : source ---
 
   Handle(TCollection_HAsciiString) asource;
-  Standard_Boolean stat2;
-  stat2 = data->ReadString (num,2,"source",ach,asource);
+  data->ReadString (num,2,"source",ach,asource);
   
   
   // --- own field : items ---
Index: oce/src/RWStepAP214/RWStepAP214_RWAppliedOrganizationAssignment.cxx
===================================================================
--- oce.orig/src/RWStepAP214/RWStepAP214_RWAppliedOrganizationAssignment.cxx
+++ oce/src/RWStepAP214/RWStepAP214_RWAppliedOrganizationAssignment.cxx
@@ -29,18 +29,12 @@ void RWStepAP214_RWAppliedOrganizationAs
   // --- inherited field : assignedOrganization ---
   
   Handle(StepBasic_Organization) aAssignedOrganization;
-#ifdef DEB
-  Standard_Boolean stat1 = 
-#endif
-    data->ReadEntity(num, 1,"assigned_organization", ach, STANDARD_TYPE(StepBasic_Organization), aAssignedOrganization);
+  data->ReadEntity(num, 1,"assigned_organization", ach, STANDARD_TYPE(StepBasic_Organization), aAssignedOrganization);
   
   // --- inherited field : role ---
 
   Handle(StepBasic_OrganizationRole) aRole;
-#ifdef DEB
-  Standard_Boolean stat2 = 
-#endif
-    data->ReadEntity(num, 2,"role", ach, STANDARD_TYPE(StepBasic_OrganizationRole), aRole);
+  data->ReadEntity(num, 2,"role", ach, STANDARD_TYPE(StepBasic_OrganizationRole), aRole);
   
   // --- own field : items ---
 
Index: oce/src/RWStepAP214/RWStepAP214_RWAppliedPersonAndOrganizationAssignment.cxx
===================================================================
--- oce.orig/src/RWStepAP214/RWStepAP214_RWAppliedPersonAndOrganizationAssignment.cxx
+++ oce/src/RWStepAP214/RWStepAP214_RWAppliedPersonAndOrganizationAssignment.cxx
@@ -29,18 +29,12 @@ void RWStepAP214_RWAppliedPersonAndOrgan
   // --- inherited field : assignedPersonAndOrganization ---
   
   Handle(StepBasic_PersonAndOrganization) aAssignedPersonAndOrganization;
-#ifdef DEB
-  Standard_Boolean stat1 = 
-#endif
-    data->ReadEntity(num, 1,"assigned_person_and_organization", ach, STANDARD_TYPE(StepBasic_PersonAndOrganization), aAssignedPersonAndOrganization);
+  data->ReadEntity(num, 1,"assigned_person_and_organization", ach, STANDARD_TYPE(StepBasic_PersonAndOrganization), aAssignedPersonAndOrganization);
   
   // --- inherited field : role ---
   
   Handle(StepBasic_PersonAndOrganizationRole) aRole;
-#ifdef DEB
-  Standard_Boolean stat2 = 
-#endif
-    data->ReadEntity(num, 2,"role", ach, STANDARD_TYPE(StepBasic_PersonAndOrganizationRole), aRole);
+  data->ReadEntity(num, 2,"role", ach, STANDARD_TYPE(StepBasic_PersonAndOrganizationRole), aRole);
   
   // --- own field : items ---
   
Index: oce/src/RWStepAP214/RWStepAP214_RWAppliedSecurityClassificationAssignment.cxx
===================================================================
--- oce.orig/src/RWStepAP214/RWStepAP214_RWAppliedSecurityClassificationAssignment.cxx
+++ oce/src/RWStepAP214/RWStepAP214_RWAppliedSecurityClassificationAssignment.cxx
@@ -28,10 +28,7 @@ void RWStepAP214_RWAppliedSecurityClassi
   // --- inherited field : assignedSecurityClassification ---
   
   Handle(StepBasic_SecurityClassification) aAssignedSecurityClassification;
-#ifdef DEB
-  Standard_Boolean stat1 = 
-#endif
-    data->ReadEntity(num, 1,"assigned_security_classification", ach, STANDARD_TYPE(StepBasic_SecurityClassification), aAssignedSecurityClassification);
+  data->ReadEntity(num, 1,"assigned_security_classification", ach, STANDARD_TYPE(StepBasic_SecurityClassification), aAssignedSecurityClassification);
   
   // --- own field : items ---
   
Index: oce/src/RWStepAP214/RWStepAP214_RWAutoDesignActualDateAndTimeAssignment.cxx
===================================================================
--- oce.orig/src/RWStepAP214/RWStepAP214_RWAutoDesignActualDateAndTimeAssignment.cxx
+++ oce/src/RWStepAP214/RWStepAP214_RWAutoDesignActualDateAndTimeAssignment.cxx
@@ -29,18 +29,12 @@ void RWStepAP214_RWAutoDesignActualDateA
 	// --- inherited field : assignedDateAndTime ---
 
 	Handle(StepBasic_DateAndTime) aAssignedDateAndTime;
-#ifdef DEB
-	Standard_Boolean stat1 = 
-#endif
-	  data->ReadEntity(num, 1,"assigned_date_and_time", ach, STANDARD_TYPE(StepBasic_DateAndTime), aAssignedDateAndTime);
+	data->ReadEntity(num, 1,"assigned_date_and_time", ach, STANDARD_TYPE(StepBasic_DateAndTime), aAssignedDateAndTime);
 
 	// --- inherited field : role ---
 
 	Handle(StepBasic_DateTimeRole) aRole;
-#ifdef DEB
-	Standard_Boolean stat2 = 
-#endif
-	  data->ReadEntity(num, 2,"role", ach, STANDARD_TYPE(StepBasic_DateTimeRole), aRole);
+	data->ReadEntity(num, 2,"role", ach, STANDARD_TYPE(StepBasic_DateTimeRole), aRole);
 
 	// --- own field : items ---
 
Index: oce/src/RWStepAP214/RWStepAP214_RWAutoDesignActualDateAssignment.cxx
===================================================================
--- oce.orig/src/RWStepAP214/RWStepAP214_RWAutoDesignActualDateAssignment.cxx
+++ oce/src/RWStepAP214/RWStepAP214_RWAutoDesignActualDateAssignment.cxx
@@ -29,18 +29,12 @@ void RWStepAP214_RWAutoDesignActualDateA
 	// --- inherited field : assignedDate ---
 
 	Handle(StepBasic_Date) aAssignedDate;
-#ifdef DEB
-	Standard_Boolean stat1 = 
-#endif
-	  data->ReadEntity(num, 1,"assigned_date", ach, STANDARD_TYPE(StepBasic_Date), aAssignedDate);
+	data->ReadEntity(num, 1,"assigned_date", ach, STANDARD_TYPE(StepBasic_Date), aAssignedDate);
 
 	// --- inherited field : role ---
 
 	Handle(StepBasic_DateRole) aRole;
-#ifdef DEB
-	Standard_Boolean stat2 = 
-#endif
-	  data->ReadEntity(num, 2,"role", ach, STANDARD_TYPE(StepBasic_DateRole), aRole);
+	data->ReadEntity(num, 2,"role", ach, STANDARD_TYPE(StepBasic_DateRole), aRole);
 
 	// --- own field : items ---
 
Index: oce/src/RWStepAP214/RWStepAP214_RWAutoDesignApprovalAssignment.cxx
===================================================================
--- oce.orig/src/RWStepAP214/RWStepAP214_RWAutoDesignApprovalAssignment.cxx
+++ oce/src/RWStepAP214/RWStepAP214_RWAutoDesignApprovalAssignment.cxx
@@ -28,10 +28,7 @@ void RWStepAP214_RWAutoDesignApprovalAss
 	// --- inherited field : assignedApproval ---
 
 	Handle(StepBasic_Approval) aAssignedApproval;
-#ifdef DEB
-	Standard_Boolean stat1 = 
-#endif
-	  data->ReadEntity(num, 1,"assigned_approval", ach, STANDARD_TYPE(StepBasic_Approval), aAssignedApproval);
+	data->ReadEntity(num, 1,"assigned_approval", ach, STANDARD_TYPE(StepBasic_Approval), aAssignedApproval);
 
 	// --- own field : items ---
 
Index: oce/src/RWStepAP214/RWStepAP214_RWAutoDesignDateAndPersonAssignment.cxx
===================================================================
--- oce.orig/src/RWStepAP214/RWStepAP214_RWAutoDesignDateAndPersonAssignment.cxx
+++ oce/src/RWStepAP214/RWStepAP214_RWAutoDesignDateAndPersonAssignment.cxx
@@ -29,18 +29,12 @@ void RWStepAP214_RWAutoDesignDateAndPers
 	// --- inherited field : assignedPersonAndOrganization ---
 
 	Handle(StepBasic_PersonAndOrganization) aAssignedPersonAndOrganization;
-#ifdef DEB
-	Standard_Boolean stat1 = 
-#endif
-	  data->ReadEntity(num, 1,"assigned_person_and_organization", ach, STANDARD_TYPE(StepBasic_PersonAndOrganization), aAssignedPersonAndOrganization);
+	data->ReadEntity(num, 1,"assigned_person_and_organization", ach, STANDARD_TYPE(StepBasic_PersonAndOrganization), aAssignedPersonAndOrganization);
 
 	// --- inherited field : role ---
 
 	Handle(StepBasic_PersonAndOrganizationRole) aRole;
-#ifdef DEB
-	Standard_Boolean stat2 = 
-#endif
-	  data->ReadEntity(num, 2,"role", ach, STANDARD_TYPE(StepBasic_PersonAndOrganizationRole), aRole);
+	data->ReadEntity(num, 2,"role", ach, STANDARD_TYPE(StepBasic_PersonAndOrganizationRole), aRole);
 
 	// --- own field : items ---
 
Index: oce/src/RWStepAP214/RWStepAP214_RWAutoDesignDocumentReference.cxx
===================================================================
--- oce.orig/src/RWStepAP214/RWStepAP214_RWAutoDesignDocumentReference.cxx
+++ oce/src/RWStepAP214/RWStepAP214_RWAutoDesignDocumentReference.cxx
@@ -21,17 +21,12 @@ void  RWStepAP214_RWAutoDesignDocumentRe
 	// --- inherited field : assigned_document
 
 	Handle(StepBasic_Document) adoc;
-#ifdef DEB
-	Standard_Boolean stat1 = 
-#endif
-	  data->ReadEntity
-	    (num, 1,"assigned_document", ach, STANDARD_TYPE(StepBasic_Document), adoc);
+	data->ReadEntity(num, 1,"assigned_document", ach, STANDARD_TYPE(StepBasic_Document), adoc);
 
 	// --- inherited field : source ---
 
 	Handle(TCollection_HAsciiString) asource;
-	Standard_Boolean stat2;
-	stat2 = data->ReadString (num,2,"source",ach,asource);
+	data->ReadString (num,2,"source",ach,asource);
 
 
         // --- own field : items ---
Index: oce/src/RWStepAP214/RWStepAP214_RWAutoDesignNominalDateAndTimeAssignment.cxx
===================================================================
--- oce.orig/src/RWStepAP214/RWStepAP214_RWAutoDesignNominalDateAndTimeAssignment.cxx
+++ oce/src/RWStepAP214/RWStepAP214_RWAutoDesignNominalDateAndTimeAssignment.cxx
@@ -29,18 +29,12 @@ void RWStepAP214_RWAutoDesignNominalDate
 	// --- inherited field : assignedDateAndTime ---
 
 	Handle(StepBasic_DateAndTime) aAssignedDateAndTime;
-#ifdef DEB
-	Standard_Boolean stat1 = 
-#endif
-	  data->ReadEntity(num, 1,"assigned_date_and_time", ach, STANDARD_TYPE(StepBasic_DateAndTime), aAssignedDateAndTime);
+	data->ReadEntity(num, 1,"assigned_date_and_time", ach, STANDARD_TYPE(StepBasic_DateAndTime), aAssignedDateAndTime);
 
 	// --- inherited field : role ---
 
 	Handle(StepBasic_DateTimeRole) aRole;
-#ifdef DEB
-	Standard_Boolean stat2 = 
-#endif
-	  data->ReadEntity(num, 2,"role", ach, STANDARD_TYPE(StepBasic_DateTimeRole), aRole);
+	data->ReadEntity(num, 2,"role", ach, STANDARD_TYPE(StepBasic_DateTimeRole), aRole);
 
 	// --- own field : items ---
 
Index: oce/src/RWStepAP214/RWStepAP214_RWAutoDesignOrganizationAssignment.cxx
===================================================================
--- oce.orig/src/RWStepAP214/RWStepAP214_RWAutoDesignOrganizationAssignment.cxx
+++ oce/src/RWStepAP214/RWStepAP214_RWAutoDesignOrganizationAssignment.cxx
@@ -29,18 +29,12 @@ void RWStepAP214_RWAutoDesignOrganizatio
 	// --- inherited field : assignedOrganization ---
 
 	Handle(StepBasic_Organization) aAssignedOrganization;
-#ifdef DEB
-	Standard_Boolean stat1 = 
-#endif
-	  data->ReadEntity(num, 1,"assigned_organization", ach, STANDARD_TYPE(StepBasic_Organization), aAssignedOrganization);
+	data->ReadEntity(num, 1,"assigned_organization", ach, STANDARD_TYPE(StepBasic_Organization), aAssignedOrganization);
 
 	// --- inherited field : role ---
 
 	Handle(StepBasic_OrganizationRole) aRole;
-#ifdef DEB
-	Standard_Boolean stat2 = 
-#endif
-	  data->ReadEntity(num, 2,"role", ach, STANDARD_TYPE(StepBasic_OrganizationRole), aRole);
+	data->ReadEntity(num, 2,"role", ach, STANDARD_TYPE(StepBasic_OrganizationRole), aRole);
 
 	// --- own field : items ---
 
Index: oce/src/RWStepAP214/RWStepAP214_RWAutoDesignPersonAndOrganizationAssignment.cxx
===================================================================
--- oce.orig/src/RWStepAP214/RWStepAP214_RWAutoDesignPersonAndOrganizationAssignment.cxx
+++ oce/src/RWStepAP214/RWStepAP214_RWAutoDesignPersonAndOrganizationAssignment.cxx
@@ -29,18 +29,12 @@ void RWStepAP214_RWAutoDesignPersonAndOr
 	// --- inherited field : assignedPersonAndOrganization ---
 
 	Handle(StepBasic_PersonAndOrganization) aAssignedPersonAndOrganization;
-#ifdef DEB
-	Standard_Boolean stat1 = 
-#endif
-	  data->ReadEntity(num, 1,"assigned_person_and_organization", ach, STANDARD_TYPE(StepBasic_PersonAndOrganization), aAssignedPersonAndOrganization);
+	data->ReadEntity(num, 1,"assigned_person_and_organization", ach, STANDARD_TYPE(StepBasic_PersonAndOrganization), aAssignedPersonAndOrganization);
 
 	// --- inherited field : role ---
 
 	Handle(StepBasic_PersonAndOrganizationRole) aRole;
-#ifdef DEB
-	Standard_Boolean stat2 = 
-#endif
-	  data->ReadEntity(num, 2,"role", ach, STANDARD_TYPE(StepBasic_PersonAndOrganizationRole), aRole);
+	data->ReadEntity(num, 2,"role", ach, STANDARD_TYPE(StepBasic_PersonAndOrganizationRole), aRole);
 
 	// --- own field : items ---
 
Index: oce/src/RWStepAP214/RWStepAP214_RWAutoDesignSecurityClassificationAssignment.cxx
===================================================================
--- oce.orig/src/RWStepAP214/RWStepAP214_RWAutoDesignSecurityClassificationAssignment.cxx
+++ oce/src/RWStepAP214/RWStepAP214_RWAutoDesignSecurityClassificationAssignment.cxx
@@ -28,10 +28,7 @@ void RWStepAP214_RWAutoDesignSecurityCla
 	// --- inherited field : assignedSecurityClassification ---
 
 	Handle(StepBasic_SecurityClassification) aAssignedSecurityClassification;
-#ifdef DEB
-	Standard_Boolean stat1 = 
-#endif
-	  data->ReadEntity(num, 1,"assigned_security_classification", ach, STANDARD_TYPE(StepBasic_SecurityClassification), aAssignedSecurityClassification);
+	data->ReadEntity(num, 1,"assigned_security_classification", ach, STANDARD_TYPE(StepBasic_SecurityClassification), aAssignedSecurityClassification);
 
 	// --- own field : items ---
 
Index: oce/src/RWStepBasic/RWStepBasic_RWApplicationContextElement.cxx
===================================================================
--- oce.orig/src/RWStepBasic/RWStepBasic_RWApplicationContextElement.cxx
+++ oce/src/RWStepBasic/RWStepBasic_RWApplicationContextElement.cxx
@@ -32,10 +32,7 @@ void RWStepBasic_RWApplicationContextEle
 	// --- own field : frameOfReference ---
 
 	Handle(StepBasic_ApplicationContext) aFrameOfReference;
-#ifdef DEB
-	Standard_Boolean stat2 = 
-#endif
-	  data->ReadEntity(num, 2,"frame_of_reference", ach, STANDARD_TYPE(StepBasic_ApplicationContext), aFrameOfReference);
+	data->ReadEntity(num, 2,"frame_of_reference", ach, STANDARD_TYPE(StepBasic_ApplicationContext), aFrameOfReference);
 
 	//--- Initialisation of the read entity ---
 
Index: oce/src/RWStepDimTol/RWStepDimTol_RWCommonDatum.cxx
===================================================================
--- oce.orig/src/RWStepDimTol/RWStepDimTol_RWCommonDatum.cxx
+++ oce/src/RWStepDimTol/RWStepDimTol_RWCommonDatum.cxx
@@ -35,13 +35,9 @@ void RWStepDimTol_RWCommonDatum::ReadSte
   data->ReadString (num, 1, "shape_aspect.name", ach, aShapeAspect_Name);
 
   Handle(TCollection_HAsciiString) aShapeAspect_Description;
-  Standard_Boolean hasShapeAspect_Description = Standard_True;
   if ( data->IsParamDefined (num,2) ) {
     data->ReadString (num, 2, "shape_aspect.description", ach, aShapeAspect_Description);
   }
-  else {
-    hasShapeAspect_Description = Standard_False;
-  }
 
   Handle(StepRepr_ProductDefinitionShape) aShapeAspect_OfShape;
   data->ReadEntity (num, 3, "shape_aspect.of_shape", ach, STANDARD_TYPE(StepRepr_ProductDefinitionShape), aShapeAspect_OfShape);
Index: oce/src/RWStepRepr/RWStepRepr_RWCompositeShapeAspect.cxx
===================================================================
--- oce.orig/src/RWStepRepr/RWStepRepr_RWCompositeShapeAspect.cxx
+++ oce/src/RWStepRepr/RWStepRepr_RWCompositeShapeAspect.cxx
@@ -34,13 +34,9 @@ void RWStepRepr_RWCompositeShapeAspect::
   data->ReadString (num, 1, "shape_aspect.name", ach, aShapeAspect_Name);
 
   Handle(TCollection_HAsciiString) aShapeAspect_Description;
-  Standard_Boolean hasShapeAspect_Description = Standard_True;
   if ( data->IsParamDefined (num,2) ) {
     data->ReadString (num, 2, "shape_aspect.description", ach, aShapeAspect_Description);
   }
-  else {
-    hasShapeAspect_Description = Standard_False;
-  }
 
   Handle(StepRepr_ProductDefinitionShape) aShapeAspect_OfShape;
   data->ReadEntity (num, 3, "shape_aspect.of_shape", ach, STANDARD_TYPE(StepRepr_ProductDefinitionShape), aShapeAspect_OfShape);
Index: oce/src/RWStepRepr/RWStepRepr_RWDerivedShapeAspect.cxx
===================================================================
--- oce.orig/src/RWStepRepr/RWStepRepr_RWDerivedShapeAspect.cxx
+++ oce/src/RWStepRepr/RWStepRepr_RWDerivedShapeAspect.cxx
@@ -34,13 +34,9 @@ void RWStepRepr_RWDerivedShapeAspect::Re
   data->ReadString (num, 1, "shape_aspect.name", ach, aShapeAspect_Name);
 
   Handle(TCollection_HAsciiString) aShapeAspect_Description;
-  Standard_Boolean hasShapeAspect_Description = Standard_True;
   if ( data->IsParamDefined (num,2) ) {
     data->ReadString (num, 2, "shape_aspect.description", ach, aShapeAspect_Description);
   }
-  else {
-    hasShapeAspect_Description = Standard_False;
-  }
 
   Handle(StepRepr_ProductDefinitionShape) aShapeAspect_OfShape;
   data->ReadEntity (num, 3, "shape_aspect.of_shape", ach, STANDARD_TYPE(StepRepr_ProductDefinitionShape), aShapeAspect_OfShape);
Index: oce/src/RWStepRepr/RWStepRepr_RWExtension.cxx
===================================================================
--- oce.orig/src/RWStepRepr/RWStepRepr_RWExtension.cxx
+++ oce/src/RWStepRepr/RWStepRepr_RWExtension.cxx
@@ -34,13 +34,9 @@ void RWStepRepr_RWExtension::ReadStep (c
   data->ReadString (num, 1, "shape_aspect.name", ach, aShapeAspect_Name);
 
   Handle(TCollection_HAsciiString) aShapeAspect_Description;
-  Standard_Boolean hasShapeAspect_Description = Standard_True;
   if ( data->IsParamDefined (num,2) ) {
     data->ReadString (num, 2, "shape_aspect.description", ach, aShapeAspect_Description);
   }
-  else {
-    hasShapeAspect_Description = Standard_False;
-  }
 
   Handle(StepRepr_ProductDefinitionShape) aShapeAspect_OfShape;
   data->ReadEntity (num, 3, "shape_aspect.of_shape", ach, STANDARD_TYPE(StepRepr_ProductDefinitionShape), aShapeAspect_OfShape);
Index: oce/src/RWStepShape/RWStepShape_RWFaceBound.cxx
===================================================================
--- oce.orig/src/RWStepShape/RWStepShape_RWFaceBound.cxx
+++ oce/src/RWStepShape/RWStepShape_RWFaceBound.cxx
@@ -131,10 +131,6 @@ void RWStepShape_RWFaceBound::Check
 	  else {
 	    myShRef = aShto.Sharings(theEL2);
 	    myShRef.SelectType (STANDARD_TYPE(StepShape_FaceBound),Standard_True);
-#ifdef DEB
-	    Standard_Integer nbRef = 
-#endif
-	      myShRef.NbEntities();	
 	    myShRef.Start();
 	    Handle(StepShape_FaceBound) theFB2 =
 	      Handle(StepShape_FaceBound)::DownCast(myShRef.Value());
Index: oce/src/Select2D/Select2D_SensitivePoint.cxx
===================================================================
--- oce.orig/src/Select2D/Select2D_SensitivePoint.cxx
+++ oce/src/Select2D/Select2D_SensitivePoint.cxx
@@ -62,9 +62,6 @@ Matches (const Standard_Real XMin,
 	 const Standard_Real YMax,
 	 const Standard_Real aTol)
 {//distance point-Line....
-#ifdef DEB
-  Standard_Real TheTol = HasOwnTolerance()? myOwnTolerance : aTol;
-#endif
   Standard_Real MinDist = gp_Lin2d(gp_Pnt2d(XMin,YMin),
 		     gp_Vec2d(gp_Pnt2d(XMin,YMin),
 			      gp_Pnt2d(XMax,YMax))
Index: oce/src/Select3D/Select3D_SensitiveCircle.cxx
===================================================================
--- oce.orig/src/Select3D/Select3D_SensitiveCircle.cxx
+++ oce/src/Select3D/Select3D_SensitiveCircle.cxx
@@ -249,9 +249,6 @@ Matches (const TColgp_Array1OfPnt2d& aPo
 { 
   Standard_Real Umin,Vmin,Umax,Vmax;
   aBox.Get(Umin,Vmin,Umax,Vmax);
-  Standard_Real Tolu,Tolv;
-  Tolu = 1e-7;
-  Tolv = 1e-7;
   CSLib_Class2d aClassifier2d(aPoly,aTol,aTol,Umin,Vmin,Umax,Vmax);
 
   for(Standard_Integer j=1;j<=mynbpoints;j++){
Index: oce/src/Select3D/Select3D_SensitiveCurve.cxx
===================================================================
--- oce.orig/src/Select3D/Select3D_SensitiveCurve.cxx
+++ oce/src/Select3D/Select3D_SensitiveCurve.cxx
@@ -113,9 +113,6 @@ Matches (const TColgp_Array1OfPnt2d& aPo
 { 
   Standard_Real Umin,Vmin,Umax,Vmax;
   aBox.Get(Umin,Vmin,Umax,Vmax);
-  Standard_Real Tolu,Tolv;
-  Tolu = 1e-7;
-  Tolv = 1e-7;
   CSLib_Class2d aClassifier2d(aPoly,aTol,aTol,Umin,Vmin,Umax,Vmax);
 
   for(Standard_Integer j=0;j<mynbpoints;j++){
Index: oce/src/Select3D/Select3D_SensitiveFace.cxx
===================================================================
--- oce.orig/src/Select3D/Select3D_SensitiveFace.cxx
+++ oce/src/Select3D/Select3D_SensitiveFace.cxx
@@ -190,9 +190,6 @@ Matches (const TColgp_Array1OfPnt2d& aPo
 { 
   Standard_Real Umin,Vmin,Umax,Vmax;
   aBox.Get(Umin,Vmin,Umax,Vmax);
-  Standard_Real Tolu,Tolv;
-  Tolu = 1e-7;
-  Tolv = 1e-7;
   CSLib_Class2d aClassifier2d(aPoly,aTol,aTol,Umin,Vmin,Umax,Vmax);
 
   for(Standard_Integer j=1;j<=mynbpoints;j++){
Index: oce/src/Select3D/Select3D_SensitivePoint.cxx
===================================================================
--- oce.orig/src/Select3D/Select3D_SensitivePoint.cxx
+++ oce/src/Select3D/Select3D_SensitivePoint.cxx
@@ -103,9 +103,6 @@ Matches (const TColgp_Array1OfPnt2d& aPo
 { 
   Standard_Real Umin,Vmin,Umax,Vmax;
   aBox.Get(Umin,Vmin,Umax,Vmax);
-  Standard_Real Tolu,Tolv;
-  Tolu = 1e-7;
-  Tolv = 1e-7;
   CSLib_Class2d aClassifier2d(aPoly,aTol,aTol,Umin,Vmin,Umax,Vmax);
 
   Standard_Integer RES = aClassifier2d.SiDans(myprojpt);
Index: oce/src/Select3D/Select3D_SensitiveSegment.cxx
===================================================================
--- oce.orig/src/Select3D/Select3D_SensitiveSegment.cxx
+++ oce/src/Select3D/Select3D_SensitiveSegment.cxx
@@ -154,9 +154,6 @@ Matches (const TColgp_Array1OfPnt2d& aPo
 { 
   Standard_Real Umin,Vmin,Umax,Vmax;
   aBox.Get(Umin,Vmin,Umax,Vmax);
-  Standard_Real Tolu,Tolv;
-  Tolu = 1e-7;
-  Tolv = 1e-7;
   CSLib_Class2d aClassifier2d(aPoly,aTol,aTol,Umin,Vmin,Umax,Vmax);
 
   Standard_Integer RES = aClassifier2d.SiDans(myprojstart);
Index: oce/src/Select3D/Select3D_SensitiveTriangle.cxx
===================================================================
--- oce.orig/src/Select3D/Select3D_SensitiveTriangle.cxx
+++ oce/src/Select3D/Select3D_SensitiveTriangle.cxx
@@ -123,9 +123,6 @@ Matches (const TColgp_Array1OfPnt2d& aPo
 { 
   Standard_Real Umin,Vmin,Umax,Vmax;
   aBox.Get(Umin,Vmin,Umax,Vmax);
-  Standard_Real Tolu,Tolv;
-  Tolu = 1e-7;
-  Tolv = 1e-7;
   CSLib_Class2d aClassifier2d(aPoly,aTol,aTol,Umin,Vmin,Umax,Vmax);
 
   for(Standard_Integer i=0;i<=2;i++){
@@ -198,7 +195,6 @@ Standard_Integer  Select3D_SensitiveTria
   gp_XY V02(p2);V02-=p0;
   gp_XY V12(p2);V12-=p1;
 
-  Standard_Real TolTol = aTol*aTol;
 
   // check these particular cases...
   // if one of vectors is almost null (2 points are mixed), 
Index: oce/src/Select3D/Select3D_SensitiveTriangulation.cxx
===================================================================
--- oce.orig/src/Select3D/Select3D_SensitiveTriangulation.cxx
+++ oce/src/Select3D/Select3D_SensitiveTriangulation.cxx
@@ -351,9 +351,6 @@ Matches (const TColgp_Array1OfPnt2d& aPo
 {
   Standard_Real Umin,Vmin,Umax,Vmax;
   aBox.Get(Umin,Vmin,Umax,Vmax);
-  Standard_Real Tolu,Tolv;
-  Tolu = 1e-7;
-  Tolv = 1e-7;
   CSLib_Class2d aClassifier2d(aPoly,aTol,aTol,Umin,Vmin,Umax,Vmax);
 
   for(Standard_Integer j=1;j<=myNodes2d.Length();j++){
@@ -586,7 +583,6 @@ Standard_Boolean Select3D_SensitiveTrian
   if(myDetectedTr==-1) 
     return Standard_False; //  currently not implemented...
   const Poly_Array1OfTriangle& triangles = myTriangul->Triangles();
-  const TColgp_Array1OfPnt& Nodes = myTriangul->Nodes();
   Standard_Integer n1,n2,n3;
   triangles( myDetectedTr ).Get(n1,n2,n3);
 
Index: oce/src/SelectBasics/SelectBasics_BasicTool.cxx
===================================================================
--- oce.orig/src/SelectBasics/SelectBasics_BasicTool.cxx
+++ oce/src/SelectBasics/SelectBasics_BasicTool.cxx
@@ -57,7 +57,6 @@ Standard_Boolean SelectBasics_BasicTool:
 						      const Standard_Real aTol,
 						      Standard_Real& DMin)
 {
-  Standard_Boolean Found= Standard_False;
   const Standard_Real SqTol = aTol * aTol;	
   gp_Vec2d AB, AC, BC; 
   const gp_Pnt2d apoint(X,Y);
Index: oce/src/ShapeAnalysis/ShapeAnalysis.cxx
===================================================================
--- oce.orig/src/ShapeAnalysis/ShapeAnalysis.cxx
+++ oce/src/ShapeAnalysis/ShapeAnalysis.cxx
@@ -172,7 +172,7 @@ Standard_Real ShapeAnalysis::ContourArea
                                          //const Handle(ShapeExtend_WireData)& sewd)
                                         
 {
-  Standard_Integer i =1, nbc = 0;
+  Standard_Integer nbc = 0;
   gp_Pnt fuv,luv, uv0;
   //Standard_Real totcross=0;
   gp_XYZ aTotal(0.,0.,0.);
Index: oce/src/ShapeAnalysis/ShapeAnalysis_FreeBounds.cxx
===================================================================
--- oce.orig/src/ShapeAnalysis/ShapeAnalysis_FreeBounds.cxx
+++ oce/src/ShapeAnalysis/ShapeAnalysis_FreeBounds.cxx
@@ -210,8 +210,7 @@ ShapeAnalysis_FreeBounds::ShapeAnalysis_
     aBox.SetGap(tolerance);
     aTreeFiller.Add(inbW, aBox);
   }
-  Standard_Integer nbFill;
-  nbFill = aTreeFiller.Fill();
+  aTreeFiller.Fill();
   Standard_Integer nsel;
   
   ShapeAnalysis_Edge sae; //szv#4:S4163:12Mar99 moved
@@ -353,7 +352,6 @@ static void SplitWire(const TopoDS_Wire&
       Standard_Boolean SearchBackward = Standard_True;
 
       while (Standard_True) {
-	Standard_Integer ei = ces.Last(); //ei-edge index, number of current edge analyzed for connection
 	Standard_Boolean found;
 	TopoDS_Edge edge;
 	TopoDS_Vertex lvertex;
@@ -393,7 +391,6 @@ static void SplitWire(const TopoDS_Wire&
     
 	//searching for connection among free edges
 	found = Standard_False;
-	ei = ces.Last();
 	edge = sewd->Edge (ces.Last());
 	lvertex = sae.LastVertex (edge);
 	lpoint = BRep_Tool::Pnt (lvertex);
Index: oce/src/ShapeBuild/ShapeBuild_ReShape.cxx
===================================================================
--- oce.orig/src/ShapeBuild/ShapeBuild_ReShape.cxx
+++ oce/src/ShapeBuild/ShapeBuild_ReShape.cxx
@@ -63,7 +63,7 @@ TopoDS_Shape ShapeBuild_ReShape::Apply (
     return res;
   }
 
-  TopAbs_ShapeEnum st = shape.ShapeType(), subt;
+  TopAbs_ShapeEnum st = shape.ShapeType();
   if ( st >= until ) return newsh;    // critere d arret
   if(st == TopAbs_VERTEX || st == TopAbs_SHAPE)
     return shape;
Index: oce/src/ShapeUpgrade/ShapeUpgrade_RemoveInternalWires.cxx
===================================================================
--- oce.orig/src/ShapeUpgrade/ShapeUpgrade_RemoveInternalWires.cxx
+++ oce/src/ShapeUpgrade/ShapeUpgrade_RemoveInternalWires.cxx
@@ -229,7 +229,6 @@ void ShapeUpgrade_RemoveInternalWires::r
         if(!myRemoveEdges.IsBound(aE) ) {
           const TopTools_ListOfShape& aLface3 = myEdgeFaces.FindFromKey(aE);
           TopTools_ListIteratorOfListOfShape aliter3(aLface3);
-          Standard_Boolean isRemoved = Standard_True;
           for( ; aliter3.More();aliter3.Next()) {
             TopoDS_Shape aF2 = Context()->Apply(aliter3.Value());
             if(aF2.IsNull())
Index: oce/src/ShapeUpgrade/ShapeUpgrade_WireDivide.cxx
===================================================================
--- oce.orig/src/ShapeUpgrade/ShapeUpgrade_WireDivide.cxx
+++ oce/src/ShapeUpgrade/ShapeUpgrade_WireDivide.cxx
@@ -460,7 +460,6 @@ void ShapeUpgrade_WireDivide::Perform ()
       Standard_Integer numE =0;
       gp_Pnt pntV1 = BRep_Tool::Pnt(V1);
       //gp_Pnt pntV2 = BRep_Tool::Pnt(V2); // pntV2 not used - see below (skl)
-      Standard_Real V1Tol = LimitTolerance( BRep_Tool::Tolerance(V1) );
       //Standard_Real V2Tol = LimitTolerance( BRep_Tool::Tolerance(V2) ); // V2Tol not used - see below (skl)
       
       Handle(ShapeUpgrade_FixSmallCurves) FixSmallCurveTool = GetFixSmallCurveTool(); //gka Precision
@@ -570,7 +569,6 @@ void ShapeUpgrade_WireDivide::Perform ()
 	  if(icurv != nbc)  {
 	    B.MakeVertex (V, P, TolEdge); //tolerance of the edge
 	    pntV1 = P;
-	    V1Tol = LimitTolerance( TolEdge );
 	  }
 	  else V = V2;
 	 // else  V2;
Index: oce/src/StlTransfer/StlTransfer.cxx
===================================================================
--- oce.orig/src/StlTransfer/StlTransfer.cxx
+++ oce/src/StlTransfer/StlTransfer.cxx
@@ -105,7 +105,6 @@ void StlTransfer::BuildIncrementalMesh (
     Standard_ConstructionError::Raise ("StlTransfer::BuildIncrementalMesh");
     }
   
-  Standard_Integer NbVertices, NbTriangles;
   BRepMesh::Mesh (Shape, Deflection);
   for (TopExp_Explorer itf(Shape,TopAbs_FACE); itf.More(); itf.Next()) {
     TopoDS_Face face = TopoDS::Face(itf.Current());
@@ -116,11 +115,6 @@ void StlTransfer::BuildIncrementalMesh (
     theTriangles.Assign(theTriangulation->Triangles());
     Mesh->AddDomain (Deflection);
     
-#ifdef DEB
-    TopAbs_Orientation orientation = 
-#endif
-      face.Orientation();
-    
     TColgp_Array1OfPnt thePoints(1, theTriangulation->NbNodes());
     thePoints.Assign(theTriangulation->Nodes());
     //compute normal of face
@@ -134,7 +128,7 @@ void StlTransfer::BuildIncrementalMesh (
       gp_Pnt p = thePoints.Value(i);
       p.Transform(Loc.Transformation());
       p.Coord (X1, Y1, Z1);
-      NbVertices = Mesh->AddVertex (X1, Y1, Z1);
+      Mesh->AddVertex (X1, Y1, Z1);
     }
     try {
       OCC_CATCH_SIGNALS
@@ -167,7 +161,7 @@ void StlTransfer::BuildIncrementalMesh (
 	    A=V1;B=V2;C=V3;
 	  }
 	}
-	NbTriangles = Mesh->AddTriangle (A, B, C, average.X(), average.Y(), average.Z());
+	Mesh->AddTriangle (A, B, C, average.X(), average.Y(), average.Z());
       }
     }
     catch(Standard_Failure)
Index: oce/src/TDF/TDF_ComparisonTool.cxx
===================================================================
--- oce.orig/src/TDF/TDF_ComparisonTool.cxx
+++ oce/src/TDF/TDF_ComparisonTool.cxx
@@ -224,10 +224,6 @@ void TDF_ComparisonTool::Cut
 {
   if (aDataSet->IsEmpty()) return;
 
-#ifdef DEB
-  TDF_LabelMap&           refLabs =
-#endif
-                                    aDataSet->Labels();
   const TDF_AttributeMap& refAtts = aDataSet->Attributes();
 
   // Removes the attributes.
Index: oce/src/TDF/TDF_CopyLabel.cxx
===================================================================
--- oce.orig/src/TDF/TDF_CopyLabel.cxx
+++ oce/src/TDF/TDF_CopyLabel.cxx
@@ -70,7 +70,6 @@ void TDF_CopyLabel::ExternalReferences(c
 				       Handle(TDF_DataSet)& ds)
 {
 //  TCollection_AsciiString entr1,entr2; //d
-  Standard_Boolean extRefFound = Standard_False;
   for (TDF_AttributeIterator itr(aLabel); itr.More(); itr.Next()) {
     itr.Value()->References(ds);
     const TDF_AttributeMap& attMap = ds->Attributes(); //attMap
@@ -84,7 +83,6 @@ void TDF_CopyLabel::ExternalReferences(c
       if (aFilter.IsKept(att) && att->Label().IsDifferent(aRefLabel) &&
 	  !att->Label().IsDescendant(aRefLabel)) {
 	aExternals.Add(att);
-	extRefFound = Standard_True;
       }
     }
 
@@ -104,7 +102,6 @@ void TDF_CopyLabel::ExternalReferences(c
 //       }
 //     }
 
-    extRefFound = Standard_False;
     ds->Clear();
   }
 }
Index: oce/src/TDF/TDF_Delta.cxx
===================================================================
--- oce.orig/src/TDF/TDF_Delta.cxx
+++ oce/src/TDF/TDF_Delta.cxx
@@ -143,17 +143,17 @@ void TDF_Delta::Apply()
 
 void TDF_Delta::Labels(TDF_LabelList& aLabelList) const
 {
-  Standard_Boolean inList;
   TDF_LabelMap labMap;
   // If <aLabelList> is not empty...
 #ifdef DEB_DELTA
+  Standard_Boolean inList;
   if (aLabelList.Extent() > 0) cout<<"Previously added as modified label(s) ";
 #endif
   for (TDF_ListIteratorOfLabelList it1(aLabelList);
        it1.More(); it1.Next()) {
+#ifdef DEB_DELTA
     const TDF_Label& lab1 = it1.Value();
     inList = labMap.Add(lab1);
-#ifdef DEB_DELTA
     if (!inList) {
       lab1.EntryDump(cout);cout<<" | ";
     }
@@ -170,9 +170,9 @@ void TDF_Delta::Labels(TDF_LabelList& aL
   for (TDF_ListIteratorOfAttributeDeltaList it2(myAttDeltaList);
        it2.More();
        it2.Next()) {
+#ifdef DEB_DELTA
     const TDF_Label& lab1 = it2.Value()->Label();
     inList = labMap.Add(lab1);
-#ifdef DEB_DELTA
     if (!inList) {
       lab1.EntryDump(cout);cout<<" | ";
     }
Index: oce/src/TFunction/TFunction_Iterator.cxx
===================================================================
--- oce.orig/src/TFunction/TFunction_Iterator.cxx
+++ oce/src/TFunction/TFunction_Iterator.cxx
@@ -174,7 +174,6 @@ void TFunction_Iterator::Next()
     TFunction_IFunction iFunction(L);
 
     Handle(TFunction_GraphNode) graphNode = iFunction.GetGraphNode();
-    const TColStd_MapOfInteger& prev      = graphNode->GetPrevious();
     const TColStd_MapOfInteger& next      = graphNode->GetNext();
     TFunction_ExecutionStatus   status    = graphNode->GetStatus();
 
Index: oce/src/TNaming/TNaming.cxx
===================================================================
--- oce.orig/src/TNaming/TNaming.cxx
+++ oce/src/TNaming/TNaming.cxx
@@ -267,18 +267,17 @@ void TNaming::Update(const TDF_Label& L,
   L.Root().FindAttribute(TNaming_UsedShapes::GetID(),US);
   TNaming_DataMapOfShapePtrRefShape& amap = US->Map();
 
-  Standard_Boolean Change = Standard_False;
   for (TNaming_Iterator it(L); it.More(); it.Next()) {
     if (!it.OldShape().IsNull()) {
       const TopoDS_Shape& S = it.OldShape();
       if (!M.IsBound(S))
-	if (Rebuild (S,M)) Change = Standard_True;
+	Rebuild (S,M);
       SubstituteShape(S,M(S),amap);
     }
     if (!it.NewShape().IsNull()) {
       const TopoDS_Shape& S = it.NewShape();
       if (!M.IsBound(S)) 
-	if (Rebuild (S,M)) Change = Standard_True;
+	Rebuild (S,M);
       SubstituteShape(S,M(S),amap);
     }
   }
Index: oce/src/TNaming/TNaming_Naming.cxx
===================================================================
--- oce.orig/src/TNaming/TNaming_Naming.cxx
+++ oce/src/TNaming/TNaming_Naming.cxx
@@ -632,7 +632,6 @@ static Standard_Boolean IsMultipleCase(c
     isCommon = Standard_True; // statement: this shape (itm.Key()) is common (to be checked below)
     TNaming_DataMapIteratorOfDataMapOfShapeMapOfShape itdm(aDMM);
     for (;itdm.More();itdm.Next()) {
-      const TopoDS_Shape& aKey1 = itdm.Key();
       const TNaming_MapOfShape& aMap = itdm.Value();
       if(!aMap.Contains(itm.Key())) {
 	isCommon = Standard_False;
Index: oce/src/TPrsStd/TPrsStd_ConstraintTools.cxx
===================================================================
--- oce.orig/src/TPrsStd/TPrsStd_ConstraintTools.cxx
+++ oce/src/TPrsStd/TPrsStd_ConstraintTools.cxx
@@ -753,11 +753,6 @@ void TPrsStd_ConstraintTools::ComputeAng
   TCollection_ExtendedString txt;
   TPrsStd_ConstraintTools::ComputeTextAndValue (aConst,val1,txt,Standard_True);  
   
-// Unused :
-#ifdef DEB
-  Standard_Boolean isface(shape.ShapeType()==TopAbs_FACE);
-#endif
-  
   Handle(AIS_AngleDimension) ais;
   TopoDS_Face face;
   if (!anAIS.IsNull()) {
@@ -777,11 +772,6 @@ void TPrsStd_ConstraintTools::ComputeAng
     ais =  new AIS_AngleDimension ( face, val1, txt);
   } 
 
-// Unused :
-#ifdef DEB
-  Standard_Integer ExtShape(0);
-#endif
-
   anAIS = ais;
 }
 
@@ -1150,9 +1140,6 @@ void TPrsStd_ConstraintTools::ComputeRad
 
   //  Update de l'AIS
 // Unused :
-#ifdef DEB
-  Standard_Boolean tocreate = Standard_True;
-#endif
   Standard_Boolean isplanar(aConst->IsPlanar());
   if (isplanar) GetGoodShape(shape1);
 
@@ -1233,10 +1220,6 @@ void TPrsStd_ConstraintTools::ComputeMin
   ComputeTextAndValue(aConst,val1,txt,Standard_False);
 
   //  Update de l'AIS
-// Unused :
-#ifdef DEB
-  Standard_Boolean tocreate = Standard_True;
-#endif
   Standard_Boolean isplanar(aConst->IsPlanar());
   if (isplanar) GetGoodShape(shape1);
 
@@ -1316,10 +1299,6 @@ void TPrsStd_ConstraintTools::ComputeMax
   ComputeTextAndValue(aConst,val1,txt,Standard_False);
 
   //  Update de l'AIS
-// Unused :
-#ifdef DEB
-  Standard_Boolean tocreate = Standard_True;
-#endif
   Standard_Boolean isplanar(aConst->IsPlanar());
   if (isplanar) GetGoodShape(shape1);
 
@@ -1772,7 +1751,6 @@ void TPrsStd_ConstraintTools::ComputeOff
   TCollection_ExtendedString txt;
   Handle(AIS_LengthDimension) ais;
   //Handle(AIS_Drawer) aDrawer;
-  Standard_Boolean NotNull = Standard_False;
 
   if (nbgeom == 1) {
       
@@ -1780,7 +1758,6 @@ void TPrsStd_ConstraintTools::ComputeOff
   
     if (!anAIS.IsNull()) {
       ais = Handle(AIS_LengthDimension)::DownCast(anAIS);
-      NotNull = Standard_True; 
     }
    
     if (S1.ShapeType() == TopAbs_FACE && S2.ShapeType() == TopAbs_FACE) {
@@ -1894,7 +1871,6 @@ void TPrsStd_ConstraintTools::ComputeOff
       }
     }
     S2 = nearest;
-    if( !anAIS.IsNull() ) NotNull = Standard_True; 
     ais = Handle(AIS_LengthDimension)::DownCast(anAIS);
     if (ais.IsNull()) {
       ais = new AIS_LengthDimension (S1,S2,aplane,val1,txt);
Index: oce/src/TestTopOpe/TestTopOpe_BOOPCommands.cxx
===================================================================
--- oce.orig/src/TestTopOpe/TestTopOpe_BOOPCommands.cxx
+++ oce/src/TestTopOpe/TestTopOpe_BOOPCommands.cxx
@@ -194,14 +194,6 @@ Standard_Integer TOPOC(Draw_Interpretor&
       DBRep::Set(namie.ToCString(),es);
       if (eca) {
 	TCollection_AsciiString s;
-#ifdef DEB
-	Standard_Integer i1 =
-#endif
-                              BDS.Shape(F1);
-#ifdef DEB
-        Standard_Integer i2 =
-#endif
-                              BDS.Shape(F2);
 	if (outdraw) {
 	  if (outclear) s = s + "clear; ";
 	  ::CATSHA(s,F1,BDS,"tsee f ","; ");
Index: oce/src/TestTopOpe/TestTopOpe_CORCommands.cxx
===================================================================
--- oce.orig/src/TestTopOpe/TestTopOpe_CORCommands.cxx
+++ oce/src/TestTopOpe/TestTopOpe_CORCommands.cxx
@@ -111,10 +111,7 @@ static void FUN_test_draw(TCollection_As
   Standard_Boolean coldef = Standard_False;
   TopExp_Explorer ex(F,TopAbs_EDGE);
   Draw_Color col;
-#ifdef DEB
-  Draw_Color savecol =
-#endif
-                       DrawTrSurf_CurveColor(Draw_Color(Draw_rouge));
+  DrawTrSurf_CurveColor(Draw_Color(Draw_rouge));
   for (; ex.More(); ex.Next()) 
     if (E.IsEqual(ex.Current())) 
       {col = DBRep_ColorOrientation(ex.Current().Orientation()); 
@@ -256,10 +253,6 @@ Standard_Integer reguso(Draw_Interpretor
     TopOpeBRepBuild_ShellToSolid SheToSo;      
     for (; itm.More(); itm.Next()) {
       const TopTools_ListOfShape& lns = itm.Value();
-#ifdef DEB
-      Standard_Integer nlns =
-#endif
-                              lns.Extent();
       TopTools_ListIteratorOfListOfShape itsh(lns);
       for (; itsh.More(); itsh.Next()) {
 	const TopoDS_Shell& she = TopoDS::Shell(itsh.Value());
@@ -602,9 +595,6 @@ static Standard_Integer classifBnd2d(Dra
   TopoDS_Shape W1 = DBRep::Get(a[1]);
   TopoDS_Shape W2 = DBRep::Get(a[2]);
   TopoDS_Shape F = DBRep::Get(a[3]);
-#ifdef DEB
-  Standard_Integer i = atoi(a[4]);
-#endif
   
   TopoDS_Wire w1 = TopoDS::Wire(W1);
   TopoDS_Wire w2 = TopoDS::Wire(W2);
@@ -773,15 +763,9 @@ static Standard_Integer normal(Draw_Inte
 //  TopoDS_Face f = TopoDS::Face(DBRep::Get(a[1]));
   if (f.IsNull()) {di<<"null shape"<<"\n";return 1;}
   gp_Pnt p; DrawTrSurf::GetPoint(a[2], p);
-#ifdef DEB
-  Standard_Real length = atof(a[3]);
-#endif
   Standard_Real dist=0.; gp_Pnt2d uv; Standard_Boolean ok = FUN_tool_projPonF(p,f,uv,dist);
   if (!ok) {di<<"projection failed"<<"\n"; return 1;}
-#ifdef DEB
-  gp_Vec ngf =
-#endif
-               FUN_tool_nggeomF(uv,f);
+  FUN_tool_nggeomF(uv,f);
   TCollection_AsciiString aa("ngS"); 
 #ifdef DRAW
   FUN_tool_draw(aa,p,ngf,length);
@@ -810,7 +794,6 @@ static Standard_Integer curvature(Draw_I
   
   Standard_Real tol = Precision::Confusion();
   BRepLProp_SLProps props(BS,2,tol);
-  Standard_Real Cur1=0., Cur2=0.;
   gp_Dir Norm,D1,D2;  
   for (Standard_Integer i = 1; i <= npnts; i++) {
     gp_Pnt p = intcs.Point(i);
@@ -821,14 +804,11 @@ static Standard_Integer curvature(Draw_I
     if (!curdef) {di<<"!IsCurvatureDefined"<<"\n"; continue;}
     Standard_Boolean umbilic = props.IsUmbilic();
     if (umbilic) { 
-      Cur1 = Cur2 = props.MeanCurvature();
       D1 = gp_Dir(0,0,1);
       D2 = gp_Dir(0,1,0);   
       di<<"umbilic";
     }
     else {
-      Cur1 = props.MaxCurvature();
-      Cur2 = props.MinCurvature();
       props.CurvatureDirections(D1,D2);
     }
     Norm = gp_Dir(D1^D2); 
Index: oce/src/TestTopOpe/TestTopOpe_DSACommands.cxx
===================================================================
--- oce.orig/src/TestTopOpe/TestTopOpe_DSACommands.cxx
+++ oce/src/TestTopOpe/TestTopOpe_DSACommands.cxx
@@ -99,24 +99,12 @@ Standard_Integer DSACCESSCOMMANDS(Draw_I
 	S = DSA.Merge(TopAbs_IN, TopAbs_IN);
       DBRep::Set(a[2], S);
       TopOpeBRepDS_DataStructure& DS = DSA.DS()->ChangeDS();
-      Standard_Integer i,j,nbsh = DS.NbShapes();
+      Standard_Integer i,nbsh = DS.NbShapes();
       for(i = 1;i<=nbsh;i++) {
 	TopTools_ListOfShape& los = DS.ChangeShapeSameDomain(i);
-	j = los.Extent();
-#ifdef DEB
-	Standard_Integer iref =
-#endif
-                                DS.SameDomainRef(i);
-#ifdef DEB
-	Standard_Integer iind =
-#endif
-                                DS.SameDomainInd(i);
 	TopTools_ListIteratorOfListOfShape li(los);
 	for(; li.More(); li.Next()) {
-#ifdef DEB
-	  const TopoDS_Shape& Shap =
-#endif
-                                     li.Value();
+      li.Value();
 	}
       }
     }
Index: oce/src/TestTopOpe/TestTopOpe_HDSCommands.cxx
===================================================================
--- oce.orig/src/TestTopOpe/TestTopOpe_HDSCommands.cxx
+++ oce/src/TestTopOpe/TestTopOpe_HDSCommands.cxx
@@ -236,13 +236,6 @@ static void SetCurve
   const Handle(Geom_Curve) GC = DSC.Curve();
   if ( GC.IsNull() ) { cout<<"Curve() nulle"<<endl; return; }
   
-#ifdef DEB
-  static Standard_Integer Cdiscret = 16;
-  static Standard_Real Cdeflect = 0.01;
-  static Standard_Integer Cdrawmod = 1;
-  static Standard_Boolean Cdisplayorigin = Standard_True;
-#endif
-  
   Standard_Real f = GC->FirstParameter();
   Standard_Real l = GC->LastParameter();
   
@@ -364,10 +357,7 @@ static Standard_Integer SeeSectionEdge(c
   if ( ISE < 1 || ISE > nse ) return 0;
   const TopoDS_Shape& SE  = PHDSD->CurrentBDS().SectionEdge(ISE);
   if (SE.IsNull()) return 0;
-#ifdef DEB
-  Standard_Integer ids =
-#endif
-                         PHDSD->CurrentBDS().Shape(SE,SFindKeep);
+  PHDSD->CurrentBDS().Shape(SE,SFindKeep);
   
   TCollection_AsciiString namedbrep; PHDSD->SectionEdgeName(ISE,SE,namedbrep); 
   TCollection_AsciiString namedisp; PHDSD->SectionEdgeDisplayName(ISE,SE,namedisp);
@@ -534,9 +524,6 @@ static Standard_Integer SeeGeometry(cons
   
   const TopOpeBRepDS_DataStructure& BDS = PHDSD->CurrentBDS();
 
-#ifdef DEB  
-  Standard_Integer ig,ng = 0;
-#endif
   if      (TK == TopOpeBRepDS_POINT) {
     TopOpeBRepDS_PointExplorer pex(BDS,GFindKeep);
     for (; pex.More(); pex.Next()) {
@@ -899,11 +886,10 @@ void AddShapeKI
 (TColStd_ListOfInteger& LOK,TColStd_ListOfInteger& LOI,
  const TopOpeBRepDS_Kind K,const Standard_Integer I)
 {
-  TopAbs_ShapeEnum TS;
   Standard_Boolean isshape,isgeome; isshape = isgeome = Standard_False;
   isshape = TopOpeBRepDS::IsTopology(K);
-  if (isshape) TS = TopOpeBRepDS::KindToShape(K);
-  else isgeome = TopOpeBRepDS::IsGeometry(K);
+  if (!isshape)
+    isgeome = TopOpeBRepDS::IsGeometry(K);
   
   if (LOK.IsEmpty() && LOI.IsEmpty()) { 
     LOK.Append((Standard_Integer)K); LOI.Append(I); 
@@ -1133,10 +1119,6 @@ Standard_Integer tds(Draw_Interpretor& d
   if (PHDSD == NULL) return 0;
   const Handle(TopOpeBRepDS_HDataStructure)& HDS = PHDSD->CurrentHDS();
   if (HDS.IsNull()) {COUTNOHDS(di);return 0;}
-#ifdef DEB
-  const TopOpeBRepDS_DataStructure& BDS =
-#endif
-                                          PHDSD->CurrentBDS();
   
   TopOpeBRepDS_Dumper Dumper(HDS);
   if ( na == 1 ) { Dumper.Dump(cout,TDSkeep,TDScompact); return 0; }
@@ -1396,7 +1378,7 @@ Standard_Integer tdsri(Draw_Interpretor&
   if ( strcasecmp(a[i1arg + 2],"i") ) return 0;
   Standard_Integer ii = atoi(a[i1arg + 3]);  
 //  Standard_Integer ia,is,ig;
-  Standard_Integer is,ig;
+  Standard_Integer is;
   if ( Tpar.isshap() ) {
     is = atoi(a[i1arg + 1]);
     const TopoDS_Shape& s = GetShape(is,Tpar.TS()); if (s.IsNull()) return 0;
@@ -1410,9 +1392,6 @@ Standard_Integer tdsri(Draw_Interpretor&
       else it.Next();
     }
   }
-  else if ( Tpar.isgeom() ) { 
-    ig = atoi(a[i1arg + 1]);
-  }
   return 0;
 } // tdsri
 
Index: oce/src/TestTopOpe/TestTopOpe_OtherCommands.cxx
===================================================================
--- oce.orig/src/TestTopOpe/TestTopOpe_OtherCommands.cxx
+++ oce/src/TestTopOpe/TestTopOpe_OtherCommands.cxx
@@ -188,13 +188,11 @@ Standard_Integer MKSOLSHE(Draw_Interpret
 
   // take all the SHELL args, place them in the solid <sol>
   TopoDS_Solid sol; BB.MakeSolid(sol);
-  Standard_Boolean yashell = Standard_False;
   for (i = i1; i < i2; i++) {
     const TopoDS_Shape& S = DBRep::Get(a[i]);
     if (S.IsNull()) continue;
     if (S.ShapeType() == TopAbs_SHELL) {
       BB.Add(sol,S);
-      yashell = Standard_True;
     }
   }
 
@@ -219,7 +217,7 @@ Standard_Integer MKSOLSHE(Draw_Interpret
 Standard_Integer GRILLE(Draw_Interpretor& di, Standard_Integer narg, const char** a)
 {
   if (narg != 10) return 1;
-  Standard_Real xmin,ymin,zmin,xmax,ymax,zmax,dx,dy,dz;
+  Standard_Real xmin,ymin,zmin,xmax,ymax,zmax,dx,dy;
   Standard_Integer nbx,nby,nbz;
   xmin = atof(a[1]);
   ymin = atof(a[2]);
@@ -234,7 +232,6 @@ Standard_Integer GRILLE(Draw_Interpretor
     return 1;
   if(nbx) dx = (xmax-xmin)/nbx; else dx=0;
   if(nby) dy = (ymax-ymin)/nby; else dy=0;
-  if(nbz) dz = (zmax-zmin)/nbz; else dz=0;
   di<<"compound CE"<<"\n";
   for(Standard_Real x=xmin; x<xmax; x+=dx) { 
     for(Standard_Real y=ymin; y<ymax; y+=dx) { 
Index: oce/src/TestTopOpeDraw/TestTopOpeDraw_Displayer.cxx
===================================================================
--- oce.orig/src/TestTopOpeDraw/TestTopOpeDraw_Displayer.cxx
+++ oce/src/TestTopOpeDraw/TestTopOpeDraw_Displayer.cxx
@@ -467,10 +467,7 @@ void TestTopOpeDraw_SurfaceDisplayer::In
 void TestTopOpeDraw_SurfaceDisplayer::DisplaySurface(const Handle(Geom_Surface& S))
 {
   if (S.IsNull()) return;
-#ifdef DEB
-  Draw_ColorKind isocol =
-#endif
-                          TestTopOpeDraw_TTOT::GeometryColor(TopOpeBRepDS_SURFACE);
+  TestTopOpeDraw_TTOT::GeometryColor(TopOpeBRepDS_SURFACE);
   Handle(TestTopOpeDraw_DrawableSUR) D;
   D = new TestTopOpeDraw_DrawableSUR
     (S,mySDIsoColor,mySDBoundColor,mySDNormalColor,
Index: oce/src/TestTopOpeDraw/TestTopOpeDraw_DrawableMesure.cxx
===================================================================
--- oce.orig/src/TestTopOpeDraw/TestTopOpeDraw_DrawableMesure.cxx
+++ oce/src/TestTopOpeDraw/TestTopOpeDraw_DrawableMesure.cxx
@@ -109,10 +109,6 @@ static Standard_CString makename2(const
 
   C = "";C = C + P.Coord(2);
   TCollection_AsciiString S1 = C.Token(".",1);
-#ifdef DEB
-  Standard_Integer l =
-#endif
-                       S1.Length();
   S1.RightJustify(15, ' ');
   TCollection_AsciiString S2 = C.Token(".",2);
   S2.Trunc(2);
Index: oce/src/TopOpeBRep/TopOpeBRep_DSFiller.cxx
===================================================================
--- oce.orig/src/TopOpeBRep/TopOpeBRep_DSFiller.cxx
+++ oce/src/TopOpeBRep/TopOpeBRep_DSFiller.cxx
@@ -159,10 +159,7 @@ void BREP_correctgbound(const Handle(Top
       if ( GK != TopOpeBRepDS_VERTEX ) continue;
       
       const TopoDS_Shape& v = BDS.Shape(GI);
-#ifdef DEB
-      Standard_Boolean isb =
-#endif
-                SSI->GBound();      
+      SSI->GBound();      
       Standard_Boolean vofe = imev.Contains(v);
       SSI->SetGBound(vofe);
     } // it.More()   
@@ -274,10 +271,7 @@ static
       const TopoDS_Edge& e2 = TopoDS::Edge(BDS.Shape(S1));
       if (!map2.Contains(e2)) continue;
 
-#ifdef DEB
-      Standard_Integer G1 =
-#endif
-               I1->Geometry(); TopOpeBRepDS_Kind GT1 = I1->GeometryType();
+      TopOpeBRepDS_Kind GT1 = I1->GeometryType();
       if (GT1 == TopOpeBRepDS_POINT) {
 	Handle(TopOpeBRepDS_CurvePointInterference) CPI1 = Handle(TopOpeBRepDS_CurvePointInterference)::DownCast(I1); 
 	Standard_Real par1 = CPI1->Parameter();
@@ -450,14 +444,6 @@ void TopOpeBRep_DSFiller::InsertIntersec
     const TopoDS_Shape& gs2 = myShapeIntersector.CurrentGeomShape(2);
     TopAbs_ShapeEnum t1 = gs1.ShapeType();
     TopAbs_ShapeEnum t2 = gs2.ShapeType();
-#ifdef DEB
-    TopAbs_Orientation o1 =
-#endif
-              gs1.Orientation();
-#ifdef DEB
-    TopAbs_Orientation o2 = 
-#endif
-              gs2.Orientation();
     
     // si le couple courant apres un couple facefacesamedomain n'est
     // pas un couple edgeedge ==> facefacesamedomain est deconnecte 
@@ -689,10 +675,6 @@ void TopOpeBRep_DSFiller::RemoveUnshared
     TopTools_ListIteratorOfListOfShape itsd(lSsd);
     for (; itsd.More(); itsd.Next()){
       TopoDS_Shape Ssd = itsd.Value(); //xpuxpu
-#ifdef DEB
-      Standard_Integer iSsd =
-#endif
-                 BDS.Shape(Ssd);
       Standard_Integer rkSsd = BDS.AncestorRank(Ssd);
       if (rkSsd == 1) continue;
       
@@ -768,14 +750,6 @@ void TopOpeBRep_DSFiller::InsertIntersec
     const TopoDS_Shape& gs2 = myShapeIntersector2d.CurrentGeomShape(2);
     TopAbs_ShapeEnum t1 = gs1.ShapeType();
     TopAbs_ShapeEnum t2 = gs2.ShapeType();
-#ifdef DEB
-    TopAbs_Orientation o1 =
-#endif
-              gs1.Orientation();
-#ifdef DEB
-    TopAbs_Orientation o2 =
-#endif
-              gs2.Orientation();
     
     // si le couple courant apres un couple facefacesamedomain n'est
     // pas un couple edgeedge ==> facefacesamedomain est deconnecte 
@@ -814,10 +788,6 @@ void TopOpeBRep_DSFiller::InsertIntersec
     else if ((t1 == TopAbs_EDGE) && (t2 == TopAbs_EDGE)) {
       TopOpeBRep_EdgesIntersector& EE = myShapeIntersector2d.ChangeEdgesIntersector();
       EE.Dimension(2);
-#ifdef DEB
-      Standard_Boolean EEsamedomain =
-#endif
-                         EE.SameDomain();
       myEdgesFiller.Face(1,lFF1);
       myEdgesFiller.Face(2,lFF2);
       myEdgesFiller.Insert(gs1,gs2,EE,HDS);
Index: oce/src/TopOpeBRep/TopOpeBRep_EdgesFiller.cxx
===================================================================
--- oce.orig/src/TopOpeBRep/TopOpeBRep_EdgesFiller.cxx
+++ oce/src/TopOpeBRep/TopOpeBRep_EdgesFiller.cxx
@@ -69,39 +69,18 @@ void TopOpeBRep_EdgesFiller::Insert(cons
   }
 #endif
   
-#ifdef DEB
-  Standard_Boolean hs =
-#endif
-           myPEI->HasSegment();
   Standard_Boolean esd = myPEI->SameDomain();
   if (esd) myPDS->FillShapesSameDomain(E1,E2);
   
   // exit if no point.
   myPEI->InitPoint(); if ( !myPEI->MorePoint() ) return;
   
-#ifdef DEB
-  Standard_Boolean reducesegment = (hs && !esd);
-#endif
-
-#ifdef DEB
-  TopAbs_Orientation E1ori =
-#endif
-               E1.Orientation();
-#ifdef DEB
-  TopAbs_Orientation E2ori =
-#endif
-               E2.Orientation();
-  
   // --- Add <E1,E2> in BDS
   Standard_Integer E1index = myPDS->AddShape(E1,1);
   Standard_Integer E2index = myPDS->AddShape(E2,2);
   
   // --- get list of interferences connected to edges <E1>,<E2>
   TopOpeBRepDS_ListOfInterference& EIL1 = myPDS->ChangeShapeInterferences(E1);
-#ifdef DEB
-  TopOpeBRepDS_ListOfInterference& EIL2 =
-#endif
-                 myPDS->ChangeShapeInterferences(E2);
   
   Handle(TopOpeBRepDS_Interference) EPI;  //edge/point interference
   Handle(TopOpeBRepDS_Interference) EVI;  //edge/vertex interference
@@ -112,18 +91,10 @@ void TopOpeBRep_EdgesFiller::Insert(cons
     const TopOpeBRep_Point2d P2D = myPEI->Point();
     Standard_Real par1 = P2D.Parameter(1);
     Standard_Real par2 = P2D.Parameter(2);
-    Standard_Integer if1 = 0; if ( ! myF1.IsNull() ) if1 = myPDS->AddShape(myF1,1);
-    Standard_Integer if2 = 0; if ( ! myF2.IsNull() ) if2 = myPDS->AddShape(myF2,2);
 
 #ifdef DEB
     Standard_Boolean pointofsegment =
-#endif
                          P2D.IsPointOfSegment();
-#ifdef DEB
-    Standard_Boolean reducesegmentpoint = (reducesegment && pointofsegment);
-#endif
-
-#ifdef DEB
     if (trc) {
       if      (pointofsegment &&  esd) debposesd();
       else if (pointofsegment && !esd) debposnesd();
@@ -377,10 +348,7 @@ Standard_Boolean TopOpeBRep_EdgesFiller:
   Standard_Boolean isvertex2 = P2D.IsVertex(2);
   if (isvertex1 && isvertex2) {
     Standard_Integer G1 = myPDS->AddShape(P2D.Vertex(1),1);
-#ifdef DEB
-    Standard_Integer G2 =
-#endif
-              myPDS->AddShape(P2D.Vertex(2),2);
+    myPDS->AddShape(P2D.Vertex(2),2);
     G = G1;
     K = TopOpeBRepDS_VERTEX;
   }
@@ -467,14 +435,8 @@ Standard_Boolean TopOpeBRep_EdgesFiller:
 {
   Standard_Boolean b = Standard_True;
   const TopOpeBRepDS_Transition& T = I->Transition();
-#ifdef DEB
-  TopAbs_State sb =
-#endif
-            T.Before();
-#ifdef DEB
-  TopAbs_State sa =
-#endif
-            T.After();
+  T.Before();
+  T.After();
   Standard_Boolean pointofsegment = P2D.IsPointOfSegment();
   Standard_Boolean esd = myPEI->SameDomain();
   b = b && (pointofsegment && !esd);
@@ -523,10 +485,6 @@ void TopOpeBRep_EdgesFiller::RecomputeIn
     Standard_Integer ifb = TU.IndexBefore();
     Standard_Integer ifa = TU.IndexAfter();
     const TopoDS_Face& fb = TopoDS::Face(myPDS->Shape(ifb));
-#ifdef DEB
-    const TopoDS_Face& fa =
-#endif
-                    TopoDS::Face(myPDS->Shape(ifa));
 
 #ifdef DEB
     if (ifb != ifa) {cout<<"TopOpeBRep_EdgesFiller : ifb != ifa on E"<<EIX<<" NYI"<<endl;}
Index: oce/src/TopOpeBRep/TopOpeBRep_EdgesIntersector.cxx
===================================================================
--- oce.orig/src/TopOpeBRep/TopOpeBRep_EdgesIntersector.cxx
+++ oce/src/TopOpeBRep/TopOpeBRep_EdgesIntersector.cxx
@@ -108,9 +108,6 @@ void TopOpeBRep_EdgesIntersector::SetFac
 //=======================================================================
 void TopOpeBRep_EdgesIntersector::SetFaces(const TopoDS_Shape& F1,const TopoDS_Shape& F2,const Bnd_Box& B1,const Bnd_Box& B2)
 {
-#ifdef DEB
-  Standard_Boolean memesfaces = F1.IsSame(F2);
-#endif
   Standard_Boolean computerestriction = Standard_False;
   
   Standard_Boolean so11 = Standard_True;
@@ -282,14 +279,6 @@ Standard_Boolean EdgesIntersector_checkT
 {
   mysp2d.Clear();
   myip2d = 1; mynp2d = 0;
-#ifdef DEB
-  TopAbs_Orientation E1ori =
-#endif
-               E1.Orientation();
-#ifdef DEB
-  TopAbs_Orientation E2ori =
-#endif
-               E2.Orientation();
   myEdge1 = TopoDS::Edge(E1);
   myEdge2 = TopoDS::Edge(E2);
   
@@ -364,23 +353,8 @@ Standard_Boolean EdgesIntersector_checkT
       if (apex) {
 	TopoDS_Vertex vf,vl; TopExp::Vertices(myEdge1,vf,vl);
 	gp_Pnt ptf = BRep_Tool::Pnt(vf); Standard_Real df = pt2.Distance(ptf); 
-	gp_Pnt ptl = BRep_Tool::Pnt(vl);
-#ifdef DEB
-        Standard_Real dl =
-#endif
-                 pt2.Distance(ptl); 
 	Standard_Real tolf = BRep_Tool::Tolerance(vf);
-#ifdef DEB
-        Standard_Real toll =
-#endif
-                   BRep_Tool::Tolerance(vl);
-#ifdef DEB
-	Standard_Real tol = Max (tolf,toll);
-#endif
 	Standard_Boolean onf = (df < tolf);
-#ifdef DEB
-        Standard_Boolean onl = (dl < toll);
-#endif
 	TopoDS_Vertex v1 = onf ? vf : vl;
 	TopTools_IndexedDataMapOfShapeListOfShape mapVE; TopExp::MapShapesAndAncestors(myFace1,TopAbs_VERTEX,TopAbs_EDGE,mapVE);
 	const TopTools_ListOfShape& Edsanc = mapVE.FindFromKey(v1);
@@ -557,10 +531,6 @@ Standard_Boolean EdgesIntersector_checkT
       Standard_Boolean isvertex11 = isvertex1 && !isvertex12;
 
       Standard_Boolean T1INT = (T1.Orientation(TopAbs_IN) == TopAbs_INTERNAL);
-#ifdef DEB
-      Standard_Boolean T1EXT = (T1.Orientation(TopAbs_IN) == TopAbs_EXTERNAL);
-      Standard_Boolean INTEXT1 = T1INT || T1EXT;
-#endif
       if (T1INT && isvertex2 && !isvertex1) {
 	const TopoDS_Vertex& V2 = P2D.Vertex(2);	
 	TopOpeBRepDS_Transition newT; Standard_Boolean computed = ::EdgesIntersector_checkT1D(myEdge1,myEdge2,V2,newT);
@@ -656,15 +626,6 @@ Standard_Boolean TopOpeBRep_EdgesInterse
   Standard_Boolean rr = (Abs(r1-r2) < Precision::Confusion()); //xpu281098 (cto019D2) tolerance a revoir
   if (!rr) return SetSameDomain(Standard_False);
 
-#ifdef DEB
-  const gp_Ax22d& pos1 =
-#endif
-                         c1.Position();
-#ifdef DEB
-  const gp_Ax22d& pos2 =
-#endif
-                         c2.Position();
-
   const gp_Pnt2d& p1 = c1.Location();
   const gp_Pnt2d& p2 = c2.Location();
 
@@ -739,10 +700,6 @@ Standard_Boolean TopOpeBRep_EdgesInterse
   
   Standard_Boolean pospsa = psa.IsPointOfSegment();
   TopOpeBRep_P2Dstatus stspsa = psa.Status();
-#ifdef DEB
-  const gp_Pnt& Ppsa =
-#endif
-                       psa.Value();
   Standard_Real tpsa1 = psa.Parameter(1);
   Standard_Real tpsa2 = psa.Parameter(2);
   const TopOpeBRepDS_Transition& Tpsa1 = psa.Transition(1);
@@ -750,10 +707,6 @@ Standard_Boolean TopOpeBRep_EdgesInterse
   
   Standard_Boolean pospsb = psb.IsPointOfSegment();
   TopOpeBRep_P2Dstatus stspsb = psb.Status();
-#ifdef DEB
-  const gp_Pnt& Ppsb =
-#endif
-                       psb.Value();
   Standard_Real tpsb1 = psb.Parameter(1);
   Standard_Real tpsb2 = psb.Parameter(2);
   const TopOpeBRepDS_Transition& Tpsb1 = psb.Transition(1);
@@ -801,10 +754,6 @@ Standard_Boolean TopOpeBRep_EdgesInterse
     psb.SetKeep(Standard_False);
     
     TopOpeBRepDS_Config cpsa = psa.EdgesConfig();
-#ifdef DEB
-    TopOpeBRepDS_Config cpsb =
-#endif
-                               psb.EdgesConfig();
     Pn.SetEdgesConfig(cpsa);
     
     Standard_Boolean isvpsa1 = psa.IsVertex(1);if (isvpsa1) Pn.SetVertex(1,psa.Vertex(1));
Index: oce/src/TopOpeBRep/TopOpeBRep_FaceEdgeFiller.cxx
===================================================================
--- oce.orig/src/TopOpeBRep/TopOpeBRep_FaceEdgeFiller.cxx
+++ oce/src/TopOpeBRep/TopOpeBRep_FaceEdgeFiller.cxx
@@ -63,10 +63,7 @@ void TopOpeBRep_FaceEdgeFiller::Insert
 
   // --- Add <FF,EE> in BDS
   Standard_Integer FFindex = BDS.AddShape(FF,1);
-#ifdef DEB
-  Standard_Integer EEindex =
-#endif
-                             BDS.AddShape(EE,2);
+  BDS.AddShape(EE,2);
 
   // --- get list of interferences connected to edges <FF>,<EE>
   TopOpeBRepDS_ListOfInterference& EIL1 = BDS.ChangeShapeInterferences(FF);
@@ -77,15 +74,8 @@ void TopOpeBRep_FaceEdgeFiller::Insert
 
   for (; FEINT.MorePoint(); FEINT.NextPoint() ) {
     gp_Pnt2d      pUV; FEINT.UVPoint(pUV);
-#ifdef DEB
-    TopAbs_State  sta =
-#endif
-                        FEINT.State();
     Standard_Real parE = FEINT.Parameter();
 
-#ifdef DEB
-    TopOpeBRepDS_Transition TFF =
-#endif
                                   FEINT.Transition(1,EEori); //  EEori bidon = EXTERNAL
     TopOpeBRepDS_Transition TEE = FEINT.Transition(2,FFori);
     TEE.Index(FFindex);
Index: oce/src/TopOpeBRep/TopOpeBRep_FaceEdgeIntersector.cxx
===================================================================
--- oce.orig/src/TopOpeBRep/TopOpeBRep_FaceEdgeIntersector.cxx
+++ oce/src/TopOpeBRep/TopOpeBRep_FaceEdgeIntersector.cxx
@@ -88,10 +88,7 @@ void TopOpeBRep_FaceEdgeIntersector::Per
   TopLoc_Location loc;
   const Handle(Geom_Curve) C = BRep_Tool::Curve(myEdge,loc,f,l);
   
-#ifdef DEB
-  gp_Trsf Tao1 =
-#endif
-                 loc.Transformation();
+  loc.Transformation();
   Handle(Geom_Geometry) GGao1 = C->Transformed(loc.Transformation());
   Handle(Geom_Curve)* PGCao1 = (Handle(Geom_Curve)*)&GGao1;
   myCurve.Load(*PGCao1,f,l);
Index: oce/src/TopOpeBRep/TopOpeBRep_FacesFiller.cxx
===================================================================
--- oce.orig/src/TopOpeBRep/TopOpeBRep_FacesFiller.cxx
+++ oce/src/TopOpeBRep/TopOpeBRep_FacesFiller.cxx
@@ -467,9 +467,6 @@ void TopOpeBRep_FacesFiller::VP_Position
   
   for (; VPI.More(); VPI.Next()) {
     TopOpeBRep_VPointInter& VP = VPI.ChangeCurrentVP();
-#ifdef DEB
-    Standard_Integer VPsi = VP.ShapeIndex();
-#endif
     
     Standard_Boolean isvertex = VP.IsVertex(Esi);
     if ( isvertex ) {
Index: oce/src/TopOpeBRep/TopOpeBRep_FacesFiller_1.cxx
===================================================================
--- oce.orig/src/TopOpeBRep/TopOpeBRep_FacesFiller_1.cxx
+++ oce/src/TopOpeBRep/TopOpeBRep_FacesFiller_1.cxx
@@ -231,10 +231,6 @@ static Standard_Boolean FUN_findTF(const
     if (!OOdone) return Standard_False;
 
     const TopoDS_Edge& E   = TopoDS::Edge(pDS->Shape(iE));
-#ifdef DEB
-    const TopoDS_Face& F   =
-#endif
-                     TopoDS::Face(pDS->Shape(iF));
     const TopoDS_Face& OOF = TopoDS::Face(pDS->Shape(iOOF));
 
     Standard_Real f,l; FUN_tool_bounds(E,f,l);
@@ -734,10 +730,7 @@ void TopOpeBRep_FacesFiller::ProcessRLin
     Standard_Integer iOO = myDS->AddShape(OOE,OOrank);
 
     Standard_Real OOpar; 
-#ifdef DEB
-    Standard_Boolean okOO =
-#endif
-               VP.ParonE(OOE,OOpar);
+    VP.ParonE(OOE,OOpar);
  
     // xpu091198 : 1d interf done in EdgesFiller processing (cto cylcong *)     
     Standard_Boolean sdmeds = FUN_ds_sdm((*myDS),Erest,OOE);
@@ -767,13 +760,13 @@ void TopOpeBRep_FacesFiller::ProcessRLin
       Standard_Integer iOOFace = myDS->Shape(OOFace);
 
       TopoDS_Edge edge,OOedge; Standard_Integer SIedgeIndex,OOedgeIndex;
-      Standard_Real paredge,OOparedge;
+      Standard_Real paredge;
       Standard_Integer onbound;
       if (SIErest) 
 	{edge = Erest;  SIedgeIndex = iErest; paredge = parRest; onbound = obRest; 
-	 OOedge = OOE;  OOedgeIndex = iOO;    OOparedge = OOpar;} 
+	 OOedge = OOE;  OOedgeIndex = iOO;    } 
       else         
-	{OOedge = Erest;OOedgeIndex = iErest; OOparedge = parRest;   onbound = obOO;
+	{OOedge = Erest;OOedgeIndex = iErest; onbound = obOO;
 	 edge = OOE;    SIedgeIndex = iOO;    paredge = OOpar;}
       
       // PVIndex :
@@ -807,7 +800,6 @@ void TopOpeBRep_FacesFiller::ProcessRLin
       const TopOpeBRepDS_Transition& llt2 = FaceFaceTransition(2);
       TopOpeBRepDS_Transition Trans = (ShapeIndex == 1)? llt1 : llt2;
       Standard_Boolean TransUNK = Trans.IsUnknown();
-      TopAbs_Orientation Transori; if (!TransUNK) Transori = Trans.Orientation(TopAbs_IN); 
       
       TopOpeBRepDS_Transition transEdge; Standard_Boolean Tunk = Standard_True;
       if (!TransUNK) { //xpu281098 PRO12875(edge9,OOface11)
@@ -976,8 +968,8 @@ void TopOpeBRep_FacesFiller::FillLineVPo
   //----------------------------------------------------------------------
   
 #ifdef DEB
-  Standard_Boolean trcd = Standard_False;
 #ifdef DRAW
+  Standard_Boolean trcd = Standard_False;
   if (trcd) FUN_DrawMap(myDataforDegenEd);
 #endif
 #endif
@@ -1188,10 +1180,6 @@ void TopOpeBRep_FacesFiller::StoreCurveI
     myDSCIndex = myDS->AddCurve(DSC);
     
 #ifdef DEB
-    const TopOpeBRepDS_Curve& CCC = myDS->Curve(myDSCIndex);
-#endif
-    
-#ifdef DEB
     if (TopOpeBRepDS_GettraceDSF() || TopOpeBRepDS_GettraceDSNC()) 
       cout<<"new DSC "<<myDSCIndex<<endl;
     if (TopOpeBRepDS_GettraceDSLT()) myLine->DumpLineTransitions(cout);
Index: oce/src/TopOpeBRep/TopOpeBRep_FacesIntersector.cxx
===================================================================
--- oce.orig/src/TopOpeBRep/TopOpeBRep_FacesIntersector.cxx
+++ oce/src/TopOpeBRep/TopOpeBRep_FacesIntersector.cxx
@@ -219,10 +219,6 @@ void TopOpeBRep_FacesIntersector::Perfor
   for (InitLine(); MoreLine(); NextLine()) {
     TopOpeBRep_LineInter& L = CurrentLine();
     if (L.TypeLineCurve() == TopOpeBRep_RESTRICTION) {
-#ifdef DEB
-      Standard_Boolean isedge1 = L.ArcIsEdge(1); //DEB
-      Standard_Boolean isedge2 = L.ArcIsEdge(2); //DEB
-#endif
       const TopoDS_Shape& E = L.Arc();
       myEdgeRestrictionMap.Add(E);
     }
@@ -289,9 +285,6 @@ Standard_Boolean TopOpeBRep_FacesInterse
     Standard_ProgramError::Raise("FacesIntersector : bad SameDomain");
 
   Standard_Boolean sd = myIntersector.TangentFaces();
-#ifdef DEB
-  Standard_Boolean plpl = (mySurfaceType1 == GeomAbs_Plane) && (mySurfaceType2 == GeomAbs_Plane);
-#endif
 //  if (!plpl) return Standard_False;
   return sd;
 }
@@ -730,14 +723,6 @@ Handle(IntPatch_RLine) BuildRLineBasedOn
     return anRLine;
 
   Standard_Boolean IsOnFirst = (theRank == 1);
-#ifdef DEB
-  Standard_Integer ParamMinOnLine = (Standard_Integer) 
-#endif
-    Vtx1.ParameterOnLine();
-#ifdef DEB
-  Standard_Integer ParamMaxOnLine = (Standard_Integer) 
-#endif
-    Vtx2.ParameterOnLine();
 
   Handle(IntSurf_LineOn2S) aLineOn2S = new IntSurf_LineOn2S();
   const Handle(IntSurf_LineOn2S)& Lori = theWLine->Curve();
@@ -1440,13 +1425,12 @@ static Standard_Boolean IsPointOK(const
   Extrema_ExtPS extPS(theTestPnt,theTestSurface,ExtTol,ExtTol);
   if( extPS.IsDone() && extPS.NbExt() > 0 )
     {
-      Standard_Integer i = 0, minext = 1;
+      Standard_Integer i = 0;
       Standard_Real MinDist2 = 1.e+200;
       for(i = 1; i <= extPS.NbExt(); i++)
 	{
 	  if( extPS.SquareDistance(i) < MinDist2 )
 	    {
-	      minext = i;
 	      MinDist2 = extPS.SquareDistance(i);
 	    }
 	}
Index: oce/src/TopOpeBRep/TopOpeBRep_Hctxee2d.cxx
===================================================================
--- oce.orig/src/TopOpeBRep/TopOpeBRep_Hctxee2d.cxx
+++ oce/src/TopOpeBRep/TopOpeBRep_Hctxee2d.cxx
@@ -103,23 +103,8 @@ void TopOpeBRep_Hctxee2d::SetEdges(const
       if (apex) {
 	TopoDS_Vertex vf,vl; TopExp::Vertices(myEdge1,vf,vl);
 	gp_Pnt ptf = BRep_Tool::Pnt(vf); Standard_Real df = pt2.Distance(ptf); 
-	gp_Pnt ptl = BRep_Tool::Pnt(vl);
-#ifdef DEB
-        Standard_Real dl =
-#endif
-                 pt2.Distance(ptl); 
 	Standard_Real tolf = BRep_Tool::Tolerance(vf);
-#ifdef DEB
-        Standard_Real toll =
-#endif
-                   BRep_Tool::Tolerance(vl);
-#ifdef DEB
-	Standard_Real tol = Max (tolf,toll);
-#endif
 	Standard_Boolean onf = (df < tolf);
-#ifdef DEB
-        Standard_Boolean onl = (dl < toll);
-#endif
 	TopoDS_Vertex v1 = onf ? vf : vl;
 	TopTools_IndexedDataMapOfShapeListOfShape mapVE; TopExp::MapShapesAndAncestors(F1,TopAbs_VERTEX,TopAbs_EDGE,mapVE);
 	const TopTools_ListOfShape& Edsanc = mapVE.FindFromKey(v1);
@@ -161,11 +146,6 @@ void TopOpeBRep_Hctxee2d::SetEdges(const
     }
   }
   
-#ifdef DEB
-  GeomAbs_CurveType myCurveType1 = myCurve1.GetType();
-  GeomAbs_CurveType myCurveType2 = myCurve2.GetType();
-#endif
-
 } // SetEdges
 
 //=======================================================================
Index: oce/src/TopOpeBRep/TopOpeBRep_Point2d.cxx
===================================================================
--- oce.orig/src/TopOpeBRep/TopOpeBRep_Point2d.cxx
+++ oce/src/TopOpeBRep/TopOpeBRep_Point2d.cxx
@@ -83,14 +83,15 @@ void TopOpeBRep_Point2d::Dump(const Stan
   Standard_Boolean keep = Keep();
   Standard_Integer sts = Status();
   Standard_Boolean pos = IsPointOfSegment();
+#ifdef DRAW
   Standard_Real tol = Tolerance();
+#endif
   
   const TopOpeBRepDS_Transition& T1 = Transition(1);
   const TopOpeBRepDS_Transition& T2 = Transition(2);
   
   Standard_Boolean isvertex1 = IsVertex(1); TopoDS_Vertex V1; if (isvertex1) V1 = Vertex(1);
   Standard_Boolean isvertex2 = IsVertex(2); TopoDS_Vertex V2; if (isvertex2) V2 = Vertex(2);
-  Standard_Boolean isvertex = isvertex1 || isvertex2;
 
   Standard_Integer ia1,ia2; SegmentAncestors(ia1,ia2);
   cout<<endl<<"p2d "<<index<<"  k="<<keep<<" pos="<<pos;
Index: oce/src/TopOpeBRep/TopOpeBRep_ProcessGR.cxx
===================================================================
--- oce.orig/src/TopOpeBRep/TopOpeBRep_ProcessGR.cxx
+++ oce/src/TopOpeBRep/TopOpeBRep_ProcessGR.cxx
@@ -150,8 +150,8 @@ TopAbs_State TopOpeBRep_FacesFiller::StB
   gp_Pnt pmil = BC.Value(parmil);
   
 #ifdef DEB
-  Standard_Boolean trc = TopOpeBRep_GettraceBIPS();
 #ifdef DRAW
+  Standard_Boolean trc = TopOpeBRep_GettraceBIPS();
   if (trc) {TCollection_AsciiString aa("pmil"); FUN_brep_draw(aa,pmil);}
 #endif
 #endif
@@ -202,10 +202,6 @@ void TopOpeBRep_FacesFiller::Lminmax(con
   VPI.Init(L,Standard_False);
   for (; VPI.More(); VPI.Next()) {
     const TopOpeBRep_VPointInter& VP = VPI.CurrentVP();
-#ifdef DEB
-    Standard_Integer iVP =
-#endif
-              VPI.CurrentVPIndex();
     Standard_Real p = VP.ParameterOnLine();
     pmin = Min(pmin,p);
     pmax = Max(pmax,p);
@@ -315,10 +311,6 @@ Standard_Real TopOpeBRep_FacesFiller::VP
   // If vp(index) is an edge boundary returns the point's parameter.
 
   const TopoDS_Edge& E = TopoDS::Edge(Lrest.Arc());
-#ifdef DEB
-  Standard_Boolean isdg =
-#endif
-             BRep_Tool::Degenerated(E);
   Standard_Boolean isedge1 =  Lrest.ArcIsEdge(1);
   Standard_Boolean isedge2 =  Lrest.ArcIsEdge(2);
   if (isedge1 && vp.IsVertexOnS1()) {
Index: oce/src/TopOpeBRep/TopOpeBRep_ProcessSectionEdges.cxx
===================================================================
--- oce.orig/src/TopOpeBRep/TopOpeBRep_ProcessSectionEdges.cxx
+++ oce/src/TopOpeBRep/TopOpeBRep_ProcessSectionEdges.cxx
@@ -58,10 +58,6 @@ void TopOpeBRep_FacesFiller::GetESL(TopT
     
     if (isrest) {
       const TopoDS_Edge& E = TopoDS::Edge(L.Arc());
-#ifdef DEB
-      Standard_Boolean FIisrest =
-#endif
-                     myFacesIntersector->IsRestriction(E);
       
 #ifdef DEB
       if (trRL) {
@@ -100,10 +96,6 @@ void TopOpeBRep_FacesFiller::GetESL(TopT
 Standard_Boolean TopOpeBRep_FacesFiller::KeepRLine
 (const TopOpeBRep_LineInter& L,const Standard_Boolean checkkeep) const
 { 
-#ifdef DEB
-  Standard_Boolean trc = (TopOpeBRepDS_GettraceDSF() || TopOpeBRepDS_GettraceDSNC());
-#endif
-
   TopOpeBRep_TypeLineCurve t = L.TypeLineCurve();
   Standard_Boolean isrest = (t == TopOpeBRep_RESTRICTION);
   if (!isrest) return Standard_False;
@@ -340,10 +332,7 @@ void TopOpeBRep_FacesFiller::ProcessSect
        itLES.Next(),itLOI.Next()) {
     const TopoDS_Shape& E1 = itLES.Value();
     Standard_Integer rE1 = itLOI.Value();
-#ifdef DEB
-    Standard_Integer iE1 =
-#endif
-              myDS->AddShape(E1,rE1);
+    myDS->AddShape(E1,rE1);
   }
   
   // determination des aretes SameDomain en 3d pur
Index: oce/src/TopOpeBRep/TopOpeBRep_ShapeIntersector.cxx
===================================================================
--- oce.orig/src/TopOpeBRep/TopOpeBRep_ShapeIntersector.cxx
+++ oce/src/TopOpeBRep/TopOpeBRep_ShapeIntersector.cxx
@@ -377,8 +377,6 @@ Standard_Boolean TopOpeBRep_ShapeInterse
   Standard_Boolean res = myIntersectionDone;
 
 #ifdef DEB
-  Standard_Integer i1 = Index(1);
-  Standard_Integer i2 = Index(2);
   if (TopOpeBRep_GettraceSI() && res) {
     if      ( myFFDone )   cout<<"FF : ";
     else if ( myEEFFDone ) cout<<"    EE : ";
@@ -581,8 +579,6 @@ void TopOpeBRep_ShapeIntersector::FindFF
 #ifdef DEB
     SAVFFi1 = myFaceScanner.Index(); SAVFFi2 = myFaceExplorer.Index(); 
     if (TopOpeBRep_GettraceSI()) {
-      Standard_Integer i1 = myFaceScanner.Index();
-      Standard_Integer i2 = myFaceExplorer.Index();
       cout<<"?? FF : ";
       myFaceScanner.DumpCurrent(cout); myFaceExplorer.DumpCurrent(cout);
       cout<<endl;
@@ -716,8 +712,6 @@ void TopOpeBRep_ShapeIntersector::FindEE
     myEEIntersector.Perform(GS1,GS2);
 
 #ifdef DEB
-    Standard_Integer i1 = Index(1);
-    Standard_Integer i2 = Index(2);
     if (TopOpeBRep_GettraceSI() && myEEIntersector.IsEmpty()) {
       cout<<"    EE : ";
       myEdgeScanner.DumpCurrent(cout);
Index: oce/src/TopOpeBRep/TopOpeBRep_ShapeIntersector2d.cxx
===================================================================
--- oce.orig/src/TopOpeBRep/TopOpeBRep_ShapeIntersector2d.cxx
+++ oce/src/TopOpeBRep/TopOpeBRep_ShapeIntersector2d.cxx
@@ -119,8 +119,6 @@ Standard_Boolean TopOpeBRep_ShapeInterse
   Standard_Boolean res = myIntersectionDone;
   
 #ifdef DEB
-  Standard_Integer i1 = Index(1);
-  Standard_Integer i2 = Index(2);
   if (TopOpeBRep_GettraceSI() && res) {
     if      ( myFFDone )   cout<<"FF : ";
     else if ( myEEFFDone ) cout<<"    EE : ";
@@ -252,8 +250,6 @@ void TopOpeBRep_ShapeIntersector2d::Find
     
 #ifdef DEB
     if (TopOpeBRep_GettraceSI()) {
-      Standard_Integer i1 = myFaceScanner.Index();
-      Standard_Integer i2 = myFaceExplorer.Index();
       cout<<"?? FF : ";
       myFaceScanner.DumpCurrent(cout); 
       myFaceExplorer.DumpCurrent(cout);
@@ -262,14 +258,8 @@ void TopOpeBRep_ShapeIntersector2d::Find
 #endif
 
     const TopOpeBRepTool_BoxSort& BS = myFaceScanner.BoxSort();
-#ifdef DEB
-    const Bnd_Box& B1 =
-#endif
-                        BS.Box(GS1);
-#ifdef DEB
-    const Bnd_Box& B2 =
-#endif
-                        BS.Box(GS2);
+    BS.Box(GS1);
+    BS.Box(GS2);
     myFFDone = Standard_True;
     break;
     NextFFCouple();
@@ -365,8 +355,6 @@ void TopOpeBRep_ShapeIntersector2d::Find
     myEEIntersector.Perform(GS1,GS2);
     
 #ifdef DEB
-    Standard_Integer i1 = Index(1);
-    Standard_Integer i2 = Index(2);
     if (TopOpeBRep_GettraceSI() && myEEIntersector.IsEmpty()) {
       cout<<"    EE : ";
       myEdgeScanner.DumpCurrent(cout);
Index: oce/src/TopOpeBRep/TopOpeBRep_VPointInterClassifier.cxx
===================================================================
--- oce.orig/src/TopOpeBRep/TopOpeBRep_VPointInterClassifier.cxx
+++ oce/src/TopOpeBRep/TopOpeBRep_VPointInterClassifier.cxx
@@ -85,10 +85,6 @@ TopAbs_State TopOpeBRep_VPointInterClass
     return myState;
   }
 
-#ifdef DEB
-  const gp_Pnt& P3D = VP.Value();
-#endif
- 
   TopoDS_Face FF = TopoDS::Face(F);
   TopOpeBRepTool_ShapeTool::AdjustOnPeriodic(FF,u,v);
   gp_Pnt2d p2d(u,v);
Index: oce/src/TopOpeBRep/TopOpeBRep_VPointInterIterator.cxx
===================================================================
--- oce.orig/src/TopOpeBRep/TopOpeBRep_VPointInterIterator.cxx
+++ oce/src/TopOpeBRep/TopOpeBRep_VPointInterIterator.cxx
@@ -52,10 +52,6 @@ void TopOpeBRep_VPointInterIterator::Ini
   if ( mycheckkeep ) {
     while ( More() ) { 
       const TopOpeBRep_VPointInter& VP = CurrentVP();
-#ifdef DEB
-      Standard_Integer iVP = 
-#endif
-	CurrentVPIndex();
       if (VP.Keep()) break;
       else myVPointIndex++;
     }
@@ -83,10 +79,6 @@ void  TopOpeBRep_VPointInterIterator::Ne
   if ( mycheckkeep ) {
     while ( More() ) { 
       const TopOpeBRep_VPointInter& VP = CurrentVP();
-#ifdef DEB
-      Standard_Integer iVP = 
-#endif
-	CurrentVPIndex();
       if (VP.Keep()) break;
       else myVPointIndex++;
     }
Index: oce/src/TopOpeBRep/TopOpeBRep_kpart.cxx
===================================================================
--- oce.orig/src/TopOpeBRep/TopOpeBRep_kpart.cxx
+++ oce/src/TopOpeBRep/TopOpeBRep_kpart.cxx
@@ -332,7 +332,6 @@ Standard_Boolean FUNBREP_topowalki
     lastinin = lastinin && (lasttransLine.After() == TopAbs_IN);
   }
   
-  Standard_Boolean LIdefinie = Standard_False;
   Standard_Boolean LITdefinie = Standard_False;
   Standard_Boolean LITonsort = Standard_False;
   TopOpeBRepDS_Transition LIT;
@@ -340,7 +339,6 @@ Standard_Boolean FUNBREP_topowalki
   Standard_Boolean nointerf = DSCIL.IsEmpty();
   if (!nointerf) {
     I = DSCIL.Last();
-    LIdefinie = Standard_True;
     LIT = I->Transition();
     LITdefinie = ! LIT.IsUnknown();
     if (LITdefinie) LITonsort = (LIT.Orientation(TopAbs_OUT) == TopAbs_FORWARD);
@@ -467,9 +465,6 @@ Standard_Boolean FUNBREP_topogline_new
     Standard_ProgramError::Raise("FUNBREP_topogline_new : line is not a GLine");
     return Standard_False;
   }
-#ifdef DEB
-  Standard_Boolean trc = TopOpeBRepDS_GettraceDSF();
-#endif	    
 
   Standard_Integer iVP = VP.Index();
   Standard_Integer iINON1,iINONn,nINON; L.VPBounds(iINON1,iINONn,nINON);
@@ -583,9 +578,6 @@ Standard_Boolean FUNBREP_topogline
  Standard_Real& parline,TopOpeBRepDS_Transition& transLine)
 //----------------------------------------------------------------------
 {
-#ifdef DEB
-  Standard_Boolean trc = TopOpeBRepDS_GettraceDSF();
-#endif	    
 
   if (L.TypeLineCurve() == TopOpeBRep_WALKING) {
     Standard_ProgramError::Raise("FUNBREP_topogline : line is not a GLine");
@@ -611,9 +603,6 @@ Standard_Boolean FUNBREP_topogline
     if (iVP == iINONn) transLine = TopOpeBRepDS_Transition(TopAbs_IN,TopAbs_OUT);    
   }
   Standard_Boolean onsort = (transLine.Orientation(TopAbs_OUT) == TopAbs_FORWARD);
-  Standard_Boolean lastdefinie = ! lasttransLine.IsUnknown();
-  Standard_Boolean lastonsort = Standard_False;
-  if (lastdefinie) lastonsort = (lasttransLine.Orientation(TopAbs_OUT) == TopAbs_FORWARD);
 
   Standard_Boolean LITdefinie = Standard_False;
   Standard_Boolean LITonsort = Standard_False;
Index: oce/src/TopOpeBRep/TopOpeBRep_vpr.cxx
===================================================================
--- oce.orig/src/TopOpeBRep/TopOpeBRep_vpr.cxx
+++ oce/src/TopOpeBRep/TopOpeBRep_vpr.cxx
@@ -184,10 +184,6 @@ static void FUN_VPgeometryfound
   
   const TopOpeBRepDS_DataStructure& BDS = HDS->DS();
   if (BDS.HasShape(edge)) {
-#ifdef DEB
-    Standard_Integer iedge =
-#endif
-                BDS.Shape(edge);
     const TopOpeBRepDS_ListOfInterference& EPIL = BDS.ShapeInterferences(edge);
     TopOpeBRepDS_ListIteratorOfListOfInterference itEPIL(EPIL);
     EPIfound = FF.GetGeometry(itEPIL,VP,PVIndex,PVKind);
@@ -233,10 +229,6 @@ static void FUN_VPgeometryfound
     Standard_Real tolOOe = FUN_tool_maxtol(OOedge);
     Standard_Real OOtolp = Precision::Parametric(tolOOe);
     if (BDS.HasShape(OOedge)) {
-#ifdef DEB
-      Standard_Integer iooedge =
-#endif
-                    BDS.Shape(OOedge);
       const TopOpeBRepDS_ListOfInterference& OOEPIL = BDS.ShapeInterferences(OOedge);
       TopOpeBRepDS_ListIteratorOfListOfInterference OOitEPIL(OOEPIL);
       OOEPIfound = FF.GetGeometry(OOitEPIL,VP,PVIndex,PVKind);
@@ -546,9 +538,6 @@ static void FUN_processCPI
  Standard_Integer& keptVPnbr)
 //-----------------------------------------------------------------------
 {    
-#ifdef DEB
-  Standard_Boolean CPIfound = !Ifound.IsNull();
-#endif
   Standard_Integer OOShapeIndex = (ShapeIndex == 1) ? 2 : 1;
 
   TopOpeBRepDS_Transition ttransLine = transLine;
@@ -990,15 +979,6 @@ void TopOpeBRep_FacesFiller::ProcessVPon
     }
   }//myLineINL
 
-#ifdef DEB
-  Standard_Integer SEPI = (EPIfound) ? IEPI->Support() : 0;
-#endif
-  TopOpeBRepDS_Kind SKEPI; if(EPIfound) SKEPI=IEPI->SupportType();
-#ifdef DEB
-  Standard_Integer SCPI = (CPIfound) ? ICPI->Support() : 0;
-#endif
-  TopOpeBRepDS_Kind SKCPI; if(CPIfound) SKCPI=ICPI->SupportType();
-
   // Gfound = VP corresponds with an existing geometry of ShapeIndex
   Standard_Boolean Gfound = ( EPIfound || CPIfound );  
 #ifdef DEB
Index: oce/src/TopOpeBRep/TopOpeBRep_vprclo.cxx
===================================================================
--- oce.orig/src/TopOpeBRep/TopOpeBRep_vprclo.cxx
+++ oce/src/TopOpeBRep/TopOpeBRep_vprclo.cxx
@@ -151,20 +151,12 @@ void TopOpeBRep_FacesFiller::ProcessVPon
 //  Standard_Boolean isvertex = VP.IsVertex(ShapeIndex);
   Standard_Boolean isvertex = (PVKind == TopOpeBRepDS_VERTEX);
   Standard_Integer absindex = VP.ShapeIndex(); // 0,1,2,3
-#ifdef DEB
-  Standard_Integer iVP =
-#endif
-            VP.Index();
   Standard_Boolean OOShapeIndex = (ShapeIndex == 1) ? 2 : 1;
   Standard_Boolean on2edges = (absindex == 3);
   Standard_Boolean hasONedge = (VP.State(OOShapeIndex) == TopAbs_ON);
   Standard_Boolean hasOOedge = (on2edges) ? Standard_True : hasONedge;
 
   TopoDS_Face Face = (*this).Face(ShapeIndex);
-#ifdef DEB
-  Standard_Integer iSIFace =
-#endif
-                myDS->Shape(Face);
   TopoDS_Face OOFace = (*this).Face(OOShapeIndex);
   Standard_Integer iOOFace = myDS->Shape(OOFace);
   if (iOOFace == 0) iOOFace = myDS->AddShape(OOFace,OOShapeIndex);
@@ -174,27 +166,19 @@ void TopOpeBRep_FacesFiller::ProcessVPon
   const TopoDS_Edge& edge = TopoDS::Edge(VP.Edge(ShapeIndex));
   if (myDS->HasShape(edge)) SIedgeIndex = myDS->Shape(edge);
   else                      myDS->AddShape(edge,ShapeIndex);
-#ifdef DEB
-  Standard_Boolean isrest =
-#endif
-               myDS->IsSectionEdge(edge);
-#ifdef DEB
-  Standard_Boolean closing =
-#endif
-                TopOpeBRepTool_ShapeTool::Closed(edge,Face);
+  myDS->IsSectionEdge(edge);
+  TopOpeBRepTool_ShapeTool::Closed(edge,Face);
   Standard_Real paredge = VP.EdgeParameter(ShapeIndex);
   
   // dummy if !<hasOOedge>
   Standard_Integer OOedgeIndex = 0; 
-  Standard_Boolean OOclosing,OOisrest; OOclosing = OOisrest = Standard_False;
   TopoDS_Edge OOedge;
   if ( hasOOedge ) {
     TopoDS_Shape OOe;
     if (on2edges) OOe = VP.Edge(OOShapeIndex);
     else          OOe = VP.EdgeON(OOShapeIndex);
     OOedge = TopoDS::Edge(OOe);
-    OOisrest = myDS->IsSectionEdge(OOedge);
-    OOclosing = TopOpeBRepTool_ShapeTool::Closed(OOedge,OOFace);
+    TopOpeBRepTool_ShapeTool::Closed(OOedge,OOFace);
     if (myDS->HasShape(OOedge)) OOedgeIndex = myDS->Shape(OOedge);
     else                        OOedgeIndex = myDS->AddShape(OOedge,OOShapeIndex);
   }
Index: oce/src/TopOpeBRep/TopOpeBRep_vprdeg.cxx
===================================================================
--- oce.orig/src/TopOpeBRep/TopOpeBRep_vprdeg.cxx
+++ oce/src/TopOpeBRep/TopOpeBRep_vprdeg.cxx
@@ -947,11 +947,6 @@ static Standard_Integer FUN_putInterfonD
  TopoDS_Edge& OOEi, Standard_Real& paronOOEi, Standard_Boolean hasOOEi,
  Standard_Boolean& isT2d)
 {  
-#ifdef DEB
-  Standard_Boolean traceDSF = TopOpeBRepDS_GettraceDSF();
-  Standard_Boolean traceDEGEN = TopOpeBRepDS_GettraceDEGEN();
-  Standard_Boolean trace = traceDSF || traceDEGEN;
-#endif
   OOEi.Nullify();
 
   Standard_Boolean on3 = (VP.ShapeIndex() == 3);// <VP> is shared by edge of 1 and edge of 2.
@@ -1021,13 +1016,12 @@ static Standard_Integer FUN_putInterfonD
     if (rkv != rkdg) {TopoDS_Vertex tmp = v; v = ov; ov = tmp; rkv = rkdg;} // ensure v is vertex of dge
   }
 
-  Standard_Boolean setrest = Standard_False;
   Standard_Integer mkt = 0; Standard_Real par1 = 0.0,par2 = 0.0;
   if (on3) {
     TopoDS_Edge ei = (rki == 1) ? TopoDS::Edge(VP.ArcOnS1()) : TopoDS::Edge(VP.ArcOnS2());
     Standard_Real pari = (rki == 1) ? VP.ParameterOnArc1() : VP.ParameterOnArc2();
     // if okrest, ei interfers in the compute of transitions for dge
-    setrest = mktdg.SetRest(pari,ei);
+    mktdg.SetRest(pari,ei);
     ok = mktdg.MkTonE(ei,mkt, par1,par2);  
     if ((!ok) || (mkt == NOI)) return NOI;      
     OOEi = ei; paronOOEi = pari; hasOOEi = Standard_True;
Index: oce/src/TopOpeBRepBuild/TopOpeBRepBuild_BuildEdges.cxx
===================================================================
--- oce.orig/src/TopOpeBRepBuild/TopOpeBRepBuild_BuildEdges.cxx
+++ oce/src/TopOpeBRepBuild/TopOpeBRepBuild_BuildEdges.cxx
@@ -77,7 +77,6 @@ void TopOpeBRepBuild_Builder::BuildEdges
   TopOpeBRepDS_DataStructure& BDS = HDS->ChangeDS();
 
   myNewEdges.Clear();
-  Standard_Integer nc = BDS.NbCurves();
   TopOpeBRepDS_CurveExplorer cex;
 
   Standard_Integer ick = 0;
@@ -95,7 +94,6 @@ void TopOpeBRepBuild_Builder::BuildEdges
     BDS.ChangeNbCurves(ick-1);
   }
 
-  nc = BDS.NbCurves();
   for (cex.Init(BDS,Standard_False); cex.More(); cex.Next()) {
     Standard_Integer ic = cex.Index();
     Standard_Integer im = cex.Curve(ic).Mother();
Index: oce/src/TopOpeBRepBuild/TopOpeBRepBuild_Builder1.cxx
===================================================================
--- oce.orig/src/TopOpeBRepBuild/TopOpeBRepBuild_Builder1.cxx
+++ oce/src/TopOpeBRepBuild/TopOpeBRepBuild_Builder1.cxx
@@ -760,7 +760,6 @@ void TopOpeBRepBuild_Builder1::GFillEdge
   //1) Get split parts of edge with state TB
   const TopTools_ListOfShape& LSE = myDataStructure -> DS().GetShapeWithState(EOR).Part(TB);
   TopTools_ListIteratorOfListOfShape  it (LSE);
-  Standard_Boolean first = Standard_True;
   for(; it.More(); it.Next()) {
 
     TopoDS_Edge newE = TopoDS::Edge(it.Value());
@@ -785,7 +784,6 @@ void TopOpeBRepBuild_Builder1::GFillEdge
   
   //2) Get ON parts of the edge and define to keep it or not
   const TopTools_ListOfShape& LSEOn = myDataStructure -> DS().GetShapeWithState(EOR).Part(TopAbs_ON);
-  first = Standard_True;
   it.Initialize(LSEOn);
   for(; it.More(); it.Next()) {
     
@@ -1013,14 +1011,10 @@ void TopOpeBRepBuild_Builder1::PerformON
 
   Standard_Integer iref = myDataStructure -> DS().AncestorRank(FOR1);
     
-  Standard_Boolean RevOri;
-
   if(iref == 1) {//object
     FTB = FTB1;
-    RevOri = G1.IsToReverse1();
   }
   else {//tool
-    RevOri = G1.IsToReverse2();
     FTB = FTB2;
   }
 
Index: oce/src/TopOpeBRepBuild/TopOpeBRepBuild_BuilderON.cxx
===================================================================
--- oce.orig/src/TopOpeBRepBuild/TopOpeBRepBuild_BuilderON.cxx
+++ oce/src/TopOpeBRepBuild/TopOpeBRepBuild_BuilderON.cxx
@@ -1170,11 +1170,11 @@ void TopOpeBRepBuild_BuilderON::GFillONP
     }
 
     TopOpeBRepDS_Transition TFEe3; TopAbs_State TFEe3bef = TFEe3.Before(); TopAbs_State TFEe3aft = TFEe3.After();
-    TopAbs_Orientation oe3FORF = TopAbs_FORWARD; Standard_Boolean e3BoundFOR = Standard_False;
+    TopAbs_Orientation oe3FORF = TopAbs_FORWARD;
     if (ssif) {
       TFEe3 = ssie3->Transition();
       TFEe3bef = TFEe3.Before();
-      e3BoundFOR = FUN_tool_orientEinFFORWARD(e3,FOR,oe3FORF);	
+      FUN_tool_orientEinFFORWARD(e3,FOR,oe3FORF);	
     }
 
     if (FFinSDSO) {
Index: oce/src/TopOpeBRepBuild/TopOpeBRepBuild_CorrectFace2d.cxx
===================================================================
--- oce.orig/src/TopOpeBRepBuild/TopOpeBRepBuild_CorrectFace2d.cxx
+++ oce/src/TopOpeBRepBuild/TopOpeBRepBuild_CorrectFace2d.cxx
@@ -335,7 +335,6 @@
   //
   // 2. Define the First Edge on the Wire from aCopyAvoidMap
   Standard_Integer i, aNbEdges=0, aNbAvoidEdgesOnWire;
-  Standard_Boolean IsAllAvoidEdgesDegenerated=Standard_False;
   Standard_Real aDMax=0, aR;
 
   TopExp_Explorer aWExp; 
@@ -374,7 +373,6 @@
     // All of anAvoidMap edges are degenerated
     // So take the edge with max dist. between 
     //First and Last 2d points as the First edge
-    IsAllAvoidEdgesDegenerated=Standard_True;
     //if(aNbAvoidEdgesOnWire != 1)
      // return 1; //in case of several degenerated edges we cannot connect wire by right way
     for (i=1; i<=aNbAvoidEdgesOnWire; i++) {
@@ -677,7 +675,7 @@
   void TopOpeBRepBuild_CorrectFace2d::CheckList (const TopoDS_Face& aFace,
 						 TopTools_ListOfShape&  HeadList)
 {
-  TopAbs_Orientation r1, r2;
+  TopAbs_Orientation r1;
   Standard_Real aDTolerance=Precision::Confusion();
   TopTools_SequenceOfShape aSeq;
   TopTools_ListIteratorOfListOfShape anIt(HeadList);
@@ -686,7 +684,6 @@
   }
 
   r1=aSeq(1).Orientation();
-  r2=aSeq(2).Orientation();
   Standard_Integer i, aNb=aSeq.Length();
 //modified by NIZNHY-PKV Mon Apr 24 14:43:57 2000f
   Standard_Boolean aFirstCheck=Standard_False;
@@ -720,7 +717,6 @@
 //modified by NIZNHY-PKV Mon Apr 24 14:43:59 2000t
 
   r1=aSeq(1).Orientation();
-  r2=aSeq(2).Orientation();
 
   TopoDS_Vertex aV1R, aV2F;
   
Index: oce/src/TopOpeBRepBuild/TopOpeBRepBuild_FREGU.cxx
===================================================================
--- oce.orig/src/TopOpeBRepBuild/TopOpeBRepBuild_FREGU.cxx
+++ oce/src/TopOpeBRepBuild/TopOpeBRepBuild_FREGU.cxx
@@ -280,8 +280,6 @@ void TopOpeBRepBuild_Builder::Regularize
 //	Standard_Integer nlspfsdFFe = lspfsdFFe.Extent();
 #endif    
 	  
-        Standard_Integer nDEB2=0 ;
-	
 	for (TopTools_ListIteratorOfListOfShape it(lspfsdFFe);it.More();it.Next()) {
 	  
 	  // fsdFFe (Cf supra E) a ete splittee, espfdsFFe = arete splittee de fsdFFe
@@ -302,7 +300,6 @@ void TopOpeBRepBuild_Builder::Regularize
 	    
 	    // son decoupage lresplit est stocke dans la DS du Builder
 	    const TopTools_ListOfShape& lresplit = myESplits.Find(espfsdFFe); //Cf supra E''
-	    nDEB2 = lresplit.Extent();
 	    
 	    // on memorise que espfsdFFe est redecoupee ...
 	    myMemoSplit.Add(espfsdFFe);
@@ -310,7 +307,6 @@ void TopOpeBRepBuild_Builder::Regularize
 	    // on stocke le nouveau decoupage de espfsdFFe dans la DS du builder ...
 	    TopTools_ListOfShape& lsp = ChangeSplit(espfsdFFe,stafsdFFe);  
 	    GCopyList(lresplit,lsp);
-	    nDEB2 = lsp.Extent();
 	  }
 	} // it.More
       } // iiista
Index: oce/src/TopOpeBRepBuild/TopOpeBRepBuild_FuseFace.cxx
===================================================================
--- oce.orig/src/TopOpeBRepBuild/TopOpeBRepBuild_FuseFace.cxx
+++ oce/src/TopOpeBRepBuild/TopOpeBRepBuild_FuseFace.cxx
@@ -144,7 +144,7 @@ void TopOpeBRepBuild_FuseFace::PerformFa
     
   TopTools_ListIteratorOfListOfShape it2,it3,it4;
   TopTools_DataMapIteratorOfDataMapOfShapeListOfShape itt1,itt2,itt3;
-  TopAbs_Orientation ori,ori1;
+  TopAbs_Orientation ori1;
 
   Standard_Boolean Ori3dReversed = Standard_False;
   Standard_Boolean Ori3dForward = Standard_False;
@@ -282,7 +282,6 @@ void TopOpeBRepBuild_FuseFace::PerformFa
 	  TopTools_ListOfShape myWireLE;
 	  for (itt3.Initialize(mapEdgLEdg); itt3.More(); itt3.Next()) {
 	    const TopoDS_Shape& edg = itt3.Key();
-	    ori = edg.Orientation();
 	    const TopTools_ListOfShape& LEdg1 = mapEdgLEdg.Find(edg);
 	    Standard_Boolean OriReversed = Standard_False;
 	    Standard_Boolean OriForward = Standard_False;
Index: oce/src/TopOpeBRepBuild/TopOpeBRepBuild_Grid.cxx
===================================================================
--- oce.orig/src/TopOpeBRepBuild/TopOpeBRepBuild_Grid.cxx
+++ oce/src/TopOpeBRepBuild/TopOpeBRepBuild_Grid.cxx
@@ -249,16 +249,8 @@ void TopOpeBRepBuild_Builder::GFindSamDo
     else if ( o != oref && !GContains(s,LLDO) ) LLDO.Append(s);
   }
   
-  Standard_Integer nso,ndo;
-  
-  nso = LLSO.Extent();
-  ndo = LLDO.Extent();
-  
   LSO = LLSO;
   LDO = LLDO;
-  
-  nso = LSO.Extent();
-  ndo = LDO.Extent();
 }
 
 //=======================================================================
Index: oce/src/TopOpeBRepBuild/TopOpeBRepBuild_GridEE.cxx
===================================================================
--- oce.orig/src/TopOpeBRepBuild/TopOpeBRepBuild_GridEE.cxx
+++ oce/src/TopOpeBRepBuild/TopOpeBRepBuild_GridEE.cxx
@@ -155,9 +155,8 @@ void TopOpeBRepBuild_Builder::GFillEdgeP
                                            const TopOpeBRepBuild_GTopo& G,
                                            TopOpeBRepBuild_PaveSet& PVS)
 {
-  TopAbs_ShapeEnum t1,t2,ShapeInterf;
+  TopAbs_ShapeEnum t1,t2;
   G.Type(t1,t2);
-  ShapeInterf = t1;
   TopAbs_State TB1,TB2;
   G.StatesON(TB1,TB2);
   
@@ -345,7 +344,7 @@ void TopOpeBRepBuild_Builder::GFillPoint
   // BUC60093 :  only 2 G : 1 point && 1 vertex  
   // deleting interfs on G = vertex sdm && closingE  
   TopoDS_Vertex vclo; Standard_Boolean closedE = TopOpeBRepTool_TOOL::ClosedE(TopoDS::Edge(E),vclo);
-  Standard_Integer kp1 = 0; Standard_Integer ikp1 = 0; 
+  Standard_Integer kp1 = 0;
   if (closedE) {
     tki.Init();
     Standard_Integer nG = 0;
@@ -358,7 +357,7 @@ void TopOpeBRepBuild_Builder::GFillPoint
       TopoDS_Shape oov;
       FUN_ds_getoov(v,myDataStructure,oov);
       Standard_Boolean samev = v.IsSame(vclo), sameoov = oov.IsSame(vclo);
-      if (samev || sameoov) {ikp1 = Gcur; kp1 = Gcur;}
+      if (samev || sameoov) {kp1 = Gcur;}
       tki.Next();
     }
     if (nG == 1) kp1 = 0; // we have only one interf on vGclo -> keep the interf
@@ -402,8 +401,8 @@ void TopOpeBRepBuild_Builder::GFillPoint
 	      aa += TCollection_AsciiString(Gcur); DSD.DumpLOI(LICur,cout,aa);}
 #endif
 
-    Standard_Boolean Ghsd = Standard_False; TopoDS_Shape vGsd; 
-    if (vertex) Ghsd = FUN_ds_getoov(BDS.Shape(Gcur), myDataStructure, vGsd); //xpu221098
+    TopoDS_Shape vGsd; 
+    if (vertex) FUN_ds_getoov(BDS.Shape(Gcur), myDataStructure, vGsd); //xpu221098
 
     // recall : I3d=(I3dF,I3dFE) : I3dF=(T(F),G,F), I3dFE=(T(F),G,E)
     //          I2d=I2dFE
@@ -496,8 +495,7 @@ void TopOpeBRepBuild_Builder::GFillPoint
     // - kp3 -
     // xpu200598 interference 2d at GPOINT
     Standard_Boolean kp3 = (n2d > 0) && point;
-    TopAbs_Orientation Okp3 = TopAbs_EXTERNAL; 
-    if (kp3) Okp3=l2dFEcur.First()->Transition().Orientation(TopAbs_IN);
+    if (kp3) l2dFEcur.First()->Transition().Orientation(TopAbs_IN);
 
 
     TopOpeBRepDS_PointIterator itCur(LICur); Standard_Integer iICur=0;
Index: oce/src/TopOpeBRepBuild/TopOpeBRepBuild_GridFF.cxx
===================================================================
--- oce.orig/src/TopOpeBRepBuild/TopOpeBRepBuild_GridFF.cxx
+++ oce/src/TopOpeBRepBuild/TopOpeBRepBuild_GridFF.cxx
@@ -1049,8 +1049,8 @@ void debmergee(const Standard_Integer /*
 					   const TopOpeBRepBuild_GTopo& G1,
 					   const TopTools_ListOfShape& LSclass)
 {
-  TopAbs_ShapeEnum t1,t2,ShapeInterf;
-  G1.Type(t1,t2); ShapeInterf = t1;
+  TopAbs_ShapeEnum t1,t2;
+  G1.Type(t1,t2);
   TopAbs_State TB1,TB2; G1.StatesON(TB1,TB2);
   // work on a FORWARD edge <EF>
   TopoDS_Shape EF = EOR; EF.Orientation(TopAbs_FORWARD);
Index: oce/src/TopOpeBRepBuild/TopOpeBRepBuild_GridSS.cxx
===================================================================
--- oce.orig/src/TopOpeBRepBuild/TopOpeBRepBuild_GridSS.cxx
+++ oce/src/TopOpeBRepBuild/TopOpeBRepBuild_GridSS.cxx
@@ -482,20 +482,15 @@ void TopOpeBRepBuild_Builder::GFillShell
       cout<<endl;}
 #endif
   
-  Standard_Integer nlsfs = SFS.ChangeStartShapes().Extent();
   TopOpeBRepTool_ShapeExplorer exFace;
-  Standard_Integer ifor = 0;
   
   // 1/ : toutes les faces HasSameDomain
   for (exFace.Init(SH,TopAbs_FACE); exFace.More(); exFace.Next()) {
-    nlsfs = SFS.ChangeStartShapes().Extent();
     const TopoDS_Shape& FOR = exFace.Current();
-    ifor = myDataStructure->Shape(FOR);
     Standard_Boolean hsd = myDataStructure->HasSameDomain(FOR);
     if ( hsd ) {
       GFillFaceSFS(FOR,LSO2,G1,SFS);
     } // hsd
-    nlsfs = SFS.ChangeStartShapes().Extent();
   } // exFace.More()
   
 #ifdef DEB
@@ -506,14 +501,11 @@ void TopOpeBRepBuild_Builder::GFillShell
   
   // 2/ : toutes les faces non HasSameDomain
   for (exFace.Init(SH,TopAbs_FACE); exFace.More(); exFace.Next()) {
-    nlsfs = SFS.ChangeStartShapes().Extent();
     const TopoDS_Shape& FOR = exFace.Current();
-    ifor = myDataStructure->Shape(FOR);
     Standard_Boolean hsd = myDataStructure->HasSameDomain(FOR);
     if ( !hsd ) {
       GFillFaceSFS(FOR,LSO2,G1,SFS);
     } // hsd
-    nlsfs = SFS.ChangeStartShapes().Extent();
   }
   
 } // GFillShellSFS
Index: oce/src/TopOpeBRepBuild/TopOpeBRepBuild_KPart.cxx
===================================================================
--- oce.orig/src/TopOpeBRepBuild/TopOpeBRepBuild_KPart.cxx
+++ oce/src/TopOpeBRepBuild/TopOpeBRepBuild_KPart.cxx
@@ -660,15 +660,12 @@ void TopOpeBRepBuild_Builder::MergeKPart
   TopTools_ListOfShape& lmergesha1 = ChangeMerged(myShape1,myState1);
 /*  TopTools_ListOfShape& lmergesha2 =*/ ChangeMerged(myShape2,myState2);
   
-  Standard_Boolean traite = Standard_True;
-
   Standard_Boolean soldisj = Standard_False;
   TopOpeBRepTool_ShapeExplorer exsol1(myShape1,TopAbs_SOLID);
   Standard_Boolean hassol1 = exsol1.More();
   TopOpeBRepTool_ShapeExplorer exsol2(myShape2,TopAbs_SOLID);
   Standard_Boolean hassol2 = exsol2.More();
   soldisj = (hassol1 && hassol2);
-  traite = soldisj;
 
 //modified by NIZHNY-MKK  Fri May 19 16:18:12 2000.BEGIN  
   Standard_Boolean hasnotsol1=Standard_False;
@@ -683,7 +680,6 @@ void TopOpeBRepBuild_Builder::MergeKPart
       hasnotsol2 = Standard_True;
   }
   soldisj = !(hasnotsol1 || hasnotsol2);
-  traite = soldisj;
 //modified by NIZHNY-MKK  Fri May 19 16:18:16 2000.END
   
   TopoDS_Solid sol1; TopoDS_Shell outsha1;
Index: oce/src/TopOpeBRepBuild/TopOpeBRepBuild_PaveSet.cxx
===================================================================
--- oce.orig/src/TopOpeBRepBuild/TopOpeBRepBuild_PaveSet.cxx
+++ oce/src/TopOpeBRepBuild/TopOpeBRepBuild_PaveSet.cxx
@@ -379,12 +379,12 @@ Standard_Boolean  TopOpeBRepBuild_PaveSe
   }
 
   if ( !myHasEqualParameters ) {
-    Standard_Boolean rd; Standard_Real f=0,l;
+    Standard_Boolean rd; Standard_Real f=0;
     {
       TopLoc_Location loc; Standard_Real ff,ll;
       Handle(Geom_Curve) CmyEdge = BRep_Tool::Curve(myEdge,loc,ff,ll);
       if ( CmyEdge.IsNull() ) rd = Standard_False;
-      else { f = ff; l = ll; rd = Standard_True; }
+      else { f = ff; rd = Standard_True; }
     }
     if (rd) {
       for (it1.Initialize(myVertices); 
Index: oce/src/TopOpeBRepBuild/TopOpeBRepBuild_SREGU.cxx
===================================================================
--- oce.orig/src/TopOpeBRepBuild/TopOpeBRepBuild_SREGU.cxx
+++ oce/src/TopOpeBRepBuild/TopOpeBRepBuild_SREGU.cxx
@@ -247,7 +247,6 @@ void TopOpeBRepBuild_Builder::Regularize
 //      Standard_Integer nlspssdSSf = lspssdSSf.Extent();
 #endif    
 
-      Standard_Integer nDEB2=0;      
       TopTools_ListOfShape newlspssdSSf; // nouvel ensemble de faces splittees de ssdSSf
 
       for (TopTools_ListIteratorOfListOfShape it(lspssdSSf);it.More();it.Next()) {
@@ -268,7 +267,6 @@ void TopOpeBRepBuild_Builder::Regularize
 
 	  // son decoupage lrfsplit est stocke dans la DS du Builder
 	  const TopTools_ListOfShape& lrfsplit = myFSplits.Find(fspssdSSf);//Cf supra E''
-	  nDEB2 = lrfsplit.Extent();
 
 	  // on memorise que fspssdSSf est redecoupee ...
 	  myMemoSplit.Add(fspssdSSf);
@@ -276,7 +274,6 @@ void TopOpeBRepBuild_Builder::Regularize
 	  // on stocke le nouveau decoupage de fspssdSSf dans la DS du builder ...
 	  TopTools_ListOfShape& lsp = ChangeSplit(fspssdSSf,stassdSSf);  
 	  GCopyList(lrfsplit,lsp);
-	  nDEB2 = lsp.Extent();
 	}	
       } // lspssdSSf.More()
     } // explore(ssdSS,TopAbs_FACE)
Index: oce/src/TopOpeBRepBuild/TopOpeBRepBuild_Tools.cxx
===================================================================
--- oce.orig/src/TopOpeBRepBuild/TopOpeBRepBuild_Tools.cxx
+++ oce/src/TopOpeBRepBuild/TopOpeBRepBuild_Tools.cxx
@@ -531,10 +531,8 @@ const Standard_Real PAR_T = 0.43213918;
 {
   TopoDS_Edge aEd=anEdgeObj;
   TopoDS_Face aFS=aFObj;
-  Standard_Real tolE = 0., f2 = 0., l2 = 0., tolpc = 0., tol = 0., f = 0., l = 0., par = 0.;
-  tolE=BRep_Tool::Tolerance(aEd);
+  Standard_Real f2 = 0., l2 = 0., tolpc = 0., f = 0., l = 0., par = 0.;
   Handle(Geom2d_Curve) C2D=FC2D_CurveOnSurface(aEd,aFS,f2,l2,tolpc, Standard_True);
-  tol = Max(tolE,tolpc);
 
   BRepAdaptor_Curve  aCA(aEd);
   f=aCA.FirstParameter();
Index: oce/src/TopOpeBRepBuild/TopOpeBRepBuild_Tools2d.cxx
===================================================================
--- oce.orig/src/TopOpeBRepBuild/TopOpeBRepBuild_Tools2d.cxx
+++ oce/src/TopOpeBRepBuild/TopOpeBRepBuild_Tools2d.cxx
@@ -180,14 +180,10 @@ static
 //=======================================================================
   void TopOpeBRepBuild_Tools2d::DumpMapOfShapeVertexInfo(const TopOpeBRepBuild_IndexedDataMapOfShapeVertexInfo& M)
 {
-  Standard_Integer i, aNb, aNbEdgesIn, aNbEdgesOut;
+  Standard_Integer i, aNb;
   aNb=M.Extent();
   for (i=1; i<=aNb; i++) {
     const TopOpeBRepBuild_VertexInfo& aVInfo=M(i);
-    const TopTools_IndexedMapOfOrientedShape& EdgesIn   =aVInfo.EdgesIn();
-    const TopTools_IndexedMapOfOrientedShape& EdgesOut  =aVInfo.EdgesOut();
-    aNbEdgesIn   =EdgesIn.Extent();
-    aNbEdgesOut  =EdgesOut.Extent();
     
     printf(" Vert.#%d, ", i);
     const TopTools_ListOfShape& aList=aVInfo.ListPassed();
Index: oce/src/TopOpeBRepBuild/TopOpeBRepBuild_VertexInfo.cxx
===================================================================
--- oce.orig/src/TopOpeBRepBuild/TopOpeBRepBuild_VertexInfo.cxx
+++ oce/src/TopOpeBRepBuild/TopOpeBRepBuild_VertexInfo.cxx
@@ -189,9 +189,8 @@
   const TopoDS_Edge& TopOpeBRepBuild_VertexInfo::CurrentOut () 
 {
 
-  Standard_Integer i, aNbOut, aNbPassed ;
+  Standard_Integer i, aNbOut;
   aNbOut =myLocalEdgesOut.Extent();
-  aNbPassed=myEdgesPassed.Extent();
   
   TopTools_IndexedMapOfOrientedShape aMapPassed;
   TopTools_ListIteratorOfListOfShape anIt(myEdgesPassed);
Index: oce/src/TopOpeBRepBuild/TopOpeBRepBuild_WireEdgeSet.cxx
===================================================================
--- oce.orig/src/TopOpeBRepBuild/TopOpeBRepBuild_WireEdgeSet.cxx
+++ oce/src/TopOpeBRepBuild/TopOpeBRepBuild_WireEdgeSet.cxx
@@ -531,12 +531,6 @@ void TopOpeBRepBuild_WireEdgeSet::IsUVIS
   PC = FC2D_CurveOnSurface(E,F,fE,lE,tolpc,trim3d);
   if (PC.IsNull()) Standard_ProgramError::Raise("TopOpeBRepBuild_WireEdgeSet::IsUVISO");
 
-#ifdef DEB
-  Standard_Integer iE = 0, iF = 0;
-  if (LOCAL_PBUILDER_DEB != NULL) iE = LOCAL_PBUILDER_DEB->DataStructure()->Shape(E);
-  if (LOCAL_PBUILDER_DEB != NULL) iF = LOCAL_PBUILDER_DEB->DataStructure()->Shape(F);
-#endif
-
   Handle(Standard_Type) TheType = PC->DynamicType();
   if (TheType == STANDARD_TYPE(Geom2d_Line)) {
     const Handle(Geom2d_Line)& HL = *((Handle(Geom2d_Line)*)&PC);
Index: oce/src/TopOpeBRepBuild/TopOpeBRepBuild_ffsfs.cxx
===================================================================
--- oce.orig/src/TopOpeBRepBuild/TopOpeBRepBuild_ffsfs.cxx
+++ oce/src/TopOpeBRepBuild/TopOpeBRepBuild_ffsfs.cxx
@@ -401,7 +401,7 @@ void TopOpeBRepBuild_Builder::GFillFaceS
       GLOBAL_SplitAnc->Clear(); // xpu280598
 
       // FuseFace
-      Standard_Integer nlsfs = SFS.ChangeStartShapes().Extent();
+      SFS.ChangeStartShapes().Extent();
       if (performfufa) {	
 #ifdef DEB
 	if(tSPS) debffflo(iF);
@@ -440,7 +440,7 @@ void TopOpeBRepBuild_Builder::GFillFaceS
 #endif
 	  SFS.AddStartElement(flfr2);
 	}
-	nlsfs = SFS.ChangeStartShapes().Extent();
+	SFS.ChangeStartShapes().Extent();
       } // performfufa (context)
       
     } // makemerge
Index: oce/src/TopOpeBRepBuild/TopOpeBRepBuild_kpkole.cxx
===================================================================
--- oce.orig/src/TopOpeBRepBuild/TopOpeBRepBuild_kpkole.cxx
+++ oce/src/TopOpeBRepBuild/TopOpeBRepBuild_kpkole.cxx
@@ -741,7 +741,6 @@ Standard_EXPORT Standard_Boolean FUNKP_K
   TopTools_ListOfShape lfhg; 
   Standard_Integer nfhg = BU.KPlhg(sol,TopAbs_FACE,lfhg);
   if ( nfhg != 0 ) {
-    Standard_Boolean hasgeominterf = Standard_False; // DEB
     TopTools_ListIteratorOfListOfShape its(lfhg);
     for(; its.More(); its.Next()) {
       TopOpeBRepDS_ListIteratorOfListOfInterference iti(BDS.ShapeInterferences(its.Value()));
@@ -749,7 +748,6 @@ Standard_EXPORT Standard_Boolean FUNKP_K
 	Handle(TopOpeBRepDS_ShapeShapeInterference) ssi;
 	ssi = Handle(TopOpeBRepDS_ShapeShapeInterference)::DownCast(iti.Value());
 	if (ssi.IsNull()) {
-	  hasgeominterf = Standard_True; // DEB
 	  return Standard_False;
 	}
       }
Index: oce/src/TopOpeBRepDS/TopOpeBRepDS_EIR.cxx
===================================================================
--- oce.orig/src/TopOpeBRepDS/TopOpeBRepDS_EIR.cxx
+++ oce/src/TopOpeBRepDS/TopOpeBRepDS_EIR.cxx
@@ -735,15 +735,13 @@ static void FUN_ProcessEdgeInterferences
   }
 #endif
 
-  Standard_Integer nF = 0, nE = 0, nFE = 0;
-
   // LI -> (lF + lFE) + lE + [LI]
   // lF  = {interference on edge <EIX> :  (T(face),G=POINT/VERTEX,S)
   // lFE = {interference on edge <EIX> :  (T(face),G=POINT/VERTEX,S=EDGE)
   // lE  = {interference on edge <EIX> :  (T(edge),G=POINT/VERTEX,S)
-  TopOpeBRepDS_ListOfInterference lF; nF = FUN_selectTRASHAinterference(LI,TopAbs_FACE,lF);
-  TopOpeBRepDS_ListOfInterference lFE; nFE = FUN_selectSKinterference(lF,TopOpeBRepDS_EDGE,lFE);
-  TopOpeBRepDS_ListOfInterference lE; nE = FUN_selectTRASHAinterference(LI,TopAbs_EDGE,lE);
+  TopOpeBRepDS_ListOfInterference lF; FUN_selectTRASHAinterference(LI,TopAbs_FACE,lF);
+  TopOpeBRepDS_ListOfInterference lFE; FUN_selectSKinterference(lF,TopOpeBRepDS_EDGE,lFE);
+  TopOpeBRepDS_ListOfInterference lE; FUN_selectTRASHAinterference(LI,TopAbs_EDGE,lE);
 
 #ifdef DEB 
   TopOpeBRepDS_Dumper DSD(HDS);	      
@@ -972,7 +970,6 @@ void TopOpeBRepDS_EIR::ProcessEdgeInterf
     for (tki.Init(); tki.More(); tki.Next()) {
       TopOpeBRepDS_Kind K; Standard_Integer G; tki.Value(K,G);
       TopOpeBRepDS_ListOfInterference& loi = tki.ChangeValue(K,G);
-      Standard_Integer nloi = loi.Extent();
       if (K != TopOpeBRepDS_POINT) {
 	LI.Append(loi);
 	continue;
@@ -1018,7 +1015,6 @@ void TopOpeBRepDS_EIR::ProcessEdgeInterf
 	if (curvefound) break;
       } // itlfx.More()
       
-      nloi = loi.Extent();
 #ifdef DEB
 //      Standard_Integer nLI = LI.Extent();
 #endif
Index: oce/src/TopOpeBRepDS/TopOpeBRepDS_EXPORT.cxx
===================================================================
--- oce.orig/src/TopOpeBRepDS/TopOpeBRepDS_EXPORT.cxx
+++ oce/src/TopOpeBRepDS/TopOpeBRepDS_EXPORT.cxx
@@ -287,10 +287,6 @@ Standard_EXPORT Standard_Boolean FDS_Edg
 (const TopoDS_Shape& E,const Handle(TopOpeBRepDS_HDataStructure)& HDS)  // not used
 //----------------------------------------------------
 {
-#ifdef DEB
-  Standard_Integer if1 = 0, if2 = 0;
-#endif
-
   const TopOpeBRepDS_DataStructure& BDS = HDS->DS();
   const TopTools_ListOfShape& lf = FDSCNX_EdgeConnexitySameShape(E,HDS);
   Standard_Integer nlf = lf.Extent();
@@ -303,9 +299,6 @@ Standard_EXPORT Standard_Boolean FDS_Edg
     TopTools_ListIteratorOfListOfShape i2(i1);
     for(;i2.More();i2.Next()) {
       const TopoDS_Shape& f2 = i2.Value();
-#ifdef DEB
-      if1 = BDS.Shape(f1);if2 = BDS.Shape(f2);
-#endif
       samdom = FDS_aresamdom(BDS,E,f1,f2);
       if (samdom) break;
     }
@@ -1733,8 +1726,8 @@ Standard_EXPORT void FUN_ds_completeforS
 	    else if (M_EXTERNAL(O))                 {newT.Set(O);}
 	    else if (M_INTERNAL(O))                 {
 	      Standard_Real parEsd   = BRep_Tool::Parameter(vG,Esd);
-	      gp_Vec tgEsd; Standard_Boolean ok = TopOpeBRepTool_TOOL::TggeomE(parEsd,Esd,tgEsd); // dir
-	      gp_Vec tgE  ;     ok = TopOpeBRepTool_TOOL::TggeomE(parE,SE,tgE);      // dir
+	      gp_Vec tgEsd; TopOpeBRepTool_TOOL::TggeomE(parEsd,Esd,tgEsd); // dir
+	      gp_Vec tgE  ; TopOpeBRepTool_TOOL::TggeomE(parE,SE,tgE);      // dir
 	      Standard_Real dot = tgEsd.Dot(tgE);
 #ifdef DEB
 	      Standard_Real tola =
Index: oce/src/TopOpeBRepDS/TopOpeBRepDS_ProcessEdgeInterferences.cxx
===================================================================
--- oce.orig/src/TopOpeBRepDS/TopOpeBRepDS_ProcessEdgeInterferences.cxx
+++ oce/src/TopOpeBRepDS/TopOpeBRepDS_ProcessEdgeInterferences.cxx
@@ -95,14 +95,13 @@ static Standard_Boolean FUN_keepEinterfe
   //  Standard_Boolean k4I = (((shab == TopAbs_FACE) && (stab == TopAbs_OUT)) &&
 //		((shaa == TopAbs_FACE) && (staa == TopAbs_OUT))); 
 #endif
-    Standard_Boolean k4C = Standard_False;
     {
       TopoDS_Vertex Vf,Vr; TopExp::Vertices(TopoDS::Edge(E),Vf,Vr);
       TopTools_ListIteratorOfListOfShape it(DS.ShapeSameDomain(VG));
       for (; it.More(); it.Next()) {
 	const TopoDS_Shape& Vsd = it.Value();
-	if      ( Vsd.IsSame(Vf) ) { k4C = Standard_True; break; }
-	else if ( Vsd.IsSame(Vr) ) { k4C = Standard_True; break; }
+	if      ( Vsd.IsSame(Vf) ) { break; }
+	else if ( Vsd.IsSame(Vr) ) { break; }
       }
     }
 #ifdef DEB
Index: oce/src/TopOpeBRepDS/TopOpeBRepDS_ProcessFaceInterferences.cxx
===================================================================
--- oce.orig/src/TopOpeBRepDS/TopOpeBRepDS_ProcessFaceInterferences.cxx
+++ oce/src/TopOpeBRepDS/TopOpeBRepDS_ProcessFaceInterferences.cxx
@@ -285,10 +285,6 @@ Standard_EXPORT void FUN_resolveFUNKNOWN
 
     const TopoDS_Face& FS = TopoDS::Face(BDS.Shape(S1));
 
-    Standard_Boolean isclosedFF = BRep_Tool::IsClosed(EE,FF);
-    Standard_Boolean isclosedFS = BRep_Tool::IsClosed(EE,FS);
-    Standard_Boolean go = Standard_True;
-    go = (isclosedFF || isclosedFS);
 //    if (!go) continue;
 
     // la face FF transitionne par la transition T1.IsUnknown()
Index: oce/src/TopOpeBRepTool/TopOpeBRepTool_2d.cxx
===================================================================
--- oce.orig/src/TopOpeBRepTool/TopOpeBRepTool_2d.cxx
+++ oce/src/TopOpeBRepTool/TopOpeBRepTool_2d.cxx
@@ -282,9 +282,6 @@ static void FC2D_translate(Handle(Geom2d
   
   if (isperio && uviso && !EFnull) {
     // C2D prend comme origine dans F l'origine de la pcurve de EF dans F
-#ifdef DEB
-    Standard_Real period = S1->IsUPeriodic() ? S1->UPeriod() : S1->IsVPeriodic() ? S1->VPeriod() : 0.;
-#endif
     TopoDS_Face FFOR = F;
     FFOR.Orientation(TopAbs_FORWARD);
     gp_Pnt2d p1,p2; BRep_Tool::UVPoints(EF,FFOR,p1,p2);
Index: oce/src/TopOpeBRepTool/TopOpeBRepTool_BoxSort.cxx
===================================================================
--- oce.orig/src/TopOpeBRepTool/TopOpeBRepTool_BoxSort.cxx
+++ oce/src/TopOpeBRepTool/TopOpeBRepTool_BoxSort.cxx
@@ -290,10 +290,6 @@ const Bnd_Box& TopOpeBRepTool_BoxSort::B
   }
 
   if ( myHBT->HasBox(S) ) {
-#ifdef DEB
-    Standard_Integer i =
-#endif
-            myHBT->Index(S);
     const Bnd_Box& B = myHBT->Box(S);
     return B;
   }
Index: oce/src/TopOpeBRepTool/TopOpeBRepTool_CORRISO.cxx
===================================================================
--- oce.orig/src/TopOpeBRepTool/TopOpeBRepTool_CORRISO.cxx
+++ oce/src/TopOpeBRepTool/TopOpeBRepTool_CORRISO.cxx
@@ -34,7 +34,7 @@ Standard_EXPORT TopTools_IndexedMapOfOri
 static void FUN_RaiseError()
 {
 #ifdef DEB
-  Standard_Boolean trc = TopOpeBRepTool_GettraceCORRISO();
+//  Standard_Boolean trc = TopOpeBRepTool_GettraceCORRISO();
   FUN_REINIT(); 
 //  if (trc) cout <<"*********failure in CORRISO***********\n";
 #endif
@@ -72,10 +72,7 @@ TopOpeBRepTool_CORRISO::TopOpeBRepTool_C
 TopOpeBRepTool_CORRISO::TopOpeBRepTool_CORRISO(const TopoDS_Face& Fref)
 {
   myFref = Fref;
-#ifdef DEB
-  Standard_Boolean closed =
-#endif
-               FUN_tool_closedS(myFref,myUclosed,myUper,myVclosed,myVper);
+  FUN_tool_closedS(myFref,myUclosed,myUper,myVclosed,myVper);
 
   const Handle(Geom_Surface)& SU = BRep_Tool::Surface(myFref);
   myGAS = GeomAdaptor_Surface(SU);
@@ -153,10 +150,7 @@ Standard_Boolean TopOpeBRepTool_CORRISO:
 //    Standard_Real f,l,tol; Handle(Geom2d_Curve) PC = FC2D_CurveOnSurface(E,myFref,f,l,tol);
     Handle(Geom2d_Curve) PC; Standard_Real f,l,tol;
     Standard_Boolean hasold = FC2D_HasOldCurveOnSurface(E,myFref,PC);
-#ifdef DEB
-    Standard_Boolean hasnew =
-#endif
-                 FC2D_HasNewCurveOnSurface(E,myFref,PC);
+    FC2D_HasNewCurveOnSurface(E,myFref,PC);
     PC = FC2D_EditableCurveOnSurface(E,myFref,f,l,tol);
     if (!hasold) FC2D_AddNewCurveOnSurface(PC,E,myFref,f,l,tol);
     if (PC.IsNull()) return Standard_False;
@@ -168,7 +162,10 @@ Standard_Boolean TopOpeBRepTool_CORRISO:
     for (; exv.More(); exv.Next()){
       const TopoDS_Vertex& v = TopoDS::Vertex(exv.Current());   
 #ifdef DEB
-      Standard_Integer iv = STATIC_PURGE_mapv.Add(v);
+#ifdef DRAW
+      Standard_Integer iv =
+#endif
+        STATIC_PURGE_mapv.Add(v);
 #ifdef DRAW
       if (trc) {TCollection_AsciiString bb = TCollection_AsciiString("v"); FUN_tool_draw(bb,v,iv);}
 #endif      
@@ -334,15 +331,7 @@ static Standard_Boolean FUN_isonOcE(cons
     TopOpeBRepTool_C2DF OcE2d; Standard_Boolean isOb = CO.UVRep(OcE,OcE2d);
     if (!isOb) return Standard_False; // NYIRAISE
     
-#ifdef DEB
-    const TopoDS_Vertex& vce1 =
-#endif
-                      TopoDS::Vertex(vcE(1)); 
     Standard_Real parvce1 = TopOpeBRepTool_TOOL::ParE(1,cE);   gp_Pnt2d UVvce1 = TopOpeBRepTool_TOOL::UVF(parvce1,cE2d);
-#ifdef DEB
-    const TopoDS_Vertex& vOce2 =
-#endif
-                       TopoDS::Vertex(vOcE(2)); 
     Standard_Real parvOcE2 = TopOpeBRepTool_TOOL::ParE(2,OcE); gp_Pnt2d UVvOcE2 = TopOpeBRepTool_TOOL::UVF(parvOcE2,OcE2d);
     Standard_Real tol = Max(tttuvcE,tttuvOcE);
     isonOcE2d = (UVvce1.Distance(UVvOcE2) < tol);
@@ -380,10 +369,7 @@ Standard_Boolean TopOpeBRepTool_CORRISO:
 
   if      (fyceds.Extent() == 1) {// ivf == 3 : cto016G*
     TopTools_DataMapOfOrientedShapeInteger fyeds;
-#ifdef DEB
-    Standard_Boolean found =
-#endif
-                EdgesWithFaultyUV(myEds,3,fyeds);
+    EdgesWithFaultyUV(myEds,3,fyeds);
     Standard_Integer nfy = fyeds.Extent();
 
     TopTools_DataMapIteratorOfDataMapOfOrientedShapeInteger itm(fyceds);
@@ -411,15 +397,7 @@ Standard_Boolean TopOpeBRepTool_CORRISO:
       TopOpeBRepTool_C2DF OcE2d; Standard_Boolean isOb = UVRep(OcE,OcE2d);
       if (!isOb) return Standard_False; // NYIRAISE
       
-#ifdef DEB
-      const TopoDS_Vertex& vce1 =
-#endif
-                         TopoDS::Vertex(vcE(1)); 
       Standard_Real parvce1 = TopOpeBRepTool_TOOL::ParE(1,cE);   gp_Pnt2d UVvce1 = TopOpeBRepTool_TOOL::UVF(parvce1,cE2d);
-#ifdef DEB
-      const TopoDS_Vertex& vOce2 =
-#endif
-                         TopoDS::Vertex(vOcE(2)); 
       Standard_Real parvOcE2 = TopOpeBRepTool_TOOL::ParE(2,OcE); gp_Pnt2d UVvOcE2 = TopOpeBRepTool_TOOL::UVF(parvOcE2,OcE2d);
       Standard_Real tol = Max(tttuvcE,tttuvOcE);
       isoncE = (UVvce1.Distance(UVvOcE2) < tol);
@@ -523,14 +501,7 @@ Standard_Boolean TopOpeBRepTool_CORRISO:
       Standard_Real tttuvOcE = Max(Tol(1,tttolOcE),Tol(2,tttolOcE));
       TopOpeBRepTool_C2DF OcE2d; Standard_Boolean isOb = UVRep(OcE,OcE2d);
       if (!isOb) return Standard_False; // NYIRAISE
-#ifdef DEB 
-      const TopoDS_Vertex& vce1 = TopoDS::Vertex(vcE(1));
-#endif 
       Standard_Real parvce1 = TopOpeBRepTool_TOOL::ParE(1,cE);   gp_Pnt2d UVvce1 = TopOpeBRepTool_TOOL::UVF(parvce1,cE2d);
-#ifdef DEB
-      const TopoDS_Vertex& vOce2 =
-#endif
-                         TopoDS::Vertex(vOcE(2)); 
       Standard_Real parvOcE2 = TopOpeBRepTool_TOOL::ParE(2,OcE); gp_Pnt2d UVvOcE2 = TopOpeBRepTool_TOOL::UVF(parvOcE2,OcE2d);
       Standard_Real tol = Max(tttuvcE,tttuvOcE);
       isonOcE2d = (UVvce1.Distance(UVvOcE2) < tol);
@@ -547,10 +518,6 @@ Standard_Boolean TopOpeBRepTool_CORRISO:
       // <vce> (boundary of <cE>):   
       const TopoDS_Vertex& vce = TopoDS::Vertex(vcE(ivce)); 
       TopTools_ListOfShape loe; isb = Connexity(vce,loe);
-#ifdef DEB
-      Standard_Integer nloe =
-#endif
-                 loe.Extent(); // DEB
       if (!isb) return Standard_False; // NYIRAISE
 
       Standard_Real parvce = TopOpeBRepTool_TOOL::ParE(ivce,cE); gp_Pnt2d UVvce = TopOpeBRepTool_TOOL::UVF(parvce,cE2d);
@@ -684,9 +651,6 @@ Standard_Integer TopOpeBRepTool_CORRISO:
   Standard_Real xlast   = onU ? myGAS.LastUParameter() : myGAS.LastVParameter(); // xlast=xfirst+xperiod
   Standard_Real xperiod = onU ? myUper : myVper;
 
-#ifdef DEB
-  Standard_Boolean inbounds=Standard_False;  
-#endif
   Standard_Boolean isou,isov; gp_Pnt2d o2d; gp_Dir2d d2d; 
   Standard_Boolean iso = TopOpeBRepTool_TOOL::UVISO(PC,isou,isov,d2d,o2d);
 
@@ -834,10 +798,6 @@ Standard_Boolean TopOpeBRepTool_CORRISO:
     // <vEok> :
     Standard_Boolean vEok = Standard_False;
     const TopTools_ListOfShape& loe = myVEds.Find(vE);
-#ifdef DEB
-    Standard_Integer nloe =
-#endif
-               loe.Extent(); //DEB
     for (TopTools_ListIteratorOfListOfShape ite(loe); ite.More(); ite.Next()) {
       const TopoDS_Edge& e = TopoDS::Edge(ite.Value());
       TopAbs_Orientation oe = e.Orientation();
@@ -848,14 +808,6 @@ Standard_Boolean TopOpeBRepTool_CORRISO:
       if (e.IsSame(E)) continue;      
       if (M_INTERNAL(oe) || M_EXTERNAL(oe)) continue;
 
-#ifdef DEB
-      Standard_Real tttole =
-#endif
-                   BRep_Tool::Tolerance(e);
-#ifdef DEB
-      Standard_Real tttuve = Max(Tol(1,tttole),Tol(2,tttole));
-#endif
-      
       Standard_Boolean isb = myERep2d.IsBound(e);
       if (!isb) {FUN_RaiseError(); return Standard_False;}
       const TopOpeBRepTool_C2DF& C2DF = myERep2d.Find(e);
@@ -979,17 +931,11 @@ Standard_Boolean TopOpeBRepTool_CORRISO:
 {
   gp_Vec2d tt2d; 
   if (onU) {Standard_Real uper;
-#ifdef DEB
-            Standard_Boolean ok =
-#endif
-                     Refclosed(1,uper);
+            Refclosed(1,uper);
             if (!uper) return Standard_False;
 	    tt2d = gp_Vec2d(uper,0.);}
   else     {Standard_Real vper;
-#ifdef DEB
-            Standard_Boolean ok =
-#endif
-                     Refclosed(2,vper);
+            Refclosed(2,vper);
             if (!vper) return Standard_False;
 	    tt2d = gp_Vec2d(0.,vper);}
   TopTools_DataMapIteratorOfDataMapOfOrientedShapeInteger itm(FyEds);
@@ -1079,10 +1025,7 @@ Standard_Boolean TopOpeBRepTool_CORRISO:
   if (!isb) {
     Handle(Geom2d_Curve) PC; Standard_Real f,l,tol;
     Standard_Boolean hasold = FC2D_HasOldCurveOnSurface(E,myFref,PC);
-#ifdef DEB
-    Standard_Boolean hasnew =
-#endif
-                 FC2D_HasNewCurveOnSurface(E,myFref,PC);
+    FC2D_HasNewCurveOnSurface(E,myFref,PC);
     PC = FC2D_EditableCurveOnSurface(E,myFref,f,l,tol);
     if (!hasold) FC2D_AddNewCurveOnSurface(PC,E,myFref,f,l,tol);
     if (PC.IsNull()) return Standard_False;
Index: oce/src/TopOpeBRepTool/TopOpeBRepTool_GEOMETRY.cxx
===================================================================
--- oce.orig/src/TopOpeBRepTool/TopOpeBRepTool_GEOMETRY.cxx
+++ oce/src/TopOpeBRepTool/TopOpeBRepTool_GEOMETRY.cxx
@@ -79,10 +79,6 @@ Standard_EXPORT Standard_Boolean FUN_too
   }
   if (ST == GeomAbs_Sphere) {
     Standard_Real pisur2 = PI*.5;
-#ifdef DEB
-    Standard_Real u =
-#endif
-            p2d.X();
     Standard_Real v = p2d.Y();
     Standard_Boolean vpisur2 = (Abs(v-pisur2) < toluv);
     Standard_Boolean vmoinspisur2 = (Abs(v+pisur2) < toluv);
@@ -118,10 +114,6 @@ Standard_EXPORT gp_Dir FUN_tool_ngS(cons
       }
       else if (du < tol) {
 	Standard_Real vf = GS.FirstVParameter();
-#ifdef DEB
-        Standard_Real vl =
-#endif
-                 GS.LastVParameter();
 	Standard_Boolean onvf = Abs(p2d.Y()-vf)<toluv;
 
 	Standard_Real x = p2d.X(); Standard_Real y = p2d.Y();
@@ -217,9 +209,6 @@ Standard_EXPORT Standard_Boolean FUN_too
   if (pcb.IsNull()) return Standard_False;
   Geom2dAdaptor_Curve GC2d(pcb);
   GeomAbs_CurveType typ = GC2d.GetType();
-#ifdef DEB
-  Standard_Boolean isquad = Standard_False;
-#endif
   if (typ == GeomAbs_Line) return Standard_True;
 
   return Standard_False ;
Index: oce/src/TopOpeBRepTool/TopOpeBRepTool_HBoxTool.cxx
===================================================================
--- oce.orig/src/TopOpeBRepTool/TopOpeBRepTool_HBoxTool.cxx
+++ oce/src/TopOpeBRepTool/TopOpeBRepTool_HBoxTool.cxx
@@ -126,10 +126,6 @@ const Bnd_Box& TopOpeBRepTool_HBoxTool::
     Standard_ProgramError::Raise("HBT::Box1");
   }
 
-#ifdef DEB
-  Standard_Integer im =
-#endif
-           Index(S);
   const Bnd_Box& B = myIMS.FindFromKey(S);
   return B;
 }
Index: oce/src/TopOpeBRepTool/TopOpeBRepTool_PURGE.cxx
===================================================================
--- oce.orig/src/TopOpeBRepTool/TopOpeBRepTool_PURGE.cxx
+++ oce/src/TopOpeBRepTool/TopOpeBRepTool_PURGE.cxx
@@ -138,10 +138,6 @@ Standard_EXPORT Standard_Boolean FUN_too
   TopTools_DataMapIteratorOfDataMapOfShapeListOfShape itvFine(mapvFine);
   for (; itvFine.More(); itvFine.Next()){
     const TopoDS_Shape& vFine = itvFine.Key();
-#ifdef DEB
-    const TopTools_ListOfShape& edsvFine =
-#endif
-                             itvFine.Value();
     Standard_Boolean vIine = mapvIine.IsBound(vFine);
     if (vIine) {mapvok.Add(vFine); continue;}
     Standard_Boolean vRine = mapvRine.IsBound(vFine);
@@ -153,10 +149,6 @@ Standard_EXPORT Standard_Boolean FUN_too
   TopTools_DataMapIteratorOfDataMapOfShapeListOfShape itvRine(mapvRine);
   for (; itvRine.More(); itvRine.Next()){
     const TopoDS_Shape& vRine = itvRine.Key();
-#ifdef DEB
-    const TopTools_ListOfShape& edsvRine =
-#endif
-                             itvRine.Value();
     Standard_Boolean vok = mapvok.Contains(vRine);
     if (vok) continue;
     Standard_Boolean vIine = mapvIine.IsBound(vRine);
Index: oce/src/TopOpeBRepTool/TopOpeBRepTool_REGUS.cxx
===================================================================
--- oce.orig/src/TopOpeBRepTool/TopOpeBRepTool_REGUS.cxx
+++ oce/src/TopOpeBRepTool/TopOpeBRepTool_REGUS.cxx
@@ -340,10 +340,6 @@ Standard_Boolean TopOpeBRepTool_REGUS::S
     // splitting face :
     const TopoDS_Face& f = TopoDS::Face(exf.Current()); 
     TopTools_ListOfShape lfsp; Standard_Boolean issp = TopOpeBRepTool_REGUS::SplitF(f,lfsp);
-#ifdef DEB
-    Standard_Integer nf =
-#endif
-             lfsp.Extent();
     if (!issp) continue;
 
     myFsplits.Bind(f,lfsp);
@@ -599,10 +595,6 @@ Standard_Boolean TopOpeBRepTool_REGUS::N
 	// lofc : the list of faces connexed to e in <myS>
 	// lof  : the list of untouched faces connexed to e in <myS>	
 	const TopTools_ListOfShape& lofc = mymapeFsstatic.Find(e);
-#ifdef DEB
-        Standard_Integer nfc =
-#endif
-                  lofc.Extent();
 	itff.Initialize(lofc);
 	TopoDS_Face fref;
 	for (; itff.More(); itff.Next()) {
@@ -689,10 +681,6 @@ Standard_Boolean TopOpeBRepTool_REGUS::N
 #endif
   ffound.Nullify();
   TopoDS_Face fref = TopoDS::Face(myf);
-#ifdef DEB
-  Standard_Integer nf =
-#endif
-           lof.Extent();//deb
 
   // Give us egde <e>, and a reference face <fref> (= <myf>)
   // - parameter on <e> = <pare>.
@@ -709,9 +697,6 @@ Standard_Boolean TopOpeBRepTool_REGUS::N
   Standard_Real tola = Precision::Angular()*1.e3; //gp_Dir xapp,yapp; Standard_Boolean refapp = Standard_False;
   gp_Dir x,y; Standard_Boolean ok = ::FUN_vectors(fref,e,pare,y,x,tola,Standard_False);
   if (!ok) {FUN_Raise(); return Standard_False;}
-#ifdef DEB
-  gp_Dir z = x^y;    
-#endif
   
   // initializing
   // ------------
Index: oce/src/TopOpeBRepTool/TopOpeBRepTool_REGUW.cxx
===================================================================
--- oce.orig/src/TopOpeBRepTool/TopOpeBRepTool_REGUW.cxx
+++ oce/src/TopOpeBRepTool/TopOpeBRepTool_REGUW.cxx
@@ -298,10 +298,6 @@ Standard_Boolean TopOpeBRepTool_REGUW::M
   TopExp_Explorer exe(CS, TopAbs_EDGE);
   for (; exe.More(); exe.Next()){
     const TopoDS_Edge& ed = TopoDS::Edge(exe.Current());
-#ifdef DEB
-    TopAbs_Orientation oed =
-#endif
-               ed.Orientation();
 
     Standard_Boolean isdgE = BRep_Tool::Degenerated(ed); 
     Standard_Boolean iscE = TopOpeBRepTool_TOOL::IsClosingE(ed,myCORRISO.S(),Fref()); 
@@ -482,11 +478,7 @@ Standard_Boolean TopOpeBRepTool_REGUW::I
   for (; exv.More(); exv.Next()){
     const TopoDS_Shape& vcur = exv.Current();
     TopOpeBRepTool_connexity& cco = mymapvEds.ChangeFromKey(vcur);
-#ifdef DEB
-    Standard_Boolean ok =
-#endif
-             cco.RemoveItem(myed);
-//    if (!ok) return Standard_False; see for closing vertices
+    cco.RemoveItem(myed);
   }
 
   // myp2d0 :
@@ -525,9 +517,6 @@ Standard_Boolean TopOpeBRepTool_REGUW::N
   Standard_Real fac = 0.45678;
   Standard_Real tola = Precision::Angular();
   Standard_Integer iv0e1 = (iStep == 1) ? REVERSED : FORWARD;
-#ifdef DEB
-  Standard_Integer iv1e1 = (iStep == 1) ? FORWARD : REVERSED;
-#endif
 
   // initializing 
   TopTools_ListIteratorOfListOfShape ite(loe);
@@ -570,9 +559,6 @@ Standard_Boolean TopOpeBRepTool_REGUW::N
     if (trc) cout<<"ang(e"<<FUN_adds(myed)<<",e"<<FUN_adds(ei)<<")="<<angi<<endl;
 #endif
     if (eq) {
-#ifdef DEB
-      Standard_Boolean dummy=Standard_True;//DEB
-#endif
       FUN_Raise(); 
       return Standard_False;
     }
@@ -645,18 +631,11 @@ Standard_Boolean TopOpeBRepTool_REGUW::N
     myed = efound;
   }
 
-#ifdef DEB
-  TopOpeBRepTool_connexity& newco =
-#endif
-                mymapvEds.ChangeFromKey(myv);
+  mymapvEds.ChangeFromKey(myv);
   TopExp_Explorer exv(myed, TopAbs_VERTEX);
   for (; exv.More(); exv.Next()){
     TopOpeBRepTool_connexity& cco = mymapvEds.ChangeFromKey(exv.Current());
-#ifdef DEB
-    Standard_Boolean ok =
-#endif
-             cco.RemoveItem(myed);
-//    if (!ok) {FUN_Raise(); return Standard_False;} closed edges
+    cco.RemoveItem(myed);
   }
 
   TopOpeBRepTool_C2DF c2df; myCORRISO.UVRep(myed,c2df);
Index: oce/src/TopOpeBRepTool/TopOpeBRepTool_RegularizeW.cxx
===================================================================
--- oce.orig/src/TopOpeBRepTool/TopOpeBRepTool_RegularizeW.cxx
+++ oce/src/TopOpeBRepTool/TopOpeBRepTool_RegularizeW.cxx
@@ -626,10 +626,6 @@ Standard_EXPORT Standard_Boolean FUN_too
   // noldW = 1
   // ---------
   if (noldW == 1) {
-#ifdef DEB
-    const TopoDS_Shape& owi =
-#endif  
-                     itm.Key(); // DEB
     const TopTools_ListOfShape& low = itm.Value();
     Standard_Boolean ok = CLASSI.Classilist(low,mapWlow);
     if (!ok) return Standard_False;
@@ -662,10 +658,6 @@ Standard_EXPORT Standard_Boolean FUN_too
     if (!isb1) continue; 
 
     const TopTools_ListOfShape& lw1 = mapOwNw.Find(Ow1);
-#ifdef DEB
-    Standard_Integer nw1 =
-#endif
-              lw1.Extent();
     if (nOw == 1) { 
       // all wires of <mapWs> have been treated, except the last one
       // if (nw1 == 0) mapWlow binds already (Ow1,null); 
@@ -706,10 +698,6 @@ Standard_EXPORT Standard_Boolean FUN_too
 		cout<<endl;}
 #endif
       const TopTools_ListOfShape& lw2 = mapOwNw.Find(Ow2);
-#ifdef DEB
-      Standard_Integer nw2 =
-#endif
-                lw2.Extent();
      
       TopTools_ListOfShape lw1r; FUN_addOwlw(Ow1,lw1,lw1r);
       TopTools_ListOfShape lw2r; FUN_addOwlw(Ow2,lw2,lw2r);
Index: oce/src/TopOpeBRepTool/TopOpeBRepTool_ShapeClassifier.cxx
===================================================================
--- oce.orig/src/TopOpeBRepTool/TopOpeBRepTool_ShapeClassifier.cxx
+++ oce/src/TopOpeBRepTool/TopOpeBRepTool_ShapeClassifier.cxx
@@ -556,10 +556,6 @@ void TopOpeBRepTool_ShapeClassifier::Sta
       myP2Ddef = Standard_True;
       TopoDS_Face F = TopoDS::Face(myRef);
       F.Orientation(TopAbs_FORWARD);
-#ifdef DEB
-      Standard_Real tol2d =
-#endif
-                  Precision::PConfusion();
       Standard_Real  TolClass  = 1e-8;
       BRepTopAdaptor_FClass2d FClass2d(F,TolClass);
       myState = FClass2d.Perform(P2D);
Index: oce/src/TopOpeBRepTool/TopOpeBRepTool_ShapeTool.cxx
===================================================================
--- oce.orig/src/TopOpeBRepTool/TopOpeBRepTool_ShapeTool.cxx
+++ oce/src/TopOpeBRepTool/TopOpeBRepTool_ShapeTool.cxx
@@ -192,19 +192,11 @@ void TopOpeBRepTool_ShapeTool::AdjustOnP
 
   if (isUperio) {
     Standard_Real Uperiod = Surf->UPeriod();
-#ifdef DEB
-    Standard_Real ubid = UFfirst;
-#endif
-//    ElCLib::AdjustPeriodic(UFfirst,UFfirst + Uperiod,tol,ubid,u);
     if (Abs(u - UFfirst-Uperiod) > tol)
       u = ElCLib::InPeriod(u,UFfirst,UFfirst + Uperiod);
   }
   if (isVperio) {
     Standard_Real Vperiod = Surf->VPeriod();
-#ifdef DEB
-    Standard_Real vbid = VFfirst;
-#endif
-//    ElCLib::AdjustPeriodic(VFfirst,VFfirst + Vperiod,tol,vbid,v);
     if (Abs(v - VFfirst-Vperiod) > tol)
       v = ElCLib::InPeriod(v,VFfirst,VFfirst + Vperiod);
   }
@@ -301,9 +293,6 @@ Standard_Real TopOpeBRepTool_ShapeTool::
 
   Standard_Real Ufirst,Ulast,Vfirst,Vlast;
   Surf->Bounds(Ufirst,Ulast,Vfirst,Vlast);
-  Standard_Real Uperiod = 0., Vperiod = 0.;
-  if (isUperio) Uperiod = Ulast - Ufirst;
-  if (isVperio) Vperiod = Vlast - Vfirst;
 
   Standard_Real first,last,tolpc;
   const Handle(Geom2d_Curve) PC = FC2D_CurveOnSurface(E,F,first,last,tolpc);
Index: oce/src/TopOpeBRepTool/TopOpeBRepTool_TOOL.cxx
===================================================================
--- oce.orig/src/TopOpeBRepTool/TopOpeBRepTool_TOOL.cxx
+++ oce/src/TopOpeBRepTool/TopOpeBRepTool_TOOL.cxx
@@ -494,14 +494,6 @@ Standard_Boolean TopOpeBRepTool_TOOL::Tg
 Standard_Boolean TopOpeBRepTool_TOOL::TggeomE(const Standard_Real par, const BRepAdaptor_Curve& BC, 
 				 gp_Vec& Tg)
 {
-#ifdef DEB
-  GeomAbs_CurveType ct =
-#endif
-                         BC.GetType();
-#ifdef DEB
-  Standard_Boolean apoles = (ct == GeomAbs_BezierCurve)||(ct == GeomAbs_BSplineCurve);
-#endif
-  
   Standard_Real f = BC.FirstParameter(), l = BC.LastParameter();
   Standard_Real tolE = BC.Tolerance(); Standard_Real tolp = BC.Resolution(tolE);
   
@@ -510,7 +502,6 @@ Standard_Boolean TopOpeBRepTool_TOOL::Tg
 
   if ((!inbounds) && (!onf) && (!onl)) return Standard_False;
   Standard_Real thepar = par;
-//  if (apoles && (onf || onl)) thepar = onf ? (thepar+tolp) : (thepar-tolp);
 
   gp_Pnt thepnt; BC.D1(thepar, thepnt, Tg);
   Tg.Normalize(); 
@@ -948,10 +939,7 @@ Standard_Boolean TopOpeBRepTool_TOOL::UV
   //  Standard_Real f,l,tol; Handle(Geom2d_Curve) PC = FC2D_CurveOnSurface(E,F,f,l,tol);
   Handle(Geom2d_Curve) PC; Standard_Real f,l,tol;
   Standard_Boolean hasold = FC2D_HasOldCurveOnSurface(E,F,PC);
-#ifdef DEB
-  Standard_Boolean hasnew =
-#endif
-               FC2D_HasNewCurveOnSurface(E,F,PC);
+  FC2D_HasNewCurveOnSurface(E,F,PC);
   PC = FC2D_EditableCurveOnSurface(E,F,f,l,tol);
   if (!hasold) FC2D_AddNewCurveOnSurface(PC,E,F,f,l,tol);
   
@@ -1117,17 +1105,10 @@ Standard_Boolean TopOpeBRepTool_TOOL::Ge
   Bnd_Box bndf; BRepBndLib::AddClose(f,bndf);
   Standard_Real f1,f2,f3,l1,l2,l3; bndf.Get(f1,f2,f3,l1,l2,l3);
   gp_Vec d123(f1-l1, f2-l2, f3-l3);
-#ifdef DEB
-  Standard_Real dmax =
-#endif
-             d123.Dot(dir);
 
   gp_Pnt p; FUN_tool_value(uv,f,p); p.Translate(dir.Multiplied(factor));
   Standard_Real d; gp_Pnt2d uvtr;
-#ifdef DEB
-  Standard_Boolean ok =
-#endif
-           FUN_tool_projPonF(p,f, uvtr,d);
+  FUN_tool_projPonF(p,f, uvtr,d);
   Standard_Real tolf = BRep_Tool::Tolerance(f); tolf *= 1.e2; //NYIXPUTOL
   if (d > tolf) return Standard_False;
 
@@ -1340,9 +1321,6 @@ Standard_Boolean TopOpeBRepTool_TOOL::Ma
   Standard_Real x = 0.45678; Standard_Real pare = (1-x)*f+x*l;
 
   Standard_Real eps = 0.123; //NYIXPU190199
-#ifdef DEB
-  Standard_Real tola = Precision::Angular()*1.e3;
-#endif
 
   gp_Pnt2d uv1; FUN_tool_paronEF(e,pare,f1,uv1);
   gp_Dir nt1; Standard_Boolean ok1 = TopOpeBRepTool_TOOL::Nt(uv1,f1,nt1);
@@ -1359,20 +1337,6 @@ Standard_Boolean TopOpeBRepTool_TOOL::Ma
   Standard_Real dot = v12.Dot(nt1);
   ang = (dot < 0.) ? 0. : 2.*PI;
 
-//  gp_Dir nt1; ok1 = TopOpeBRepTool_TOOL::Nt(uv1,f1,nt1);
-//  if (!ok1) return Standard_False;
-//  gp_Dir xx1; ok1 = TopOpeBRepTool_TOOL::XX(uv1,f1,pare,e,xx1);
-//  if (!ok1) return Standard_False;    
-//  gp_Pnt2d uv2; Standard_Boolean ok2 = TopOpeBRepTool_TOOL::uvApp(f2,e,pare,eps,uv2);
-//  if (!ok2) return Standard_False;
-//  gp_Dir nt2; ok2 = TopOpeBRepTool_TOOL::Nt(uv2,f2,nt2);
-//  if (!ok2) return Standard_False;
-//  gp_Dir xx2; ok2 = TopOpeBRepTool_TOOL::XX(uv2,f2,pare,e,xx2);
-//  if (!ok2) return Standard_False;  
-//  Standard_Real angapp; Standard_Boolean ok = TopOpeBRepTool_TOOL::Matter(xx1,nt1, xx2,nt2,tola,angapp);
-//  if (!ok) return Standard_False;
-//  Standard_Boolean is0 = (Abs(angapp) < Abs(2.*PI-angapp));
-//  ang = is0 ? 0. : 2.*PI;
   return Standard_True;
 }
 
Index: oce/src/TopOpeBRepTool/TopOpeBRepTool_TOPOLOGY.cxx
===================================================================
--- oce.orig/src/TopOpeBRepTool/TopOpeBRepTool_TOPOLOGY.cxx
+++ oce/src/TopOpeBRepTool/TopOpeBRepTool_TOPOLOGY.cxx
@@ -129,10 +129,7 @@ Standard_EXPORT Standard_Boolean FUN_too
   if (S.IsNull()) return Standard_False;
 
   Standard_Boolean uclosed,vclosed; Standard_Real uperiod,vperiod; 
-#ifdef DEB
-  Standard_Boolean uvclosed =
-#endif
-                 FUN_tool_closedS(F,uclosed,uperiod,vclosed,vperiod);
+  FUN_tool_closedS(F,uclosed,uperiod,vclosed,vperiod);
 
 //  Standard_Real uf,ul,vf,vl; S->Bounds(uf,ul,vf,vl);
 
@@ -174,10 +171,7 @@ Standard_EXPORT Standard_Boolean FUN_too
 
   const TopoDS_Face& F = TopoDS::Face(Sh);
   Standard_Boolean uclosed,vclosed; Standard_Real uperiod,vperiod; 
-#ifdef DEB
-  Standard_Boolean uvclosed =
-#endif
-                 FUN_tool_closedS(F,uclosed,uperiod,vclosed,vperiod);
+  FUN_tool_closedS(F,uclosed,uperiod,vclosed,vperiod);
   Standard_Real tolp = 1.e-6;
   
   if (uclosed) {
@@ -302,9 +296,6 @@ Standard_EXPORT Standard_Boolean FUN_too
   TopExp_Explorer e(F,TopAbs_EDGE);
   for (;e.More();e.Next()) {
     const TopoDS_Shape& EF = e.Current(); 
-#ifdef DEB
-    Standard_Boolean b = EF.IsSame(E);
-#endif
     if (EF.IsSame(E)) { 
       oriEinF=EF.Orientation();
       break;
@@ -884,10 +875,7 @@ Standard_EXPORT Standard_Real FUN_tool_m
 	TopExp_Explorer exe(S,TopAbs_FACE);
 	for (; exe.More(); exe.Next()){
 	  const TopoDS_Shape& ee = exe.Current();
-#ifdef DEB
-	  Standard_Boolean hasvertex =
-#endif
-                          FUN_tool_maxtol(ee,TopAbs_VERTEX,maxtol);
+      FUN_tool_maxtol(ee,TopAbs_VERTEX,maxtol);
 	}
       }
     }
@@ -898,17 +886,11 @@ Standard_EXPORT Standard_Real FUN_tool_m
       TopExp_Explorer exe(S,TopAbs_FACE);
       for (; exe.More(); exe.Next()){
 	const TopoDS_Shape& ee = exe.Current();
-#ifdef DEB
-	Standard_Boolean hasvertex =
-#endif
-                        FUN_tool_maxtol(ee,TopAbs_VERTEX,maxtol);
+    FUN_tool_maxtol(ee,TopAbs_VERTEX,maxtol);
       }
     }
     if (!hasedge) {
-#ifdef DEB
-      Standard_Boolean hasvertex =
-#endif
-                      FUN_tool_maxtol(S,TopAbs_VERTEX,maxtol);
+      FUN_tool_maxtol(S,TopAbs_VERTEX,maxtol);
     }
   }
   return maxtol;
@@ -1044,18 +1026,7 @@ Standard_EXPORT Standard_Boolean FUN_too
       
       Standard_Real tole = BRep_Tool::Tolerance(e);
       TopoDS_Vertex vf,vl; TopExp::Vertices(e,vf,vl);
-#ifdef DEB
-      Standard_Real parf  =
-#endif
-                  BRep_Tool::Parameter(vf,e);
-#ifdef DEB
-      Standard_Real parl  =
-#endif
-                  BRep_Tool::Parameter(vl,e);
       TopoDS_Edge newe = faultyE;
-//      TopoDS_Edge newe; FUN_ds_CopyEdge(e,newe); newe.Orientation(TopAbs_FORWARD);
-//      vf.Orientation(TopAbs_FORWARD);  BB.Add(newe,vf); FUN_ds_Parameter(newe,vf,parf); 
-//      vl.Orientation(TopAbs_REVERSED); BB.Add(newe,vl); FUN_ds_Parameter(newe,vl,parl);
       BB.UpdateEdge(newe,C2d,fF,tole);
       newe.Orientation(e.Orientation());
       loe.Append(newe);  
@@ -1232,10 +1203,7 @@ Standard_EXPORT Standard_Boolean FUN_too
     if (clo) {
       Standard_Boolean isou,isov; gp_Pnt2d o2d; gp_Dir2d d2d; 
       Standard_Real f,l,tol; Handle(Geom2d_Curve) PC = FC2D_CurveOnSurface(E,F,f,l,tol);
-#ifdef DEB
-      Standard_Boolean isouv =
-#endif
-                  TopOpeBRepTool_TOOL::UVISO(PC,isou,isov,d2d,o2d); 
+      TopOpeBRepTool_TOOL::UVISO(PC,isou,isov,d2d,o2d); 
       if (UISO && isou) {
 	Eclo=E; 
 	return Standard_True;
Index: oce/src/TopOpeBRepTool/TopOpeBRepTool_closing.cxx
===================================================================
--- oce.orig/src/TopOpeBRepTool/TopOpeBRepTool_closing.cxx
+++ oce/src/TopOpeBRepTool/TopOpeBRepTool_closing.cxx
@@ -76,28 +76,16 @@ Standard_EXPORT Standard_Boolean FUN_too
 //  Standard_Real f,l,tolpc; Standard_Boolean trim3d = Standard_True; 
 //  Handle(Geom2d_Curve) PC = FC2D_CurveOnSurface(E,F,f,l,tolpc,trim3d);  
   Standard_Real f,l,tol; Handle(Geom2d_Curve) PC;
-#ifdef DEB
-  Standard_Boolean hasold =
-#endif
-               FC2D_HasOldCurveOnSurface(E,FFOR,PC);
-#ifdef DEB
-  Standard_Boolean hasnew =
-#endif
-               FC2D_HasNewCurveOnSurface(E,FFOR,PC);
+  FC2D_HasOldCurveOnSurface(E,FFOR,PC);
+  FC2D_HasNewCurveOnSurface(E,FFOR,PC);
   PC = FC2D_EditableCurveOnSurface(E,FFOR,f,l,tol);  
 
   Standard_Boolean isoU,isoV; gp_Pnt2d o2d; gp_Dir2d d2d; 
-#ifdef DEB
-  Standard_Boolean ISO =
-#endif
-            TopOpeBRepTool_TOOL::UVISO(PC,isoU,isoV,d2d,o2d);
+  TopOpeBRepTool_TOOL::UVISO(PC,isoU,isoV,d2d,o2d);
   Standard_Boolean xiso = (inU && isoU)||((!inU) && isoV);
   if (!xiso) return Standard_False;      
   Standard_Real par = dx*f + (1-dx)*l; gp_Vec2d dxx;
-#ifdef DEB
-  Standard_Boolean ok =
-#endif
-           FUN_tool_getdxx(FFOR,E,par,dxx);
+  FUN_tool_getdxx(FFOR,E,par,dxx);
 
   TopExp_Explorer ex(FFOR, TopAbs_EDGE);
   for (; ex.More(); ex.Next()){    
@@ -107,28 +95,16 @@ Standard_EXPORT Standard_Boolean FUN_too
 
 //    Standard_Real f1,l1; Handle(Geom2d_Curve) PC1 = BRep_Tool::CurveOnSurface(e1,F,f1,l1);  
     Standard_Real f1,l1,tol1; Handle(Geom2d_Curve) PC1;
-#ifdef DEB
-    Standard_Boolean hasold1 =
-#endif
-                  FC2D_HasOldCurveOnSurface(e1,FFOR,PC1);
-#ifdef DEB
-    Standard_Boolean hasnew1 =
-#endif
-                  FC2D_HasNewCurveOnSurface(e1,FFOR,PC1);
+    FC2D_HasOldCurveOnSurface(e1,FFOR,PC1);
+    FC2D_HasNewCurveOnSurface(e1,FFOR,PC1);
     PC1 = FC2D_EditableCurveOnSurface(e1,FFOR,f1,l1,tol1);
 
     Standard_Boolean isoU1,isoV1; gp_Pnt2d o2d1; gp_Dir2d d2d1; 
-#ifdef DEB
-    Standard_Boolean ISO1 =
-#endif
-               TopOpeBRepTool_TOOL::UVISO(PC1,isoU1,isoV1,d2d1,o2d1);
+    TopOpeBRepTool_TOOL::UVISO(PC1,isoU1,isoV1,d2d1,o2d1);
 
     // 2d(e1,FFOR) and 2d(E,FFOR) describe the same side of matter 
     Standard_Real par1 = dx*f1 + (1-dx)*l1; gp_Vec2d dxx1;
-#ifdef DEB
-    Standard_Boolean ok1 =
-#endif
-              FUN_tool_getdxx(FFOR,e1,par1,dxx1);
+    FUN_tool_getdxx(FFOR,e1,par1,dxx1);
     Standard_Real dot = dxx.Dot(dxx1);
     if (dot < 0.) continue;
 
Index: oce/src/TopOpeBRepTool/TopOpeBRepTool_connexity.cxx
===================================================================
--- oce.orig/src/TopOpeBRepTool/TopOpeBRepTool_connexity.cxx
+++ oce/src/TopOpeBRepTool/TopOpeBRepTool_connexity.cxx
@@ -198,10 +198,6 @@ Standard_Integer TopOpeBRepTool_connexit
 
   // all subshapes of INTERNAL(EXTERNAL) are oriented INTERNAL(EXTERNAL)
   TopTools_ListOfShape lINT; lINT.Assign(theItems.Value(INTERNAL));
-#ifdef DEB
-  Standard_Integer n1 =
-#endif
-           lINT.Extent();
   TopTools_ListIteratorOfListOfShape it1(lINT);
   while (it1.More()) {
     const TopoDS_Shape& item1 = it1.Value();
@@ -213,10 +209,6 @@ Standard_Integer TopOpeBRepTool_connexit
   }
 
   TopTools_ListOfShape lEXT; lEXT.Assign(theItems.Value(EXTERNAL));
-#ifdef DEB
-  Standard_Integer n2 =
-#endif
-           lEXT.Extent();
   TopTools_ListIteratorOfListOfShape it2(lEXT);
   while (it2.More()) {
     const TopoDS_Shape& item2 = it2.Value();
Index: oce/src/TopOpeBRepTool/TopOpeBRepTool_mkTondgE.cxx
===================================================================
--- oce.orig/src/TopOpeBRepTool/TopOpeBRepTool_mkTondgE.cxx
+++ oce/src/TopOpeBRepTool/TopOpeBRepTool_mkTondgE.cxx
@@ -149,10 +149,7 @@ Standard_Integer TopOpeBRepTool_mkTondgE
     if (!ok) continue;
 
     Standard_Real parei;
-#ifdef DEB
-    Standard_Boolean oki =
-#endif
-              TopOpeBRepTool_TOOL::ParISO(myuvi,ei,myFi, parei);
+    TopOpeBRepTool_TOOL::ParISO(myuvi,ei,myFi, parei);
     myEpari.Bind(ei,parei);
     lEi.Append(ei);
   }
Index: oce/src/Transfer/Transfer_TransferInput.cxx
===================================================================
--- oce.orig/src/Transfer/Transfer_TransferInput.cxx
+++ oce/src/Transfer/Transfer_TransferInput.cxx
@@ -26,9 +26,7 @@
 // Vrai resultat : doit etre transient (simple ou liste)
     DeclareAndCast(Transfer_SimpleBinderOfTransient,transb,binder);
     DeclareAndCast(Transfer_MultipleBinder,multi,binder);
-    Standard_Boolean OK = Standard_False;
     if (!transb.IsNull()) {
-      OK = Standard_True;
       if (transb->HasResult()) iter.AddItem(transb->Result());
     }
     else if (!multi.IsNull()) {
Index: oce/src/Units/Units_Lexicon.cxx
===================================================================
--- oce.orig/src/Units/Units_Lexicon.cxx
+++ oce/src/Units/Units_Lexicon.cxx
@@ -43,7 +43,7 @@ void Units_Lexicon::Creates(const Standa
   char *Oper = oper ;
   char *Coeff = coeff ;
 #endif
-  Standard_Integer fr,i;
+  Standard_Integer i;
   Standard_Real value;
   Handle(Units_Token) token;
   struct stat buf;
@@ -73,19 +73,19 @@ void Units_Lexicon::Creates(const Standa
     if(len == 1) continue; //skl - ???
     for ( i = 0 ; i < 30 ; i++ ) {
       if ( i < len )
-        fr=sscanf(&line[i],"%c",&chain[i]);
+        sscanf(&line[i],"%c",&chain[i]);
       else
         chain[i] = 0 ;
     }
     for ( i = 0 ; i < 10 ; i++ ) {
       if ( 30+i < len )
-        fr=sscanf(&line[30+i],"%c",&oper[i]);
+        sscanf(&line[30+i],"%c",&oper[i]);
       else
         oper[i] = 0 ;
     }
     for ( i = 0 ; i < 30 ; i++ ) {
       if ( 40+i < len )
-        fr=sscanf(&line[40+i],"%c",&coeff[i]);
+        sscanf(&line[40+i],"%c",&coeff[i]);
       else
         coeff[i] = 0 ;
     }
Index: oce/src/Units/Units_Sentence.cxx
===================================================================
--- oce.orig/src/Units/Units_Sentence.cxx
+++ oce/src/Units/Units_Sentence.cxx
@@ -42,8 +42,9 @@ Units_Sentence::Units_Sentence(const Han
 			       const Standard_CString astring)
 {
   Standard_Integer index;
-  Standard_Integer i,k,l,limchain;
-  char chain[255];
+  Standard_Integer i,limchain;
+//  Standard_Integer k,l;
+//  char chain[255];
   Handle(Units_Token) token;
   Handle(Units_Token) referencetoken;
   
@@ -51,10 +52,12 @@ Units_Sentence::Units_Sentence(const Han
   Handle(Units_TokensSequence) lstlexicon=alexicon->Sequence();
   Units_NoSuchType_Raise_if(lstlexicon.IsNull(),"BAD LEXICON descriptor");
   limchain=strlen(astring);
+/*
   k=0;
   for(l=0; l<255; l++) {
     chain[l]=0;
   }
+*/
   i=0;
 
   TCollection_AsciiString tmpstr = astring;
Index: oce/src/V3d/V3d_PerspectiveView.cxx
===================================================================
--- oce.orig/src/V3d/V3d_PerspectiveView.cxx
+++ oce/src/V3d/V3d_PerspectiveView.cxx
@@ -108,13 +108,13 @@ Standard_Real V3d_PerspectiveView::Angle
 void V3d_PerspectiveView::SetPerspective(const Standard_Real Angle, const Standard_Real UVRatio,
                                          const Standard_Real ZNear, const Standard_Real ZFar)
 {
-  Standard_Real Umin,Vmin,Umax,Vmax,Xrp,Yrp,Zrp,du,dv;
+  Standard_Real Umin,Vmin,Umax,Vmax,Yrp,Zrp,du,dv;
 
   Viewer_BadValue_Raise_if ( ZNear <= 0. || ZFar <= 0. || ZNear >= ZFar, "V3d_PerspectiveView::SetPerspective, bad distances");
   Viewer_BadValue_Raise_if ( Angle <= 0. || Angle >= Standard_PI, "V3d_PerspectiveView::SetAngle, bad angle");
 
   Graphic3d_Vertex PRP = MyViewMapping.ProjectionReferencePoint() ;
-  Xrp = Yrp = Zrp = 0.;
+  Yrp = Zrp = 0.;
 
   PRP.SetCoord(Zrp, Yrp, Zrp);
   MyViewMapping.SetProjectionReferencePoint(PRP);
Index: oce/src/V3d/V3d_View.cxx
===================================================================
--- oce.orig/src/V3d/V3d_View.cxx
+++ oce/src/V3d/V3d_View.cxx
@@ -1247,10 +1247,6 @@ void V3d_View::SetDepth(const Standard_R
   Viewer_BadValue_Raise_if( Depth <= 0. ,"V3d_View::SetDepth, bad depth");
 #endif
 
-#ifdef DEB
-  Standard_Real twist =
-#endif
-    Twist();
   MyViewReferencePoint = MyViewOrientation.ViewReferencePoint() ;
   MyViewReferencePlane = MyViewOrientation.ViewReferencePlane() ;
   MyProjReferencePoint = MyViewMapping.ProjectionReferencePoint() ;
@@ -1627,7 +1623,6 @@ void V3d_View::SetZSize(const Standard_R
 
   Standard_Real Front = MyViewContext.ZClippingFrontPlane() ;
   Standard_Real Back  = MyViewContext.ZClippingBackPlane() ;
-  Standard_Real focale= Focale();
 
   MyViewMapping.SetFrontPlaneDistance(Zmax) ;
   MyViewMapping.SetBackPlaneDistance(-Zmax) ;
Index: oce/src/V3d/V3d_View_3.cxx
===================================================================
--- oce.orig/src/V3d/V3d_View_3.cxx
+++ oce/src/V3d/V3d_View_3.cxx
@@ -55,10 +55,6 @@ void V3d_View::Move(const Standard_Real
   Zeye = Zrp*Zpn + Dx*XZ + Dy*YZ + Dz*ZZ ;
   Zrp = sqrt( Xeye*Xeye + Yeye*Yeye + Zeye*Zeye ) ;
   Viewer_BadValue_Raise_if( Zrp <= 0. ,"V3d_View::Move:: Eye,At are Confused");
-#ifdef DEB
-  Standard_Real focale = 
-#endif
-    Focale();
   Prp.SetCoord(Xrp,Yrp,Zrp) ;
   MyViewMapping.SetProjectionReferencePoint(Prp) ;
   Xpn = Xeye / Zrp ; Ypn = Yeye / Zrp ; Zpn = Zeye / Zrp ;
@@ -107,10 +103,6 @@ void V3d_View::Move(const Standard_Real
   Zrp = sqrt( Xeye*Xeye + Yeye*Yeye + Zeye*Zeye ) ;
   Viewer_BadValue_Raise_if( Zrp <= 0. ,"V3d_View::Move:: Eye,At are Confused");
   
-#ifdef DEB
-  Standard_Real focale = 
-#endif
-    Focale();
   Prp.SetCoord(Xrp,Yrp,Zrp) ;
   MyViewMapping.SetProjectionReferencePoint(Prp) ;
   Xpn = Xeye / Zrp ; Ypn = Yeye / Zrp ; Zpn = Zeye / Zrp ;
Index: oce/src/Viewer2dTest/Viewer2dTest_DisplayCommands.cxx
===================================================================
--- oce.orig/src/Viewer2dTest/Viewer2dTest_DisplayCommands.cxx
+++ oce/src/Viewer2dTest/Viewer2dTest_DisplayCommands.cxx
@@ -2122,8 +2122,6 @@ static int v2dtable (Draw_Interpretor& ,
   
   Standard_Real x1 = 24, y1 = 24;
   Standard_Integer numberOfColumn = 1, numberOfRows = 1;
-  Quantity_PlaneAngle anAngle = 0.0;
-  Quantity_Factor     aScale = 1.0;
    
   if( argc >= 3 )
     x1 = atof( argv[2] );
@@ -2297,11 +2295,6 @@ static int drawLengthDim1( Draw_Interpre
   
   double text_scale = 15;
   double length = 0; 
-  int distance_type = 0; 
-  double arrow_angle = 24;
-  double arrow_length = 24;
-  int arrow_type = 2;
-  int arrow_side = 3;
   
   double distance = FirstPt.Distance(LastPt);
   
@@ -2400,7 +2393,6 @@ static int drawRadiusDim( Draw_Interpret
   gp_Pnt2d anAp2(240, 240);
   gp_Circ2d aCirc(gp_Ax2d(anAp2,gp_Dir2d(0,1)),100.);
   
-  Quantity_Length aRadius = 100;
   TCollection_ExtendedString aText("Rad = 10%");
   
   Handle(Prs2d_Radius) theRadius;			
@@ -2434,7 +2426,6 @@ static int drawSymbDim( Draw_Interpretor
   gp_Pnt2d anAp2(240, 240);
   gp_Circ2d aCirc(gp_Ax2d(anAp2,gp_Dir2d(0,1)),100.);
   
-  Quantity_Length aRadius = 100;
   TCollection_ExtendedString aText("Rad = 10%");
   
   Handle(AIS2D_InteractiveObject) aIO = new AIS2D_InteractiveObject();
Index: oce/src/ViewerTest/ViewerTest.cxx
===================================================================
--- oce.orig/src/ViewerTest/ViewerTest.cxx
+++ oce/src/ViewerTest/ViewerTest.cxx
@@ -672,12 +672,6 @@ Handle(AIS_InteractiveObject) DetectedFr
       Handle(AIS_InteractiveObject) aisPickedShape =
 	Handle(AIS_InteractiveObject)::DownCast(aContext->DetectedInteractive());
       ret = aisPickedShape;
-#ifdef DEB
-      const char *name =
-#endif
-                   (  GetMapOfAIS().IsBound1(aisPickedShape) )?
-	GetMapOfAIS().Find1(aisPickedShape).ToCString() :
-	 (char *)  "????";
     }
   }
   return ret;
@@ -3237,7 +3231,6 @@ static int VSetTransMode ( Draw_Interpre
   }
 
   Standard_Boolean IsBound = GetMapOfAIS().IsBound2(shapeName);
-  Standard_Boolean IsDatum = Standard_False;
   Handle(Standard_Transient) anObj;
   if ( IsBound ) {
     anObj = GetMapOfAIS().Find2(shapeName);
@@ -3294,7 +3287,6 @@ Standard_Integer hlrtest(Draw_Interpreto
   /////////////////////
   TopoDS_Shape aShape =  DBRep::Get(a[1]);
   aContext2D->EraseAll(Standard_True);
-  Standard_Integer aPolyAlgo = 0;
   Standard_Boolean IsPoly = Standard_False;
   gp_Ax2 anAx2 = gp::XOY();
 
@@ -3354,7 +3346,6 @@ Standard_Integer phlrtest(Draw_Interpret
   /////////////////////
   TopoDS_Shape aShape =  DBRep::Get(a[1]);
   aContext2D->EraseAll(Standard_True);
-  Standard_Integer aPolyAlgo = 0;
   Standard_Boolean IsPoly = Standard_True;
   gp_Ax2 anAx2 = gp::XOY();
 
Index: oce/src/ViewerTest/ViewerTest_FilletCommands.cxx
===================================================================
--- oce.orig/src/ViewerTest/ViewerTest_FilletCommands.cxx
+++ oce/src/ViewerTest/ViewerTest_FilletCommands.cxx
@@ -63,10 +63,6 @@ static Standard_Real tapp_angle = 1.e-2;
 static GeomAbs_Shape blend_cont = GeomAbs_C1;
 
 static BRepFilletAPI_MakeFillet* Rakk = 0;
-#ifdef DEB
-static BRepFilletAPI_MakeFillet* Rake = 0;
-static char name[100];
-#endif
 
 
 static void printtolblend(Draw_Interpretor& di)
@@ -105,9 +101,6 @@ static Standard_Integer VBLEND(Draw_Inte
   if (narg<5) return 1;
   
   Standard_Integer NbToPick = (narg -4)/2;
-#ifdef DEB
-  Standard_Boolean autonaming = !strcasecmp(a[3],".");
-#endif
   Handle(TopTools_HArray1OfShape) arr = new TopTools_HArray1OfShape(1,NbToPick);
   if(ViewerTest::PickShapes(TopAbs_EDGE,arr)){
     for(Standard_Integer i=1;i<=NbToPick;i++){
Index: oce/src/ViewerTest/ViewerTest_ObjectCommands.cxx
===================================================================
--- oce.orig/src/ViewerTest/ViewerTest_ObjectCommands.cxx
+++ oce/src/ViewerTest/ViewerTest_ObjectCommands.cxx
@@ -2214,7 +2214,6 @@ Handle( Poly_Triangulation ) Calculation
 
   int i, j;
   int jStart, jEnd, numOffset;
-  int numPts, numPolys;
   double x[3], n[3], deltaPhi, deltaTheta, phi, theta, radius;
   double startTheta, endTheta, startPhi, endPhi;
   int base, numPoles=0, thetaResolution, phiResolution;
@@ -2244,9 +2243,6 @@ Handle( Poly_Triangulation ) Calculation
   localStartTheta = localStartTheta + (double)(start) * deltaTheta;
   localThetaResolution = end - start;
 
-  numPts =  mPhiResolution * localThetaResolution + 2;
-  numPolys =  mPhiResolution * 2 * localThetaResolution;
-
   // Create north pole if needed
   int number_point = 0;
   int number_pointArray = 0;
Index: oce/src/ViewerTest/ViewerTest_RelationCommands.cxx
===================================================================
--- oce.orig/src/ViewerTest/ViewerTest_RelationCommands.cxx
+++ oce/src/ViewerTest/ViewerTest_RelationCommands.cxx
@@ -1099,9 +1099,6 @@ static int VLenghtDimension(Draw_Interpr
       // On recupere les deux vertexes extremites de l'edge de face B
       TopoDS_Vertex  Vb,Vc;
       TopExp::Vertices(EdFromB,Vb,Vc);
-#ifdef DEB
-      gp_Pnt B=
-#endif
                BRep_Tool::Pnt(Vb);
       gp_Pnt C=BRep_Tool::Pnt(Vc);
       
@@ -1173,9 +1170,6 @@ static int VLenghtDimension(Draw_Interpr
       TopoDS_Vertex  Va,Vc;
       TopExp::Vertices(EdFromA,Va,Vc);
       gp_Pnt A=BRep_Tool::Pnt(Va);
-#ifdef DEB
-      gp_Pnt C=
-#endif
                BRep_Tool::Pnt(Vc);
 
       // On projette le point B sur la Face car il 
Index: oce/src/ViewerTest/ViewerTest_ViewerCommands.cxx
===================================================================
--- oce.orig/src/ViewerTest/ViewerTest_ViewerCommands.cxx
+++ oce/src/ViewerTest/ViewerTest_ViewerCommands.cxx
@@ -726,7 +726,7 @@ static LRESULT WINAPI AdvViewerWindowPro
       if( !DragFirst )
       {
         HDC hdc = GetDC( hwnd );
-        HGDIOBJ anObj = SelectObject( hdc, GetStockObject( WHITE_PEN ) );
+        SelectObject( hdc, GetStockObject( WHITE_PEN ) );
         SelectObject( hdc, GetStockObject( HOLLOW_BRUSH ) );
         SetROP2( hdc, R2_NOT );
         Rectangle( hdc, xx1, yy1, xx2, yy2 );
Index: oce/src/Visual3d/Visual3d_View.cxx
===================================================================
--- oce.orig/src/Visual3d/Visual3d_View.cxx
+++ oce/src/Visual3d/Visual3d_View.cxx
@@ -1232,7 +1232,6 @@ Standard_Real X, Y, Z;
 Standard_Boolean VUPIsModified  = Standard_False;
 Standard_Boolean VRPIsModified  = Standard_False;
 Standard_Boolean VRUIsModified  = Standard_False;
-Standard_Boolean ScaleIsModified  = Standard_False;
 Standard_Boolean CustomIsModified = Standard_False;
 
         (MyViewOrientation.ViewReferencePoint ()).Coord (X, Y, Z);
@@ -1265,10 +1264,6 @@ Standard_Boolean CustomIsModified = Stan
 Standard_Real Sx, Sy, Sz;
 
         MyViewOrientation.AxialScale(Sx, Sy, Sz);
-	ScaleIsModified =
-            MyCView.Orientation.ViewScaleX != float (X)
-         || MyCView.Orientation.ViewScaleY != float (Y)
-         || MyCView.Orientation.ViewScaleZ != float (Z);
         MyCView.Orientation.ViewScaleX                  = float (Sx);
         MyCView.Orientation.ViewScaleY                  = float (Sy);
         MyCView.Orientation.ViewScaleZ                  = float (Sz);
@@ -2196,8 +2191,6 @@ Standard_Integer Index = IsComputed (ASt
                   cout << flush;
                 }
 #endif
-Standard_Integer OldStructId =
-        MyCOMPUTEDSequence.Value (Index)->Identification ();
 
                 // Case COMPUTED valide
                 if (MyCOMPUTEDSequence.Value (Index)->HLRValidation ()) {
@@ -2229,8 +2222,6 @@ Standard_Integer OldStructId =
                         if (! IsDisplayed (AStructure)) {
                             MyCOMPUTEDSequence.SetValue
                                 (Index, MyCOMPUTEDSequence.Value (NewIndex));
-                            OldStructId = MyCOMPUTEDSequence.Value (NewIndex)->
-                                                        Identification ();
                             MyDisplayedStructure.Add (AStructure);
                             MyGraphicDriver->DisplayStructure (
                                 MyCView,
@@ -2380,8 +2371,6 @@ void Visual3d_View::Erase (const Handle(
 
 void Visual3d_View::Erase (const Handle(Graphic3d_Structure)& AStructure, const Aspect_TypeOfUpdate AnUpdateMode) {
 
-Standard_Integer StructId;
-
         if (IsDeleted ()) return;
 
         // No test on window as the structure is displayed only if 
@@ -2419,9 +2408,9 @@ Standard_Integer Index = IsComputed (ASt
                     if ((Index != 0) && (! DegenerateModeIsOn ()))
 #endif  // G003
                     {
-                        StructId =
-                        MyCOMPUTEDSequence.Value (Index)->Identification ();
 #ifdef TRACE_COMP
+                        Standard_Integer StructId =
+                        MyCOMPUTEDSequence.Value (Index)->Identification ();
         cout << "Structure " << AStructure->Identification ()
              << " calculated, in the view "
              << Identification () << ", by the structure "
@@ -3148,10 +3137,10 @@ Standard_Integer Index = IsComputed (ASt
 #endif
                 }
                 else {
-		  Standard_Integer OldStructId, NewStructId;
+#ifdef TRACE_COMP
+		  Standard_Integer OldStructId;
                         OldStructId =
                         MyCOMPUTEDSequence.Value (Index)->Identification ();
-#ifdef TRACE_COMP
 	Standard_Integer StructId = AStructure->Identification ();
         cout << "Structure " << StructId
              << " calculated, in the view "
@@ -3217,7 +3206,6 @@ Standard_Boolean ComputeShading = ((View
                         // Ot is ranged
                         // Find structure <AStructure>
                         // in the sequence of structures to be calculated.
-                        NewStructId = TheStructure->Identification ();
 
                         // The previous calculation is removed and the new one is dislayed
                         MyGraphicDriver->EraseStructure (
Index: oce/src/Visual3d/Visual3d_ViewManager.cxx
===================================================================
--- oce.orig/src/Visual3d/Visual3d_ViewManager.cxx
+++ oce/src/Visual3d/Visual3d_ViewManager.cxx
@@ -110,11 +110,6 @@ void Visual3d_ViewManager::Remove () {
 	//
 	// Destroy all defined views
 	//
-#ifdef DEB
-	Standard_Integer Length = MyDefinedView.Extent ();
-#else
-        MyDefinedView.Extent ();
-#endif
 
 #ifdef DESTROY
 	cout << "The Manager " << MyId << " have " << Length << " defined views\n";
@@ -137,11 +132,6 @@ void Visual3d_ViewManager::ChangeDisplay
 	//
 	// Change structure priority in all defined views
 	//
-#ifdef DEB
-	Standard_Integer Length = MyDefinedView.Extent ();
-#else
-        MyDefinedView.Extent ();
-#endif
 	Visual3d_SetIteratorOfSetOfView MyIterator(MyDefinedView);
  
 	while (MyIterator.More ()) {
@@ -192,7 +182,6 @@ void Visual3d_ViewManager::ReCompute (co
 #endif
   Standard_Integer ViewId = theView->Identification ();
 
-  Standard_Integer indexD = 0;
 
   // Even if physically the structure cannot
   // be displayed (pb of visualisation type)
@@ -217,11 +206,6 @@ void Visual3d_ViewManager::ReCompute (co
 
 void Visual3d_ViewManager::Clear (const Handle(Graphic3d_Structure)& AStructure, const Standard_Boolean WithDestruction) {
 
-#ifdef DEB
-	Standard_Integer Length = MyDefinedView.Extent ();
-#else
-        MyDefinedView.Extent ();
-#endif
 	Visual3d_SetIteratorOfSetOfView MyIterator(MyDefinedView);
  
 	while (MyIterator.More ()) {
@@ -235,11 +219,6 @@ void Visual3d_ViewManager::Clear (const
 
 void Visual3d_ViewManager::Connect (const Handle(Graphic3d_Structure)& AMother, const Handle(Graphic3d_Structure)& ADaughter) {
 
-#ifdef DEB
-	Standard_Integer Length = MyDefinedView.Extent ();
-#else
-        MyDefinedView.Extent ();
-#endif
 	Visual3d_SetIteratorOfSetOfView MyIterator(MyDefinedView);
  
 	while (MyIterator.More ()) {
@@ -253,11 +232,6 @@ void Visual3d_ViewManager::Connect (cons
 
 void Visual3d_ViewManager::Disconnect (const Handle(Graphic3d_Structure)& AMother, const Handle(Graphic3d_Structure)& ADaughter) {
 
-#ifdef DEB
-	Standard_Integer Length = MyDefinedView.Extent ();
-#else
-        MyDefinedView.Extent ();
-#endif
 	Visual3d_SetIteratorOfSetOfView MyIterator(MyDefinedView);
  
 	while (MyIterator.More ()) {
@@ -306,11 +280,6 @@ void Visual3d_ViewManager::Erase (const
 	//
 	// Erase structure in all defined views
 	//
-#ifdef DEB
-	Standard_Integer Length = MyDefinedView.Extent ();
-#else
-        MyDefinedView.Extent ();
-#endif
 	Visual3d_SetIteratorOfSetOfView MyIterator(MyDefinedView);
  
 	while (MyIterator.More ()) {
@@ -344,11 +313,6 @@ void Visual3d_ViewManager::Highlight (co
 	//
 	// Highlight in all activated views
 	//
-#ifdef DEB
-	Standard_Integer Length = MyDefinedView.Extent ();
-#else
-        MyDefinedView.Extent ();
-#endif
 	Visual3d_SetIteratorOfSetOfView MyIterator(MyDefinedView);
  
 	while (MyIterator.More ()) {
@@ -362,11 +326,6 @@ void Visual3d_ViewManager::Highlight (co
 
 void Visual3d_ViewManager::SetTransform (const Handle(Graphic3d_Structure)& AStructure, const TColStd_Array2OfReal& ATrsf) {
 
-#ifdef DEB
-	Standard_Integer Length = MyDefinedView.Extent ();
-#else
-        MyDefinedView.Extent ();
-#endif
 	Visual3d_SetIteratorOfSetOfView MyIterator(MyDefinedView);
  
 	while (MyIterator.More ()) {
@@ -398,11 +357,6 @@ void Visual3d_ViewManager::UnHighlight (
 	//
 	// UnHighlight in all activated views
 	//
-#ifdef DEB
-	Standard_Integer Length = MyDefinedView.Extent ();
-#else
-        MyDefinedView.Extent ();
-#endif
 	Visual3d_SetIteratorOfSetOfView MyIterator(MyDefinedView);
  
 	while (MyIterator.More ()) {
@@ -475,11 +429,6 @@ Handle(Visual3d_HSetOfView) Visual3d_Vie
 
 Handle (Visual3d_HSetOfView) SG = new Visual3d_HSetOfView ();
 
-#ifdef DEB
-	Standard_Integer Length = MyDefinedView.Extent ();
-#else
-        MyDefinedView.Extent ();
-#endif
 Visual3d_SetIteratorOfSetOfView MyIterator(MyDefinedView);
 
 	while (MyIterator.More ()) {
@@ -573,11 +522,6 @@ Standard_Real Dx, Dy, Ratio;
       Standard_Real APT;
 
       Visual3d_SetIteratorOfSetOfView MyIterator(MyDefinedView);
-#ifdef DEB
-      Standard_Integer Length = MyDefinedView.Extent ();
-#else
-      MyDefinedView.Extent ();
-#endif
 
       Standard_Integer stop = 0;
 
@@ -698,14 +642,9 @@ TColStd_Array2OfReal TMap_Matrix_Inv (0,
 
 Standard_Real Dx, Dy, Ratio;
 Visual3d_SetIteratorOfSetOfView MyIterator(MyDefinedView);
-Standard_Integer j;
 
 Standard_Integer stop = 0;
 
-Standard_Boolean BResult;
-
-		j = MyDefinedView.Extent ();
-
 		while ((! stop) && (MyIterator.More ())) {
 		    if (TheCView.ViewId ==
 			(MyIterator.Value ())->Identification ()) {
@@ -721,10 +660,10 @@ Standard_Boolean BResult;
 		}
 
 		// View Mapping Transformation and View Clip, inversion
-		BResult = Aspect::Inverse (TMap_Matrix, TMap_Matrix_Inv);
+		Aspect::Inverse (TMap_Matrix, TMap_Matrix_Inv);
 
 		// View Orientation Transformation, inversion
-		BResult = Aspect::Inverse (TOri_Matrix, TOri_Matrix_Inv);
+		Aspect::Inverse (TOri_Matrix, TOri_Matrix_Inv);
 
 		// (AU, AV) : Device Coordinate Space
 		// DCS -> NPCS Normalized Projection Coordinate Space
@@ -837,14 +776,9 @@ TColStd_Array2OfReal TMap_Matrix_Inv (0,
 
 Standard_Real Dx, Dy, Ratio;
 Visual3d_SetIteratorOfSetOfView MyIterator(MyDefinedView);
-Standard_Integer j;
 
 Standard_Integer stop = 0;
 
-Standard_Boolean BResult;
-
-		j = MyDefinedView.Extent ();
-
 		while ((! stop) && (MyIterator.More ())) {
 		    if (TheCView.ViewId ==
 			(MyIterator.Value ())->Identification ()) {
@@ -860,10 +794,10 @@ Standard_Boolean BResult;
 		}
 
 		// View Mapping Transformation and View Clip, inversion
-		BResult = Aspect::Inverse (TMap_Matrix, TMap_Matrix_Inv);
+		Aspect::Inverse (TMap_Matrix, TMap_Matrix_Inv);
 
 		// View Orientation Transformation, inversion
-		BResult = Aspect::Inverse (TOri_Matrix, TOri_Matrix_Inv);
+		Aspect::Inverse (TOri_Matrix, TOri_Matrix_Inv);
 
 		// (AU, AV) : Device Coordinate Space
 		// DCS -> NPCS Normalized Projection Coordinate Space
@@ -1177,12 +1111,6 @@ void Visual3d_ViewManager::Activate () {
 	//
 	Visual3d_SetIteratorOfSetOfView MyIterator(MyDefinedView);
  
-#ifdef DEB
-	Standard_Integer Length = MyDefinedView.Extent ();
-#else
-        MyDefinedView.Extent ();
-#endif
-
 	while (MyIterator.More ()) {
 		if (! (MyIterator.Value ())->IsActive ())
 			(MyIterator.Value ())->Activate ();
@@ -1198,11 +1126,6 @@ void Visual3d_ViewManager::Deactivate ()
 	//
 	// Deactivates all activated views
 	//
-#ifdef DEB
-	Standard_Integer Length = MyDefinedView.Extent ();
-#else
-        MyDefinedView.Extent ();
-#endif
 	Visual3d_SetIteratorOfSetOfView MyIterator(MyDefinedView);
  
 	while (MyIterator.More ()) {
Index: oce/src/Voxel/Voxel_FastConverter.cxx
===================================================================
--- oce.orig/src/Voxel/Voxel_FastConverter.cxx
+++ oce/src/Voxel/Voxel_FastConverter.cxx
@@ -166,7 +166,7 @@ Standard_Boolean Voxel_FastConverter::Co
 
   // Convert
   TopLoc_Location L;
-  Standard_Integer iprogress = 0, prev_progress = 0;
+  Standard_Integer iprogress = 0;
   Standard_Integer n1, n2, n3;
   Standard_Integer ixmin, iymin, izmin, ixmax, iymax, izmax;
   Standard_Real xmin, ymin, zmin, xmax, ymax, zmax;
Index: oce/src/VrmlData/VrmlData_Scene.cxx
===================================================================
--- oce.orig/src/VrmlData/VrmlData_Scene.cxx
+++ oce/src/VrmlData/VrmlData_Scene.cxx
@@ -443,8 +443,7 @@ VrmlData_ErrorStatus VrmlData_Scene::cre
   VrmlData_ErrorStatus    aStatus;
   Handle(VrmlData_Node)   aNode;
   TCollection_AsciiString aName;
-  Standard_Boolean        isReused (Standard_False);
-
+ 
   // Read the DEF token to assign the node name
   if (VrmlData_Node::OK(aStatus, ReadLine(theBuffer)))
     if (VRMLDATA_LCOMPARE(theBuffer.LinePtr, "DEF")) {
Index: oce/src/WNT/WNT_Allocator.cxx
===================================================================
--- oce.orig/src/WNT/WNT_Allocator.cxx
+++ oce/src/WNT/WNT_Allocator.cxx
@@ -594,7 +594,6 @@ WNT_ArcNote :: WNT_ArcNote (
 void WNT_ArcNote :: Play ( BOOL fDummy )
 {
   Xform ();
-  HDC hdc = ALLOCATOR -> myHDC;
   SetArcDirection ( ALLOCATOR -> myHDC, myDirect );
   Arc ( ALLOCATOR -> myHDC, myTX - myTXr, myTY - myTYr,
                             myTX + myTXr, myTY + myTYr,
@@ -941,7 +940,6 @@ void WNT_TextNote :: Play ( BOOL fDummy
 
 void WNT_TextNote :: Xform ( void )
 {
-  HDC hdc = ALLOCATOR -> myHDC;
   WNT_PointNote :: Xform ();
   RMatrix.eDx  =  float ( myTX ); 
   RMatrix.eDy  =  float ( myTY );
Index: oce/src/WNT/WNT_FontMapEntry.cxx
===================================================================
--- oce.orig/src/WNT/WNT_FontMapEntry.cxx
+++ oce/src/WNT/WNT_FontMapEntry.cxx
@@ -14,7 +14,6 @@ WNT_FontMapEntry :: WNT_FontMapEntry ( c
 {
   int   i;
   char* p;
-  BOOL  fUseDefault = FALSE;
 
   char* fName = new char[ strlen ( aFontName ) + 1 ];
 
Index: oce/src/WNT/WNT_WDriver.cxx
===================================================================
--- oce.orig/src/WNT/WNT_WDriver.cxx
+++ oce/src/WNT/WNT_WDriver.cxx
@@ -1266,8 +1266,7 @@ Standard_Address WNT_WDriver :: Internal
                                 ) {
 
  PW32_Allocator        aNew     = NULL;
- Aspect_TypeOfDrawMode DrawMode = Aspect_TODM_REPLACE;
-
+ 
  MyDrawMode = aDrawMode;
  aNew       = _FindAllocator ( myAllocators, aRetainBuffer );
 
Index: oce/src/XDEDRAW/XDEDRAW_Props.cxx
===================================================================
--- oce.orig/src/XDEDRAW/XDEDRAW_Props.cxx
+++ oce/src/XDEDRAW/XDEDRAW_Props.cxx
@@ -781,7 +781,6 @@ static Standard_Boolean GetMassProps(con
       TColStd_Array1OfReal anArrMass(1,comp.Length());
       anArrMass.Init(0.0);
       Standard_Real aTotalMass =0.0;
-      Standard_Boolean isFind = Standard_True;
       Standard_Integer k=1;
       for ( ; k <= comp.Length(); k++ ) {
         TDF_Label lab = comp(k);
Index: oce/src/XSDRAW/XSDRAW.cxx
===================================================================
--- oce.orig/src/XSDRAW/XSDRAW.cxx
+++ oce/src/XSDRAW/XSDRAW.cxx
@@ -118,10 +118,7 @@ void XSDRAW::LoadDraw (Draw_Interpretor&
 {
   char mess[100];
   sprintf (mess,command,varname);
-#ifdef DEB
-  IFSelect_ReturnStatus stat = 
-#endif
-    thepilot->Execute (mess);
+  thepilot->Execute (mess);
   return 1;  // stat ?
 }
 
Index: oce/src/XSDRAWSTLVRML/XSDRAWSTLVRML.cxx
===================================================================
--- oce.orig/src/XSDRAWSTLVRML/XSDRAWSTLVRML.cxx
+++ oce/src/XSDRAWSTLVRML/XSDRAWSTLVRML.cxx
@@ -196,7 +196,6 @@ static Standard_Integer storevrml
     di << "use: storevrml shape file defl type_of_conversion (0, 1, 2)"    << "\n";
   }
   else {
-    TopAbs_ShapeEnum Types[3] = {TopAbs_FACE, TopAbs_WIRE, TopAbs_EDGE};
     TopoDS_Shape shape = DBRep::Get(argv[1]);
     Standard_Real defl = atof(argv[3]);
     Standard_Integer type = 1;
Index: oce/src/XmlLDrivers/XmlLDrivers_DocumentRetrievalDriver.cxx
===================================================================
--- oce.orig/src/XmlLDrivers/XmlLDrivers_DocumentRetrievalDriver.cxx
+++ oce/src/XmlLDrivers/XmlLDrivers_DocumentRetrievalDriver.cxx
@@ -266,8 +266,6 @@ void XmlLDrivers_DocumentRetrievalDriver
       try {
         OCC_CATCH_SIGNALS
         TCollection_AsciiString anInf(anInfo,'?');
-        Standard_Integer aRefCounter = anInf.Token(" ",2).IntegerValue();
-        //theNewDocument->SetReferenceCounter(aRefCounter);
       }
       catch (Standard_Failure) { 
         //    cout << "warning: could not read the reference counter in " << aFileName << endl;
Index: oce/src/XmlMDataStd/XmlMDataStd_BooleanArrayDriver.cxx
===================================================================
--- oce.orig/src/XmlMDataStd/XmlMDataStd_BooleanArrayDriver.cxx
+++ oce/src/XmlMDataStd/XmlMDataStd_BooleanArrayDriver.cxx
@@ -39,7 +39,7 @@ Standard_Boolean XmlMDataStd_BooleanArra
 						       const Handle(TDF_Attribute)& theTarget,
 						       XmlObjMgt_RRelocationTable&  ) const
 {
-  Standard_Integer aFirstInd, aLastInd, aValue, ind;
+  Standard_Integer aFirstInd, aLastInd, aValue;
   const XmlObjMgt_Element& anElement = theSource;
 
   // Read the FirstIndex; if the attribute is absent initialize to 1
Index: oce/src/XmlMDataStd/XmlMDataStd_NamedDataDriver.cxx
===================================================================
--- oce.orig/src/XmlMDataStd/XmlMDataStd_NamedDataDriver.cxx
+++ oce/src/XmlMDataStd/XmlMDataStd_NamedDataDriver.cxx
@@ -125,7 +125,7 @@ Standard_Boolean XmlMDataStd_NamedDataDr
 						      const Handle(TDF_Attribute)& theTarget,
 						      XmlObjMgt_RRelocationTable&  ) const
 {
-  Standard_Integer aFirstInd, aLastInd, aValue, ind;
+  Standard_Integer aFirstInd, aLastInd, ind;
   const XmlObjMgt_Element& anElement = theSource;
 
   //DataMapOfStringInteger: Read the FirstIndex; if the attribute is absent initialize to 1
Index: oce/src/XmlMFunction/XmlMFunction_ScopeDriver.cxx
===================================================================
--- oce.orig/src/XmlMFunction/XmlMFunction_ScopeDriver.cxx
+++ oce/src/XmlMFunction/XmlMFunction_ScopeDriver.cxx
@@ -136,7 +136,6 @@ Standard_Boolean XmlMFunction_ScopeDrive
   LDOM_Node aCurNode = anElement.getFirstChild()/*.getNextSibling().getNextSibling()*/;
   LDOM_Element* aCurElement = (LDOM_Element*)&aCurNode;
   XmlObjMgt_DOMString aValueStr;
-  Standard_Integer i = aFirstInd;
   while (*aCurElement != anElement.getLastChild())
   {
     aValueStr = XmlObjMgt::GetStringValue( *aCurElement );
Index: oce/src/Xw/Xw_Driver.cxx
===================================================================
--- oce.orig/src/Xw/Xw_Driver.cxx
+++ oce/src/Xw/Xw_Driver.cxx
@@ -110,12 +110,17 @@ union {
 }
 
 void Xw_Driver::PrintError() {
+#ifndef PRO12934
 Standard_CString ErrorMessag ;
+#endif
 Standard_Integer ErrorNumber ;
 Standard_Integer ErrorGravity ;
  
         status = XW_SUCCESS ;
-        ErrorMessag = Xw_get_error(&ErrorNumber,&ErrorGravity) ;
+#ifndef PRO12934
+        ErrorMessag = 
+#endif
+          Xw_get_error(&ErrorNumber,&ErrorGravity) ;
 #ifdef PRO12934
         Xw_print_error() ;
 #else
@@ -538,7 +543,6 @@ float size,slant ;
 void Xw_Driver::InitializeMarkMap (const Handle(Aspect_MarkMap)& Markmap) {
 Aspect_MarkMapEntry entry ;
 Aspect_MarkerStyle style ;
-Aspect_TypeOfMarker type ;
 Standard_Integer index,iindex,oindex,minindex=IntegerLast(),maxindex= -minindex;
 int hindex,length ;
 
@@ -556,7 +560,6 @@ int hindex,length ;
             entry = Markmap->Entry(index) ;
             iindex = entry.Index() ;
             style = entry.Style() ;
-            type = style.Type() ;
             length = style.Length() ;
             const TColStd_Array1OfBoolean& spoint(style.SValues());
             const TShort_Array1OfShortReal& xpoint(style.XValues());
Index: oce/src/Xw/Xw_GraphicDevice.cxx
===================================================================
--- oce.orig/src/Xw/Xw_GraphicDevice.cxx
+++ oce/src/Xw/Xw_GraphicDevice.cxx
@@ -117,13 +117,12 @@ Xw_TypeOfVisual v3d = Xw_TOV_PREFERRED_T
 	MyFontMap = new Xw_FontMap(MyDisplay.ToCString()) ;
 	MyMarkMap = new Xw_MarkMap(MyDisplay.ToCString()) ;
 
-Standard_Address Bof;
-	Bof	= ExtendedColorMap2D();
-	Bof	= ExtendedColorMap3D();
-	Bof	= ExtendedTypeMap();
-	Bof	= ExtendedWidthMap();
-	Bof	= ExtendedFontMap();
-	Bof	= ExtendedMarkMap();
+	ExtendedColorMap2D();
+	ExtendedColorMap3D();
+	ExtendedTypeMap();
+	ExtendedWidthMap();
+	ExtendedFontMap();
+	ExtendedMarkMap();
 
 	if( !ExtendedColorMap2D() ||
 	    !ExtendedColorMap3D() ||
Index: oce/src/Xw/Xw_Window.cxx
===================================================================
--- oce.orig/src/Xw/Xw_Window.cxx
+++ oce/src/Xw/Xw_Window.cxx
@@ -104,12 +104,11 @@ union {
 }
 
 void Xw_Window::PrintError() {
-Standard_CString ErrorMessag ;
 Standard_Integer ErrorNumber ;
 Standard_Integer ErrorGravity ;
 
         status = XW_SUCCESS ;
-        ErrorMessag = Xw_get_error(&ErrorNumber,&ErrorGravity) ;
+        Xw_get_error(&ErrorNumber,&ErrorGravity) ;
         Xw_print_error() ;
 }
 
@@ -725,9 +724,8 @@ XW_RESIZETYPE state ;
 
 Standard_Boolean Xw_Window::DoMapping () const {
 int pxc,pyc,width,height;
-XW_WINDOWSTATE state;
 
-      state = Xw_get_window_position (MyExtendedWindow,&pxc,&pyc,&width,&height);
+      Xw_get_window_position (MyExtendedWindow,&pxc,&pyc,&width,&height);
 
       return IsMapped();
 }
Index: oce/src/Xw/Xw_alloc_pixel.cxx
===================================================================
--- oce.orig/src/Xw/Xw_alloc_pixel.cxx
+++ oce/src/Xw/Xw_alloc_pixel.cxx
@@ -84,7 +84,6 @@ XW_STATUS status = XW_ERROR;
         if( _CCLASS == PseudoColor ) {
 	  XColor color;
 	  int error,gravity;
-	  char *serror;
 	  color.pixel = pixel;
           color.red = (unsigned short) (r*65535.);
           color.green = (unsigned short) (g*65535.);
@@ -95,7 +94,7 @@ XW_STATUS status = XW_ERROR;
           if( !Xw_get_trace() ) Xw_set_synchronize(_CDISPLAY,True);
           XStoreColor(_CDISPLAY,_CINFO.colormap,&color);
           if( !Xw_get_trace() ) Xw_set_synchronize(_CDISPLAY,False);
-          serror = Xw_get_error(&error,&gravity);
+          Xw_get_error(&error,&gravity);
           if( error < 1000 ) status = XW_SUCCESS;
 	}
 
@@ -135,13 +134,12 @@ XW_STATUS status = XW_ERROR;
 
         if( _CCLASS == PseudoColor ) {
 	  int error,gravity;
-	  char *serror;
 
           Xw_print_error();
           if( !Xw_get_trace() ) Xw_set_synchronize(_CDISPLAY,True);
           XFreeColors(_CDISPLAY,_CINFO.colormap,&pixel,1,0);
           if( !Xw_get_trace() ) Xw_set_synchronize(_CDISPLAY,False);
-          serror = Xw_get_error(&error,&gravity);
+          Xw_get_error(&error,&gravity);
           if( error < 1000 ) status = XW_SUCCESS;
 	}
 
Index: oce/src/Xw/Xw_def_colormap.cxx
===================================================================
--- oce.orig/src/Xw/Xw_def_colormap.cxx
+++ oce/src/Xw/Xw_def_colormap.cxx
@@ -946,12 +946,11 @@ int nmap;
 //		  unsigned long pixel;
 		  color.red = color.green = color.blue = 0xFFFF;
 #ifdef TEST
-		  char *serror;
 		  Xw_print_error();
 		  if( !Xw_get_trace() ) Xw_set_synchronize(_CDISPLAY,True) ;
               	  status = XAllocColor(_CDISPLAY,cinfo->colormap,&color);
 		  if( !Xw_get_trace() ) Xw_set_synchronize(_CDISPLAY,False) ;
-              	  serror = Xw_get_error(&error,&gravity);
+              	  Xw_get_error(&error,&gravity);
               	  if( status && (error < 1000) ) {
 #else
               	  if( XAllocColor(_CDISPLAY,cinfo->colormap,&color) ) {
Index: oce/src/Xw/Xw_draw_polytext.cxx
===================================================================
--- oce.orig/src/Xw/Xw_draw_polytext.cxx
+++ oce/src/Xw/Xw_draw_polytext.cxx
@@ -235,7 +235,7 @@ GC gctext,gcpoly,gcline ;
 XW_ATTRIB code ;
 #endif /*XW_PROTOTYPE*/
 {
-int i,ix,iy,mode,length,font = QGFONT(code),type = QGTYPE(code) ;
+int i,ix,iy,length,font = QGFONT(code),type = QGTYPE(code) ;
 float angle,marge,cosa,sina ;
 char *pchar ;
 XPoint points[5] ;
@@ -252,7 +252,6 @@ XPoint points[5] ;
 	      iy = ptextlist->rpoints[i].y ;
 	      angle = ptextlist->rangles[i] ;
 	    }
-	    mode = ptextlist->modes[i] ;
 	    marge = ptextlist->marges[i] ;
 	    pchar = ptextlist->ptexts[i] ;
             if( type & XW_EXTENDEDTEXT_MINHEIGHT ) {
Index: oce/src/Xw/Xw_draw_text.cxx
===================================================================
--- oce.orig/src/Xw/Xw_draw_text.cxx
+++ oce/src/Xw/Xw_draw_text.cxx
@@ -216,7 +216,7 @@ GC gctext ;
 XW_ATTRIB code ;
 #endif /*XW_PROTOTYPE*/
 {
-int i,ix,iy,mode,length,font = QGFONT(code),type = QGTYPE(code) ;
+int i,ix,iy,length,font = QGFONT(code),type = QGTYPE(code) ;
 float angle,cosa,sina ;
 char *pchar ;
 
@@ -232,7 +232,6 @@ char *pchar ;
 	      iy = ptextlist->rpoints[i].y ;
 	      angle = ptextlist->rangles[i] ;
 	    }
-	    mode = ptextlist->modes[i] ;
 	    pchar = ptextlist->ptexts[i] ;
 	    if( type & XW_EXTENDEDTEXT_MINHEIGHT ) {
 //OCC186
Index: oce/src/Xw/Xw_draw_zoomed_image.cxx
===================================================================
--- oce.orig/src/Xw/Xw_draw_zoomed_image.cxx
+++ oce/src/Xw/Xw_draw_zoomed_image.cxx
@@ -34,7 +34,6 @@ float xc, yc, zoom;
   int              wWidth, wHeight, xC, yC, wp, hp, dxp, dyp, isize;
   int              x, y, xp, yp, xn, yn, xq, yq, nxC, nyC;
   unsigned long    pixel;
-  float            ratio;
 
 #ifdef TRACE_DRAW_ZOOMED_IMAGE
   if (Xw_get_trace ())
@@ -86,7 +85,6 @@ float xc, yc, zoom;
   wp = pximage->width;
   hp = pximage->height;
   dxp = dyp = 0;
-  ratio = (float) wp/hp;
   qximage->width  = (int )( wp * zoom );
   qximage->height = (int )( hp * zoom );
   nxC = wWidth  / 2;
Index: oce/src/Xw/Xw_get_window_pixelcoord.cxx
===================================================================
--- oce.orig/src/Xw/Xw_get_window_pixelcoord.cxx
+++ oce/src/Xw/Xw_get_window_pixelcoord.cxx
@@ -30,9 +30,7 @@ float *ux,*uy ;
 {
 XW_EXT_WINDOW *pwindow = (XW_EXT_WINDOW*)awindow;
 //XW_EXT_DISPLAY *pdisplay = pwindow->connexion ;
-float size ;
 
-	size = ( _WIDTH >= _HEIGHT) ? _WIDTH : _HEIGHT ;
 	*ux = UXPOINT(px) ;
 	*uy = UYPOINT(py) ;
 	
Index: oce/src/Xw/Xw_load_icons.cxx
===================================================================
--- oce.orig/src/Xw/Xw_load_icons.cxx
+++ oce/src/Xw/Xw_load_icons.cxx
@@ -611,7 +611,6 @@ XW_EXT_WINDOW *qwindow = (XW_EXT_WINDOW*
 XW_EXT_DISPLAY *pdisplay;
 XW_EXT_IMAGEDATA *pimage ;
 XW_EXT_ICON *piconinfo = NULL;
-XW_WINDOWSTATE state ;
 XW_STATUS status ;
 //int iimage,iwidth,iheight,wxc,wyc,wwidth,wheight ;
 int iwidth,iheight,wxc,wyc,wwidth,wheight ;
@@ -653,7 +652,7 @@ time_t t_start,t_finish;
 	if( width <= 0 ) width = _DWIDTH;
 	if( height <= 0 ) height = _DHEIGHT;
 
-	state = Xw_get_window_position(qwindow,
+	Xw_get_window_position(qwindow,
 					&wxc,&wyc,&wwidth,&wheight) ;
 
 	status = Xw_get_window_pixelcoord(qwindow,wwidth/2,wheight/2,&xi,&yi) ;
@@ -733,7 +732,6 @@ XW_EXT_WINDOW *pwindow = (XW_EXT_WINDOW*
 XW_EXT_IMAGEDATA *pimage;
 XW_EXT_ICON *piconinfo ;
 //XW_WINDOWSTATE state ;
-XW_STATUS status ;
 float xi,yi,tw,th,x0,y0,iw,ih ;
 //int i,j,n,wxc,wyc,wsize,wxi,wyi,nimage = 0,maximagewidth = 0,maximageheight = 0 ;
 int i,j,wxc,wyc,wsize,wxi,wyi,nimage = 0,maximagewidth = 0,maximageheight = 0 ;
@@ -763,24 +761,23 @@ int i,j,wxc,wyc,wsize,wxi,wyi,nimage = 0
 
 	{
 	    int wwidth,wheight,usize = 1+(int)sqrt((double)nimage-1) ;
-	    XW_WINDOWSTATE state ;
 
-	    state = Xw_get_window_position(pwindow,
+	    Xw_get_window_position(pwindow,
 					&wxc,&wyc,&wwidth,&wheight) ;
 	    wsize = min(wwidth,wheight)/max(maximagewidth,maximageheight) ;
 
 	    if( usize > wsize ) {	/* Grows IconBox */
 		wsize = usize ;
-		status = Xw_set_window_position(pwindow,
+		Xw_set_window_position(pwindow,
 			wxc,wyc,wsize*maximagewidth,wsize*maximageheight) ;
 		Xw_resize_window(pwindow) ;
 	    }
 	}
 
 				/* POP and erase IconBox */
-	status = Xw_set_window_state(pwindow,XW_POP) ;
+	Xw_set_window_state(pwindow,XW_POP) ;
 
-	status = Xw_erase_window(pwindow) ;
+	Xw_erase_window(pwindow) ;
 
 	nimage = 0 ;
 	for( piconinfo=(XW_EXT_ICON*) pwindow->other ; piconinfo ;
@@ -789,7 +786,7 @@ int i,j,wxc,wyc,wsize,wxi,wyi,nimage = 0
 		i = nimage%wsize ; j = nimage/wsize ;
 		wxi = i*maximagewidth+maximagewidth/2 ;
 		wyi = j*maximageheight+maximageheight/2 ;
-		status = Xw_get_window_pixelcoord(pwindow,wxi,wyi,&xi,&yi) ;
+		Xw_get_window_pixelcoord(pwindow,wxi,wyi,&xi,&yi) ;
 		Xw_draw_image(pwindow,piconinfo->pimage,xi,yi) ;
 		Xw_get_text_size(pwindow,0,piconinfo->pname,&tw,&th,&x0,&y0) ;
 		Xw_draw_text(pwindow,xi-tw/2.,yi-th/2.,piconinfo->pname,0.,0) ;
@@ -866,7 +863,6 @@ char *dirname;
 {
 XW_EXT_WINDOW *pwindow = (XW_EXT_WINDOW*)awindow ;
 XW_EXT_ICON *piconinfo,*qiconinfo ;
-int status ;
 FILE *ficon = NULL;
 char *pname,filename[256],iconname[80],lf ;
 //int n,f,skip,nicons = 0 ;
@@ -896,13 +892,13 @@ int skip,nicons = 0 ;
 					/* READ Icon File Directory */
 	while( !feof(ficon) ) {
 	    skip = False ;
-	    status = fscanf(ficon,"%s%c",filename,&lf) ;
+	    fscanf(ficon,"%s%c",filename,&lf) ;
 	    if( filename[0] == '#' ) {
-		while( lf != '\n' ) status = fscanf(ficon,"%c",&lf) ;
+		while( lf != '\n' ) fscanf(ficon,"%c",&lf) ;
 		skip = True ;
 	    } else if( lf != '\n' ) {
-	        status = fscanf(ficon,"%s%c",iconname,&lf) ;
-	        while( lf != '\n' ) status = fscanf(ficon,"%c",&lf) ;
+	        fscanf(ficon,"%s%c",iconname,&lf) ;
+	        while( lf != '\n' ) fscanf(ficon,"%c",&lf) ;
 	        if( iconname[0] == '#' ) {
 		  fprintf(stderr,"*Xw_load_icons*Unimplemented Default Icon Name %s\n",
 								filename);
@@ -964,7 +960,6 @@ int iwidth = pximage->width ;
 int iheight = pximage->height ;
 int wx,wy,ix,iy ;
 int error,gravity ;
-char *serror;
 
  	if( width == 0 ) width = iwidth ;
 	wx = (width - iwidth)/2 ; ix = 0 ;
@@ -983,7 +978,7 @@ char *serror;
 	pixmap = XCreatePixmap(_DISPLAY,_WINDOW,width,height,_DEPTH) ;
 	if( !Xw_get_trace() ) Xw_set_synchronize(_DISPLAY,False) ;
 
-        serror = Xw_get_error(&error,&gravity);
+        Xw_get_error(&error,&gravity);
         if( !pixmap || (error > 1000) ) {
           Xw_set_error(104,"Xw_create_icon_pixmap",0) ;
           return (0) ;
Index: oce/src/Xw/Xw_put_rgbpixel.cxx
===================================================================
--- oce.orig/src/Xw/Xw_put_rgbpixel.cxx
+++ oce/src/Xw/Xw_put_rgbpixel.cxx
@@ -43,7 +43,6 @@ union {
 int fpixel,lpixel,simage,index,isapproximate ;
 register int np ;
 unsigned long pixel ;
-XW_STATUS status ;
 XImage *pximage;
 
         if( !Xw_isdefine_image(pimage) ) {
@@ -54,11 +53,11 @@ XImage *pximage;
 
 	switch ( _CCLASS ) {
 	    case TrueColor :
-		status = Xw_get_color_pixel(_ICOLORMAP,r,g,b,&pixel,&isapproximate) ;
+		Xw_get_color_pixel(_ICOLORMAP,r,g,b,&pixel,&isapproximate) ;
 		break ;
 
 	    case PseudoColor :
-		status = Xw_get_color_index(_ICOLORMAP,r,g,b,&index) ;
+		Xw_get_color_index(_ICOLORMAP,r,g,b,&index) ;
 		pixel = _ICOLORMAP->pixels[index] ;
 		break ;
 	    
Index: oce/src/Xw/Xw_resize_window.cxx
===================================================================
--- oce.orig/src/Xw/Xw_resize_window.cxx
+++ oce/src/Xw/Xw_resize_window.cxx
@@ -24,7 +24,6 @@ XW_EXT_WINDOW *pwindow = (XW_EXT_WINDOW*
 int xc,yc,width,height ;
 XW_WINDOWSTATE state ;
 XW_DOUBLEBUFFERMODE dbmode ;
-XW_STATUS status ;
 XW_RESIZETYPE mode = XW_TOR_UNKNOWN ;
 int xleft,ytop,xright,ybottom,mask = 0 ;
 
@@ -86,7 +85,7 @@ int xleft,ytop,xright,ybottom,mask = 0 ;
 	    dbmode = Xw_get_double_buffer(pwindow) ;
 	    _DRAWABLE = 0 ;
 	    if( _PIXMAP  || _NWBUFFER > 0 ) Xw_close_pixmap(awindow) ;
-	    status = Xw_set_double_buffer(pwindow,dbmode) ;
+	    Xw_set_double_buffer(pwindow,dbmode) ;
 	} 
 
 #ifdef  TRACE_RESIZE_WINDOW
Index: oce/src/Xw/Xw_set_line_attrib.cxx
===================================================================
--- oce.orig/src/Xw/Xw_set_line_attrib.cxx
+++ oce/src/Xw/Xw_set_line_attrib.cxx
@@ -159,9 +159,9 @@ XW_DRAWMODE *mode ;
 {
 XW_EXT_WINDOW *pwindow = (XW_EXT_WINDOW*)awindow;
 XW_ATTRIB code;
-int j,k;
+int j;
 
-  j = pwindow->lineindex; k = j+1;
+  j = pwindow->lineindex;
 
   code = pwindow->qgline[j].code;
 
@@ -173,7 +173,7 @@ int j,k;
 #ifdef  TRACE_GET_LINE_ATTRIB
 if( Xw_get_trace() > 1 ) {
     printf(" %d = Xw_get_line_attrib(%lx,%d,%d,%d,%d)\n",
-                                k,(long ) pwindow,*color,*type,*width,*mode) ;
+                                j+1,(long ) pwindow,*color,*type,*width,*mode) ;
 }
 #endif
 
Index: oce/src/Xw/Xw_set_poly_attrib.cxx
===================================================================
--- oce.orig/src/Xw/Xw_set_poly_attrib.cxx
+++ oce/src/Xw/Xw_set_poly_attrib.cxx
@@ -167,9 +167,9 @@ XW_DRAWMODE *mode ;
 {
 XW_EXT_WINDOW *pwindow = (XW_EXT_WINDOW*)awindow;
 XW_ATTRIB code;
-int j,k;
+int j;
 
-  j = pwindow->polyindex; k = j+1;
+  j = pwindow->polyindex;
 
   code = pwindow->qgpoly[j].code;
 
@@ -181,7 +181,7 @@ int j,k;
 #ifdef  TRACE_GET_POLY_ATTRIB
 if( Xw_get_trace() > 1 ) {
     printf(" %d = Xw_get_poly_attrib(%lx,%d,%d,%d,%d)\n",
-				k,(long ) pwindow,*color,*type,*tile,*mode) ;
+				j+1,(long ) pwindow,*color,*type,*tile,*mode) ;
 }
 #endif
 
Index: oce/src/Xw/Xw_set_soft_cursor.cxx
===================================================================
--- oce.orig/src/Xw/Xw_set_soft_cursor.cxx
+++ oce/src/Xw/Xw_set_soft_cursor.cxx
@@ -43,7 +43,6 @@ int button ;
 #endif /*XW_PROTOTYPE*/
 {
 XW_EXT_WINDOW *pwindow = (XW_EXT_WINDOW*)awindow ;
-XW_STATUS status ;
 XW_EVENTTYPE mask1=(XW_EVENTTYPE ) 0 ,mask2=(XW_EVENTTYPE ) 0 ;
 
         if( !Xw_isdefine_window(pwindow) ) {
@@ -69,25 +68,25 @@ XW_EVENTTYPE mask1=(XW_EVENTTYPE ) 0 ,ma
 	switch (type) {
 
 	    case XW_WITHOUT_CURSOR :
-		status = Xw_set_internal_event(pwindow,mask1,NULL) ;
-		status = Xw_set_internal_event(pwindow,mask2,NULL) ;
+		Xw_set_internal_event(pwindow,mask1,NULL) ;
+		Xw_set_internal_event(pwindow,mask2,NULL) ;
 		break ;
 	    case XW_RUBBERLINE_CURSOR :
-		status = Xw_set_internal_event(pwindow,mask1,
+		Xw_set_internal_event(pwindow,mask1,
 							Xw_rubberline_cursor) ;
-		status = Xw_set_internal_event(pwindow,mask2,
+		Xw_set_internal_event(pwindow,mask2,
 							Xw_rubberline_cursor) ;
 		break ;
 	    case XW_RUBBERBAND_CURSOR :
-		status = Xw_set_internal_event(pwindow,mask1,
+		Xw_set_internal_event(pwindow,mask1,
 							Xw_rubberband_cursor) ;
-		status = Xw_set_internal_event(pwindow,mask2,
+		Xw_set_internal_event(pwindow,mask2,
 							Xw_rubberband_cursor) ;
 		break ;
 	    case XW_USERDEFINED_CURSOR :
-		status = Xw_set_internal_event(pwindow,mask1,
+		Xw_set_internal_event(pwindow,mask1,
 							Xw_userdefined_cursor) ;
-		status = Xw_set_internal_event(pwindow,mask2,
+		Xw_set_internal_event(pwindow,mask2,
 							Xw_userdefined_cursor) ;
 		break ;
 #ifndef DEB
Index: oce/src/Xw/Xw_set_text_attrib.cxx
===================================================================
--- oce.orig/src/Xw/Xw_set_text_attrib.cxx
+++ oce/src/Xw/Xw_set_text_attrib.cxx
@@ -149,9 +149,9 @@ XW_DRAWMODE *mode ;
 {
 XW_EXT_WINDOW *pwindow = (XW_EXT_WINDOW*)awindow;
 XW_ATTRIB code;
-int j,k;
+int j;
 
-  j = pwindow->textindex; k = j+1;
+  j = pwindow->textindex;
 
   code = pwindow->qgtext[j].code;
 
@@ -163,7 +163,7 @@ int j,k;
 #ifdef  TRACE_GET_TEXT_ATTRIB
 if( Xw_get_trace() > 1 ) {
     printf(" %d = Xw_get_text_attrib(%lx,%d,%d,%d,%d)\n",
-                                k,(long ) pwindow,*color,*type,*font,*mode) ;
+                                j+1,(long ) pwindow,*color,*type,*font,*mode) ;
 }
 #endif
 
Index: oce/src/Xw/Xw_zoom_image.cxx
===================================================================
--- oce.orig/src/Xw/Xw_zoom_image.cxx
+++ oce/src/Xw/Xw_zoom_image.cxx
@@ -31,7 +31,6 @@ XW_EXT_IMAGEDATA *pimage = (XW_EXT_IMAGE
 XImage *pximage,*qximage ;
 int i,j,isize,wp,hp,xp,yp,xq,yq,xn,yn,dxp,dyp,npixel,num_pixel[MAXCOLOR] ;
 unsigned long pixel,bpixel,tab_pixel[MAXCOLOR];
-float ratio;
 
 
     if( !Xw_isdefine_image(pimage) ) {
@@ -58,7 +57,6 @@ float ratio;
     Xw_bytecopy((char*)pximage,(char*)qximage,sizeof(XImage)) ;
 
     wp = pximage->width; hp = pximage->height;
-    ratio = (float)wp/hp;
     qximage->width = (int )( wp * zoom );
     qximage->height = (int )( hp * zoom );
     dxp = dyp = 0;
Index: oce/src/math/math_BFGS.cxx
===================================================================
--- oce.orig/src/math/math_BFGS.cxx
+++ oce/src/math/math_BFGS.cxx
@@ -123,10 +123,6 @@ static Standard_Boolean MinimizeDirectio
      F.Initialize(P, Dir);
 
      Standard_Real dy1, Hnr1, lambda, alfa=0;
-#ifdef DEB
-     Standard_Integer n = 
-#endif
-       Dir.Length();
      dy1 = Gr*Dir;
      if (dy1 != 0) {
        Hnr1 = Dir.Norm2();
Index: oce/src/math/math_BracketedRoot.cxx
===================================================================
--- oce.orig/src/math/math_BracketedRoot.cxx
+++ oce/src/math/math_BracketedRoot.cxx
@@ -15,12 +15,11 @@
 
     Standard_Real Fa,Fc,a,c=0,d=0,e=0;
     Standard_Real min1,min2,p,q,r,s,tol1,xm;
-    Standard_Boolean Ok;
   
     a = Bound1;
     TheRoot = Bound2;
-    Ok = F.Value(a,Fa);
-    Ok = F.Value(TheRoot,TheError);
+    F.Value(a,Fa);
+    F.Value(TheRoot,TheError);
     if (Fa*TheError > 0.) { Done = Standard_False;}
     else {
       Fc = TheError ;
@@ -82,7 +81,7 @@
           else {
              TheRoot += (xm > 0. ? Abs(tol1) : -Abs(tol1));
           }
-          Ok = F.Value(TheRoot,TheError);
+          F.Value(TheRoot,TheError);
       }  
      Done = Standard_False;
     }  
Index: oce/src/math/math_BrentMinimum.cxx
===================================================================
--- oce.orig/src/math/math_BrentMinimum.cxx
+++ oce/src/math/math_BrentMinimum.cxx
@@ -131,10 +131,6 @@ math_BrentMinimum::math_BrentMinimum(con
 //    Standard_Boolean math_BrentMinimum::IsSolutionReached(math_Function& F) {
     Standard_Boolean math_BrentMinimum::IsSolutionReached(math_Function& ) {
 
-       Standard_Real xm = 0.5 * (a + b);
-       // modified by NIZHNY-MKK  Mon Oct  3 17:45:57 2005.BEGIN
-//        Standard_Real tol = XTol * fabs(x) + EPSZ;
-//        return fabs(x - xm) <= 2.0 * tol - 0.5 * (b - a);
        Standard_Real TwoTol = 2.0 *(XTol * fabs(x) + EPSZ);
        return ((x <= (TwoTol + a)) && (x >= (b - TwoTol)));
        // modified by NIZHNY-MKK  Mon Oct  3 17:46:00 2005.END
Index: oce/src/math/math_FunctionAllRoots.cxx
===================================================================
--- oce.orig/src/math/math_FunctionAllRoots.cxx
+++ oce/src/math/math_FunctionAllRoots.cxx
@@ -28,11 +28,11 @@
     Standard_Real DebNul,FinNul;
     Standard_Integer Indd,Indf;
     Standard_Real cst,val,valsav=0,valbid;
-    Standard_Boolean bid,fini;
+    Standard_Boolean fini;
     Standard_Integer Nbp,i;
 
     Nbp=S.NbPoints();
-    bid=F.Value(S.GetParameter(1),val);
+    F.Value(S.GetParameter(1),val);
     PNul=Abs(val)<=EpsNul;
     if (!PNul) {valsav=val;}
     InterNul=Standard_False;
@@ -44,7 +44,7 @@
 
     while (!fini) {
 
-      bid=F.Value(S.GetParameter(i),val);
+      F.Value(S.GetParameter(i),val);
       Nul=Abs(val)<=EpsNul;
       if (!Nul) {
 	valsav=val;
@@ -88,7 +88,7 @@
 	InterNul=Standard_True;
 	if (i==2) {
 	  DebNul=S.GetParameter(1);
-	  bid = F.Value(DebNul,valbid);
+	  F.Value(DebNul,valbid);
 	  Indd = F.GetStateNumber();
 	  Nuld=Standard_True;
 	}
@@ -130,7 +130,7 @@
       pdeb.Append(DebNul);
       ideb.Append(Indd);
       FinNul = S.GetParameter(Nbp);
-      bid = F.Value(FinNul,valbid);
+      F.Value(FinNul,valbid);
       Indf = F.GetStateNumber();
       pfin.Append(FinNul);
       ifin.Append(Indf);
Index: oce/src/math/math_FunctionRoot.cxx
===================================================================
--- oce.orig/src/math/math_FunctionRoot.cxx
+++ oce/src/math/math_FunctionRoot.cxx
@@ -60,7 +60,6 @@ class math_MyFunctionSetWithDerivatives
                                         const Standard_Real Guess, 
                                         const Standard_Real Tolerance, 
                                         const Standard_Integer NbIterations ){
-     Standard_Boolean Ok;
      math_Vector V(1,1), Tol(1,1);
      math_MyFunctionSetWithDerivatives Ff(F);
      V(1)=Guess;
@@ -68,14 +67,10 @@ class math_MyFunctionSetWithDerivatives
      math_FunctionSetRoot Sol(Ff,V,Tol,NbIterations);
      Done = Sol.IsDone(); 
      if (Done) {
-#ifdef DEB
-       Standard_Integer Ier=F.GetStateNumber();
-#else
        F.GetStateNumber();
-#endif
        TheRoot = Sol.Root()(1);
        TheDerivative = Sol.Derivative()(1,1);
-       Ok = F.Value(TheRoot,TheError);
+       F.Value(TheRoot,TheError);
        NbIter = Sol.NbIterations();
      }       
    }
@@ -85,7 +80,6 @@ class math_MyFunctionSetWithDerivatives
                                         const Standard_Real A,
                                         const Standard_Real B,
                                         const Standard_Integer NbIterations ){
-     Standard_Boolean Ok;
      math_Vector V(1,1),Aa(1,1),Bb(1,1), Tol(1,1);
      math_MyFunctionSetWithDerivatives Ff(F);
      V(1)=Guess;
@@ -95,14 +89,10 @@ class math_MyFunctionSetWithDerivatives
      math_FunctionSetRoot Sol(Ff,V,Tol,Aa,Bb,NbIterations);
      Done = Sol.IsDone();
      if (Done) {
-#ifdef DEB
-       Standard_Integer Ier =F.GetStateNumber();
-#else
        F.GetStateNumber();
-#endif
        TheRoot = Sol.Root()(1);
        TheDerivative = Sol.Derivative()(1,1);
-       Ok = F.Value(TheRoot,TheError);
+       F.Value(TheRoot,TheError);
        NbIter = Sol.NbIterations();
      }
    }
Index: oce/src/math/math_FunctionRoots.cxx
===================================================================
--- oce.orig/src/math/math_FunctionRoots.cxx
+++ oce/src/math/math_FunctionRoots.cxx
@@ -983,16 +983,6 @@ math_FunctionRoots::math_FunctionRoots(m
     if(n1>n2) n=n2;
     for(Standard_Integer i=1;i<=n;i++) { 
       Standard_Real t = Sol(i)-StaticSol(i);
-#ifdef NEWSEQ
-# ifdef DEB
-      Standard_Real t1=
-# endif
-                       Sol(i);
-# ifdef DEB
-      Standard_Real t2=
-# endif
-                       StaticSol(i);
-#endif
       if(Abs(t)>NEpsX) { 
 	printf("\n mathFunctionRoots : i:%d/%d  delta: %g",i,n,t);
       }
Index: oce/src/math/math_IntegerVector.cxx
===================================================================
--- oce.orig/src/math/math_IntegerVector.cxx
+++ oce/src/math/math_IntegerVector.cxx
@@ -330,9 +330,6 @@ math_IntegerVector& math_IntegerVector::
 
   Standard_DimensionError_Raise_if(Length() != Other.Length(), " ");
 
-#ifdef DEB
-  Standard_Integer I = Other.FirstIndex;
-#endif
   (Other.Array).Copy(Array);
   return *this;
 }
Index: oce/src/math/math_KronrodSingleIntegration.cxx
===================================================================
--- oce.orig/src/math/math_KronrodSingleIntegration.cxx
+++ oce/src/math/math_KronrodSingleIntegration.cxx
@@ -74,7 +74,6 @@ void math_KronrodSingleIntegration::Perf
 			       const Standard_Real     theUpper,
 			       const Standard_Integer  theNbPnts)
 {
-  const Standard_Real aMinVol = Epsilon(1.);
   const Standard_Real aPtol = 1.e-9;
   myNbIterReached = 0;
 
@@ -110,8 +109,6 @@ void math_KronrodSingleIntegration::Perf
 
   if(!myIsDone) return;
 
-  Standard_Real anAbsVal = Abs(myValue);
-
   myAbsolutError = myErrorReached;
 
   //if (anAbsVal > aMinVol)
@@ -267,7 +264,6 @@ Standard_Boolean math_KronrodSingleInteg
 
   Standard_Boolean IsDone;
   
-  Standard_Integer aNGauss = theGaussP.Length();
   Standard_Integer aNKronrod = theKronrodP.Length();
 
   Standard_Real    aGaussVal;
Index: oce/src/math/math_Powell.cxx
===================================================================
--- oce.orig/src/math/math_Powell.cxx
+++ oce/src/math/math_Powell.cxx
@@ -96,7 +96,6 @@ void math_Powell::Perform(math_MultipleV
 
 
   Done = Standard_False;
-  Standard_Boolean Ok;
   Standard_Integer i, ibig, j;
   Standard_Real t, fptt, del;
   Standard_Integer n = TheLocation.Length();
@@ -114,12 +113,12 @@ void math_Powell::Perform(math_MultipleV
 
 
   for(Iter = 1; Iter<= Itermax; Iter++) {
-    Ok = F.Value(TheLocation, PreviousMinimum);
+    F.Value(TheLocation, PreviousMinimum);
     ibig = 0;
     del = 0.0;
     for (i = 1; i <= n; i++){
       for(j =1; j<= n; j++) xit(j) = TheDirections(j,i);
-      Ok = F.Value(TheLocation, fptt); 
+      F.Value(TheLocation, fptt); 
       Standard_Boolean IsGood = MinimizeDirection(TheLocation, xit, 
 					 TheMinimum, F_Dir);
 
@@ -155,7 +154,7 @@ void math_Powell::Perform(math_MultipleV
     
     // Valeur de la fonction au point extrapole:
 
-    Ok = F.Value(ptt, fptt);
+    F.Value(ptt, fptt);
 
     if (fptt < PreviousMinimum) {
       t = 2.0 *(PreviousMinimum -2.0*TheMinimum +fptt)*
Index: oce/src/math/math_Recipes.cxx
===================================================================
--- oce.orig/src/math/math_Recipes.cxx
+++ oce/src/math/math_Recipes.cxx
@@ -639,11 +639,9 @@ Standard_Integer DACTCL_Solve(const math
      Standard_Integer jr, jd, jh, is, k, id;
      Standard_Integer jh1, idot, idot1, idot2;
      Standard_Real aa, d, dot;
-     Standard_Boolean diag;
 
      jr = 0;
      for (j = 1; j <= Neq; j++) {
-       diag = Standard_False;
        jd = indx(j);
        jh = jd-jr;
        is = j-jh+2;
Index: oce/src/math/math_TrigonometricFunctionRoots.cxx
===================================================================
--- oce.orig/src/math/math_TrigonometricFunctionRoots.cxx
+++ oce/src/math/math_TrigonometricFunctionRoots.cxx
@@ -64,9 +64,6 @@ class MyTrigoFunction: public math_Funct
    //-- F= AA*CN*CN+2*BB*CN*SN+CC*CN+DD*SN+EE;
    //-- D = -2*AA*CN*SN+2*BB*(CN*CN-SN*SN)-CC*SN+DD*CN;
    Standard_Real AACN = AA*CN;
-#ifdef DEB
-   Standard_Real BBCN = BB*CN;
-#endif
    Standard_Real BBSN = BB*SN;
 
    F = AACN*CN + BBSN*(CN+CN) + CC*CN + DD*SN + EE;
@@ -123,7 +120,7 @@ void math_TrigonometricFunctionRoots::Pe
   Standard_Real Teta, X;
   Standard_Real Eps, Tol1 = 1.e-15;
   TColStd_Array1OfReal ko(1,5), Zer(1,4);
-  Standard_Boolean Flag3, Flag4;
+  Standard_Boolean Flag4;
   InfiniteStatus = Standard_False;
   Done = Standard_True;
 
@@ -336,7 +333,6 @@ void math_TrigonometricFunctionRoots::Pe
     X = Teta -MyBorneInf;
     if ((X >= (-Epsilon(Delta))) && (X <= Delta+ Epsilon(Delta))) {
       X = Teta;
-      Flag3 = Standard_False;
 
       // Appel de Newton:
       //OCC541(apo):  Standard_Real TetaNewton=0;  
Index: oce/src/math/math_Vector.cxx
===================================================================
--- oce.orig/src/math/math_Vector.cxx
+++ oce/src/math/math_Vector.cxx
@@ -429,9 +429,6 @@ math_Vector math_Vector::Multiplied(cons
   Standard_DimensionError_Raise_if(Length() != Right.RowNumber(), "");
 
   math_Vector Result(Right.LowerColIndex, Right.UpperColIndex);
-#ifdef DEB
-  Standard_Integer Index = LowerIndex;
-#endif
   for(Standard_Integer J2 = Right.LowerColIndex; 
       J2 <= Right.UpperColIndex; J2++) {
     Array(J2) = 0.0;
