These fixes have not been submitted at
  http://tracker.dev.opencascade.org/view.php?id=24510
because functions may have side effects, so we must
carefully check whether these changes are safe.

Index: oce/src/AIS/AIS_Dimension.cxx
===================================================================
--- oce.orig/src/AIS/AIS_Dimension.cxx
+++ oce/src/AIS/AIS_Dimension.cxx
@@ -1142,7 +1142,6 @@ Standard_Boolean AIS_Dimension::InitCirc
         theCircle = aMkCirc.Value()->Circ();
       }
 
-      gp_Vec aVec = gp_Vec (theCircle.Location(), aCurPos).Normalized();
       aFirstPoint = ElCLib::Value (aFirstU, theCircle);
       aLastPoint = ElCLib::Value (aLastU,  theCircle);
     }
Index: oce/src/AIS/AIS_EqualDistanceRelation.cxx
===================================================================
--- oce.orig/src/AIS/AIS_EqualDistanceRelation.cxx
+++ oce/src/AIS/AIS_EqualDistanceRelation.cxx
@@ -612,8 +612,6 @@ void AIS_EqualDistanceRelation::ComputeT
   AIS::ComputeGeometry( FirstVertex, FirstAttach, Plane, isOnPlane1);
   AIS::ComputeGeometry( SecondVertex, SecondAttach, Plane, isOnPlane2);
 
-  //Computation of Val
-  Standard_Real Val = FirstAttach.Distance( SecondAttach );
   Standard_Real confusion(Precision::Confusion());
   Standard_Boolean samePoint(FirstAttach.IsEqual(SecondAttach,confusion));
 
@@ -627,9 +625,6 @@ void AIS_EqualDistanceRelation::ComputeT
   }
   
   // size
-  Standard_Real arrsize = ArrowSize;
-  if (Abs(Val) <= confusion) arrsize =0.;
-
   if (AutomaticPos) {
    if (!samePoint) {
      gp_Pnt curpos((FirstAttach.XYZ()+SecondAttach.XYZ())*0.5);
Index: oce/src/AIS/AIS_InteractiveContext.cxx
===================================================================
--- oce.orig/src/AIS/AIS_InteractiveContext.cxx
+++ oce/src/AIS/AIS_InteractiveContext.cxx
@@ -238,15 +238,14 @@ void AIS_InteractiveContext::DisplayedOb
 #endif
 
     //parse all local contexts...
+#ifdef DEBUG
     Standard_Integer NbDisp;
     for(AIS_DataMapIteratorOfDataMapOfILC it1(myLocalContexts);it1.More();it1.Next()){
       const Handle(AIS_LocalContext)& LC = it1.Value();
       NbDisp =  LC->DisplayedObjects(theMap);
-#ifdef DEBUG
       cout<<"\tIn Local Context "<<it1.Key()<<" : "<<NbDisp<<endl;
-#endif
-      
     }
+#endif
     Handle(AIS_InteractiveObject) curIO;
     Handle(Standard_Transient) Tr;
       for(TColStd_MapIteratorOfMapOfTransient it2(theMap);it2.More();it2.Next()){
@@ -816,11 +815,11 @@ void AIS_InteractiveContext::Remove(cons
   }
   else
     {
-      Standard_Boolean  WasInCtx = myLocalContexts(myCurLocalIndex)->Remove(anIObj);
+      myLocalContexts(myCurLocalIndex)->Remove(anIObj);
       AIS_DataMapIteratorOfDataMapOfILC It(myLocalContexts);
       for (;It.More() ;It.Next()){
         if(It.Value()->AcceptErase())
-          WasInCtx = It.Value()->Remove(anIObj);
+          It.Value()->Remove(anIObj);
         
       }
       //      if(!WasInCtx)
Index: oce/src/AIS/AIS_LocalContext.cxx
===================================================================
--- oce.orig/src/AIS/AIS_LocalContext.cxx
+++ oce/src/AIS/AIS_LocalContext.cxx
@@ -445,7 +445,6 @@ Standard_Boolean AIS_LocalContext::Remov
   const Handle(AIS_LocalStatus)& Att = myActiveObjects(aSelectable);
   
   TColStd_ListIteratorOfListOfInteger It;
-  Standard_Boolean jobdone(Standard_False);
   // it is checked which were the temporary attributes 
   // and they are set to 0
 
@@ -468,7 +467,6 @@ Standard_Boolean AIS_LocalContext::Remov
       if(myMainPM->IsDisplayed(aSelectable,Att->HilightMode()))
 	myMainPM->Erase(aSelectable,Att->HilightMode());
       //	myMainPM->Clear(aSelectable,Att->HilightMode());
-      jobdone = Standard_True;
     }
   // if below intensity
   else
Index: oce/src/Adaptor3d/Adaptor3d_CurveOnSurface.cxx
===================================================================
--- oce.orig/src/Adaptor3d/Adaptor3d_CurveOnSurface.cxx
+++ oce/src/Adaptor3d/Adaptor3d_CurveOnSurface.cxx
@@ -549,7 +549,6 @@ static void Locate2Coord(const Standard_
 {
   Standard_Real Tol=Precision::PConfusion()/10;
   Standard_Real Comp1=0,DComp1=0;
-  Standard_Boolean DIsNull = Standard_False;
   if(Index==1)   {   Comp1=UV.X();
 		     DComp1=DUV.X();} 
   else
@@ -576,10 +575,9 @@ static void Locate2Coord(const Standard_
 		 if(Index==2) { LeftBot.SetY(I1);
 				RightTop.SetY(I2);}
 	       }
-	   DIsNull=Standard_False;
 	 }
     else 
-      if(Abs(DComp1)<=Tol) {  DIsNull = Standard_True;
+      if(Abs(DComp1)<=Tol) {
 			      if(Index==1) { LeftBot.SetX(I1) ;
 					     RightTop.SetX(I2);}
 			      if(Index==2) { LeftBot.SetY(I1) ;
Index: oce/src/AdvApp2Var/AdvApp2Var_ApproxAFunc2Var.cxx
===================================================================
--- oce.orig/src/AdvApp2Var/AdvApp2Var_ApproxAFunc2Var.cxx
+++ oce/src/AdvApp2Var/AdvApp2Var_ApproxAFunc2Var.cxx
@@ -435,7 +435,7 @@ void AdvApp2Var_ApproxAFunc2Var::Compute
 					 const AdvApp2Var_EvaluatorFunc2Var& Func,
 					 const AdvApp2Var_Criterion& Crit)
 {
-  Standard_Real Udec, Vdec, CritValue, m0=0., m1=0.;
+  Standard_Real Udec, Vdec, CritValue, m1=0.;
   Standard_Boolean Umore, Vmore, CritAbs = (Crit.Type() == AdvApp2Var_Absolute);
   Standard_Integer NbPatch, NbU, NbV, NbInt, NumDec;
   Standard_Integer FirstNA, decision=0;
@@ -445,7 +445,6 @@ void AdvApp2Var_ApproxAFunc2Var::Compute
 // complete the set of constraints 
     ComputeConstraints(UChoice, VChoice, Func, Crit);
     if (decision>0) {
-      m0 = m1;
       m1 = 0.;
     }
 
Index: oce/src/AdvApp2Var/AdvApp2Var_ApproxF2var.cxx
===================================================================
--- oce.orig/src/AdvApp2Var/AdvApp2Var_ApproxF2var.cxx
+++ oce/src/AdvApp2Var/AdvApp2Var_ApproxF2var.cxx
@@ -1326,7 +1326,7 @@ int mma1jak_(integer *ndimen,
 {
   /* System generated locals */
   integer somtab_dim1, somtab_offset, diftab_dim1, diftab_offset, 
-  crvjac_dim1, crvjac_offset, cgauss_dim1;
+  crvjac_dim1, crvjac_offset;
 
   /* Local variables */
   integer ibb;
@@ -1389,7 +1389,6 @@ int mma1jak_(integer *ndimen,
     crvjac_dim1 = *ndgjac + 1;
     crvjac_offset = crvjac_dim1;
     crvjac -= crvjac_offset;
-    cgauss_dim1 = *nbroot / 2 + 1;
 
     /* Function Body */
     ibb = AdvApp2Var_SysBase::mnfndeb_();
Index: oce/src/AdvApp2Var/AdvApp2Var_MathBase.cxx
===================================================================
--- oce.orig/src/AdvApp2Var/AdvApp2Var_MathBase.cxx
+++ oce/src/AdvApp2Var/AdvApp2Var_MathBase.cxx
@@ -7098,10 +7098,6 @@ int mmpojac_(doublereal *tparam,
 {
   integer c__2 = 2;
   
-    /* Initialized data */
-
-    integer nbcof = -1;
-
     /* System generated locals */
     integer valjac_dim1, i__1, i__2;
 
@@ -7213,8 +7209,6 @@ int mmpojac_(doublereal *tparam,
 		c__2, &i__2));
     }
 
-    nbcof = *ncoeff;
-
 /*      END IF */
 
 /*  --- Trivial Positions ----- */
@@ -9885,7 +9879,6 @@ L9999:
   logical colin;
   doublereal valaux;
   integer aux;
-  logical nul;
  
 /* ***********************************************************************
  */
@@ -9953,7 +9946,6 @@ L9999:
     if (*ndimen <= 1 || *ndimen > 3) {
 	goto L9101;
     }
-    nul = FALSE_;
     d__ = 1;
     aux = 0;
     while(d__ <= *ndimen) {
Index: oce/src/AdvApp2Var/AdvApp2Var_Patch.cxx
===================================================================
--- oce.orig/src/AdvApp2Var/AdvApp2Var_Patch.cxx
+++ oce/src/AdvApp2Var/AdvApp2Var_Patch.cxx
@@ -109,11 +109,9 @@ void AdvApp2Var_Patch::Discretise(const
 {
 
 // data stored in the Context
-  Standard_Integer NDIMEN, NBSESP, NDIMSE, ISOFAV;
+  Standard_Integer NDIMEN, ISOFAV;
   NDIMEN = Conditions.TotalDimension();
-  NBSESP = Conditions.TotalNumberSSP();
 // Attention : works only for 3D
-  NDIMSE = 3;
   ISOFAV = Conditions.FavorIso();
 
 // data related to the patch to be discretized
@@ -404,12 +402,10 @@ void AdvApp2Var_Patch::AddConstraints(co
 				      const AdvApp2Var_Framework& Constraints)
 {
 // data stored in the  Context
-  Standard_Integer NDIMEN, NBSESP, NDIMSE;
+  Standard_Integer NDIMEN;
   Standard_Integer IERCOD, NCFLMU, NCFLMV, NDegU, NDegV;
   NDIMEN = Conditions.TotalDimension();
-  NBSESP = Conditions.TotalNumberSSP();
 // Attention : works only for 3D
-  NDIMSE = 3;
   NCFLMU = Conditions.ULimit();
   NCFLMV = Conditions.VLimit();
   NDegU = NCFLMU - 1;
Index: oce/src/AdvApp2Var/AdvApp2Var_SysBase.cxx
===================================================================
--- oce.orig/src/AdvApp2Var/AdvApp2Var_SysBase.cxx
+++ oce/src/AdvApp2Var/AdvApp2Var_SysBase.cxx
@@ -155,9 +155,6 @@ int AdvApp2Var_SysBase::macinit_(integer
 
 {
  
-  /* Fortran I/O blocks */
-  cilist io______1 = { 0, 0, 0, (char*) "(' --- Debug-mode : ',I10,' ---')", 0 };
-  
   /* ************************************************************************/
   /*     FUNCTION : */
   /*     ---------- */
@@ -217,14 +214,6 @@ int AdvApp2Var_SysBase::macinit_(integer
     mblank__.imp = *ival;
   } else if (*imode == 2) {
     mblank__.ibb = *ival;
-    io______1.ciunit = mblank__.imp;
-    /*
-    s__wsfe(&io______1);
-    */
-    /*
-    do__fio(&c____1, (char *)&mblank__.ibb, (ftnlen)sizeof(integer));
-    */
-    AdvApp2Var_SysBase::e__wsfe();
   } else if (*imode == 3) {
     mblank__.lec = *ival;
   }
@@ -670,7 +659,7 @@ int macrerr_(intptr_t *,//iad,
 {
   //integer c__1 = 1;
   /* Builtin functions */
-  //integer /*s__wsfe(),*/ /*do__fio(),*/ e__wsfe();
+  //integer /*do__fio(),*/;
   
   /* Fortran I/O blocks */
   //cilist io___1 = { 0, 6, 0, "(X,A,I9,A,I3)", 0 };
@@ -707,15 +696,11 @@ int macrerr_(intptr_t *,//iad,
 /* ***********************************************************************
  */
   /*
-  s__wsfe(&io___1);
-  */
-  /*
   do__fio(&c__1, "*** ERREUR : Ecrasement de la memoire d'adresse ", 48L);
   do__fio(&c__1, (char *)&(*iad), (ftnlen)sizeof(long int));
   do__fio(&c__1, " sur l'allocation ", 18L);
   do__fio(&c__1, (char *)&(*nalloc), (ftnlen)sizeof(integer));
   */
-  AdvApp2Var_SysBase::e__wsfe();
   
   return 0 ;
 } /* macrerr_ */
@@ -744,7 +729,7 @@ int macrgfl_(intptr_t *iadfld,
   integer ibid, ienr;
   doublereal* t = 0;
   integer novfl = 0;
-  intptr_t ioff,iadrfl, iadt;
+  intptr_t ioff,iadt;
   
   
   /* ***********************************************************************
@@ -855,7 +840,6 @@ int macrgfl_(intptr_t *iadfld,
   t[ioff] = -134744073.;
   
   /*  FAKE CALL TO STOP THE DEBUGGER : */
-  iadrfl = *iadfld;
   macrbrk_();
   
   /*  UPDATE THE START FLAG */
@@ -863,7 +847,6 @@ int macrgfl_(intptr_t *iadfld,
   t[ioff] = -134744073.;
     
   /*  FAKE CALL TO STOP THE DEBUGGER : */
-  iadrfl = *iadflf;
   macrbrk_();
   
   return 0 ;
@@ -884,15 +867,9 @@ int macrmsg_(const char *,//crout,
 {
   
   /* Local variables */
-  integer inum, iunite;
-  char cfm[80], cln[3];
+  integer inum;
+  char /*cfm[80],*/ cln[3];
   
-  /* Fortran I/O blocks */
-  cilist io___5 = { 0, 0, 0, cfm, 0 };
-  cilist io___6 = { 0, 0, 0, cfm, 0 };
-  cilist io___7 = { 0, 0, 0, cfm, 0 };
- 
-
 /* ***********************************************************************
  */
 
@@ -1127,33 +1104,17 @@ t !! ')", 80L, 54L);
    */
   /*  iMPLEMENTATION OF WRITE , WITH OR WITHOUT DATA : */
   
-  iunite = AdvApp2Var_SysBase::mnfnimp_();
   if (inum == 0) {
-    io___5.ciunit = iunite;
-    /*
-    s__wsfe(&io___5);
-    */
-    AdvApp2Var_SysBase::e__wsfe();
   } else if (inum == 1) {
-    io___6.ciunit = iunite;
-    /*
-    s__wsfe(&io___6);
-    */
     /*
     do__fio(&c__1, (char *)&it[1], (ftnlen)sizeof(integer));
     */
-    AdvApp2Var_SysBase::e__wsfe();
   } else {
     /*  MESSAGE DOES NOT EXIST ... */
-    io___7.ciunit = iunite;
-    /*
-    s__wsfe(&io___7);
-    */
     /*
     do__fio(&c__1, (char *)&(*num), (ftnlen)sizeof(integer));
     do__fio(&c__1, crout, crout_len);
     */
-    AdvApp2Var_SysBase::e__wsfe();
   }
   
   return 0;
@@ -2740,7 +2701,7 @@ int AdvApp2Var_SysBase::mcrrqst_(integer
   doublereal dfmt;
   integer ifmt, iver;
   char subr[7];
-  integer ksys , ibyte, irest, isyst, ier;
+  integer ksys , ibyte, irest, ier;
   intptr_t iadfd, iadff, iaddr,lofset, loc;
   integer izu;
 
@@ -2912,15 +2873,11 @@ int AdvApp2Var_SysBase::mcrrqst_(integer
     if (iver == 1) {
 
 	if (ibyte == 0) {
-	    //s__wsle(&io___3);
 	    //do__lio(&c__9, &c__1, "Require zero allocation", 26L);
-	    AdvApp2Var_SysBase::e__wsle();
 	    maostrb_();
 	} else if (ibyte >= 4096000) {
-	    //s__wsle(&io___4);
 	    //do__lio(&c__9, &c__1, "Require allocation above 4 Mega-Octets : ", 50L);
 	    //do__lio(&c__3, &c__1, (char *)&ibyte, (ftnlen)sizeof(integer));
-	    AdvApp2Var_SysBase::e__wsle();
 	    maostrb_();
 	}
 
@@ -2949,7 +2906,6 @@ int AdvApp2Var_SysBase::mcrrqst_(integer
 
 /* DEMAND OF ALLOCATION */
 
-    isyst = 0;
 /* L1001: */
 /*      IF ( ISYST.EQ.0.AND.IBYTE .LE. 100 * 1024 ) THEN */
 /*        ALLOCATION SUR TABLE */
@@ -3131,8 +3087,6 @@ void AdvApp2Var_SysBase::miraz_(integer
 				void *adt)
 
 {
-  integer offset;
-  offset = *taille;
   memset(adt , '\0' , *taille) ;
 }
 //=======================================================================
@@ -3147,17 +3101,6 @@ integer AdvApp2Var_SysBase::mnfndeb_()
 } /* mnfndeb_ */
 
 //=======================================================================
-//function : AdvApp2Var_SysBase::mnfnimp_
-//purpose  : 
-//=======================================================================
-integer AdvApp2Var_SysBase::mnfnimp_()
-{
-  integer ret_val;
-  ret_val = 6;
-  return ret_val;
-} /* mnfnimp_ */
-
-//=======================================================================
 //function : AdvApp2Var_SysBase::msifill_
 //purpose  : 
 //=======================================================================
@@ -3277,9 +3220,6 @@ int AdvApp2Var_SysBase::mswrdbg_(const c
 
 {
 
-  cilist io___1 = { 0, 0, 0, 0, 0 };
-  
-
 /* ***********************************************************************
  */
 
@@ -3324,11 +3264,8 @@ int AdvApp2Var_SysBase::mswrdbg_(const c
  */
 
     if (AdvApp2Var_SysBase::mnfndeb_() >= 1) {
-	io___1.ciunit = AdvApp2Var_SysBase::mnfnimp_();
-	//s__wsle(&io___1);
 	//do__lio(&c__9, &c__1, "Dbg ", 4L);
 	//do__lio(&c__9, &c__1, ctexte, ctexte_len);
-	AdvApp2Var_SysBase::e__wsle();
     }
  return 0 ;
 } /* mswrdbg_ */
@@ -3361,39 +3298,6 @@ int AdvApp2Var_SysBase::do__lio ()
 {
   return 0;
 }
-//=======================================================================
-//function : e__wsfe
-//purpose  : 
-//=======================================================================
-int AdvApp2Var_SysBase::e__wsfe ()
-{
-  return 0;
-}
-//=======================================================================
-//function : e__wsle
-//purpose  : 
-//=======================================================================
-int AdvApp2Var_SysBase::e__wsle ()
-{
-  return 0;
-}
-//=======================================================================
-//function : s__wsfe
-//purpose  : 
-//=======================================================================
-int AdvApp2Var_SysBase::s__wsfe ()
-{
-  return 0;
-}
-//=======================================================================
-//function : s__wsle
-//purpose  : 
-//=======================================================================
-int AdvApp2Var_SysBase::s__wsle ()
-{
-  return 0;
-}
-
 
 /*
 C*****************************************************************************
Index: oce/src/AdvApp2Var/AdvApp2Var_SysBase.hxx
===================================================================
--- oce.orig/src/AdvApp2Var/AdvApp2Var_SysBase.hxx
+++ oce/src/AdvApp2Var/AdvApp2Var_SysBase.hxx
@@ -51,13 +51,8 @@ class AdvApp2Var_SysBase {
 				      integer *iercod);
   Standard_EXPORT static integer mnfndeb_();
 
-  Standard_EXPORT static integer mnfnimp_();
   Standard_EXPORT static int do__fio(); 
   Standard_EXPORT static int do__lio ();
-  Standard_EXPORT static int e__wsfe ();
-  Standard_EXPORT static int e__wsle ();
-  Standard_EXPORT static int s__wsfe ();
-  Standard_EXPORT static int s__wsle ();
   Standard_EXPORT int macrai4_(integer *nbelem, 
 				      integer *maxelm, 
 				      integer *itablo,
Index: oce/src/AppParCurves/AppParCurves.cxx
===================================================================
--- oce.orig/src/AppParCurves/AppParCurves.cxx
+++ oce/src/AppParCurves/AppParCurves.cxx
@@ -104,8 +104,8 @@ void AppParCurves::SecondDerivativeBerns
 //  Standard_Real U1 = 1-U, Y0, Y1, Xs;
   Standard_Real Y0, Y1, Xs;
   Standard_Integer NbPoles = DDA.Length();
-  Standard_Integer id, j, N2, N3, N4, deg = NbPoles-1;
-  N2 = deg-1; N3 = deg-2, N4 = deg*(deg-1);
+  Standard_Integer id, j, N4, deg = NbPoles-1;
+  N4 = deg*(deg-1);
   math_Vector B(1, deg-1);
   B(1) = 1.;
   
Index: oce/src/AppParCurves/AppParCurves_LeastSquare.gxx
===================================================================
--- oce.orig/src/AppParCurves/AppParCurves_LeastSquare.gxx
+++ oce/src/AppParCurves/AppParCurves_LeastSquare.gxx
@@ -430,7 +430,7 @@ void AppParCurves_LeastSquare::Perform(c
   if (!isready) {
     return;
   }
-  Standard_Integer i, j, k, Ci, Nincx, Neq, i2, k1, k2;
+  Standard_Integer i, j, k, Ci, Nincx, i2, k1, k2;
   Standard_Integer nbpol1 = nbpoles-1, Ninc1 = Ninc-1;
   Standard_Real AD1, A0;
 //  gp_Pnt Pt;
@@ -499,7 +499,7 @@ void AppParCurves_LeastSquare::Perform(c
     math_Vector myTABB(1, Nincx, 0.0);
     
     MakeTAA(TheAA, mytab);
-    Standard_Integer Error = DACTCL_Decompose(TheAA, Index);
+    DACTCL_Decompose(TheAA, Index);
     
     Standard_Integer kk2;
     for (j = 1; j <= B2.ColNumber(); j++) {
@@ -508,7 +508,7 @@ void AppParCurves_LeastSquare::Perform(c
 	myTABB(kk2) = mytab(i, j);
 	kk2++;
       }
-      Error = DACTCL_Solve(TheAA, myTABB, Index);
+      DACTCL_Solve(TheAA, myTABB, Index);
       
       i2 = 1;
       for (k = resinit; k <= resfin; k++) {
@@ -524,7 +524,6 @@ void AppParCurves_LeastSquare::Perform(c
   // ===========================================================
 
   Nincx = resfin-resinit+1;
-  Neq = LastP-FirstP+1;
   Standard_Integer deport = 0, Nincx2 = 2*Nincx;
   
   math_IntegerVector InternalIndex(1, Nincx);
@@ -868,7 +867,7 @@ void AppParCurves_LeastSquare::Perform(c
 
   math_Vector myTABB(1, Nincx, 0.0);
 
-  Standard_Integer Error = DACTCL_Decompose(AA, Index);
+  DACTCL_Decompose(AA, Index);
   
   Standard_Integer kk2;
   for (j = 1; j <= B2.ColNumber(); j++) {
@@ -878,7 +877,7 @@ void AppParCurves_LeastSquare::Perform(c
       kk2++;
     }
     
-    Error = DACTCL_Solve(AA, myTABB, Index);
+    DACTCL_Solve(AA, myTABB, Index);
     
     i2 = 1;
     for (k = resinit; k <= resfin; k++) {
@@ -992,7 +991,6 @@ void AppParCurves_LeastSquare::Error(Sta
   F = 0.0;
   i2 = 1;
   math_Vector Px(1, nbpoles), Py(1, nbpoles), Pz(1, nbpoles);
-  Standard_Integer l;
 
   for (k = 1 ; k <= nbP+nbP2d; k++) {
     i21 = i2+1; i22 = i2+2;
@@ -1005,7 +1003,6 @@ void AppParCurves_LeastSquare::Error(Sta
       AA = 0.0; BB = 0.0; CC = 0.0;
       indexdeb = myindex(i) + 1;
       indexfin = indexdeb + deg;
-      l = (i-1)*(deg+1)-indexdeb+1;
       for (j = indexdeb; j <= indexfin; j++) {
 	AIJ = A(i, j);
 	AA += AIJ*Px(j);
Index: oce/src/AppParCurves/AppParCurves_ResolConstraint.gxx
===================================================================
--- oce.orig/src/AppParCurves/AppParCurves_ResolConstraint.gxx
+++ oce/src/AppParCurves/AppParCurves_ResolConstraint.gxx
@@ -161,7 +161,7 @@ AppParCurves_ResolConstraint::
       for (i = 1; i <= IncTan; i++) {
 	Npt = ITan(i);
 	// choix du maximum de tangence pour exprimer la colinearite:
-	Ok = ToolLine::Tangency(SSP, Npt, tabV);
+	ToolLine::Tangency(SSP, Npt, tabV);
 	V = tabV(k);
 	V.Coord(T1, T2, T3);
 	Tmax = Abs(T1);
@@ -228,7 +228,7 @@ AppParCurves_ResolConstraint::
     else {
       for (i = 1; i <= IncTan; i++) {
 	Npt = ITan(i);
-	Ok = ToolLine::Tangency(SSP, Npt, tabV2d);
+	ToolLine::Tangency(SSP, Npt, tabV2d);
 	V2d = tabV2d(k-nb3d);
 	T1 = V2d.X();
 	T2 = V2d.Y();
@@ -730,7 +730,7 @@ const math_Matrix& AppParCurves_ResolCon
 	  IncCol = IncCol + IP;
 	}
 	else if (Ibont(k+1,i) == 3) {    // Relations entre T1x et T2z:
-	  Ok = ToolLine::Tangency(SSP, Npt, tabV);
+	  ToolLine::Tangency(SSP, Npt, tabV);
 	  V = tabV(k+1);
 	  T2 = V.Z();
 	  for (j = 1; j <=  Npol; j++) {
@@ -793,7 +793,7 @@ const math_Matrix& AppParCurves_ResolCon
 
 	}
 	else if (Ibont(k+1,i)== 3) {    // Relations entre T1y et T2z:
-	  Ok = ToolLine::Tangency(SSP, Npt, tabV);
+	  ToolLine::Tangency(SSP, Npt, tabV);
 	  V = tabV(k+1);
 	  T2 = V.Z();
 	  for (j = 1; j <=  Npol; j++) {
@@ -849,7 +849,7 @@ const math_Matrix& AppParCurves_ResolCon
 	}
 
 	else if (Ibont(k+1,i)==3) {      // Relations entre T1z et T2z:
-	  Ok = ToolLine::Tangency(SSP, Npt, tabV);
+	  ToolLine::Tangency(SSP, Npt, tabV);
 	  V = tabV(k+1);
 	  T2 = V.Z();
 	  for (j = 1; j <=  Npol; j++) {
Index: oce/src/Approx/Approx_ComputeLine.gxx
===================================================================
--- oce.orig/src/Approx/Approx_ComputeLine.gxx
+++ oce/src/Approx/Approx_ComputeLine.gxx
@@ -618,7 +618,6 @@ void Approx_ComputeLine::Perform(const M
 	// ========================================
 	GoUp = Standard_False;
 	Ok = Standard_True;
-	Standard_Boolean FailOnPointsAdded = Standard_False;
 	if (MyStatus == Approx_PointsAdded) {
 	  // Appel recursif du decoupage:
 	  GoUp = Standard_True;
@@ -632,7 +631,6 @@ void Approx_ComputeLine::Perform(const M
 	  //-- Si MakeML a echoue   on retourne une ligne vide
 	  if ((nbpdsotherligne == 0) || myMultiLineNb >= 3)
 	  {
-	    FailOnPointsAdded = Standard_True; 
 	    //-- cout<<" ** ApproxComputeLine MakeML Echec ** LBR lbr "<<endl;
 	    if (myfirstpt == mylastpt) break;  // Pour etre sur de ne pas 
 	    // planter la station !!
@@ -828,11 +826,10 @@ void Approx_ComputeLine::Parameters(cons
 			       const Standard_Integer lastP,
 			       math_Vector& TheParameters) const
 {
-  Standard_Integer i, j, Nbp, nbP2d, nbP3d;
+  Standard_Integer i, j, nbP2d, nbP3d;
   Standard_Real dist;
   gp_Pnt P1, P2;
   gp_Pnt2d P12d, P22d;
-  Nbp = lastP-firstP+1;
 
   if (Par == Approx_ChordLength || Par == Approx_Centripetal) {
     nbP3d = LineTool::NbP3d(Line);
@@ -994,12 +991,12 @@ Standard_Boolean  Approx_ComputeLine::Co
   gp_Vec2d V12d, V22d;
   gp_Pnt P1, P2;
   gp_Pnt2d P12d, P22d;
-  Standard_Boolean Tangent1, Tangent2, Parallel, mydone= Standard_False;
+  Standard_Boolean Tangent1, Tangent2, mydone= Standard_False;
+#ifdef DEB
+  Standard_Boolean Parallel;
+#endif
   Standard_Integer myfirstpt = firstpt, mylastpt = lastpt;
   Standard_Integer nbp = lastpt-firstpt+1, Kopt = 0;
-  AppParCurves_Constraint FirstC, LastC;
-  FirstC = AppParCurves_PassPoint;
-  LastC = AppParCurves_PassPoint;
   math_Vector Para(firstpt, lastpt);
 
   Parameters(Line, firstpt, lastpt, Para);
@@ -1042,13 +1039,17 @@ Standard_Boolean  Approx_ComputeLine::Co
   if (nbp == 2) {
     // S il n y a que 2 points, on verifie quand meme que les tangentes sont 
     // alignees.
+#ifdef DEB
     Parallel = Standard_True;
+#endif
     if (Tangent1) {
       for (i = 1; i <= nbP3d; i++) {
 	gp_Vec PVec(tabP1(i), tabP2(i));
 	V13d = tabV1(i);
 	if (!PVec.IsParallel(V13d, Precision::Angular())) {
+#ifdef DEB
 	  Parallel = Standard_False;
+#endif
 	  break;
 	}
       }
@@ -1056,7 +1057,9 @@ Standard_Boolean  Approx_ComputeLine::Co
 	gp_Vec2d PVec2d(tabP12d(i), tabP22d(i));
 	V12d = tabV12d(i);
 	if (!PVec2d.IsParallel(V12d, Precision::Angular())) {
+#ifdef DEB
 	  Parallel = Standard_False;
+#endif
 	  break;
 	}
       }
@@ -1067,7 +1070,9 @@ Standard_Boolean  Approx_ComputeLine::Co
 	gp_Vec PVec(tabP1(i), tabP2(i));
 	V23d = tabV2(i);
 	if (!PVec.IsParallel(V23d, Precision::Angular())) {
+#ifdef DEB
 	  Parallel = Standard_False;
+#endif
 	  break;
 	}
       }
@@ -1075,7 +1080,9 @@ Standard_Boolean  Approx_ComputeLine::Co
 	gp_Vec2d PVec2d(tabP12d(i), tabP22d(i));
 	V22d = tabV22d(i);
 	if (!PVec2d.IsParallel(V22d, Precision::Angular())) {
+#ifdef DEB
 	  Parallel = Standard_False;
+#endif
 	  break;
 	}
       }
Index: oce/src/Aspect/Aspect_ColorScale.cxx
===================================================================
--- oce.orig/src/Aspect/Aspect_ColorScale.cxx
+++ oce/src/Aspect/Aspect_ColorScale.cxx
@@ -432,7 +432,6 @@ void Aspect_ColorScale::DrawScale( const
 
   TCollection_ExtendedString aTitle = GetTitle();
 
-  Standard_Integer titleWidth = 0;
   Standard_Integer titleHeight = 0;
 
   Standard_Integer aGray = (Standard_Integer)(255 * ( aBgColor.Red() * 11 + aBgColor.Green() * 16 + aBgColor.Blue() * 5 ) / 32);
@@ -440,7 +439,6 @@ void Aspect_ColorScale::DrawScale( const
 
   // Draw title
   if ( aTitle.Length() ) {
-    titleWidth = TextWidth( aTitle );
     titleHeight = TextHeight( aTitle ) + 2 * spacer;
     PaintText( aTitle, X + spacer, Y + spacer, aFgColor );
   }
Index: oce/src/BOPAlgo/BOPAlgo_BuilderSolid.cxx
===================================================================
--- oce.orig/src/BOPAlgo/BOPAlgo_BuilderSolid.cxx
+++ oce/src/BOPAlgo/BOPAlgo_BuilderSolid.cxx
@@ -233,7 +233,7 @@ static
   //
   myLoops.Clear();
   //
-  Standard_Integer aNbLF, aNbOff, aNbFP, aNbFA;
+  Standard_Integer aNbLF, aNbOff, aNbFP;
   Standard_Integer i;
   TopAbs_Orientation anOr;
   TopoDS_Edge aEL;
@@ -403,8 +403,6 @@ static
   aEFMap.Clear();
   AddedFacesMap.Clear();
   //
-  aNbFA=myShapesToAvoid.Extent();
-  //
   aItM.Initialize(myShapesToAvoid);
   for (; aItM.More(); aItM.Next()) {
     const TopoDS_Shape& aFF=aItM.Key();
Index: oce/src/BOPAlgo/BOPAlgo_Builder_2Cnt.hxx
===================================================================
--- oce.orig/src/BOPAlgo/BOPAlgo_Builder_2Cnt.hxx
+++ oce/src/BOPAlgo/BOPAlgo_Builder_2Cnt.hxx
@@ -51,15 +51,15 @@ class BOPAlgo_BuilderFaceFunctor {
     : myPVBF(&aVBF) {
   }
   //
-  void operator()( const flexible_range<Standard_Size>& aBR ) const{
-    Standard_Size i, iBeg, iEnd;
+  void operator()( const flexible_range<Standard_Integer>& aBR ) const{
+    Standard_Integer i, iBeg, iEnd;
     //
     BOPAlgo_VectorOfBuilderFace& aVBF=*myPVBF;
     //
     iBeg=aBR.begin();
     iEnd=aBR.end();
     for(i=iBeg; i!=iEnd; ++i) {
-      BOPAlgo_BuilderFace& aBF=aVBF((Standard_Integer)i);
+      BOPAlgo_BuilderFace& aBF=aVBF(i);
       //
       aBF.Perform();
     }
@@ -77,13 +77,13 @@ class BOPAlgo_BuilderFaceCnt {
 				      BOPAlgo_VectorOfBuilderFace& aVBF) {
     //
     BOPAlgo_BuilderFaceFunctor aBFF(aVBF);
-    Standard_Size aNbBF=aVBF.Extent();
+    Standard_Integer aNbBF=aVBF.Extent();
     //
     if (bRunParallel) {
-      flexible_for(flexible_range<Standard_Size>(0,aNbBF), aBFF);
+      flexible_for(flexible_range<Standard_Integer>(0,aNbBF), aBFF);
     }
     else {
-      aBFF.operator()(flexible_range<Standard_Size>(0,aNbBF));
+      aBFF.operator()(flexible_range<Standard_Integer>(0,aNbBF));
     }
   }
   //
Index: oce/src/BOPAlgo/BOPAlgo_Builder_3.cxx
===================================================================
--- oce.orig/src/BOPAlgo/BOPAlgo_Builder_3.cxx
+++ oce/src/BOPAlgo/BOPAlgo_Builder_3.cxx
@@ -474,7 +474,7 @@ void BOPAlgo_Builder::BuildSplitSolids(B
   myErrorStatus=0;
   //
   Standard_Boolean bFlagSD;
-  Standard_Integer i, aNbS, iErr, aNbSFS;
+  Standard_Integer i, aNbS, iErr;
   TopExp_Explorer aExp;
   BOPCol_ListIteratorOfListOfShape aIt;
   BOPCol_DataMapIteratorOfDataMapOfShapeShape aIt1;
@@ -544,8 +544,6 @@ void BOPAlgo_Builder::BuildSplitSolids(B
       aSFS.Append(aF);
     }
     //
-    aNbSFS=aSFS.Extent();
-    //
     // 1.3 Build new solids   
     Handle(NCollection_IncAllocator) aAlr1;
     aAlr1=new NCollection_IncAllocator();  
@@ -600,7 +598,7 @@ void BOPAlgo_Builder::FillInternalShapes
 {
   myErrorStatus=0;
   //
-  Standard_Integer i, j,  aNbS, aNbSI, aNbSx, aNbSd;
+  Standard_Integer i, j,  aNbS, aNbSI, aNbSx;
   TopAbs_ShapeEnum aType;
   TopAbs_State aState; 
   TopoDS_Iterator aItS;
@@ -731,8 +729,6 @@ void BOPAlgo_Builder::FillInternalShapes
     }
   }// for (i=0; i<aNbS; ++i) {
   //
-  aNbSd=aLSd.Extent();
-  //
   // 3. Some shapes of aMSI can be already tied with faces of 
   //    split solids
   aItM.Initialize(aMSI); 
Index: oce/src/BOPAlgo/BOPAlgo_PaveFiller_1.cxx
===================================================================
--- oce.orig/src/BOPAlgo/BOPAlgo_PaveFiller_1.cxx
+++ oce/src/BOPAlgo/BOPAlgo_PaveFiller_1.cxx
@@ -44,7 +44,7 @@
   void BOPAlgo_PaveFiller::PerformVV() 
 {
   Standard_Boolean bWithSubShape;
-  Standard_Integer n1, n2, iFlag, nX, n, aSize, i, aNbVV, j, iX, k, aNbBlocks;
+  Standard_Integer n1, n2, iFlag, nX, n, aSize, i, j, iX, k, aNbBlocks;
   Handle(NCollection_IncAllocator) aAllocator;
   BOPCol_DataMapIteratorOfDataMapOfIntegerListOfInteger aItMILI;
   BOPCol_ListIteratorOfListOfInteger aItLI, aItLI2;
@@ -131,7 +131,6 @@
       }
     }
   }
-  aNbVV=aVVs.Extent();
   //
   //-----------------------------------------------------scope t
   aLV.Clear();
Index: oce/src/BOPAlgo/BOPAlgo_PaveFiller_6.cxx
===================================================================
--- oce.orig/src/BOPAlgo/BOPAlgo_PaveFiller_6.cxx
+++ oce/src/BOPAlgo/BOPAlgo_PaveFiller_6.cxx
@@ -271,7 +271,7 @@ void BOPAlgo_PaveFiller::MakeBlocks()
   Standard_Boolean bExist, bValid2D;
   Standard_Integer i, nF1, nF2, aNbC, aNbP, j;
   Standard_Integer nV1, nV2;
-  Standard_Real aTolR3D, aTolR2D, aT1, aT2, aTol;
+  Standard_Real aTolR3D, aT1, aT2, aTol;
   Handle(NCollection_IncAllocator) aAllocator;
   BOPDS_ListIteratorOfListOfPaveBlock aItLPB;
   TopoDS_Edge aES;
@@ -310,7 +310,6 @@ void BOPAlgo_PaveFiller::MakeBlocks()
     const TopoDS_Face& aF2=(*(TopoDS_Face *)(&myDS->Shape(nF2)));
     //
     aTolR3D=aFF.TolR3D();
-    aTolR2D=aFF.TolR2D();
     //
     // Update face info
     if (aMF.Add(nF1)) {
Index: oce/src/BOPAlgo/BOPAlgo_PaveFiller_7.cxx
===================================================================
--- oce.orig/src/BOPAlgo/BOPAlgo_PaveFiller_7.cxx
+++ oce/src/BOPAlgo/BOPAlgo_PaveFiller_7.cxx
@@ -72,7 +72,7 @@ static void UpdateVertices(const TopoDS_
   }
   //
   Standard_Boolean bCB, bV1, bV2;
-  Standard_Integer i, nE, nV1, nV2, nSp, aNbPB, nOrE;
+  Standard_Integer i, nE, nV1, nV2, nSp, aNbPB;
   Standard_Real aT1, aT2;
   Handle(NCollection_IncAllocator) aAllocator;
   BOPDS_ListIteratorOfListOfPaveBlock aItPB, aItPBCB;
@@ -90,7 +90,6 @@ static void UpdateVertices(const TopoDS_
     //DEBf
     if (aNbPB) {
       aPBx=aLPB.First();
-      nOrE=aPBx->OriginalEdge();
     }
     //DEBt
     if (aNbPB==1) {
Index: oce/src/BOPAlgo/BOPAlgo_PaveFiller_8.cxx
===================================================================
--- oce.orig/src/BOPAlgo/BOPAlgo_PaveFiller_8.cxx
+++ oce/src/BOPAlgo/BOPAlgo_PaveFiller_8.cxx
@@ -243,7 +243,7 @@ static
                                      const BOPDS_ListOfPaveBlock& aLPBOut,
                                      const Handle(BOPDS_PaveBlock)& aPBD)
 {
-  Standard_Boolean bXDir, bIsDone, bReject;
+  Standard_Boolean bXDir, bIsDone;
   Standard_Integer nE, aNbPoints, j;
   Standard_Real aTD1, aTD2, aT1, aT2, aTolInter, aX, aDT;
   Standard_Real aTolCmp;
@@ -329,7 +329,6 @@ static
         continue; 
       }
       //
-      bReject=Standard_False;
       if (aPBD->ContainsParameter(aX, aDT)) {
         continue;
       }
Index: oce/src/BOPDS/BOPDS_IteratorSI.cxx
===================================================================
--- oce.orig/src/BOPDS/BOPDS_IteratorSI.cxx
+++ oce/src/BOPDS/BOPDS_IteratorSI.cxx
@@ -73,7 +73,7 @@
 {
   Standard_Boolean bFlag;
   Standard_Integer aNbS, i, aNbB;//, iFlag, aNbLV, aNbA
-  Standard_Integer aNbSD, iX, j, iDS, jB, k;;
+  Standard_Integer aNbSD, iX, j, iDS, jB;
   TopAbs_ShapeEnum aTi, aTj;
   Handle(NCollection_IncAllocator) aAllocator;
   BOPCol_ListIteratorOfListOfInteger aIt;
@@ -157,8 +157,6 @@
     //
     const BOPCol_ListOfInteger& aLI=aSelector.Indices();
     //
-    k=0;
-    //
     aIt.Initialize(aLI);
     for (; aIt.More(); aIt.Next()) {
       jB=aIt.Value();  // box index in MII
Index: oce/src/BOPInt/BOPInt_Context.cxx
===================================================================
--- oce.orig/src/BOPInt/BOPInt_Context.cxx
+++ oce/src/BOPInt/BOPInt_Context.cxx
@@ -564,8 +564,7 @@
                                                        const Standard_Real aTol) 
 {
   Standard_Boolean bFlag;
-  Standard_Real Umin, myEpsT, U, V;
-  myEpsT=1.e-12;
+  Standard_Real Umin, U, V;
 
   GeomAPI_ProjectPointOnSurf& aProjector=ProjPS(aF);
   aProjector.Perform(aP);
@@ -614,14 +613,12 @@
                                                         const Standard_Real aTol) 
 {
   Standard_Boolean bFlag;
-  Standard_Real aTInterm, aFirst, aLast;
+  Standard_Real aTInterm;
   gp_Pnt aPInterm;
 
   aTInterm=IntTools_Tools::IntermediatePoint(aT1, aT2);
 
   Handle(Geom_Curve) aC3D=aC.Curve();
-  aFirst=aC3D->FirstParameter();
-  aLast =aC3D->LastParameter();
   // point 3D
   aC3D->D0(aTInterm, aPInterm);
   //
Index: oce/src/BOPTest/BOPTest_PartitionCommands.cxx
===================================================================
--- oce.orig/src/BOPTest/BOPTest_PartitionCommands.cxx
+++ oce/src/BOPTest/BOPTest_PartitionCommands.cxx
@@ -150,7 +150,7 @@ Standard_Integer bfillds(Draw_Interpreto
   }
   //
   char buf[32];
-  Standard_Integer aNbS, aNbT, iErr;
+  Standard_Integer aNbS, iErr;
   BOPCol_ListIteratorOfListOfShape aIt;
   BOPCol_ListOfShape aLC;
   
@@ -162,7 +162,6 @@ Standard_Integer bfillds(Draw_Interpreto
   }
   //
   BOPCol_ListOfShape& aLT=BOPTest_Objects::Tools();
-  aNbT=aLT.Extent();
   //
   aIt.Initialize(aLS);
   for (; aIt.More(); aIt.Next()) {
Index: oce/src/BOPTest/BOPTest_TolerCommands.cxx
===================================================================
--- oce.orig/src/BOPTest/BOPTest_TolerCommands.cxx
+++ oce/src/BOPTest/BOPTest_TolerCommands.cxx
@@ -213,7 +213,7 @@ void ReduceVertexTolerance (const TopoDS
 void ProcessEdge(const TopoDS_Edge& aE, const Standard_Real aTolTreshold)
 {
   Standard_Integer i, aNb=23;
-  Standard_Real aTolE, aD2, aTolMax2, aT1, aT2, aT, dT;
+  Standard_Real aD2, aTolMax2, aT1, aT2, aT, dT;
   gp_Pnt aPC3D, aP3D;
   gp_Pnt2d aPC2D;
 
@@ -277,7 +277,6 @@ void ProcessEdge(const TopoDS_Edge& aE,
     return;
   }
   //
-  aTolE =BRep_Tool::Tolerance(aE);
   //
   aTolMax2=sqrt(aTolMax2); 
   
@@ -296,7 +295,7 @@ void ProcessVertex(const TopoDS_Vertex&
 		   const TopTools_ListOfShape& aLE,
 		   const TopTools_ListOfShape& aLF)
 {
-  Standard_Real aTol, aTol2, aD2, aTolMax2, aTolE, aParam;
+  Standard_Real aTol, aD2, aTolMax2, aTolE, aParam;
   gp_Pnt aPC3D;
   gp_Pnt2d aPC2D;
   TopAbs_Orientation anOrV;
@@ -312,7 +311,6 @@ void ProcessVertex(const TopoDS_Vertex&
   Handle(BRep_TVertex)& TV = *((Handle(BRep_TVertex)*) &aV.TShape());
   const gp_Pnt& aPV3D = TV->Pnt();
   aTol =BRep_Tool::Tolerance(aV);
-  aTol2=aTol*aTol;
   //
   anIt.Initialize(aLE);
   for (; anIt.More(); anIt.Next()) {
Index: oce/src/BOPTools/BOPTools_AlgoTools.cxx
===================================================================
--- oce.orig/src/BOPTools/BOPTools_AlgoTools.cxx
+++ oce/src/BOPTools/BOPTools_AlgoTools.cxx
@@ -1189,7 +1189,7 @@ Standard_Boolean BOPTools_AlgoTools::IsH
   Standard_Boolean bIsHole;
   Standard_Integer i, aNbS;
   Standard_Real aT1, aT2, aS;
-  Standard_Real aU1, aU2, aU, dU;
+  Standard_Real aU1, aU, dU;
   Standard_Real aX1, aY1, aX0, aY0;
   TopAbs_Orientation aOr;
   
@@ -1228,11 +1228,9 @@ Standard_Boolean BOPTools_AlgoTools::IsH
     dU=(aT2-aT1)/(Standard_Real)(aNbS-1);
     aU =aT1;
     aU1=aT1;
-    aU2=aT2;
     if (aOr==TopAbs_REVERSED) {
       aU =aT2;
       aU1=aT2;
-      aU2=aT1;
       dU=-dU;
     }
     //
Index: oce/src/BOPTools/BOPTools_AlgoTools3D.cxx
===================================================================
--- oce.orig/src/BOPTools/BOPTools_AlgoTools3D.cxx
+++ oce/src/BOPTools/BOPTools_AlgoTools3D.cxx
@@ -741,7 +741,7 @@ void Add(const TopoDS_Shape& aS,
   Standard_Boolean bIsDone, bHasFirstPoint, bHasSecondPoint;
   Standard_Integer iErr, aIx, aNbDomains;
   Standard_Real aUMin, aUMax, aVMin, aVMax;
-  Standard_Real aVx = 0., aUx, aV1, aV2, aEpsT;
+  Standard_Real aVx = 0., aUx, aV1, aV2;
   gp_Dir2d aD2D (0., 1.);
   gp_Pnt2d aP2D;
   gp_Pnt aPx;
@@ -753,7 +753,6 @@ void Add(const TopoDS_Shape& aS,
   Geom2dHatch_Hatcher& aHatcher = theContext->Hatcher(aF);
   //
   iErr=0;
-  aEpsT=1.e-12;
   //
   aFF=aF;
   aFF.Orientation (TopAbs_FORWARD);
Index: oce/src/BOPTools/BOPTools_AlgoTools_1.cxx
===================================================================
--- oce.orig/src/BOPTools/BOPTools_AlgoTools_1.cxx
+++ oce/src/BOPTools/BOPTools_AlgoTools_1.cxx
@@ -172,7 +172,7 @@ static
 void CorrectWires(const TopoDS_Face& aFx)
 {
   Standard_Integer i, aNbV;
-  Standard_Real aTol, aTol2, aD2, aD2max, aT1, aT2, aT, aTol2d; 
+  Standard_Real aTol, aTol2, aD2, aD2max, aT1, aT2, aT;
   gp_Pnt aP, aPV;
   gp_Pnt2d aP2D;
   TopoDS_Face aF;
@@ -182,7 +182,6 @@ void CorrectWires(const TopoDS_Face& aFx
   //
   aF=aFx;
   aF.Orientation(TopAbs_FORWARD);
-  aTol2d = Precision::Confusion();
   const Handle(Geom_Surface)& aS=BRep_Tool::Surface(aFx);
   //
   TopExp::MapShapesAndAncestors(aF, TopAbs_VERTEX, TopAbs_EDGE, aMVE);
Index: oce/src/BRepAdaptor/BRepAdaptor_CompCurve.cxx
===================================================================
--- oce.orig/src/BRepAdaptor/BRepAdaptor_CompCurve.cxx
+++ oce/src/BRepAdaptor/BRepAdaptor_CompCurve.cxx
@@ -86,9 +86,8 @@ BRepAdaptor_CompCurve::BRepAdaptor_CompC
   Forward = Standard_True; // Defaut ; The Reverse Edges are parsed.
   if((NbEdge > 2) || ((NbEdge==2) && (!myWire.Closed())) ) {
     TopAbs_Orientation Or = myCurves->Value(1).Edge().Orientation();
-    Standard_Boolean B;
     TopoDS_Vertex VI, VL;
-    B = TopExp::CommonVertex(myCurves->Value(1).Edge(),
+    TopExp::CommonVertex(myCurves->Value(1).Edge(),
 			     myCurves->Value(2).Edge(),
 			     VI);
     VL = TopExp::LastVertex(myCurves->Value(1).Edge());
Index: oce/src/BRepBlend/BRepBlend_CurvPointRadInv.cxx
===================================================================
--- oce.orig/src/BRepBlend/BRepBlend_CurvPointRadInv.cxx
+++ oce/src/BRepBlend/BRepBlend_CurvPointRadInv.cxx
@@ -78,14 +78,13 @@ Standard_Boolean BRepBlend_CurvPointRadI
 {
   gp_Pnt ptcur1, ptcur2;
   gp_Vec d1cur1,d2cur1, d1cur2, nplan, dnplan;
-  Standard_Real theD, dtheD, normd1cur1, unsurnormd1cur1;
+  Standard_Real dtheD, normd1cur1, unsurnormd1cur1;
 
   curv1->D2(X(1), ptcur1, d1cur1, d2cur1);
 
   normd1cur1      = d1cur1.Magnitude();
   unsurnormd1cur1 = 1. / normd1cur1;
   nplan           = unsurnormd1cur1 * d1cur1;
-  theD            = -(nplan.XYZ().Dot(ptcur1.XYZ()));
   dnplan.SetLinearForm(-nplan.Dot(d2cur1), nplan, d2cur1);
   dnplan.Multiply(unsurnormd1cur1);
   dtheD  = - nplan.XYZ().Dot(d1cur1.XYZ()) - dnplan.XYZ().Dot(ptcur1.XYZ());
@@ -107,10 +106,8 @@ Standard_Boolean BRepBlend_CurvPointRadI
 						   math_Vector& F,
 						   math_Matrix& D) 
 {
-  Standard_Boolean Retour;
-
-  Retour = Value(X, F);
-  Retour = Derivatives(X, D);
+  Value(X, F);
+  Derivatives(X, D);
 
   return Standard_True;
 }
Index: oce/src/BRepBlend/BRepBlend_RstRstConstRad.cxx
===================================================================
--- oce.orig/src/BRepBlend/BRepBlend_RstRstConstRad.cxx
+++ oce/src/BRepBlend/BRepBlend_RstRstConstRad.cxx
@@ -131,10 +131,8 @@ Standard_Boolean BRepBlend_RstRstConstRa
 						  math_Vector&       F,
 						  math_Matrix&       D)
 {
-  Standard_Boolean Error;
-
-  Error = Value(X, F);  
-  Error = Derivatives(X, D);
+  Value(X, F);  
+  Derivatives(X, D);
  
   return Standard_True;
 }
@@ -462,9 +460,7 @@ Blend_DecrochStatus BRepBlend_RstRstCons
   // Normal to the reference surface 2
   NRst2     = d1u.Crossed(d1v);
 
-  Standard_Boolean IsCenter;
-
-  IsCenter = CenterCircleRst1Rst2(PtTmp1, PtTmp2, nplan, Center, NotUsed);
+  CenterCircleRst1Rst2(PtTmp1, PtTmp2, nplan, Center, NotUsed);
 
   norm      = nplan.Crossed(NRst1).Magnitude();
   unsurnorm = 1. / norm;
@@ -603,9 +599,7 @@ void BRepBlend_RstRstConstRad::Section(c
   ptrst1   = cons1.Value(U);
   ptrst2   = cons2.Value(V);
 
-  Standard_Boolean IsCenter;
-
-  IsCenter = CenterCircleRst1Rst2(ptrst1, ptrst2, np, Center, NotUsed);
+  CenterCircleRst1Rst2(ptrst1, ptrst2, np, Center, NotUsed);
 
   C.SetRadius(Abs(ray));
   ns = gp_Vec(Center, ptrst1).Normalized(); 
@@ -778,8 +772,7 @@ void BRepBlend_RstRstConstRad::Section(c
   }
 
   // Calculate the center of the circle
-  Standard_Boolean IsCenter;
-  IsCenter = CenterCircleRst1Rst2(ptrst1, ptrst2, nplan, Center, NotUsed);
+  CenterCircleRst1Rst2(ptrst1, ptrst2, nplan, Center, NotUsed);
 
   // normals to the section with points 
   ns  = gp_Vec(Center, ptrst1).Normalized();  
Index: oce/src/BRepBlend/BRepBlend_RstRstEvolRad.cxx
===================================================================
--- oce.orig/src/BRepBlend/BRepBlend_RstRstEvolRad.cxx
+++ oce/src/BRepBlend/BRepBlend_RstRstEvolRad.cxx
@@ -193,10 +193,8 @@ Standard_Boolean BRepBlend_RstRstEvolRad
 						 math_Vector&       F,
 						 math_Matrix&       D)
 {
-  Standard_Boolean Error;
-
-  Error = Value(X, F);  
-  Error = Derivatives(X, D);
+  Value(X, F);  
+  Derivatives(X, D);
  
   return Standard_True;
 }
@@ -533,9 +531,7 @@ Blend_DecrochStatus BRepBlend_RstRstEvol
   // Normal to the reference surface 2
   NRst2     = d1u.Crossed(d1v);
 
-  Standard_Boolean IsCenter;
-
-  IsCenter = CenterCircleRst1Rst2(PtTmp1, PtTmp2, nplan, Center, NotUsed);
+  CenterCircleRst1Rst2(PtTmp1, PtTmp2, nplan, Center, NotUsed);
 
   norm      = nplan.Crossed(NRst1).Magnitude();
   unsurnorm = 1. / norm;
@@ -672,9 +668,7 @@ void BRepBlend_RstRstEvolRad::Section(co
   ptrst1   = cons1.Value(U);
   ptrst2   = cons2.Value(V);
 
-  Standard_Boolean IsCenter;
-
-  IsCenter = CenterCircleRst1Rst2(ptrst1, ptrst2, np, Center, NotUsed);
+  CenterCircleRst1Rst2(ptrst1, ptrst2, np, Center, NotUsed);
 
   C.SetRadius(Abs(ray));
   ns = gp_Vec(Center, ptrst1).Normalized(); 
@@ -881,8 +875,7 @@ void BRepBlend_RstRstEvolRad::Section(co
   }
 
   // Calculate the center of the circle
-  Standard_Boolean IsCenter;
-  IsCenter = CenterCircleRst1Rst2(ptrst1, ptrst2, nplan, Center, NotUsed);
+  CenterCircleRst1Rst2(ptrst1, ptrst2, nplan, Center, NotUsed);
 
   // normals to the section with points 
   n1  = gp_Vec(Center, ptrst1).Normalized();  
Index: oce/src/BRepBlend/BRepBlend_RstRstLineBuilder.cxx
===================================================================
--- oce.orig/src/BRepBlend/BRepBlend_RstRstLineBuilder.cxx
+++ oce/src/BRepBlend/BRepBlend_RstRstLineBuilder.cxx
@@ -1421,11 +1421,10 @@ Blend_Status BRepBlend_RstRstLineBuilder
   if(!prevpointistangent){
     prevTg = previousP.TangentOnC1();
   }
-  Standard_Real Norme, curNorme;
+  Standard_Real Norme;
   Standard_Real prevNorme = 0.;
   gp_Vec Corde(prevP, Psurf);
   Norme = Corde.SquareMagnitude();
-  if (!curpointistangent) curNorme = Tgsurf.SquareMagnitude();
   if (!prevpointistangent) prevNorme = prevTg.SquareMagnitude();
 
   if (Norme <= tolesp * tolesp) {
@@ -1499,11 +1498,10 @@ Blend_Status BRepBlend_RstRstLineBuilder
   if (!prevpointistangent) {
     prevTg = previousP.TangentOnC2();
   }
-  Standard_Real Norme, curNorme;
+  Standard_Real Norme;
   Standard_Real prevNorme = 0.;
   gp_Vec Corde(prevP, Psurf);
   Norme = Corde.SquareMagnitude();
-  if (!curpointistangent) curNorme   = Tgsurf.SquareMagnitude();
   if (!prevpointistangent) prevNorme = prevTg.SquareMagnitude();
 
   if (Norme <= tolesp * tolesp){
Index: oce/src/BRepBlend/BRepBlend_SurfPointEvolRadInv.cxx
===================================================================
--- oce.orig/src/BRepBlend/BRepBlend_SurfPointEvolRadInv.cxx
+++ oce/src/BRepBlend/BRepBlend_SurfPointEvolRadInv.cxx
@@ -95,7 +95,7 @@ const Handle(Adaptor3d_HCurve)& C,
 {
   gp_Pnt ptcur,pts;
   gp_Vec d1cur,d2cur,nplan,dnplan,d1u,d1v,d2u,d2v,duv;
-  Standard_Real theD, dtheD, normd1cur, unsurnormd1cur,dray;
+  Standard_Real dtheD, normd1cur, unsurnormd1cur,dray;
 
   curv->D2(X(1),ptcur,d1cur,d2cur);
   tevol->D1(X(1),ray,dray);
@@ -104,7 +104,6 @@ const Handle(Adaptor3d_HCurve)& C,
   normd1cur = d1cur.Magnitude();
   unsurnormd1cur = 1./normd1cur;
   nplan = unsurnormd1cur * d1cur;
-  theD = -(nplan.XYZ().Dot(ptcur.XYZ()));
   dnplan.SetLinearForm(-nplan.Dot(d2cur),nplan,d2cur);
   dnplan.Multiply(unsurnormd1cur);
   dtheD = - nplan.XYZ().Dot(d1cur.XYZ()) - dnplan.XYZ().Dot(ptcur.XYZ());
Index: oce/src/BRepCheck/BRepCheck_Edge.cxx
===================================================================
--- oce.orig/src/BRepCheck/BRepCheck_Edge.cxx
+++ oce/src/BRepCheck/BRepCheck_Edge.cxx
@@ -529,7 +529,7 @@ Standard_Real BRepCheck_Edge::Tolerance(
 
   Standard_Real dist2, tol2, tolCal=0., prm;
   gp_Pnt center, othP;
-  Standard_Integer i, imax;
+  Standard_Integer i;
   for (i= 0; i< NCONTROL; i++) {
     prm = ((NCONTROL-1-i)*First + i*Last)/(NCONTROL-1);
     tol2=dist2=0.;
@@ -541,7 +541,6 @@ Standard_Real BRepCheck_Edge::Tolerance(
     }
     if (tol2>tolCal) {
       tolCal=tol2;
-      imax=i;
     }
   }
   // On prend 5% de marge car au dessus on crontrole severement
Index: oce/src/BRepCheck/BRepCheck_Wire.cxx
===================================================================
--- oce.orig/src/BRepCheck/BRepCheck_Wire.cxx
+++ oce/src/BRepCheck/BRepCheck_Wire.cxx
@@ -938,7 +938,6 @@ BRepCheck_Status BRepCheck_Wire::SelfInt
 {
 
 
-  Standard_Boolean ok;
   Standard_Integer i,j,Nbedges;
   Standard_Real first1,last1,first2,last2, tolint;
   gp_Pnt2d pfirst1,plast1,pfirst2,plast2;
@@ -950,7 +949,6 @@ BRepCheck_Status BRepCheck_Wire::SelfInt
   TopTools_IndexedMapOfOrientedShape EMap;
   TopTools_MapOfOrientedShape auxmape;
   //
-  ok=Standard_True;
   //-- check with proper tolerances if there is no 
   //-- point in the tolerance of a vertex.
   tolint = 1.e-10; 
@@ -1057,7 +1055,6 @@ BRepCheck_Status BRepCheck_Wire::SelfInt
 	    }
 	  }
 	  if(localok==Standard_False) { 
-	    ok=0;
 	    retE1=E1;
 	    if (Update) {
 	      BRepCheck::Add(myMap(myShape),BRepCheck_SelfIntersectingWire);
@@ -1223,23 +1220,20 @@ BRepCheck_Status BRepCheck_Wire::SelfInt
 	      cout << "\n--- BRepCheck Wire: AutoIntersection Phase1 -> Erreur \n" <<endl;
 	      
 #endif
-	      Standard_Boolean yaunvtxproche;
 	      Standard_Real distauvtxleplusproche,VParaOnEdge1,VParaOnEdge2;
 	      gp_Pnt VertexLePlusProche;
 	      //
-	      yaunvtxproche=Standard_False;
 	      VParaOnEdge1 =0.;
 	      VParaOnEdge2 =0.;
 	      distauvtxleplusproche=RealLast();
 	      //Find the nearest common vertex
 	      itl.Initialize( CommonVertices );
 	      for (; itl.More(); itl.Next())   {
-		Standard_Real tolvtt, disptvtx;
+		Standard_Real disptvtx;
 		gp_Pnt p3dvtt;
 		//
 		const TopoDS_Vertex& vtt = TopoDS::Vertex(itl.Value());
 		p3dvtt = BRep_Tool::Pnt(vtt);
-		tolvtt = BRep_Tool::Tolerance(vtt);
 		disptvtx = P3d.Distance(p3dvtt);
 		if (disptvtx < distauvtxleplusproche)	{
 		  VertexLePlusProche = p3dvtt; 
@@ -1346,7 +1340,6 @@ BRepCheck_Status BRepCheck_Wire::SelfInt
 	    } //end of if (localok == Standard_False && !CommonVertices.IsEmpty())
 	    //
 	    if(localok==Standard_False)	  { 
-	      ok=0;
 	      retE1=E1;
 	      retE2=E2;
 	      if (Update) {
@@ -1481,7 +1474,6 @@ BRepCheck_Status BRepCheck_Wire::SelfInt
 	    } //end of for (k = 0; k < 2; k++)
 	    //
 	    if(localok==Standard_False)	  { 
-	      ok=0;
 	      retE1=E1;
 	      retE2=E2;
 	      if (Update) {
Index: oce/src/BRepFeat/BRepFeat.cxx
===================================================================
--- oce.orig/src/BRepFeat/BRepFeat.cxx
+++ oce/src/BRepFeat/BRepFeat.cxx
@@ -176,12 +176,10 @@ Standard_Real BRepFeat::ParametricBaryce
       extpc.Perform(pone);
       if (extpc.IsDone() && extpc.NbExt() >= 1) {
 	    Standard_Real Dist2Min = extpc.SquareDistance(1);
-	    Standard_Integer kmin = 1;
 	    for (Standard_Integer k=2; k<=extpc.NbExt(); k++) {
 	      Standard_Real Dist2 = extpc.SquareDistance(k);
 	      if (Dist2 < Dist2Min) {
 	        Dist2Min = Dist2;
-	        kmin = k;
 	      }
 	    }
 	    nbp++;
Index: oce/src/BRepFeat/BRepFeat_Builder.cxx
===================================================================
--- oce.orig/src/BRepFeat/BRepFeat_Builder.cxx
+++ oce/src/BRepFeat/BRepFeat_Builder.cxx
@@ -742,8 +742,7 @@
   myErrorStatus=0;
   //
   Standard_Boolean bIsIN, bHasImage;
-  Standard_Integer aNbS, aNbSolids, i, j, aNbFaces, aNbFP, aNbFPx, aNbFIN, aNbLIF, aNbEFP;
-  Standard_Integer aNbRem;
+  Standard_Integer aNbS, i, j, aNbFP, aNbFPx, aNbFIN, aNbLIF, aNbEFP;
   TopAbs_ShapeEnum aType;  
   TopAbs_State aState;
   TopoDS_Iterator aIt, aItF;
@@ -763,8 +762,6 @@
   //
   theDraftSolids.Clear();
   //
-  aNbRem = myRemoved.Extent();
-  //
   aNbS=myDS->NbSourceShapes();
   for (i=0; i<aNbS; ++i) {
     const BOPDS_ShapeInfo& aSI=myDS->ShapeInfo(i);
@@ -802,9 +799,6 @@
     }
   }
   //
-  aNbFaces=aMFaces.Extent();
-  aNbSolids=aMSolids.Extent();
-  //
   aItMS.Initialize(aMSolids);
   for (; aItMS.More(); aItMS.Next()) {
     const TopoDS_Solid& aSolid=(*(TopoDS_Solid*)(&aItMS.Value()));
Index: oce/src/BRepFeat/BRepFeat_Form.cxx
===================================================================
--- oce.orig/src/BRepFeat/BRepFeat_Form.cxx
+++ oce/src/BRepFeat/BRepFeat_Form.cxx
@@ -164,7 +164,6 @@ static void Descendants(const TopoDS_Sha
   TColGeom_SequenceOfCurve scur;
   Curves(scur);
 
-  Standard_Integer tempo;
   Standard_Real locmin;
   Standard_Real locmax;
   Standard_Real mf, Mf, mu, Mu;
@@ -195,7 +194,6 @@ static void Descendants(const TopoDS_Sha
 
   {
 //  Find sens, locmin, locmax, FFrom, FUntil
-    tempo=0;
     locmin = RealFirst();
     locmax = RealLast();
     for (Standard_Integer jj=1; jj<=scur.Length(); jj++) {
Index: oce/src/BRepFeat/BRepFeat_MakeLinearForm.cxx
===================================================================
--- oce.orig/src/BRepFeat/BRepFeat_MakeLinearForm.cxx
+++ oce/src/BRepFeat/BRepFeat_MakeLinearForm.cxx
@@ -1026,18 +1026,16 @@ void BRepFeat_MakeLinearForm::Perform()
 
   TopoDS_Vertex Vprevious;
   gp_Pnt ptprev;
-  Standard_Real tvp, dp;
+  Standard_Real dp;
 
   while (!(LastOK && FirstOK)) {
     if (v1OK) {
       Vprevious=v2;
       ptprev=p2;
-      tvp=t2;
     }
     else {
       Vprevious=v1;
       ptprev=p1;
-      tvp=t1;
     }
     
     // find edge connected to v1 or v2:
Index: oce/src/BRepFeat/BRepFeat_RibSlot.cxx
===================================================================
--- oce.orig/src/BRepFeat/BRepFeat_RibSlot.cxx
+++ oce/src/BRepFeat/BRepFeat_RibSlot.cxx
@@ -136,12 +136,8 @@ void BRepFeat_RibSlot::LFPerform()
     theOpe = 1;
   }
 
-  Standard_Boolean ChangeOpe = Standard_False;
       // Hope that there is just a solid in the result
-  Standard_Boolean UntilInShape = Standard_False;
-
   if (!mySUntil.IsNull()) {
-    UntilInShape = Standard_True;
     for (exp2.Init(mySUntil,TopAbs_FACE); exp2.More(); exp2.Next()) {
       const TopoDS_Shape& funtil = exp2.Current();
       for (exp.Init(mySbase,TopAbs_FACE); exp.More(); exp.Next()) {
@@ -150,7 +146,6 @@ void BRepFeat_RibSlot::LFPerform()
         }
       }
       if (!exp.More()) {
-        UntilInShape = Standard_False;
         break;
       }
     }
@@ -182,7 +177,6 @@ void BRepFeat_RibSlot::LFPerform()
         Collage = BRepFeat::IsInside(glface, fac);
         if(!Collage) {
           theOpe = 2;
-          ChangeOpe = Standard_True;
           break;
         }
         else {
@@ -201,7 +195,6 @@ void BRepFeat_RibSlot::LFPerform()
         (!myFuse && ope != LocOpe_CUT) ||
         (!Collage)) {
       theOpe = 2;
-      ChangeOpe = Standard_True;
 #ifdef DEB
       cout << "Passage to topological operations" << endl;
 #endif
@@ -223,7 +216,6 @@ void BRepFeat_RibSlot::LFPerform()
     }
     else {
       theOpe = 2;
-      ChangeOpe = Standard_True;
 #ifdef DEB
       cout << "Passage to topologic operation" << endl;
 #endif
Index: oce/src/BRepFill/BRepFill_Sweep.cxx
===================================================================
--- oce.orig/src/BRepFill/BRepFill_Sweep.cxx
+++ oce/src/BRepFill/BRepFill_Sweep.cxx
@@ -908,20 +908,16 @@ static Standard_Boolean Filling(const To
 		     f2, l2, C3);
   C2 = C3;
 
-  Standard_Boolean pointu_f,  pointu_l;
 //  P1 = BT.Pnt(Vf);
   P1 = BRep_Tool::Pnt(Vf);
 //  P2 = BT.Pnt(V1);
   P2 = BRep_Tool::Pnt(V1);
 //  pointu_f = Vf.IsSame(V1) || (P1.Distance(P2) < BT.Tolerance(Vf));
-  pointu_f = Vf.IsSame(V1) || (P1.Distance(P2) < BRep_Tool::Tolerance(Vf));
 //  P1 = BT.Pnt(Vl);
   P1 = BRep_Tool::Pnt(Vl);
 //  P2 = BT.Pnt(V2);
   P2 = BRep_Tool::Pnt(V2);
 //  pointu_l = Vl.IsSame(V2) || (P1.Distance(P2) < BT.Tolerance(Vl));
-  pointu_l = Vl.IsSame(V2) || (P1.Distance(P2) < BRep_Tool::Tolerance(Vl));
-
 
   P2d.SetCoord(0.,f1);
   L = new (Geom2d_Line) (P2d, gp::DX2d());
@@ -1703,7 +1699,9 @@ BRepFill_Sweep::BRepFill_Sweep(const Han
   LastShape  = Last; 
 
   // It is necessary to check the SameRange on its (PRO13551)
+#ifdef DEB
   Standard_Boolean issame = Standard_True;
+#endif
   BRep_Builder B;
   BRepTools_WireExplorer wexp;
   if (!FirstShape.IsNull()) {
@@ -1711,7 +1709,9 @@ BRepFill_Sweep::BRepFill_Sweep(const Han
       if (!BRepLib::CheckSameRange(wexp.Current())) {
 	B.SameRange(wexp.Current(), Standard_False);
 	B.SameParameter(wexp.Current(), Standard_False);
+#ifdef DEB
 	issame = Standard_False;
+#endif
       }
     }
   }
@@ -1721,7 +1721,9 @@ BRepFill_Sweep::BRepFill_Sweep(const Han
       if (!BRepLib::CheckSameRange(wexp.Current())) {
 	B.SameRange(wexp.Current(), Standard_False); 
 	B.SameParameter(wexp.Current(), Standard_False);
+#ifdef DEB
 	issame = Standard_False;
+#endif
       }
     }
   }
Index: oce/src/BRepFill/BRepFill_TrimShellCorner.cxx
===================================================================
--- oce.orig/src/BRepFill/BRepFill_TrimShellCorner.cxx
+++ oce/src/BRepFill/BRepFill_TrimShellCorner.cxx
@@ -526,16 +526,9 @@ Standard_Boolean MakeFacesNonSec(const S
     Standard_Integer aFaceIndex = (fit == 1) ? theFaceIndex1 : theFaceIndex2;
     TopoDS_Shape aFace          = theDS->Shape(aFaceIndex);
     TopAbs_Orientation aFaceOri = aFace.Orientation();
-    TopAbs_Orientation anEdgeOri = TopAbs_FORWARD;
     aFace.Orientation(TopAbs_FORWARD);
 
     TopExp_Explorer anExpE(aFace, TopAbs_EDGE);
-    const TopoDS_Shape& aCheckEdge = (fit == 1) ? aE1 : aE2;
-
-    for(; anExpE.More(); anExpE.Next()) {
-      if(aCheckEdge.IsSame(anExpE.Current()))
-        anEdgeOri = anExpE.Current().Orientation();
-    }
 
     if(bHasNewEdge) {
       aNewEdge.Orientation(TopAbs_FORWARD);
Index: oce/src/BRepFill/BRepFill_TrimSurfaceTool.cxx
===================================================================
--- oce.orig/src/BRepFill/BRepFill_TrimSurfaceTool.cxx
+++ oce/src/BRepFill/BRepFill_TrimSurfaceTool.cxx
@@ -497,9 +497,6 @@ void BRepFill_TrimSurfaceTool::Project
        Handle(Geom2d_Curve)& PCurve2,
        GeomAbs_Shape&        Cont) const 
 {
-  Standard_Integer Deg1, Deg2;
-  Deg1 = Deg2 = 8;
-
   Handle(Geom2d_TrimmedCurve) CT = 
     new Geom2d_TrimmedCurve(myBis,U1,U2);
   BRepFill_MultiLine ML(myFace1,myFace2,
Index: oce/src/BRepGProp/BRepGProp.cxx
===================================================================
--- oce.orig/src/BRepGProp/BRepGProp.cxx
+++ oce/src/BRepGProp/BRepGProp.cxx
@@ -57,7 +57,10 @@ void  BRepGProp::LinearProperties(const
 }
 
 static Standard_Real surfaceProperties(const TopoDS_Shape& S, GProp_GProps& Props, const Standard_Real Eps){
-  Standard_Integer i, iErrorMax = 0;
+  Standard_Integer i;
+#ifdef DEB
+  Standard_Integer iErrorMax = 0;
+#endif
   Standard_Real ErrorMax = 0.0, Error;
   TopExp_Explorer ex; 
   gp_Pnt P(roughBaryCenter(S));
@@ -73,7 +76,12 @@ static Standard_Real surfaceProperties(c
     if(Eps < 1.0) {
       G.Perform(BF, BD, Eps); 
       Error = G.GetEpsilon();
-      if(ErrorMax < Error){ ErrorMax = Error; iErrorMax = i;}
+      if(ErrorMax < Error) {
+        ErrorMax = Error;
+#ifdef DEB
+        iErrorMax = i;
+#endif
+      }
     } else {
       if(BF.NaturalRestriction()) G.Perform(BF);
       else G.Perform(BF, BD);
@@ -109,7 +117,10 @@ Standard_Real BRepGProp::SurfaceProperti
 //=======================================================================
 
 static Standard_Real volumeProperties(const TopoDS_Shape& S, GProp_GProps& Props, const Standard_Real Eps){
-  Standard_Integer i, iErrorMax = 0;
+  Standard_Integer i;
+#ifdef DEB
+  Standard_Integer iErrorMax = 0;
+#endif
   Standard_Real ErrorMax = 0.0, Error = 0.0;
   TopExp_Explorer ex; 
   gp_Pnt P(roughBaryCenter(S)); 
@@ -126,7 +137,12 @@ static Standard_Real volumeProperties(co
       if(Eps < 1.0) {
 	G.Perform(BF, BD, Eps); 
 	Error = G.GetEpsilon();
-	if(ErrorMax < Error){ ErrorMax = Error; iErrorMax = i;}
+	if(ErrorMax < Error) {
+	  ErrorMax = Error;
+#ifdef DEB
+	  iErrorMax = i;
+#endif
+	}
       }
       else {
 	if(BF.NaturalRestriction()) G.Perform(BF);
@@ -147,14 +163,13 @@ void  BRepGProp::VolumeProperties(const
   // find the origin
   gp_Pnt P(0,0,0);  P.Transform(S.Location());
   Props = GProp_GProps(P);
-  Standard_Real Error = 0.0;
   if(OnlyClosed){
     TopExp_Explorer ex(S,TopAbs_SHELL);
     for (; ex.More(); ex.Next()) {
       const TopoDS_Shape& Sh = ex.Current();
-      if(BRep_Tool::IsClosed(Sh)) Error = volumeProperties(Sh,Props,1.0);
+      if(BRep_Tool::IsClosed(Sh)) volumeProperties(Sh,Props,1.0);
     }
-  } else Error = volumeProperties(S,Props,1.0);
+  } else volumeProperties(S,Props,1.0);
 }
 
 //=======================================================================
@@ -168,7 +183,10 @@ Standard_Real BRepGProp::VolumePropertie
   // find the origin
   gp_Pnt P(0,0,0);  P.Transform(S.Location());
   Props = GProp_GProps(P);
-  Standard_Integer i, iErrorMax = 0;
+  Standard_Integer i;
+#ifdef DEB
+  Standard_Integer iErrorMax = 0;
+#endif
   Standard_Real ErrorMax = 0.0, Error = 0.0;
   if(OnlyClosed){
     TopExp_Explorer ex(S,TopAbs_SHELL);
@@ -176,7 +194,12 @@ Standard_Real BRepGProp::VolumePropertie
       const TopoDS_Shape& Sh = ex.Current();
       if(BRep_Tool::IsClosed(Sh)) {
 	Error = volumeProperties(Sh,Props,Eps);
-	if(ErrorMax < Error){ ErrorMax = Error; iErrorMax = i;}
+	if(ErrorMax < Error) {
+	  ErrorMax = Error;
+#ifdef DEB
+	  iErrorMax = i;
+#endif
+	}
       }
     }
   } else ErrorMax = volumeProperties(S,Props,Eps);
Index: oce/src/BRepOffset/BRepOffset_Tool.cxx
===================================================================
--- oce.orig/src/BRepOffset/BRepOffset_Tool.cxx
+++ oce/src/BRepOffset/BRepOffset_Tool.cxx
@@ -796,11 +796,9 @@ void BRepOffset_Tool::PipeInter(const To
 //=======================================================================
 
 static Standard_Boolean IsAutonomVertex(const TopoDS_Shape& aVertex,
-					const TopoDS_Shape& F1,
-					const TopoDS_Shape& F2,
-                                        const BOPDS_PDS& pDS)
+					const BOPDS_PDS& pDS)
 {
-  Standard_Integer index, indF1, indF2; 
+  Standard_Integer index;
   Standard_Integer aNbVVs, aNbEEs, aNbEFs, aInt;
   //
   index = pDS->Index(aVertex);
@@ -817,9 +815,6 @@ static Standard_Boolean IsAutonomVertex(
 	    }
 	}
   //
-  indF1 = pDS->Index(F1);
-  indF2 = pDS->Index(F2);
-  //
   if (!pDS->IsNewShape(index)) {
     return Standard_False;
     }
@@ -870,9 +865,7 @@ static Standard_Boolean IsAutonomVertex(
 
 static Standard_Boolean AreConnex(const TopoDS_Wire& W1,
 				  const TopoDS_Wire& W2,
-				  const TopoDS_Shape& F1,
-				  const TopoDS_Shape& F2,
-                                  const BOPDS_PDS& pDS)
+				  const BOPDS_PDS& pDS)
 {
   TopoDS_Vertex V11, V12, V21, V22;
   TopExp::Vertices( W1, V11, V12 );
@@ -883,14 +876,14 @@ static Standard_Boolean AreConnex(const
     {
       Standard_Boolean isCV1 = V11.IsSame(V21) || V11.IsSame(V22);
       Standard_Boolean isCV2 = V12.IsSame(V21) || V12.IsSame(V22);
-      if (isCV1 && !IsAutonomVertex(V11, F1, F2, pDS))
+      if (isCV1 && !IsAutonomVertex(V11, pDS))
 	{
 	  if (!isCV2)
 	    return Standard_False;
-          if (!IsAutonomVertex(V12, F1, F2, pDS))
+          if (!IsAutonomVertex(V12, pDS))
 	    return Standard_False;
 	}
-      if (!isCV1 && !IsAutonomVertex(V12, F1, F2, pDS))
+      if (!isCV1 && !IsAutonomVertex(V12, pDS))
 	return Standard_False;
 
       TopoDS_Vertex CV = (V11.IsSame(V21) || V11.IsSame(V22))? V11 : V12;
@@ -1516,7 +1509,7 @@ static TopoDS_Edge AssembleEdge(const BO
 	{
 	  TopoDS_Vertex V1, V2;
 	  TopExp::Vertices( CurEdge, V1, V2 );
-          if (IsAutonomVertex( V1, F1, F2, pDS ))
+          if (IsAutonomVertex( V1, pDS ))
 	    {
 	      After = Standard_False;
 	      Vfirst = Vlast = V2;
@@ -1759,7 +1752,7 @@ void BRepOffset_Tool::Inter3D(const Topo
 	    for (k = 1; k <= wseq.Length(); k++)
 	      {
 		resWire = TopoDS::Wire(wseq(k));
-                if (AreConnex( resWire, aWire, cpF1, cpF2, pDS ))
+                if (AreConnex( resWire, aWire, pDS ))
 		  {
 		    Candidates.Append( 1 );
 		    break;
@@ -1778,7 +1771,7 @@ void BRepOffset_Tool::Inter3D(const Topo
 		    //if (anEdge.IsSame(edges(Candidates.First())))
 		    //continue;
 		    aWire = BRepLib_MakeWire( anEdge );
-                    if (AreConnex( resWire, aWire, cpF1, cpF2, pDS ))
+                    if (AreConnex( resWire, aWire, pDS ))
 		      Candidates.Append( j );
 		  }
 		Standard_Integer minind = 1;
@@ -1823,13 +1816,13 @@ void BRepOffset_Tool::Inter3D(const Topo
 		      {
 			TopoDS_Vertex V1, V2;
 			TopExp::Vertices( anEdge, V1, V2 );
-                        if (!IsAutonomVertex( V1, cpF1, cpF2, pDS ))
+                        if (!IsAutonomVertex( V1, pDS ))
 			  {
 			    StartVertex = V2;
 			    StartEdge = anEdge;
 			    StartFound = Standard_True;
 			  }
-                        else if (!IsAutonomVertex( V2, cpF1, cpF2, pDS ))
+                        else if (!IsAutonomVertex( V2, pDS ))
 			  {
 			    StartVertex = V1;
 			    StartEdge = anEdge;
Index: oce/src/BRepOffsetAPI/BRepOffsetAPI_MiddlePath.cxx
===================================================================
--- oce.orig/src/BRepOffsetAPI/BRepOffsetAPI_MiddlePath.cxx
+++ oce/src/BRepOffsetAPI/BRepOffsetAPI_MiddlePath.cxx
@@ -609,17 +609,17 @@ void BRepOffsetAPI_MiddlePath::Build()
           if (E2.IsNull())
             E2 = TopoDS::Edge(myPaths((j<=NbPaths)? j : 1)(i-1));
           Standard_Real fpar1, lpar1, fpar2, lpar2;
-          Standard_Real FirstPar1, LastPar1, FirstPar2, LastPar2;
+          Standard_Real LastPar1, LastPar2;
           Handle(Geom2d_Curve) PCurve1 = BRep_Tool::CurveOnSurface(E1, theFace, fpar1, lpar1);
           Handle(Geom2d_Curve) PCurve2 = BRep_Tool::CurveOnSurface(E2, theFace, fpar2, lpar2);
           if (E1.Orientation() == TopAbs_FORWARD)
-          { FirstPar1 = fpar1; LastPar1 = lpar1; }
+          { LastPar1 = lpar1; }
           else
-          { FirstPar1 = lpar1; LastPar1 = fpar1; }
+          { LastPar1 = fpar1; }
           if (E2.Orientation() == TopAbs_FORWARD)
-          { FirstPar2 = fpar2; LastPar2 = lpar2; }
+          { LastPar2 = lpar2; }
           else
-          { FirstPar2 = lpar2; LastPar2 = fpar2; }
+          { LastPar2 = fpar2; }
           gp_Pnt2d FirstPnt2d = PCurve1->Value(LastPar1);
           gp_Pnt2d LastPnt2d  = PCurve2->Value(LastPar2);
           Handle(Geom_Surface) theSurf = BRep_Tool::Surface(theFace);
Index: oce/src/BRepSweep/BRepSweep_Rotation.cxx
===================================================================
--- oce.orig/src/BRepSweep/BRepSweep_Rotation.cxx
+++ oce/src/BRepSweep/BRepSweep_Rotation.cxx
@@ -344,11 +344,6 @@ TopoDS_Shape  BRepSweep_Rotation::MakeEm
       break;
     case GeomAbs_Cylinder :
       {
-#ifdef DEB
-	gp_Cylinder c = AS.Cylinder();
-	gp_Ax3 b = AS.Axis();
-	gp_Ax3 a = c.Position();
-#endif
 	Handle(Geom_CylindricalSurface) Cy = 
 	  new Geom_CylindricalSurface(AS.Cylinder());
 	S = Cy;
Index: oce/src/BRepTest/BRepTest_BasicCommands.cxx
===================================================================
--- oce.orig/src/BRepTest/BRepTest_BasicCommands.cxx
+++ oce/src/BRepTest/BRepTest_BasicCommands.cxx
@@ -270,8 +270,6 @@ static Standard_Integer nurbsconvert(Dra
 static Standard_Integer mkedgecurve (Draw_Interpretor& ,Standard_Integer n,const char** a)
 {
 
-  Standard_Boolean CurveDone ;
-
   if (n < 3) return 1;
   Standard_Real Tolerance = Draw::Atof(a[2]) ;
 
@@ -279,7 +277,6 @@ static Standard_Integer mkedgecurve (Dra
   
   if (S.IsNull()) return 1;
   
-   CurveDone = 
    BRepLib::BuildCurves3d(S,
 			  Tolerance) ;
    return 0 ;
Index: oce/src/BRepTest/BRepTest_CurveCommands.cxx
===================================================================
--- oce.orig/src/BRepTest/BRepTest_CurveCommands.cxx
+++ oce/src/BRepTest/BRepTest_CurveCommands.cxx
@@ -946,7 +946,6 @@ static Standard_Integer bsplineprof(Draw
   Standard_Boolean face  = Standard_True;
   Standard_Boolean close = Standard_True;
 //  Standard_Boolean first = Standard_True;
-  Standard_Boolean stayfirst = Standard_False;
   Standard_Boolean isplanar  = Standard_True;
   Standard_Real  length ; 
   TopoDS_Shape S;
@@ -976,7 +975,6 @@ static Standard_Integer bsplineprof(Draw
           else 
             P = Plane->Pln();
         }
-        stayfirst = Standard_True;
         i += 1 ;
         break;
 
Index: oce/src/BSplCLib/BSplCLib.cxx
===================================================================
--- oce.orig/src/BSplCLib/BSplCLib.cxx
+++ oce/src/BSplCLib/BSplCLib.cxx
@@ -3110,7 +3110,6 @@ void  BSplCLib::Eval
   NewRequest,
   ExtrapolatingFlag[2],
   ErrorCode,
-  ReturnCode,
   Order = Degree + 1,
   FirstNonZeroBsplineIndex,
   LocalRequest = DerivativeRequest ;
@@ -3180,7 +3179,6 @@ void  BSplCLib::Eval
 			       FirstNonZeroBsplineIndex,
 			       BsplineBasis) ;
   if (ErrorCode != 0) {
-    ReturnCode = 1 ;
     goto FINISH ;
   }
   if (ExtrapolatingFlag[0] == 0 && ExtrapolatingFlag[1] == 0) {
@@ -3311,7 +3309,6 @@ void  BSplCLib::Eval
   NewRequest,
   ExtrapolatingFlag[2],
   ErrorCode,
-  ReturnCode,
   Order = Degree + 1,
   FirstNonZeroBsplineIndex,
   LocalRequest = DerivativeRequest ;
@@ -3381,7 +3378,6 @@ void  BSplCLib::Eval
 			       FirstNonZeroBsplineIndex,
 			       BsplineBasis);
   if (ErrorCode != 0) {
-    ReturnCode = 1 ;
     goto FINISH ;
   }
   if (ExtrapolatingFlag[0] == 0 && ExtrapolatingFlag[1] == 0) {
Index: oce/src/BiTgte/BiTgte_Blend.cxx
===================================================================
--- oce.orig/src/BiTgte/BiTgte_Blend.cxx
+++ oce/src/BiTgte/BiTgte_Blend.cxx
@@ -229,8 +229,6 @@ static void KPartCurve3d(TopoDS_Edge
   TopLoc_Location Loc;
   Standard_Real Tol = Precision::Confusion();
 
-  Standard_Boolean IsComputed = Standard_False;
-
   // Seach only isos on analytical surfaces.
   Geom2dAdaptor_Curve C(Curve);
   GeomAdaptor_Surface S(Surf);
@@ -261,7 +259,6 @@ static void KPartCurve3d(TopoDS_Edge
 	      Circle->Reverse();
 	    TheBuilder.UpdateEdge(Edge, Circle, Loc, Tol);
 	  }
-	  IsComputed = Standard_True;
 	}
 	else if ( STy == GeomAbs_Cylinder) {
 	  gp_Cylinder Cyl  = S.Cylinder();
@@ -277,7 +274,6 @@ static void KPartCurve3d(TopoDS_Edge
 	  if ( D.IsOpposite(gp::DX2d(),Precision::Angular())) 
 	    Circle->Reverse();
 	  TheBuilder.UpdateEdge(Edge, Circle, Loc, Tol);
-	  IsComputed = Standard_True;
 	}
 	else if ( STy == GeomAbs_Cone) {
 	  gp_Cone  Cone = S.Cone();
@@ -294,7 +290,6 @@ static void KPartCurve3d(TopoDS_Edge
 	  if ( D.IsOpposite(gp::DX2d(),Precision::Angular())) 
 	    Circle->Reverse();
 	  TheBuilder.UpdateEdge(Edge, Circle, Loc, Tol);
-	  IsComputed = Standard_True;
 	}
 	else if ( STy == GeomAbs_Torus) {
 	  gp_Torus Tore = S.Torus();
@@ -311,7 +306,6 @@ static void KPartCurve3d(TopoDS_Edge
 	  if ( D.IsOpposite(gp::DX2d(),Precision::Angular())) 
 	    Circle->Reverse();
 	  TheBuilder.UpdateEdge(Edge, Circle, Loc, Tol);
-	  IsComputed = Standard_True;
 	}
       }
       else if ( D.IsParallel(gp::DY2d(),Precision::Angular())) { // Iso U.
@@ -336,7 +330,6 @@ static void KPartCurve3d(TopoDS_Edge
 	  if ( D.IsOpposite(gp::DY2d(),Precision::Angular())) 
 	    Circle->Reverse();
 	  TheBuilder.UpdateEdge(Edge, Circle, Loc, Tol);
-	  IsComputed = Standard_True;
 	}
 	else if ( STy == GeomAbs_Cylinder) {
 	  gp_Cylinder Cyl = S.Cylinder();
@@ -351,7 +344,6 @@ static void KPartCurve3d(TopoDS_Edge
 	  if ( D.IsOpposite(gp::DY2d(),Precision::Angular()))
 	    Line->Reverse();
 	  TheBuilder.UpdateEdge(Edge, Line, Loc, Tol);
-	  IsComputed = Standard_True;
 	}
 	else if ( STy == GeomAbs_Cone) {
 	  gp_Cone  Cone = S.Cone();
@@ -366,7 +358,6 @@ static void KPartCurve3d(TopoDS_Edge
 	  if ( D.IsOpposite(gp::DY2d(),Precision::Angular()))
 	    Line->Reverse();
 	  TheBuilder.UpdateEdge(Edge, Line, Loc, Tol);
-	  IsComputed = Standard_True;
 	}
 	else if ( STy == GeomAbs_Torus) {
 	}
@@ -376,7 +367,6 @@ static void KPartCurve3d(TopoDS_Edge
   else { // Case Plane
     Handle(Geom_Curve) C3d = GeomAPI::To3d(Curve,S.Plane());
     TheBuilder.UpdateEdge(Edge, C3d, Loc, Tol);
-    IsComputed = Standard_True;
   }
 }
 
@@ -1897,8 +1887,6 @@ void BiTgte_Blend::ComputeSurfaces()
   // Iteration on the edges lines of center
   // and their valid valid part is taken after cut and tube construction.
   // --------------------------------------------------------------------
-  BRepOffset_Type    OT = BRepOffset_Concave;
-  if (myRadius < 0.) OT = BRepOffset_Convex; 
 
   //TopTools_MapIteratorOfMapOfShape ic(myEdges);
   Standard_Integer i;
Index: oce/src/Bisector/Bisector_BisecAna.cxx
===================================================================
--- oce.orig/src/Bisector/Bisector_BisecAna.cxx
+++ oce/src/Bisector/Bisector_BisecAna.cxx
@@ -204,7 +204,7 @@ void Bisector_BisecAna::Perform(const Ha
 
   Standard_Boolean ok;
   Standard_Real    distanceptsol,parameter,firstparameter =0.;
-  Standard_Boolean thesense = Standard_False,sense,theSense;
+  Standard_Boolean thesense = Standard_False,sense;
   Standard_Real    distancemini;
   Standard_Integer nbsolution;
   Standard_Real    PreConf = Precision::Confusion();
@@ -407,7 +407,6 @@ void Bisector_BisecAna::Perform(const Ha
 	}
 	else {ok = Standard_True;}
 
-	theSense = sense;
 	if (ok) {
 	  sense = Standard_False;
 //  Modified by skv - Tue Feb 15 17:51:29 2005 Integration Begin
@@ -560,7 +559,6 @@ void Bisector_BisecAna::Perform(const Ha
 	sense = Standard_True;
 	distanceptsol = Distance(apoint,solution,tan1,tan2,
 				 adirection,parameter,sense,ok);
-	theSense = sense;
 	if (ok || !oncurve) {
 	  sense = Standard_False;
 //  Modified by skv - Tue Feb 15 17:51:29 2005 Integration Begin
@@ -764,7 +762,7 @@ void Bisector_BisecAna::Perform(const Ha
 				const Standard_Boolean      oncurve       )
 {
   Standard_Boolean ok;
-  Standard_Boolean thesense = Standard_False,sense,theSense;
+  Standard_Boolean thesense = Standard_False,sense;
   Standard_Real    distanceptsol,parameter,firstparameter =0.,secondparameter;
   Handle(Geom2d_Curve) curve;
   Handle(GccInt_Bisec) TheSol;
@@ -917,7 +915,6 @@ void Bisector_BisecAna::Perform(const Ha
     case 2 : {
       GccAna_LinPnt2dBisec Bisector(line,asecondpoint->Pnt2d());
       
-      theSense = Standard_True;
 #ifdef DEB
       gp_Vec2d V(line.Direction());
 #else
@@ -1022,14 +1019,14 @@ void Bisector_BisecAna::Perform(const Ha
 				const Standard_Boolean      oncurve       )
 {
   Standard_Boolean sense,ok;
-  Standard_Real distanceptsol,parameter;
+  Standard_Real parameter;
 
   GccAna_Pnt2dBisec bisector(afirstpoint->Pnt2d(),asecondpoint->Pnt2d());
   gp_Lin2d line = bisector.ThisSolution();
   Handle(GccInt_Bisec) solution = new GccInt_BLine(line);
 
   sense = Standard_False;
-  distanceptsol = Distance(apoint,solution,
+  Distance(apoint,solution,
 			   afirstvector,asecondvector,
 			   adirection,parameter,sense,ok);
   if (ok || !oncurve) {
Index: oce/src/Bisector/Bisector_BisecPC.cxx
===================================================================
--- oce.orig/src/Bisector/Bisector_BisecPC.cxx
+++ oce/src/Bisector/Bisector_BisecPC.cxx
@@ -597,13 +597,12 @@ gp_Vec2d Bisector_BisecPC::DN (const Sta
 Standard_Real Bisector_BisecPC::SearchBound (const Standard_Real U1,
 					     const Standard_Real U2) const
 {
-  Standard_Real Dist1,Dist2,DistMid,U11,U22; 
+  Standard_Real Dist1,DistMid,U11,U22; 
   Standard_Real UMid = 0.;
   Standard_Real Tol      = Precision::PConfusion();
   Standard_Real DistMax2 = distMax*distMax;
   U11 = U1; U22 = U2;
   Dist1 = Distance(U11);
-  Dist2 = Distance(U22);
   
   while ((U22 - U11) > Tol) {
     UMid    = 0.5*( U22 + U11);
@@ -614,7 +613,6 @@ Standard_Real Bisector_BisecPC::SearchBo
     }
     else {
       U22    = UMid;
-      Dist2 = DistMid;
     }
   }
   return UMid;
Index: oce/src/Blend/Blend_CSWalking_2.gxx
===================================================================
--- oce.orig/src/Blend/Blend_CSWalking_2.gxx
+++ oce/src/Blend/Blend_CSWalking_2.gxx
@@ -166,7 +166,7 @@ Blend_Status Blend_CSWalking::CheckDefle
 
   Standard_Real Norme, prevNorme, Cosi, Cosi2; // JAG MODIF 25.04.94
   Standard_Real FlecheCourante;
-  Standard_Real Du,Dv,Duv,SqrtDuv;
+  Standard_Real Du,Dv,Duv;
   Standard_Real paramu,paramv,tolu,tolv;
 //  TColgp_Array1OfPnt Poles(1,4);
 //  gp_Pnt POnCurv,Milieu;
@@ -204,7 +204,6 @@ Blend_Status Blend_CSWalking::CheckDefle
   Du = Ponsurf.X() - paramu;
   Dv = Ponsurf.Y() - paramv;
   Duv = Du * Du + Dv * Dv;
-  SqrtDuv = Sqrt(Duv);
   if ((Abs(Du) < tolu && Abs(Dv) < tolv) ||  // JAG MODIF 25.04.94
       (Abs(previousd2d.X()) < tolu && Abs(previousd2d.Y()) < tolv)){
     // il faudra peut etre  forcer meme point   JAG MODIF 25.04.94
Index: oce/src/Blend/Blend_Walking_1.gxx
===================================================================
--- oce.orig/src/Blend/Blend_Walking_1.gxx
+++ oce/src/Blend/Blend_Walking_1.gxx
@@ -182,8 +182,6 @@ Standard_Boolean Blend_Walking::PerformF
 
   Pos1 = Pos2 = TopAbs_UNKNOWN;
 
-  Blend_Status State;
-
   param = Pdep;
   Func.Set(param);
 
@@ -207,7 +205,7 @@ Standard_Boolean Blend_Walking::PerformF
     return Standard_False;
   }
 
-  State = TestArret(Func, Blend_OK, Standard_False);
+  TestArret(Func, Blend_OK, Standard_False);
 #ifdef DEB
   if (Blend_GettraceDRAWSECT()){
     Drawsect(surf1,surf2,sol,param,Func);
Index: oce/src/BlendFunc/BlendFunc_Chamfer.cxx
===================================================================
--- oce.orig/src/BlendFunc/BlendFunc_Chamfer.cxx
+++ oce/src/BlendFunc/BlendFunc_Chamfer.cxx
@@ -23,9 +23,6 @@
 #include <ElCLib.hxx>
 #include <Precision.hxx>
 #include <Standard_NotImplemented.hxx>
-#ifdef DEB
-static Standard_Boolean putsderivatives = 0;
-#endif
 
 //=======================================================================
 //function : BlendFunc_Chamfer
Index: oce/src/BlendFunc/BlendFunc_ConstRad.cxx
===================================================================
--- oce.orig/src/BlendFunc/BlendFunc_ConstRad.cxx
+++ oce/src/BlendFunc/BlendFunc_ConstRad.cxx
@@ -1159,9 +1159,8 @@ void BlendFunc_ConstRad::Section(const S
   math_Vector X(1,4);
   X(1) = U1; X(2) = V1; X(3) = U2; X(4) = V2; 
   Standard_Real prm = Param;
-  Standard_Boolean Ok;
 
-  Ok = ComputeValues(X, 0, Standard_True, prm);
+  ComputeValues(X, 0, Standard_True, prm);
 
   ns1 = nsurf1;
   np = nplan;
@@ -1318,7 +1317,6 @@ void BlendFunc_ConstRad::Section(const B
 
   math_Vector X(1,4);
   Standard_Real prm = P.Parameter();
-  Standard_Boolean Ok;
 
   Standard_Integer low = Poles.Lower();
   Standard_Integer upp = Poles.Upper();
@@ -1326,7 +1324,7 @@ void BlendFunc_ConstRad::Section(const B
   P.ParametersOnS1(X(1), X(2));
   P.ParametersOnS2(X(3), X(4));
 
-  Ok = ComputeValues(X, 0, Standard_True, prm);
+  ComputeValues(X, 0, Standard_True, prm);
   distmin = Min (distmin, pts1.Distance(pts2));
 
   // ns1, ns2, np are copied locally to avoid crushing the fields !
Index: oce/src/BlendFunc/BlendFunc_EvolRad.cxx
===================================================================
--- oce.orig/src/BlendFunc/BlendFunc_EvolRad.cxx
+++ oce/src/BlendFunc/BlendFunc_EvolRad.cxx
@@ -1142,9 +1142,8 @@ void BlendFunc_EvolRad::Section(const St
   math_Vector X(1,4);
   X(1) = U1; X(2) = V1; X(3) = U2; X(4) = V2; 
   Standard_Real prm = Param;
-  Standard_Boolean Ok;
 
-  Ok = ComputeValues(X, 0, Standard_True, prm);
+  ComputeValues(X, 0, Standard_True, prm);
 
   ns1 = nsurf1;
   np = nplan;
@@ -1415,7 +1414,6 @@ void BlendFunc_EvolRad::Section(const Bl
 
   math_Vector X(1,4);
   Standard_Real prm = P.Parameter();
-  Standard_Boolean Ok;
 
   Standard_Integer low = Poles.Lower();
   Standard_Integer upp = Poles.Upper();
@@ -1424,7 +1422,7 @@ void BlendFunc_EvolRad::Section(const Bl
   P.ParametersOnS2(X(3), X(4));
 
   // Calculation and storage of distmin
-  Ok = ComputeValues(X, 0, Standard_True, prm);
+  ComputeValues(X, 0, Standard_True, prm);
   distmin = Min (distmin, pts1.Distance(pts2));
 
   // ns1, ns2, np are copied locally to avoid crashing the fields !
Index: oce/src/Bnd/Bnd_BoundSortBox.cxx
===================================================================
--- oce.orig/src/Bnd/Bnd_BoundSortBox.cxx
+++ oce/src/Bnd/Bnd_BoundSortBox.cxx
@@ -636,11 +636,10 @@ const TColStd_ListOfInteger& Bnd_BoundSo
   //-- Rejection with the table of bits
   Standard_Boolean touch = Standard_True;
   touch = Standard_False;
-  Standard_Real _Xmin,_Ymin,_Zmin,_Xmax,_Ymax,_Zmax;
+  Standard_Real _Xmax,_Ymax,_Zmax;
   BSB_T3Bits* Map = (BSB_T3Bits *)TabBits;
   Standard_Real xmin, ymin, zmin, xmax, ymax, zmax;
   _Xmax=Map->Xmax; _Ymax=Map->Ymax; _Zmax=Map->Zmax;
-  _Xmin=Map->Xmin; _Ymin=Map->Ymin; _Zmin=Map->Zmin;
   theBox.Get(xmin, ymin, zmin, xmax, ymax, zmax);
   Standard_Integer i0,i1,j0,j1,k0,k1;
   if(xmin>Xmin) i0=(Standard_Integer )((xmin-Xmin)*deltaX)-1; else  i0=1;
Index: oce/src/CSLib/CSLib_Class2d.cxx
===================================================================
--- oce.orig/src/CSLib/CSLib_Class2d.cxx
+++ oce/src/CSLib/CSLib_Class2d.cxx
@@ -231,9 +231,8 @@ Standard_Integer CSLib_Class2d::Internal
   Standard_Integer nbc, i, ip1, SH, NH, iRet;
   Standard_Real *Pnts2dX, *Pnts2dY;
   Standard_Real x, y, nx, ny, aX;
-  Standard_Real aYmin, aTol;
+  Standard_Real aYmin;
   //
-  aTol=(Tolu>Tolv)? Tolu : Tolv;
   nbc = 0;
   i   = 0;
   ip1 = 1;
Index: oce/src/ChFi2d/ChFi2d_Builder.cxx
===================================================================
--- oce.orig/src/ChFi2d/ChFi2d_Builder.cxx
+++ oce/src/ChFi2d/ChFi2d_Builder.cxx
@@ -756,10 +756,9 @@ TopoDS_Edge ChFi2d_Builder::BuildFilletE
   //    The first arc is found.                                        +
   //========================================================================
 
-  TopAbs_Orientation O1,O2;
-  TopAbs_Orientation OE1,OE2;
+  TopAbs_Orientation O1;
+  TopAbs_Orientation OE1;
   OE1 = E1.Orientation();
-  OE2 = E2.Orientation();
   E1.Orientation(TopAbs_FORWARD);
   E2.Orientation(TopAbs_FORWARD);
   TopoDS_Shape aLocalShape = E1.EmptyCopied();
@@ -787,12 +786,10 @@ TopoDS_Edge ChFi2d_Builder::BuildFilletE
   if (V3.IsSame(V)) {
     param3 = BRep_Tool::Parameter(V3,E2);
     param4 = BRep_Tool::Parameter(V4,E2);
-    O2 = V4.Orientation();
   }
   else {
     param3 = BRep_Tool::Parameter(V4,E2);
     param4 = BRep_Tool::Parameter(V3,E2);
-    O2 = V3.Orientation();
   }
   
   //========================================================================
Index: oce/src/ChFi3d/ChFi3d_Builder_2.cxx
===================================================================
--- oce.orig/src/ChFi3d/ChFi3d_Builder_2.cxx
+++ oce/src/ChFi3d/ChFi3d_Builder_2.cxx
@@ -2283,7 +2283,7 @@ void ChFi3d_Builder::PerformSetOfKPart(H
   Handle(ChFiDS_Spine)&        Spine = Stripe->ChangeSpine();
   Handle(BRepAdaptor_HSurface) HS1,HS2;
   TopAbs_Orientation           Or1,Or2,RefOr1,RefOr2;
-  Standard_Integer             Choix,RefChoix;
+  Standard_Integer             RefChoix;
   
   // initialization of the stripe.
   Stripe->Reset();
@@ -2327,7 +2327,7 @@ void ChFi3d_Builder::PerformSetOfKPart(H
       intl = ((iedge == Spine->NbEdges()) && !Spine->IsPeriodic());
       Or1   = HS1->ChangeSurface().Face().Orientation();
       Or2   = HS2->ChangeSurface().Face().Orientation();
-      Choix = ChFi3d::NextSide(Or1,Or2,RefOr1,RefOr2,RefChoix);      
+      ChFi3d::NextSide(Or1,Or2,RefOr1,RefOr2,RefChoix);      
       It1->Initialize(HS1);
       It2->Initialize(HS2);
       
Index: oce/src/ChFi3d/ChFi3d_Builder_C1.cxx
===================================================================
--- oce.orig/src/ChFi3d/ChFi3d_Builder_C1.cxx
+++ oce/src/ChFi3d/ChFi3d_Builder_C1.cxx
@@ -3631,7 +3631,7 @@ Standard_Boolean ChFi3d_Builder::FindFac
     return Standard_False;
   }
   TopTools_ListIteratorOfListOfShape It,Jt;
-  Standard_Boolean Found = Standard_False, ContainsV = Standard_False;
+  Standard_Boolean Found = Standard_False;
   for(It.Initialize(myEFMap(P1.Arc()));It.More() && !Found;It.Next()) {
     Fv = TopoDS::Face(It.Value());
     if(!Fv.IsSame(Favoid)){
@@ -3640,6 +3640,8 @@ Standard_Boolean ChFi3d_Builder::FindFac
       }
     }
   }
+#ifdef DEB
+  Standard_Boolean ContainsV = Standard_False;
   if (Found) {
     for(It.Initialize(myVFMap(V));It.More();It.Next()) {
       if (TopoDS::Face(It.Value()).IsSame(Fv)) {
@@ -3648,10 +3650,11 @@ Standard_Boolean ChFi3d_Builder::FindFac
       }
     }
   }
-#ifdef DEB
   if(!ContainsV){
     cout<<"FindFace : the extremity of the spine is not in the end face"<<endl;
   }
+#else
+  (void)V; // avoid compiler warning on unused variable
 #endif
   return Found;
 }
@@ -3823,10 +3826,9 @@ void ChFi3d_Builder::IntersectMoreCorner
     if(!CV1.IsOnArc() && !CV2.IsOnArc())
       Standard_Failure::Raise("Corner intersmore : no point on arc");
     else if(CV1.IsOnArc() && CV2.IsOnArc()){
-      Standard_Boolean sur1 = 0, sur2 = 0;
+      Standard_Boolean sur2 = 0;
       for(ex.Init(CV1.Arc(),TopAbs_VERTEX); ex.More(); ex.Next()){
 	if(Vtx.IsSame(ex.Current())) {
-	  sur1 = 1;
 	  break;
 	}
       }
Index: oce/src/ChFi3d/ChFi3d_FilBuilder.cxx
===================================================================
--- oce.orig/src/ChFi3d/ChFi3d_FilBuilder.cxx
+++ oce/src/ChFi3d/ChFi3d_FilBuilder.cxx
@@ -1400,8 +1400,6 @@ void  ChFi3d_FilBuilder::PerformSurf(ChF
     maybesingular = (func.GetMinimalDistance()<=100*tolapp3d); 
   }
   else {
-   Standard_Real SpFirst = HGuide->FirstParameter();
-  Standard_Real SpLast =  HGuide->LastParameter();
     BRepBlend_SurfRstEvolRad func(HS2,HS1,PC1,HGuide,fsp->Law(HGuide));
     func.Set(HSref1,PCref1);
     Handle(Adaptor3d_HCurveOnSurface) HC = new Adaptor3d_HCurveOnSurface();
@@ -1419,7 +1417,6 @@ void  ChFi3d_FilBuilder::PerformSurf(ChF
     finvp.Set(petitchoix);
     func.Set(petitchoix);
     func.Set(myShape);
-    SpFirst = HGuide->FirstParameter();SpLast =  HGuide->LastParameter();
     done = ComputeData(Data,HGuide,lin,HS2,I2,HS1,PC1,I1,Decroch1,
 		       func,finv,finvp,finvc,
 		       PFirst,MaxStep,Fleche,TolGuide,First,Last,
@@ -1881,7 +1878,6 @@ void ChFi3d_FilBuilder::ExtentTwoCorner(
   // to faces and tangents to the guideline.
   Standard_Integer Sens;
   Standard_Real    Coeff = 0.3, Eval=0.0, dU, rad;
-  Standard_Integer IE;
   ChFiDS_ListIteratorOfListOfStripe itel(LS);
   Standard_Boolean FF = Standard_True;
   Handle(ChFiDS_Stripe) Stripe;
@@ -1911,7 +1907,7 @@ void ChFi3d_FilBuilder::ExtentTwoCorner(
 
   // One applies
   for (itel.Initialize(LS) ; itel.More(); itel.Next()) {    
-    IE = ChFi3d_IndexOfSurfData(V,itel.Value(),Sens);
+    ChFi3d_IndexOfSurfData(V,itel.Value(),Sens);
     if (!FF && Stripe == itel.Value()) Sens = -Sens;
     Stripe = itel.Value();
     Spine = Stripe->Spine();
Index: oce/src/ChFiDS/ChFiDS_FilSpine.cxx
===================================================================
--- oce.orig/src/ChFiDS/ChFiDS_FilSpine.cxx
+++ oce/src/ChFiDS/ChFiDS_FilSpine.cxx
@@ -181,9 +181,6 @@ void  ChFiDS_FilSpine::SetRadius(const g
     Handle(ChFiDS_HElSpine) Els = It.Value();
     if (Els->IsPeriodic()) Itl.Value() = ComputeLaw(Els);
     else{
-      Standard_Real nW = W;
-      if(IsPeriodic())
-	nW = ElCLib::InPeriod(W,FirstParameter(),LastParameter());
       for (; It.More(); It.Next(), Itl.Next()) {
 	Els = It.Value();
 	Standard_Real uf = Els->FirstParameter();
Index: oce/src/ChFiKPart/ChFiKPart_ComputeData_FilPlnCyl.cxx
===================================================================
--- oce.orig/src/ChFiKPart/ChFiKPart_ComputeData_FilPlnCyl.cxx
+++ oce/src/ChFiKPart/ChFiKPart_ComputeData_FilPlnCyl.cxx
@@ -77,13 +77,12 @@ Standard_Boolean ChFiKPart_MakeFillet(To
 
   // Parallel cylinder
   Standard_Real    ROff = Cyl.Radius();
-  Standard_Boolean dedans = Standard_False;
 
   if ((Or2 == TopAbs_FORWARD  &&  Cyl.Direct()) ||
       (Or2 == TopAbs_REVERSED && !Cyl.Direct()))
       ROff+=Radius;
   else if (Radius < ROff)  {
-    ROff-=Radius;dedans = Standard_True;
+    ROff-=Radius;
   }
   else {
 #ifdef DEB
Index: oce/src/DDataStd/DDataStd_DrawDriver.cxx
===================================================================
--- oce.orig/src/DDataStd/DDataStd_DrawDriver.cxx
+++ oce/src/DDataStd/DDataStd_DrawDriver.cxx
@@ -68,12 +68,6 @@ static Standard_Integer DISCRET    = 100
 static Standard_Integer NBISOS     = 10;
 static Standard_Real    THESIZE       = 1000.;
 
-// Unused
-#ifdef DEB
-static Standard_Real    PLANETHESIZE  = 100.;
-static Standard_Real    DEFLECTION = 0.0;
-#endif
-
 static Handle(DDataStd_DrawDriver) DrawDriver;
 
 
Index: oce/src/Draw/Draw_VariableCommands.cxx
===================================================================
--- oce.orig/src/Draw/Draw_VariableCommands.cxx
+++ oce/src/Draw/Draw_VariableCommands.cxx
@@ -842,9 +842,10 @@ void Draw::Set(const Standard_CString Na
 Handle(Draw_Drawable3D) Draw::Get(Standard_CString& name, 
 			          const Standard_Boolean )
 {
+#if !((TCL_MAJOR_VERSION > 8) || ((TCL_MAJOR_VERSION == 8) && (TCL_MINOR_VERSION >= 4))) || defined(USE_NON_CONST)
   Standard_PCharacter pName;
-  //
   pName=(Standard_PCharacter)name;
+#endif
   //
   Standard_Boolean pick = ((name[0] == '.') && (name[1] == '\0'));
   Handle(Draw_Drawable3D) D;
Index: oce/src/Draw/Draw_Window.cxx
===================================================================
--- oce.orig/src/Draw/Draw_Window.cxx
+++ oce/src/Draw/Draw_Window.cxx
@@ -801,8 +801,7 @@ void Draw_Window::Wait (Standard_Boolean
 
 void ProcessEvent(Draw_Window& win, XEvent& xev)
 {
-  Standard_Integer X,Y,button,lenk;
-  char c;
+  Standard_Integer X,Y,button;
   KeySym keysym;
   XComposeStatus stat;
   char chainekey[10];
@@ -829,17 +828,11 @@ void ProcessEvent(Draw_Window& win, XEve
     break;
 
   case KeyPress :
-    lenk = XLookupString(&(xev.xkey),
+    XLookupString(&(xev.xkey),
                          chainekey,
                          10,
                          &keysym,
                          &stat);
-    if (lenk==1)
-      c = chainekey[0];
-    else
-      c = '\0';
-
-    //WKeyPress(c,keysym);
     break;
 
   case MotionNotify :
Index: oce/src/DrawDim/DrawDim_Angle.cxx
===================================================================
--- oce.orig/src/DrawDim/DrawDim_Angle.cxx
+++ oce/src/DrawDim/DrawDim_Angle.cxx
@@ -101,9 +101,6 @@ void DrawDim_Angle::DrawOn(Draw_Display&
 
 
   // output
-#ifdef DEB
-  gp_Dir myDirAttach;
-#endif
   gp_Pnt myFAttach;
   gp_Pnt mySAttach;
   gp_Pnt myPosition(0.,0.,0.);
@@ -111,8 +108,6 @@ void DrawDim_Angle::DrawOn(Draw_Display&
   gp_Dir myFDir;
   gp_Dir mySDir;
   Standard_Boolean myAutomaticPosition = Standard_True;
-  
-
 
   // calculation of myAxis
   gp_Pln pln1, pln2;
@@ -120,24 +115,6 @@ void DrawDim_Angle::DrawOn(Draw_Display&
   if (!DrawDim::Pln(myPlane2,pln2)) return; 
   IntAna_QuadQuadGeo ip (pln1,pln2,Precision::Confusion(), Precision::Angular());
   if (!ip.IsDone()) return;
-#ifdef DEB
-  gp_Lin linter =
-#endif
-                  ip.Line(1);
-  
-  //Handle(Geom_Surface) curve1 = BRep_Tool::Surface(myPlane1);
-  //Handle(Geom_PlaneLine) line1 = Handle(Geom_Line)::DownCast(curve1);    
-  
-
-
-//=======================================================================
-//function : ComputeTwoFacesAngle
-//purpose  : 
-//=======================================================================
-
-// void AIS_AngleDimension::ComputeTwoFacesAngle(const Handle(Prs3d_Presentation)& aPresentation)
-// {
-  // Return planes
  
   gp_Pnt curpos;
   gp_Ax1 AxePos = myAxis;      
Index: oce/src/DrawDim/DrawDim_PlanarAngle.cxx
===================================================================
--- oce.orig/src/DrawDim/DrawDim_PlanarAngle.cxx
+++ oce/src/DrawDim/DrawDim_PlanarAngle.cxx
@@ -49,14 +49,6 @@
 #include <DBRep_DrawableShape.hxx>
 #include <TopoDS.hxx>
 
-#ifdef DEB
-static Standard_Integer DISCRET    = 100;
-static Standard_Integer NBISOS     = 2;
-static Standard_Real    SIZE       = 100.;
-static Standard_Real    DEFLECTION = 0.0;
-static Standard_Real    RAP        = 0.4;
-#endif
-
 //=======================================================================
 //function : DrawDim_PlanarAngle
 //purpose  : 
Index: oce/src/DrawTrSurf/DrawTrSurf.cxx
===================================================================
--- oce.orig/src/DrawTrSurf/DrawTrSurf.cxx
+++ oce/src/DrawTrSurf/DrawTrSurf.cxx
@@ -392,8 +392,6 @@ static Standard_Integer draw (Draw_Inter
   if (n <= 2) {
 	if (!strcmp(a[0],"dmode")) {
 	  if (n == 2) {
-	    Standard_Integer mod = 0;
-	    if ((*a[n-1] == 'U')||(*a[n-1] == 'u')) mod = 1;
 	    DrawMode = 1;
 	  }
 	  if (DrawMode)
Index: oce/src/DsgPrs/DsgPrs_DiameterPresentation.cxx
===================================================================
--- oce.orig/src/DsgPrs/DsgPrs_DiameterPresentation.cxx
+++ oce/src/DsgPrs/DsgPrs_DiameterPresentation.cxx
@@ -157,7 +157,6 @@ void DsgPrs_DiameterPresentation::Add (c
   Standard_Real parEndOfArrow = ElCLib::Parameter(aCircle,AttachmentPoint);
   gp_Pnt EndOfArrow;
   gp_Pnt DrawPosition = AttachmentPoint;// point of attachment
-  Standard_Boolean otherside = Standard_False;
 
   gp_Pnt Center = aCircle.Location();
   gp_Pnt FirstPoint = ElCLib::Value(uFirst, aCircle);
@@ -169,7 +168,6 @@ void DsgPrs_DiameterPresentation::Add (c
     if (DsgPrs_InDomain(fpara,lpara,otherpar)) {
       parEndOfArrow = otherpar; // parameter on circle
       EndOfArrow = ElCLib::Value(parEndOfArrow, aCircle);
-      otherside = Standard_True;
     }
     else {
       gp_Dir dir1(gp_Vec(Center, FirstPoint));
Index: oce/src/ExprIntrp/ExprIntrp_yaccintrf.cxx
===================================================================
--- oce.orig/src/ExprIntrp/ExprIntrp_yaccintrf.cxx
+++ oce/src/ExprIntrp/ExprIntrp_yaccintrf.cxx
@@ -70,9 +70,8 @@ static Standard_Integer ExprIntrp_nbdiff
 
 extern "C" void ExprIntrp_StartFunction()
 {
-  int nbcar;
   char funcname[100];
-  nbcar = ExprIntrp_GetResult(funcname);
+  ExprIntrp_GetResult(funcname);
   TCollection_AsciiString name(funcname);
   ExprIntrp_Recept.PushName(name);
   ExprIntrp_nbargs = 0;
@@ -80,9 +79,8 @@ extern "C" void ExprIntrp_StartFunction(
 
 extern "C" void ExprIntrp_StartDerivate()
 {
-  int nbcar;
   char funcname[100];
-  nbcar = ExprIntrp_GetResult(funcname);
+  ExprIntrp_GetResult(funcname);
   TCollection_AsciiString name(funcname);
   ExprIntrp_Recept.PushName(name);
 }
@@ -113,8 +111,7 @@ extern "C" void ExprIntrp_Derivation()
 extern "C" void ExprIntrp_DerivationValue()
 {
   char num[30];
-  int nbcar;
-  nbcar = ExprIntrp_GetResult(num);
+  ExprIntrp_GetResult(num);
   Standard_Integer degree = ExprIntrp_Recept.PopValue();
   degree = atoi(num);
   ExprIntrp_Recept.PushValue(degree);
@@ -461,8 +458,7 @@ extern "C" void ExprIntrp_UnaryMinusOper
 extern "C" void ExprIntrp_VariableIdentifier()
 {
   char name[30];
-  int nbcar;
-  nbcar = ExprIntrp_GetResult(name);
+  ExprIntrp_GetResult(name);
   TCollection_AsciiString thename(name);
   Handle(Expr_NamedExpression) nameexp = ExprIntrp_Recept.GetNamed(thename);
   if (nameexp.IsNull()) {
@@ -484,15 +480,13 @@ extern "C" void ExprIntrp_NumValue()
 
 extern "C" void ExprIntrp_AssignVariable()
 {
-  int nbcar;
-  nbcar = ExprIntrp_GetResult(ExprIntrp_assname);
+  ExprIntrp_GetResult(ExprIntrp_assname);
 }
 
 extern "C" void ExprIntrp_Deassign()
 {
-  int nbcar;
   char name[100];
-  nbcar = ExprIntrp_GetResult(name);
+  ExprIntrp_GetResult(name);
   TCollection_AsciiString thename(name);
   Handle(Expr_NamedExpression) nameexp = ExprIntrp_Recept.GetNamed(thename);
   if (nameexp.IsNull()) {
Index: oce/src/Extrema/Extrema_ExtElC2d.cxx
===================================================================
--- oce.orig/src/Extrema/Extrema_ExtElC2d.cxx
+++ oce/src/Extrema/Extrema_ExtElC2d.cxx
@@ -94,13 +94,7 @@ Method:
   Standard_Real Dy = D.Dot(y2);
   Standard_Real U1, teta[2];
   gp_Pnt2d O1=C1.Location();
-#ifdef DEB
-  gp_Pnt2d O2= C2.Location();
   gp_Pnt2d P1, P2;
-#else
-  C2.Location();
-  gp_Pnt2d P1, P2;
-#endif
   
   if (Abs(Dy) <= RealEpsilon()) {
     teta[0] = M_PI/2.0;
@@ -146,11 +140,7 @@ Extrema_ExtElC2d::Extrema_ExtElC2d (cons
   Standard_Real Dx = D.Dot(x2);
   Standard_Real Dy = D.Dot(y2);
   Standard_Real U1, teta[2], r1 = C2.MajorRadius(), r2 = C2.MinorRadius();
-#ifdef DEB
-  gp_Pnt2d O1=C1.Location(), O2= C2.Location(), P1, P2;
-#else
   gp_Pnt2d O1=C1.Location(), P1, P2;
-#endif
   
   if (Abs(Dy) <= RealEpsilon()) {
     teta[0] = M_PI/2.0;
Index: oce/src/GCPnts/GCPnts_TangentialDeflection.gxx
===================================================================
--- oce.orig/src/GCPnts/GCPnts_TangentialDeflection.gxx
+++ oce/src/GCPnts/GCPnts_TangentialDeflection.gxx
@@ -366,8 +366,6 @@ void GCPnts_TangentialDeflection::Perfor
     TooSmall   = Standard_False;
     Correction = Standard_True;
 
-    Standard_Real lastCoef = 0;
-     
     while (Correction) {                     //Ajustement Du
       MiddleU = (U1+U2)*0.5;                 //Verif / au point milieu
       D0 (C, MiddleU, MiddlePoint);
@@ -412,7 +410,6 @@ void GCPnts_TangentialDeflection::Perfor
           }
           else {
             TooSmall = Standard_True;
-            lastCoef = Coef;
             //Standard_Real UUU2 = U2;
             Du += Min((U2-U1)*(1.-Coef), Du*Us3);
 
Index: oce/src/GCPnts/GCPnts_UniformAbscissa.gxx
===================================================================
--- oce.orig/src/GCPnts/GCPnts_UniformAbscissa.gxx
+++ oce/src/GCPnts/GCPnts_UniformAbscissa.gxx
@@ -170,7 +170,7 @@ PerformLengthParametrized( Handle(TColSt
 {
   Standard_Boolean NotDone = Standard_True;
 //  Standard_Boolean LocalDone = Standard_True;
-  Standard_Boolean Forward = Standard_True  ;
+//  Standard_Boolean Forward = Standard_True  ;
   Standard_Real UU1 = Min(U1, U2);
 //  Standard_Real UCurrent;
   Standard_Real Delta, Ui;
@@ -184,7 +184,6 @@ PerformLengthParametrized( Handle(TColSt
 
 
   if (Abscissa < 0.0e0)    {
-    Forward = Standard_False ;
     UU2 = Min(U1, U2);
     UU1 = Max(U1, U2);
   }
Index: oce/src/GProp/GProp_SGProps.gxx
===================================================================
--- oce.orig/src/GProp/GProp_SGProps.gxx
+++ oce/src/GProp/GProp_SGProps.gxx
@@ -689,7 +689,7 @@ static void Compute(Face& S, Domain& D,
   Standard_Integer NbCGaussgp_Pnts = 0;
 
   Standard_Real l1, l2, lm, lr, l;   //boundary curve parametrization
-  Standard_Real v1, v2, vm, vr, v;   //Face parametrization in v direction
+  Standard_Real v1, v2,         v;   //Face parametrization in v direction
   Standard_Real u1, u2, um, ur, u;
   Standard_Real ds;                  //Jacobien (x, y, z) -> (u, v) = ||n||
 
@@ -750,11 +750,6 @@ static void Compute(Face& S, Domain& D,
     lm = 0.5 * (l2 + l1);         
     lr = 0.5 * (l2 - l1);
 
-    Puv = S.Value2d (lm);
-    vm  = Puv.Y();
-    Puv = S.Value2d (lr);
-    vr  = Puv.Y();
-
     for (Standard_Integer i = 1; i <= NbCGaussgp_Pnts; i++) {
       l = lm + lr * GaussCP (i);
       S.D12d(l, Puv, Vuv);
Index: oce/src/GccAna/GccAna_Circ2d3Tan_2.cxx
===================================================================
--- oce.orig/src/GccAna/GccAna_Circ2d3Tan_2.cxx
+++ oce/src/GccAna/GccAna_Circ2d3Tan_2.cxx
@@ -118,7 +118,6 @@ pararg3(1,8)
 	       Standard_Real dist2 = L2.Distance(Center);
 	       Standard_Real dist3 = L3.Distance(Center);
 	       Standard_Integer nbsol1 = 0;
-	       Standard_Integer nbsol2 = 0;
 	       Standard_Integer nbsol3 = 0;
 	       Standard_Boolean ok = Standard_False;
 	       if (Qualified1.IsEnclosed()) {
@@ -152,7 +151,6 @@ pararg3(1,8)
 		   for (Standard_Integer ii = 1 ; ii <= nbsol1 ; ii++) {
 		     if (Abs(dist2-Radius(ii)) < Tol) { 
 		       ok = Standard_True;
-		       nbsol2 = 1;
 		       Radius(1) = Radius(ii);
 		     }
 		   }
@@ -164,7 +162,6 @@ pararg3(1,8)
 		   for (Standard_Integer ii = 1 ; ii <= nbsol1 ; ii++) {
 		     if (Abs(dist2-Radius(ii)) < Tol) { 
 		       ok = Standard_True;
-		       nbsol2 = 1;
 		       Radius(1) = Radius(ii);
 		     }
 		   }
@@ -174,7 +171,6 @@ pararg3(1,8)
 		 for (Standard_Integer ii = 1 ; ii <= nbsol1 ; ii++) {
 		   if (Abs(dist2-Radius(ii)) < Tol) { 
 		     ok = Standard_True;
-		     nbsol2 = 1;
 		     Radius(1) = Radius(ii);
 		   }
 		 }
Index: oce/src/GccAna/GccAna_Circ2d3Tan_5.cxx
===================================================================
--- oce.orig/src/GccAna/GccAna_Circ2d3Tan_5.cxx
+++ oce/src/GccAna/GccAna_Circ2d3Tan_5.cxx
@@ -123,7 +123,6 @@ GccAna_Circ2d3Tan::
 	     Standard_Real dist2 = L2.Distance(Center);
 	     Standard_Real dist3 = Center.Distance(Point3);
 	     Standard_Integer nbsol1 = 0;
-	     Standard_Integer nbsol2 = 0;
 	     Standard_Integer nbsol3 = 0;
 	     Standard_Boolean ok = Standard_False;
 	     if (Qualified1.IsEnclosed()) {
@@ -157,7 +156,6 @@ GccAna_Circ2d3Tan::
 		 for (Standard_Integer ii = 1 ; ii <= nbsol1 ; ii++) {
 		   if (Abs(dist2-Radius(ii)) < Tol) { 
 		     ok = Standard_True;
-		     nbsol2 = 1;
 		     Radius(1) = Radius(ii);
 		   }
 		 }
@@ -169,7 +167,6 @@ GccAna_Circ2d3Tan::
 		 for (Standard_Integer ii = 1 ; ii <= nbsol1 ; ii++) {
 		   if (Abs(dist2-Radius(ii)) < Tol) { 
 		     ok = Standard_True;
-		     nbsol2 = 1;
 		     Radius(1) = Radius(ii);
 		   }
 		 }
@@ -179,7 +176,6 @@ GccAna_Circ2d3Tan::
 	       for (Standard_Integer ii = 1 ; ii <= nbsol1 ; ii++) {
 		 if (Abs(dist2-Radius(ii)) < Tol) { 
 		   ok = Standard_True;
-		   nbsol2 = 1;
 		   Radius(1) = Radius(ii);
 		 }
 	       }
Index: oce/src/GccAna/GccAna_Circ2d3Tan_6.cxx
===================================================================
--- oce.orig/src/GccAna/GccAna_Circ2d3Tan_6.cxx
+++ oce/src/GccAna/GccAna_Circ2d3Tan_6.cxx
@@ -110,15 +110,12 @@ GccAna_Circ2d3Tan::
 	     Standard_Real dist2 = L2.Distance(Center);
 	     Standard_Real dist3 = Center.Distance(Point3);
 	     Standard_Real Radius=0;
-	     Standard_Integer nbsol1 = 0;
-	     Standard_Integer nbsol2 = 0;
 	     Standard_Integer nbsol3 = 0;
 	     Standard_Boolean ok = Standard_False;
 	     if (Qualified1.IsEnclosed()) {
 	       if ((((origin1.X()-Center.X())*(-dir1.Y()))+
 		    ((origin1.Y()-Center.Y())*(dir1.X())))<=0){
 		 ok = Standard_True;
-		 nbsol1 = 1;
 		 Radius = dist1;
 	       }
 	     }
@@ -126,31 +123,29 @@ GccAna_Circ2d3Tan::
 	       if ((((origin1.X()-Center.X())*(-dir1.Y()))+
 		    ((origin1.Y()-Center.Y())*(dir1.X())))>=0){
 		 ok = Standard_True;
-		 nbsol1 = 1;
 		 Radius = dist1;
 	       }
 	     }
 	     else if (Qualified1.IsUnqualified()) {
 	       ok = Standard_True;
-	       nbsol1 = 1;
 	       Radius = dist1;
 	     }
 	     if (Qualified2.IsEnclosed()) {
 	       if ((((origin2.X()-Center.X())*(-dir2.Y()))+
 		    ((origin2.Y()-Center.Y())*(dir2.X())))<=0){
-		 if (Abs(dist2-Radius) < Tol) { nbsol2 = 1; }
+		 if (Abs(dist2-Radius) < Tol) { }
 		 else { ok = Standard_False; }
 	       }
 	     }
 	     else if (Qualified2.IsOutside() && ok) {
 	       if ((((origin2.X()-Center.X())*(-dir2.Y()))+
 		    ((origin2.Y()-Center.Y())*(dir2.X())))>=0){
-		 if (Abs(dist2-Radius) < Tol) { nbsol2 = 1; }
+		 if (Abs(dist2-Radius) < Tol) { }
 		 else { ok = Standard_False; }
 	       }
 	     }
 	     else if (Qualified2.IsUnqualified() && ok) {
-	       if (Abs(dist2-Radius) < Tol) { nbsol2 = 1; }
+	       if (Abs(dist2-Radius) < Tol) { }
 	       else { ok = Standard_False; }
 	     }
 	     if (ok) {
Index: oce/src/GccAna/GccAna_Circ2d3Tan_8.cxx
===================================================================
--- oce.orig/src/GccAna/GccAna_Circ2d3Tan_8.cxx
+++ oce/src/GccAna/GccAna_Circ2d3Tan_8.cxx
@@ -108,8 +108,6 @@ GccAna_Circ2d3Tan::
 	   Standard_Real dist2 = Center.Distance(Point2);
 
 	   Standard_Real Radius=0;
-	   Standard_Integer nbsol1 = 0;
-//	   Standard_Integer nbsol2 = 0;
 	   Standard_Integer nbsol3 = 0;
 	   Standard_Boolean ok = Standard_False;
      Standard_Real  difference = (((origin1.X()-Center.X())*(-dir1.Y())) + ((origin1.Y()-Center.Y())*(dir1.X())));
@@ -118,7 +116,6 @@ GccAna_Circ2d3Tan::
          (Qualified1.IsUnqualified()))
      {
        ok = Standard_True;
-       nbsol1 = 1;
        Radius = dist1;
      }
 	   if (ok) {
Index: oce/src/GccAna/GccAna_Circ2dTanOnRad.cxx
===================================================================
--- oce.orig/src/GccAna/GccAna_Circ2dTanOnRad.cxx
+++ oce/src/GccAna/GccAna_Circ2dTanOnRad.cxx
@@ -95,7 +95,6 @@ GccAna_Circ2dTanOnRad::
      gp_Pnt2d center1(C1.Location());
      Standard_Real x1 = center1.X();
      Standard_Real y1 = center1.Y();
-     Standard_Real xbid = 0.;
      if (Qualified1.IsEnclosed()) {
 //   ============================
        if (Tol < Radius-R1+dist) { WellDone = Standard_True; }
@@ -195,7 +194,6 @@ GccAna_Circ2dTanOnRad::
 	 if ( Abs(D) <= Tol ) {
 	   A = B;
 	   B = D;
-	   xbid = x1;
 	   x0 = y1;
 	   y0 = x1;
 	 }
Index: oce/src/GccAna/GccAna_Lin2dTanPer.cxx
===================================================================
--- oce.orig/src/GccAna/GccAna_Lin2dTanPer.cxx
+++ oce/src/GccAna/GccAna_Lin2dTanPer.cxx
@@ -208,7 +208,6 @@ GccAna_Lin2dTanPer::
 
    WellDone = Standard_False;
    NbrSol = 0;
-   Standard_Integer nbsol = 0;
    Standard_Integer signe = 0;
    gp_Circ2d C1 = Qualified1.Qualified();
 
@@ -218,19 +217,16 @@ GccAna_Lin2dTanPer::
    }
    else if (Qualified1.IsEnclosing()) {
 // ==================================
-     nbsol = 1;
      signe = -1;
      qualifier1(1) = GccEnt_enclosing;
    }
    else if (Qualified1.IsOutside()) {
 // ================================
-     nbsol = 1;
      signe = 1;
      qualifier1(1) = GccEnt_outside;
    }
    else if (Qualified1.IsUnqualified()) {
 // ====================================
-     nbsol = 2;
      signe = -1;
      qualifier1(1) = GccEnt_enclosing;
      qualifier1(2) = GccEnt_outside;
Index: oce/src/GccGeo/GccGeo_Circ2d2TanOn.gxx
===================================================================
--- oce.orig/src/GccGeo/GccGeo_Circ2d2TanOn.gxx
+++ oce/src/GccGeo/GccGeo_Circ2d2TanOn.gxx
@@ -152,7 +152,6 @@ GccGeo_Circ2d2TanOn::
 	    Standard_Real dist1 = Center.Distance(C1.Location());
 	    Standard_Real dist2 = Center.Distance(C2.Location());
 	    Standard_Integer nbsol = 0;
-	    Standard_Integer nsol = 0;
 	    Standard_Integer nnsol = 0;
 	    R1 = C1.Radius();
 	    R2 = C2.Radius();
@@ -179,22 +178,18 @@ GccGeo_Circ2d2TanOn::
 	    }
 	    if (Qualified2.IsEnclosed() && nbsol != 0) {
 	      if (dist2-R2 < Tol) {
-		nsol = 1;
 		RBid(1) = Abs(R2-dist2);
 	      }
 	    }
 	    else if (Qualified2.IsOutside() && nbsol != 0) {
 	      if (R2-dist2 < Tol) {
-		nsol = 1;
 		RBid(1) = Abs(R2-dist2);
 	      }
 	    }
 	    else if (Qualified2.IsEnclosing() && nbsol != 0) {
-	      nsol = 1;
 	      RBid(1) = dist2+R2;
 	    }
 	    else if (Qualified2.IsUnqualified() && nbsol != 0) {
-	      nsol = 1;
 	      RBid(1) = dist2+R2;
 	      RBid(2) = Abs(R2-dist2);
 	    }
Index: oce/src/GccIter/GccIter_Circ2d2TanOn.gxx
===================================================================
--- oce.orig/src/GccIter/GccIter_Circ2d2TanOn.gxx
+++ oce/src/GccIter/GccIter_Circ2d2TanOn.gxx
@@ -100,17 +100,11 @@ GccIter_Circ2d2TanOn::
      Standard_Real dist2 = point3.Distance(point2);
      if ( Abs(dist1-dist2)/2. <= Tol) {
        cirsol = gp_Circ2d(gp_Ax2d(point3,dirx),(dist1+dist2)/2.);
-       Standard_Real normetan1 = Tan1.Magnitude();
        Standard_Real normetan2 = Tan2.Magnitude();
        gp_Vec2d Vec1(point1,point3);
        gp_Vec2d Vec2(point2,point3);
-       Standard_Real normevec1 = Vec1.Magnitude();
        Standard_Real normevec2 = Vec2.Magnitude();
-       Standard_Real angle1,angle2;
-       if (normevec1 >= gp::Resolution() && normetan1 >= gp::Resolution()) {
-	 angle1 = Vec1.Angle(Tan1);
-       }
-       else { angle1 = 0.; }
+       Standard_Real angle2;
        if (normevec2 >= gp::Resolution() && normetan2 >= gp::Resolution()) {
 	 angle2 = Vec2.Angle(Tan2);
        }
@@ -400,17 +394,11 @@ GccIter_Circ2d2TanOn::
      Standard_Real dist2 = point3.Distance(point2);
      if ( Abs(dist1-dist2)/2. <= Tol) {
        cirsol = gp_Circ2d(gp_Ax2d(point3,dirx),(dist1+dist2)/2.);
-       Standard_Real normetan1 = Tan1.Magnitude();
        Standard_Real normetan2 = Tan2.Magnitude();
        gp_Vec2d Vec1(point1,point3);
        gp_Vec2d Vec2(point2,point3);
-       Standard_Real normevec1 = Vec1.Magnitude();
        Standard_Real normevec2 = Vec2.Magnitude();
-       Standard_Real angle1,angle2;
-       if (normevec1 >= gp::Resolution() && normetan1 >= gp::Resolution()) {
-	 angle1 = Vec1.Angle(Tan1);
-       }
-       else { angle1 = 0.; }
+       Standard_Real angle2;
        if (normevec2 >= gp::Resolution() && normetan2 >= gp::Resolution()) {
 	 angle2 = Vec2.Angle(Tan2);
        }
@@ -511,17 +499,11 @@ GccIter_Circ2d2TanOn::
      Standard_Real dist2 = point3.Distance(point2);
      if ( Abs(dist1-dist2)/2. <= Tol) {
        cirsol = gp_Circ2d(gp_Ax2d(point3,dirx),(dist1+dist2)/2.);
-       Standard_Real normetan1 = Tan1.Magnitude();
        Standard_Real normetan2 = Tan2.Magnitude();
        gp_Vec2d Vec1(point1,point3);
        gp_Vec2d Vec2(point2,point3);
-       Standard_Real normevec1 = Vec1.Magnitude();
        Standard_Real normevec2 = Vec2.Magnitude();
-       Standard_Real angle1,angle2;
-       if (normevec1 >= gp::Resolution() && normetan1 >= gp::Resolution()) {
-	 angle1 = Vec1.Angle(Tan1);
-       }
-       else { angle1 = 0.; }
+       Standard_Real angle2;
        if (normevec2 >= gp::Resolution() && normetan2 >= gp::Resolution()) {
 	 angle2 = Vec2.Angle(Tan2);
        }
@@ -621,17 +603,11 @@ GccIter_Circ2d2TanOn::
      Standard_Real dist2 = point3.Distance(point2);
      if ( Abs(dist1-dist2)/2. <= Tol) {
        cirsol = gp_Circ2d(gp_Ax2d(point3,dirx),(dist1+dist2)/2.);
-       Standard_Real normetan1 = Tan1.Magnitude();
        Standard_Real normetan2 = Tan2.Magnitude();
        gp_Vec2d Vec1(point1,point3);
        gp_Vec2d Vec2(point2,point3);
-       Standard_Real normevec1 = Vec1.Magnitude();
        Standard_Real normevec2 = Vec2.Magnitude();
-       Standard_Real angle1,angle2;
-       if (normevec1 >= gp::Resolution() && normetan1 >= gp::Resolution()) {
-	 angle1 = Vec1.Angle(Tan1);
-       }
-       else { angle1 = 0.; }
+       Standard_Real angle2;
        if (normevec2 >= gp::Resolution() && normetan2 >= gp::Resolution()) {
 	 angle2 = Vec2.Angle(Tan2);
        }
@@ -1026,17 +1002,11 @@ GccIter_Circ2d2TanOn::
      if ( Abs(dist1-dist2)/2. <= Tol) {
        gp_Dir2d dirx(1.,0.);
        cirsol = gp_Circ2d(gp_Ax2d(point3,dirx),(dist1+dist2)/2.);
-       Standard_Real normetan1 = Tan1.Magnitude();
        Standard_Real normetan2 = Tan2.Magnitude();
        gp_Vec2d Vec1(point1.XY(),point3.XY());
        gp_Vec2d Vec2(point2.XY(),point3.XY());
-       Standard_Real normevec1 = Vec1.Magnitude();
        Standard_Real normevec2 = Vec2.Magnitude();
-       Standard_Real angle1,angle2;
-       if (normevec1 >= gp::Resolution() && normetan1 >= gp::Resolution()) {
-	 angle1 = Vec1.Angle(Tan1);
-       }
-       else { angle1 = 0.; }
+       Standard_Real angle2;
        if (normevec2 >= gp::Resolution() && normetan2 >= gp::Resolution()) {
 	 angle2 = Vec2.Angle(Tan2);
        }
@@ -1132,17 +1102,11 @@ GccIter_Circ2d2TanOn::
      Standard_Real dist2 = point3.Distance(point2);
      if ( Abs(dist1-dist2)/2. <= Tol) {
        cirsol = gp_Circ2d(gp_Ax2d(point3,dirx),(dist1+dist2)/2.);
-       Standard_Real normetan1 = Tan1.Magnitude();
        Standard_Real normetan2 = Tan2.Magnitude();
        gp_Vec2d Vec1(point1,point3);
        gp_Vec2d Vec2(point2,point3);
-       Standard_Real normevec1 = Vec1.Magnitude();
        Standard_Real normevec2 = Vec2.Magnitude();
-       Standard_Real angle1,angle2;
-       if (normevec1 >= gp::Resolution() && normetan1 >= gp::Resolution()) {
-	 angle1 = Vec1.Angle(Tan1);
-       }
-       else { angle1 = 0.; }
+       Standard_Real angle2;
        if (normevec2 >= gp::Resolution() && normetan2 >= gp::Resolution()) {
 	 angle2 = Vec2.Angle(Tan2);
        }
Index: oce/src/Geom/Geom_BSplineSurface.cxx
===================================================================
--- oce.orig/src/Geom/Geom_BSplineSurface.cxx
+++ oce/src/Geom/Geom_BSplineSurface.cxx
@@ -1025,15 +1025,12 @@ void Geom_BSplineSurface::SetUKnots (con
       Upper < 1 || Upper > uknots->Length() ) {
     Standard_OutOfRange::Raise();
   }
-  Standard_Real Eps;
   if (Lower > 1) {
-    Eps = Abs (Epsilon (uknots->Value (Lower-1)));
     if (Abs (UK (Lower) - uknots->Value (Lower-1)) <= gp::Resolution()) {
       Standard_ConstructionError::Raise();
     }
   }
   if (Upper < uknots->Length ()) {
-    Eps = Abs (Epsilon (uknots->Value (Upper+1)));
     if (Abs (UK (Upper) - uknots->Value (Upper+1)) <= gp::Resolution()) {
       Standard_ConstructionError::Raise();
     }
@@ -1042,7 +1039,6 @@ void Geom_BSplineSurface::SetUKnots (con
   for (Standard_Integer i = Lower; i <= Upper; i++) {
     uknots->SetValue (i, UK(i));
     if (i != Lower) {
-      Eps = Abs (Epsilon (K1));
       if (Abs (UK(i) - K1) <= gp::Resolution()) {
         Standard_ConstructionError::Raise();
       }
@@ -1114,15 +1110,12 @@ void Geom_BSplineSurface::SetVKnots (con
       Upper < 1 || Upper > vknots->Length() ) {
     Standard_OutOfRange::Raise();
   }
-  Standard_Real Eps;
   if (Lower > 1) {
-    Eps = Abs (Epsilon (vknots->Value (Lower-1)));
     if (Abs (VK (Lower) - vknots->Value (Lower-1)) <= gp::Resolution()) {
       Standard_ConstructionError::Raise();
     }
   }
   if (Upper < vknots->Length ()) {
-    Eps = Abs (Epsilon (vknots->Value (Upper+1)));
     if (Abs (VK (Upper) - vknots->Value (Upper+1)) <= gp::Resolution()) {
       Standard_ConstructionError::Raise();
     }
@@ -1131,7 +1124,6 @@ void Geom_BSplineSurface::SetVKnots (con
   for (Standard_Integer i = Lower; i <= Upper; i++) {
     vknots->SetValue (i, VK(i));
     if (i != Lower) {
-      Eps = Abs (Epsilon (K1));
       if (Abs (VK(i) - K1) <= gp::Resolution()) {
         Standard_ConstructionError::Raise();
       }
Index: oce/src/Geom2dConvert/Geom2dConvert.cxx
===================================================================
--- oce.orig/src/Geom2dConvert/Geom2dConvert.cxx
+++ oce/src/Geom2dConvert/Geom2dConvert.cxx
@@ -1147,9 +1147,8 @@ void  Geom2dConvert::ConcatG1(TColGeom2d
        Standard_ConstructionError::Raise("Geom2dConvert Concatenation Error") ;
      Curve2=C.BSplineCurve();
    }
-   Standard_Boolean   rm;
    Curve2->SetPeriodic();      //1 seule courbe C1
-   rm=Curve2->RemoveKnot(Curve2->LastUKnotIndex(),
+   Curve2->RemoveKnot(Curve2->LastUKnotIndex(),
 			 Curve2->Multiplicity(Curve2->LastUKnotIndex())-1,
 			 Precision::Confusion());
    ArrayOfConcatenated->SetValue(0,Curve2);
@@ -1388,9 +1387,8 @@ void  Geom2dConvert::ConcatC1(TColGeom2d
        Curve2=C.BSplineCurve();
      }
    }
-   Standard_Boolean   rm;
    Curve2->SetPeriodic();      //1 seule courbe C1
-   rm=Curve2->RemoveKnot(Curve2->LastUKnotIndex(),
+   Curve2->RemoveKnot(Curve2->LastUKnotIndex(),
 			 Curve2->Multiplicity(Curve2->LastUKnotIndex())-1,
 			 Precision::Confusion());
    ArrayOfConcatenated->SetValue(0,Curve2);
Index: oce/src/GeomConvert/GeomConvert.cxx
===================================================================
--- oce.orig/src/GeomConvert/GeomConvert.cxx
+++ oce/src/GeomConvert/GeomConvert.cxx
@@ -955,9 +955,8 @@ private:
        Standard_ConstructionError::Raise("GeomConvert Concatenation Error") ;
      Curve2=C.BSplineCurve();
    }
-   Standard_Boolean   rm;
    Curve2->SetPeriodic();      
-   rm=Curve2->RemoveKnot(Curve2->LastUKnotIndex(),
+   Curve2->RemoveKnot(Curve2->LastUKnotIndex(),
 			 Curve2->Multiplicity(Curve2->LastUKnotIndex())-1,
 			 Precision::Confusion());
    ArrayOfConcatenated->SetValue(0,Curve2);
@@ -1192,9 +1191,8 @@ void  GeomConvert::ConcatC1(TColGeom_Arr
        Curve2=C.BSplineCurve();
      }
    }
-   Standard_Boolean   rm;
    Curve2->SetPeriodic();                               //only one C1 curve
-   rm=Curve2->RemoveKnot(Curve2->LastUKnotIndex(),
+   Curve2->RemoveKnot(Curve2->LastUKnotIndex(),
 			 Curve2->Multiplicity(Curve2->LastUKnotIndex())-1,
 			 Precision::Confusion());
    ArrayOfConcatenated->SetValue(0,Curve2);
Index: oce/src/GeomConvert/GeomConvert_1.cxx
===================================================================
--- oce.orig/src/GeomConvert/GeomConvert_1.cxx
+++ oce/src/GeomConvert/GeomConvert_1.cxx
@@ -765,10 +765,8 @@ Handle(BSplineSurface) GeomConvert::Spli
       Weights.Init(1.);
       if ( C->IsRational()) C->Weights(Weights);
 
-      Standard_Integer nbUSpans;
       Standard_Real AlfaU;
       NbUKnots = 4;
-      nbUSpans = 3;
       AlfaU    = M_PI / 3.;
       NbUPoles = 6;
 
Index: oce/src/GeomFill/GeomFill_ConstrainedFilling.cxx
===================================================================
--- oce.orig/src/GeomFill/GeomFill_ConstrainedFilling.cxx
+++ oce/src/GeomFill/GeomFill_ConstrainedFilling.cxx
@@ -1421,8 +1421,10 @@ void GeomFill_ConstrainedFilling::CheckR
   }
   gp_Pnt pbound[31],pres[31];
   gp_Vec vbound[31],vres[31];
+#ifdef DRAW
   Standard_Real ang[31];
   Standard_Boolean hasang[31];
+#endif
   Handle(GeomFill_Boundary) bou = ptch->Bound(I);
   Standard_Integer k ;
   for ( k = 0; k <= 30; k++){
@@ -1437,10 +1439,14 @@ void GeomFill_ConstrainedFilling::CheckR
 	Standard_Real alpha = Abs(vres[k].Angle(vbound[k]));
 	alpha = Min(alpha,Abs(M_PI-alpha));
 	if(alpha > maxang) maxang = alpha;
+#ifdef DRAW
 	ang[k] = alpha;
 	hasang[k] = 1;
+#endif
       }
+#ifdef DRAW
       else hasang[k] = 0;
+#endif
     }
     if(pres[k].Distance(pbound[k]) > maxdist) maxdist = pres[k].Distance(pbound[k]);
     uu += duu;
Index: oce/src/GeomFill/GeomFill_CorrectedFrenet.cxx
===================================================================
--- oce.orig/src/GeomFill/GeomFill_CorrectedFrenet.cxx
+++ oce/src/GeomFill/GeomFill_CorrectedFrenet.cxx
@@ -466,7 +466,7 @@ Handle(GeomFill_TrihedronLaw) GeomFill_C
   gp_Vec Tangent, Normal, BN, cross;
   TColStd_SequenceOfReal parameters;
   TColStd_SequenceOfReal EvolAT;
-  Standard_Real Param = First, LengthMin, L, norm;
+  Standard_Real Param = First, L, norm;
   Standard_Boolean isZero = Standard_True, isConst = Standard_True;
   const Standard_Real minnorm = 1.e-16;
   Standard_Integer i;
@@ -476,7 +476,6 @@ Handle(GeomFill_TrihedronLaw) GeomFill_C
   frenet->SetInterval(First, Last); //To have the rigth evaluation at bounds
   GeomFill_SnglrFunc CS(myCurve);
   BndLib_Add3dCurve::Add(CS, First, Last, 1.e-2, Boite);
-  LengthMin = Boite.GetGap()*1.e-4;
     
   aT = gp_Vec(0, 0, 0);
   aN = gp_Vec(0, 0, 0);   
Index: oce/src/GeomFill/GeomFill_EvolvedSection.cxx
===================================================================
--- oce.orig/src/GeomFill/GeomFill_EvolvedSection.cxx
+++ oce/src/GeomFill/GeomFill_EvolvedSection.cxx
@@ -42,7 +42,6 @@ static Standard_Boolean Affich = 0;
 GeomFill_EvolvedSection::GeomFill_EvolvedSection(const Handle(Geom_Curve)& C,
 						 const Handle(Law_Function)& L)
 {
-  Standard_Boolean Bof;
   L->Bounds(First, Last);
   mySection = Handle(Geom_Curve)::DownCast(C->Copy());
   myLaw =  L->Trim(First, Last, 1.e-20);
@@ -52,7 +51,7 @@ GeomFill_EvolvedSection::GeomFill_Evolve
     myCurve = GeomConvert::CurveToBSplineCurve(C, Convert_QuasiAngular);
     if (myCurve->IsPeriodic()) {
       Standard_Integer M = myCurve->Degree()/2+1;
-      Bof = myCurve->RemoveKnot(1, M, Precision::Confusion());
+      myCurve->RemoveKnot(1, M, Precision::Confusion());
     }
   }
 
Index: oce/src/GeomFill/GeomFill_LocationGuide.cxx
===================================================================
--- oce.orig/src/GeomFill/GeomFill_LocationGuide.cxx
+++ oce/src/GeomFill/GeomFill_LocationGuide.cxx
@@ -79,11 +79,10 @@ static void TraceRevol(const Standard_Re
 {
   gp_Vec T, N, B;
   gp_Pnt P;
-  Standard_Boolean Ok;
   gp_Ax3 Rep(gp::Origin(), gp::DZ(), gp::DX());
 
   Curve->D0(t, P);
-  Ok = Law->D0(t, T, N, B);
+  Law->D0(t, T, N, B);
 
   gp_Mat M(N.XYZ(), B.XYZ(), T.XYZ());
   M *= Trans;
@@ -223,7 +222,7 @@ static void InGoodPeriod(const Standard_
   gp_Vec T,N,B;
   Standard_Integer ii, Deg;
   Standard_Boolean isconst, israt=Standard_False;
-  Standard_Real t, v,w, OldAngle=0, Angle, DeltaG, DeltaU, Diff;
+  Standard_Real t, v,w, OldAngle=0, Angle, DeltaG, Diff;
   Standard_Real CurAngle =  PrecAngle, a1/*, a2*/;
   gp_Pnt2d p1,p2;
   Handle(Geom_SurfaceOfRevolution) Revol; // surface de revolution
@@ -283,7 +282,6 @@ static void InGoodPeriod(const Standard_
   Sup(3) = Ul + Delta/10;
 
   // JALONNEMENT
-  DeltaU = (Ul-Uf)/(2+NbKnots);
   if (uperiodic) UPeriod = Ul-Uf;
 
   for (ii=1; ii<=myNbPts; ii++) {
@@ -454,7 +452,7 @@ static void InGoodPeriod(const Standard_
       }
       Diff = v -  myPoles2d->Value(2, ii-1).Y();
 #if DEB
-      if (Abs(Diff) > DeltaU) {
+      if (Abs(Diff) > (Ul-Uf)/(2+NbKnots)) {
 	cout << "Diff sur section trop grand !!" << endl;
       } 
 #endif
Index: oce/src/GeomFill/GeomFill_Pipe.cxx
===================================================================
--- oce.orig/src/GeomFill/GeomFill_Pipe.cxx
+++ oce/src/GeomFill/GeomFill_Pipe.cxx
@@ -612,13 +612,11 @@ void GeomFill_Pipe::Init(const Handle(Ge
     new Adaptor3d_HCurveOnSurface(Adaptor3d_CurveOnSurface(
 		       new Geom2dAdaptor_HCurve(Path), 
 		       new GeomAdaptor_HSurface(Support)));
-  Standard_Real param =  Path->FirstParameter();
  
   myLoc = new (GeomFill_CurveAndTrihedron) (TLaw);
   myLoc->SetCurve(myAdpPath);
   GeomFill_SectionPlacement Place(myLoc, FirstSect);
   Place.Perform(myAdpPath, Precision::Confusion());
-  param =  Place.ParameterOnPath();
   Sect = Place.Section(Standard_False);
   
 #ifdef DRAW
@@ -648,7 +646,6 @@ void GeomFill_Pipe::Init(const Handle(Ge
   Handle(Geom_Curve) Sect;
   myAdpPath = new (GeomAdaptor_HCurve) 
     (Handle(Geom_Curve)::DownCast(Path->Copy()));
-  Standard_Real param =  Path->FirstParameter();
   gp_Vec V;
   V.SetXYZ(Direction.XYZ());
   Handle (GeomFill_ConstantBiNormal) TLaw = 
@@ -658,7 +655,6 @@ void GeomFill_Pipe::Init(const Handle(Ge
   myLoc->SetCurve(myAdpPath);
   GeomFill_SectionPlacement Place(myLoc, FirstSect);
   Place.Perform(Precision::Confusion());
-  param =  Place.ParameterOnPath();
   Sect = Place.Section(Standard_False);
 
 #ifdef DRAW
Index: oce/src/GeomFill/GeomFill_Sweep.cxx
===================================================================
--- oce.orig/src/GeomFill/GeomFill_Sweep.cxx
+++ oce/src/GeomFill/GeomFill_Sweep.cxx
@@ -266,8 +266,6 @@ GeomFill_Sweep::GeomFill_Sweep(const Han
 					   const Standard_Integer Segmax) 
 {
   Standard_Boolean Ok = Standard_False;
-  Standard_Integer nbsegmax = Segmax, nbspan = myLoc->NbIntervals(GeomAbs_C1);
-  if (Segmax < nbspan)  nbsegmax = nbspan;
 
   Handle(GeomFill_SweepFunction) Func 
     = new (GeomFill_SweepFunction) (mySec, myLoc, First, SFirst,
Index: oce/src/GeomFill/GeomFill_TgtOnCoons.cxx
===================================================================
--- oce.orig/src/GeomFill/GeomFill_TgtOnCoons.cxx
+++ oce/src/GeomFill/GeomFill_TgtOnCoons.cxx
@@ -119,11 +119,7 @@ gp_Vec GeomFill_TgtOnCoons::D1(const Sta
 
   Standard_Real scal = tgsc.Dot(n);
   gp_Vec scaln = n.Multiplied(-scal);
-#ifdef DEB
-  gp_Vec tpur = tgsc.Added(scaln);
-#else
   tgsc.Added(scaln);
-#endif
 
   gp_Vec scaldn = dn.Multiplied(-scal);
 
Index: oce/src/GeomFill/GeomFill_UniformSection.cxx
===================================================================
--- oce.orig/src/GeomFill/GeomFill_UniformSection.cxx
+++ oce/src/GeomFill/GeomFill_UniformSection.cxx
@@ -49,9 +49,8 @@ GeomFill_UniformSection::GeomFill_Unifor
  if (myCurve.IsNull()) {
    myCurve = GeomConvert::CurveToBSplineCurve(C, Convert_QuasiAngular);
    if (myCurve->IsPeriodic()) {
-     Standard_Boolean B;
      Standard_Integer M = myCurve->Degree()/2+1;
-     B = myCurve->RemoveKnot(1, M, Precision::Confusion());
+     myCurve->RemoveKnot(1, M, Precision::Confusion());
    }
  }
 
Index: oce/src/GeomInt/GeomInt_IntSS_1.cxx
===================================================================
--- oce.orig/src/GeomInt/GeomInt_IntSS_1.cxx
+++ oce/src/GeomInt/GeomInt_IntSS_1.cxx
@@ -407,10 +407,9 @@ Standard_Real ProjectPointOnSurf::LowerD
 	(Handle(IntPatch_GLine)::DownCast(L)->Ellipse());
     }
     //
-    Standard_Real aPeriod, aNul, aRealEpsilon;
+    Standard_Real aPeriod, aRealEpsilon;
     //
     aRealEpsilon=RealEpsilon();
-    aNul=0.;
     aPeriod=M_PI+M_PI;
     //
     aNbParts=myLConstruct.NbParts();
Index: oce/src/GeometryTest/GeometryTest_APICommands.cxx
===================================================================
--- oce.orig/src/GeometryTest/GeometryTest_APICommands.cxx
+++ oce/src/GeometryTest/GeometryTest_APICommands.cxx
@@ -562,14 +562,9 @@ void GeometryTest::APICommands(Draw_Inte
   if (done) return;
 
   done = Standard_True;
-  const char* g;
-
-  g = "GEOMETRY curves and surfaces analysis";
 
   theCommands.Add("proj", "proj curve/surf x y z [extrema algo: g(grad)/t(tree)]",__FILE__, proj);
 
-  g = "GEOMETRY approximations";
-
   theCommands.Add("appro", "appro result nbpoint [curve]",__FILE__, appro);
   theCommands.Add("surfapp","surfapp result nbupoint nbvpoint x y z ....",
 		  __FILE__,
@@ -578,8 +573,6 @@ void GeometryTest::APICommands(Draw_Inte
        "grilapp result nbupoint nbvpoint X0 dX Y0 dY z11 z12 .. z1nu ....  ",
         __FILE__,grilapp);
 
-  g = "GEOMETRY curves and surfaces analysis";
-
   theCommands.Add("extrema", "extrema curve/surface curve/surface",__FILE__,extrema);
   theCommands.Add("totalextcc", "totalextcc curve curve",__FILE__,totalextcc);
 }
Index: oce/src/GeometryTest/GeometryTest_CurveCommands.cxx
===================================================================
--- oce.orig/src/GeometryTest/GeometryTest_CurveCommands.cxx
+++ oce/src/GeometryTest/GeometryTest_CurveCommands.cxx
@@ -418,7 +418,7 @@ static Standard_Integer project (Draw_In
   Standard_Real U1,U2,V1,V2;
   GS->Bounds(U1,U2,V1,V2);
 
-  Standard_Boolean Verif = Standard_False, Extent = Standard_False;
+  Standard_Boolean Verif = Standard_False;
   Standard_Integer NbPoints=0;
 
   Standard_Integer index = 4;
@@ -430,7 +430,6 @@ static Standard_Integer project (Draw_In
       Standard_Real dU = p * (U2 - U1) / 100.;
       Standard_Real dV = p * (V2 - V1) / 100.;
       U1 -= dU; U2 += dU; V1 -= dV; V2 += dV;
-      Extent = Standard_True;
     }
     else if ( a[index][1] == 'v') {
       Verif = Standard_True;
@@ -762,7 +761,7 @@ static Standard_Integer bisec (Draw_Inte
 
 static Standard_Integer movelaw (Draw_Interpretor& di, Standard_Integer n, const char** a)
 {
-  Standard_Integer dimension,
+  Standard_Integer 
   ii,
   condition=0,
   error_status ;
@@ -774,7 +773,6 @@ static Standard_Integer movelaw (Draw_In
   u = Draw::Atof(a[2]);
   x = Draw::Atof(a[3]);
   tolerance = 1.0e-5 ;
-  dimension = 2 ;
   if (n < 5) {
       return 1 ;
   }
Index: oce/src/GeometryTest/GeometryTest_FairCurveCommands.cxx
===================================================================
--- oce.orig/src/GeometryTest/GeometryTest_FairCurveCommands.cxx
+++ oce/src/GeometryTest/GeometryTest_FairCurveCommands.cxx
@@ -56,7 +56,6 @@ BattenCurve(Draw_Interpretor& di, Standa
   const char *cheigth = argv[5];
   const char *BattenName = argv[6];
 
-  Standard_Boolean Ok;
   FairCurve_AnalysisCode Iana;
   Standard_Real a1 = Draw::Atof(cangle1),
                 a2 = Draw::Atof(cangle2),
@@ -71,7 +70,7 @@ BattenCurve(Draw_Interpretor& di, Standa
   Bat->SetAngle1(a1*M_PI/180);
   Bat->SetAngle2(a2*M_PI/180);
   
-  Ok = Bat->Compute(Iana);
+  Bat->Compute(Iana);
   
   Handle(DrawFairCurve_Batten) aBatten = new DrawFairCurve_Batten(Bat);
 
@@ -100,7 +99,6 @@ MVCurve(Draw_Interpretor& di, Standard_I
   const char *cheigth = argv[5];
   const char *MVCName = argv[6];
 
-  Standard_Boolean Ok;
   FairCurve_AnalysisCode Iana;
   Standard_Real a1 = Draw::Atof(cangle1),
                 a2 = Draw::Atof(cangle2),
@@ -115,7 +113,7 @@ MVCurve(Draw_Interpretor& di, Standard_I
   MVC->SetAngle1(a1*M_PI/180);
   MVC->SetAngle2(a2*M_PI/180);
   
-  Ok = MVC->Compute(Iana);
+  MVC->Compute(Iana);
   
   Handle(DrawFairCurve_MinimalVariation) aMVC = new DrawFairCurve_MinimalVariation(MVC);
 
Index: oce/src/GeometryTest/GeometryTest_SurfaceCommands.cxx
===================================================================
--- oce.orig/src/GeometryTest/GeometryTest_SurfaceCommands.cxx
+++ oce/src/GeometryTest/GeometryTest_SurfaceCommands.cxx
@@ -81,9 +81,6 @@ static Standard_Integer sweep (Draw_Inte
   GeomFill_Trihedron Option = GeomFill_IsCorrectedFrenet;
   Standard_Integer ipath =2, isection =4 , NbSeg=30, MaxDegree = 10;
   Standard_Real Tol = 1.e-4;
-#if DEB
-  static Standard_Boolean AdvApprox_Debug = 1; 
-#endif
 
   if (n < 4 ) return 1;
   
@@ -161,9 +158,6 @@ static Standard_Integer tuyau (Draw_Inte
                                Standard_Integer n, const char** a)
 {
   if ( n < 4) return 1;
-#if DEB
-  static Standard_Boolean AdvApprox_Debug = 1;
-#endif 
 
   GeomAbs_Shape Cont = GeomAbs_C2;
   GeomFill_Pipe Pipe;
Index: oce/src/GeomliteTest/GeomliteTest_SurfaceCommands.cxx
===================================================================
--- oce.orig/src/GeomliteTest/GeomliteTest_SurfaceCommands.cxx
+++ oce/src/GeomliteTest/GeomliteTest_SurfaceCommands.cxx
@@ -1198,20 +1198,6 @@ static Standard_Integer rempole (Draw_In
     BSpline = Standard_True;
   }
   
-  Standard_Integer Index;
-  if ( !strcasecmp(a[0],"remrowpole")) {
-    if (BSpline)
-      Index = GBs->UDegree();
-    else 
-      Index = GBz->UDegree();
-  }  
-  else if ( !strcasecmp(a[0],"remcolpole")) {
-    if (BSpline) 
-      Index = GBs->VDegree();
-    else
-      Index = GBz->VDegree();
-  }
-  
   if ( !strcasecmp(a[0],"remrowpole")) {
     if ( BSpline) {
       di << " Error : Cannot remove a polerow on a BSplineSurface " << "\n";
Index: oce/src/HLRBRep/HLRBRep_Hider.cxx
===================================================================
--- oce.orig/src/HLRBRep/HLRBRep_Hider.cxx
+++ oce/src/HLRBRep/HLRBRep_Hider.cxx
@@ -328,7 +328,6 @@ void HLRBRep_Hider::Hide(const Standard_
 
 	Standard_Boolean foundHidden = Standard_False;
 	
-	Standard_Integer aStartLevel;
 	if (!ILHidden.IsEmpty()) {    
 
 	  HLRBRep_EdgeIList::ProcessComplex // complex transition on ILHidden
@@ -338,7 +337,6 @@ void HLRBRep_Hider::Hide(const Standard_
 	    level = myDS->HidingStartLevel(E,ed,ILHidden);  // **************
 	  	  HLRAlgo_ListIteratorOfInterferenceList It(ILHidden); 
 	  
-	  aStartLevel = level;
 	  while(It.More()) {           // suppress multi-inside Intersections
 	                               // ***********************************
 	  
Index: oce/src/HLRBRep/HLRBRep_PolyAlgo.cxx
===================================================================
--- oce.orig/src/HLRBRep/HLRBRep_PolyAlgo.cxx
+++ oce/src/HLRBRep/HLRBRep_PolyAlgo.cxx
@@ -441,7 +441,6 @@
 #ifdef DEB
 static Standard_Integer DoTrace = Standard_False; 
 static Standard_Integer DoError = Standard_False; 
-static Standard_Integer IndexPlusOnePerCentThree [] = { 1 , 2 , 0 };
 #endif
 //=======================================================================
 //function : HLRBRep_PolyAlgo
@@ -2521,20 +2520,17 @@ HLRBRep_PolyAlgo::InsertOnOutLine (TColS
       TTMa[2][0] = ttma.Value(3,1);
       TTMa[2][1] = ttma.Value(3,2);
       TTMa[2][2] = ttma.Value(3,3);
-      Standard_Integer iseg,nbT,nbS,nbN;
-
-      nbT = (*pid)->NbTData();
-      nbN = (*pid)->NbPINod();
-      nbS = (*pid)->NbPISeg();
 
 #ifdef DEB
       if (DoTrace) {
-	cout << " InsertOnOutLine : NbTData " << nbT << endl;
-	cout << " InsertOnOutLine : NbPISeg " << nbS << endl;
-	cout << " InsertOnOutLine : NbPINod " << nbN << endl;
+	cout << " InsertOnOutLine : NbTData " << (*pid)->NbTData() << endl;
+	cout << " InsertOnOutLine : NbPISeg " << (*pid)->NbPISeg() << endl;
+	cout << " InsertOnOutLine : NbPINod " << (*pid)->NbPINod() << endl;
       }
 #endif
 
+      Standard_Integer iseg,nbS;
+      nbS = (*pid)->NbPISeg();
       for (iseg = 1; iseg <= nbS; iseg++) {
 	Seg1Indices =
 	  ((HLRAlgo_Array1OfPISeg*)PISeg1)->ChangeValue(iseg).Indices();
@@ -2610,15 +2606,13 @@ HLRBRep_PolyAlgo::InsertOnOutLine (TColS
       if (IntOutL)
 	(*pid)->IntOutL(Standard_True);
 
-      nbT = (*pid)->NbTData();
-      nbN = (*pid)->NbPINod();
       nbS = (*pid)->NbPISeg();
 
 #ifdef DEB
       if (DoTrace) {
-	cout << " InsertOnOutLine : NbTData " << nbT << endl;
-	cout << " InsertOnOutLine : NbPISeg " << nbS << endl;
-	cout << " InsertOnOutLine : NbPINod " << nbN << endl;
+	cout << " InsertOnOutLine : NbTData " << (*pid)->NbTData() << endl;
+	cout << " InsertOnOutLine : NbPISeg " << (*pid)->NbPISeg() << endl;
+	cout << " InsertOnOutLine : NbPINod " << (*pid)->NbPINod() << endl;
       }
 #endif
     }
@@ -3538,7 +3532,6 @@ UpdateEdgesBiPoints (HLRAlgo_ListOfBPoin
 		     const Standard_Boolean closed)
 {
   Standard_Integer itri1,itri2,tbid;
-  Standard_Boolean OK;
   HLRAlgo_ListIteratorOfListOfBPoint it;
   
   for (it.Initialize(List); it.More(); it.Next()) {      
@@ -3556,8 +3549,8 @@ UpdateEdgesBiPoints (HLRAlgo_ListOfBPoin
 	pid1->PINod().ChangeValue(F1Pt1Index)->Indices();
       Standard_Address Nod21Indices = 
 	pid2->PINod().ChangeValue(F2Pt1Index)->Indices();
-      OK = Triangles(F1Pt1Index,F1Pt2Index,Nod11Indices,PISeg1,itri1,tbid);
-      OK = Triangles(F2Pt1Index,F2Pt2Index,Nod21Indices,PISeg2,itri2,tbid);
+      Triangles(F1Pt1Index,F1Pt2Index,Nod11Indices,PISeg1,itri1,tbid);
+      Triangles(F2Pt1Index,F2Pt2Index,Nod21Indices,PISeg2,itri2,tbid);
 
       if (itri1 != 0 && itri2 != 0) {
 	if (F1Index != F2Index || itri1 != itri2) {
Index: oce/src/HLRTest/HLRTest.cxx
===================================================================
--- oce.orig/src/HLRTest/HLRTest.cxx
+++ oce/src/HLRTest/HLRTest.cxx
@@ -90,9 +90,7 @@ Handle(HLRTopoBRep_OutLiner) HLRTest::Ge
 static Standard_Integer
 hprj (Draw_Interpretor& , Standard_Integer n, const char** a)
 {
-  Standard_Integer id = 1;
   if (n < 2) return 1;
-  if (n > 2) id = Draw::Atoi(a[2]);
   //
   gp_Ax2 anAx2 = gp::XOY();
   if (n == 11)
Index: oce/src/IFGraph/IFGraph_Articulations.cxx
===================================================================
--- oce.orig/src/IFGraph/IFGraph_Articulations.cxx
+++ oce/src/IFGraph/IFGraph_Articulations.cxx
@@ -43,9 +43,8 @@ IFGraph_Articulations::IFGraph_Articulat
 //  Utilisation de Visit
   Standard_Integer nb = thegraph.Size();
   for (Standard_Integer i = 1; i <= nb; i ++) {
-    Standard_Integer visited;
     thenow = 0;
-    if (thegraph.IsPresent(i)) visited = Visit(i);
+    if (thegraph.IsPresent(i)) Visit(i);
   }
 //  Resultat dans thelist
   Reset();
Index: oce/src/IFSelect/IFSelect_BasicDumper.cxx
===================================================================
--- oce.orig/src/IFSelect/IFSelect_BasicDumper.cxx
+++ oce/src/IFSelect/IFSelect_BasicDumper.cxx
@@ -144,11 +144,10 @@ IFSelect_BasicDumper::IFSelect_BasicDump
     return Standard_True;
   }
   if (type.IsEqual("IFSelect_SelectTextType")) {
-    Standard_Boolean exact;
     const TCollection_AsciiString exname = file.ParamValue(1);
     if (exname.Length() < FIRSTCHAR) return Standard_False;
-    if      (exname.Value(FIRSTCHAR) == 'e') exact = Standard_True;
-    else if (exname.Value(FIRSTCHAR) == 'c') exact = Standard_False;
+    if      (exname.Value(FIRSTCHAR) == 'e') {}
+    else if (exname.Value(FIRSTCHAR) == 'c') {}
     else  return Standard_False;
 //    item = new IFSelect_SelectTextType (file.TextValue(2).ToCString(),exact);
 //    return Standard_True;
Index: oce/src/IFSelect/IFSelect_ListEditor.cxx
===================================================================
--- oce.orig/src/IFSelect/IFSelect_ListEditor.cxx
+++ oce/src/IFSelect/IFSelect_ListEditor.cxx
@@ -73,11 +73,9 @@ Standard_Boolean  IFSelect_ListEditor::L
   if (list.IsNull()) return Standard_False;
   Standard_Integer i, nb = list->Length();
   if (nb > themax) return Standard_False;
-  Interface_ParamType pty = Interface_ParamText;
 
 //   check values
   if (!thedef.IsNull()) {
-    pty = thedef->Type();
     for (i = 1; i <= nb; i ++) {
       Handle(TCollection_HAsciiString) newval = list->Value(i);
       if (!CheckValue (newval,themodl,thedef)) return Standard_False;
Index: oce/src/IFSelect/IFSelect_WorkSession.cxx
===================================================================
--- oce.orig/src/IFSelect/IFSelect_WorkSession.cxx
+++ oce/src/IFSelect/IFSelect_WorkSession.cxx
@@ -3434,8 +3434,6 @@ void IFSelect_WorkSession::DumpModel
     if (level == 5 || level ==  8) mode = IFSelect_CountByItem;
     if (level == 6 || level ==  9) mode = IFSelect_ListByItem;
     if (level == 7 || level == 10) mode = IFSelect_EntitiesByItem;
-    Standard_Boolean failsonly = Standard_False;
-    if (level < 8 && level != 4) failsonly = Standard_True;
     PrintCheckList (ModelCheckList(),Standard_False, mode);
   } else {
     if (level == 3) S << "        ********  Check Model (Fails)  ********"<<endl;
Index: oce/src/IGESConvGeom/IGESConvGeom.cxx
===================================================================
--- oce.orig/src/IGESConvGeom/IGESConvGeom.cxx
+++ oce/src/IGESConvGeom/IGESConvGeom.cxx
@@ -572,16 +572,12 @@ Standard_Integer IGESConvGeom::IncreaseS
 {
   if (continuity < 1) return continuity;
   Standard_Boolean isC1 = Standard_True, isC2 = Standard_True;
-  Standard_Integer i,j;
-
-  i = res->LastUKnotIndex();   //knots.Upper();
-  j = res->FirstUKnotIndex();  //knots.Lower();
   Standard_Integer DegreeU = res->UDegree();
   
   Standard_Boolean isModified;
   do {
     isModified = Standard_False;
-    for (i = res->FirstUKnotIndex()+1; i < res->LastUKnotIndex(); i++) 
+    for (Standard_Integer i = res->FirstUKnotIndex()+1; i < res->LastUKnotIndex(); i++) 
       if(DegreeU - res->UMultiplicity(i) < continuity) {
         if (continuity >= 2) {
           if (!res->RemoveUKnot(i, DegreeU-2, epsgeom)) {
@@ -605,7 +601,7 @@ Standard_Integer IGESConvGeom::IncreaseS
   Standard_Integer DegreeV = res->VDegree();
   do {
     isModified = Standard_False;
-    for (i = res->FirstVKnotIndex()+1; i < res->LastVKnotIndex(); i++) 
+    for (Standard_Integer i = res->FirstVKnotIndex()+1; i < res->LastVKnotIndex(); i++) 
       if(DegreeV - res->VMultiplicity(i) < continuity) {
         if (continuity >= 2) {
           if (!res->RemoveVKnot(i, DegreeV-2, epsgeom)) {
Index: oce/src/IntAna/IntAna_IntQuadQuad.cxx
===================================================================
--- oce.orig/src/IntAna/IntAna_IntQuadQuad.cxx
+++ oce/src/IntAna/IntAna_IntQuadQuad.cxx
@@ -581,13 +581,11 @@ void IntAna_IntQuadQuad::Perform(const g
 				 const Standard_Real)  
 { 
   //
-  Standard_Boolean UN_SEUL_Z_PAR_THETA, DEUX_Z_PAR_THETA, 
-                   Z_POSITIF, Z_INDIFFERENT, Z_NEGATIF;
+  Standard_Boolean UN_SEUL_Z_PAR_THETA,
+                   Z_POSITIF, Z_NEGATIF;
   //
   UN_SEUL_Z_PAR_THETA=Standard_False;
-  DEUX_Z_PAR_THETA=Standard_True;
   Z_POSITIF=Standard_True;
-  Z_INDIFFERENT=Standard_True;
   Z_NEGATIF=Standard_False;
   //
   Standard_Integer i;
Index: oce/src/IntAna/IntAna_QuadQuadGeo.cxx
===================================================================
--- oce.orig/src/IntAna/IntAna_QuadQuadGeo.cxx
+++ oce/src/IntAna/IntAna_QuadQuadGeo.cxx
@@ -849,9 +849,8 @@ gp_Ax2 DirToAx2(const gp_Pnt& P,const gp
   Standard_Real RmR, RmR_Relative;
   RmR=(R1>R2)? (R1-R2) : (R2-R1);
   {
-    Standard_Real Rmax, Rmin;
+    Standard_Real Rmax;
     Rmax=(R1>R2)? R1 : R2;
-    Rmin=(R1>R2)? R2 : R1;
     RmR_Relative=RmR/Rmax;
   }
 
Index: oce/src/IntAna/IntAna_Quadric.cxx
===================================================================
--- oce.orig/src/IntAna/IntAna_Quadric.cxx
+++ oce/src/IntAna/IntAna_Quadric.cxx
@@ -130,20 +130,8 @@ void IntAna_Quadric::NewCoefficients( St
                                                   //   = X DirX + Y DirY + Z DirZ + Loc
   
   Standard_Real Cxx,Cyy,Czz,Cxy,Cxz,Cyz,Cx,Cy,Cz,Ccte;            
-
-
-#ifdef DEB  
-  gp_Dir DirX = Axis.XDirection();
-  gp_Dir DirY = Axis.YDirection();
-  gp_Dir DirZ = Axis.Direction();
-#else
-  Axis.XDirection();
-  Axis.YDirection();
-  Axis.Direction();
-#endif
   
   gp_Trsf Trans;
-  
   Trans.SetTransformation(Axis);
   Trans.Invert();
   t11=Trans.Value(1,1);  t12=Trans.Value(1,2); t13=Trans.Value(1,3); t14=Trans.Value(1,4);
Index: oce/src/IntCurve/IntCurve_IntPolyPolyGen.gxx
===================================================================
--- oce.orig/src/IntCurve/IntCurve_IntPolyPolyGen.gxx
+++ oce/src/IntCurve/IntCurve_IntPolyPolyGen.gxx
@@ -216,13 +216,6 @@ void IntCurve_IntPolyPolyGen::Perform( c
   Standard_Real Tl=(TheTol < TOL_MINI)? TOL_MINI : TheTol;
   Standard_Real TlConf=(TheTolConf < TOL_CONF_MINI)? TOL_CONF_MINI : TheTolConf;
   Perform(C1,D1,TlConf,Tl,0,DU,DU);
-  //----------------------------------------------------------------------
-  //-- Traitement des points en bouts 
-  //----------------------------------------------------------------------
-  Standard_Boolean HeadOn1 = Standard_False;
-  Standard_Boolean HeadOn2 = Standard_False;
-  Standard_Boolean EndOn1  = Standard_False;
-  Standard_Boolean EndOn2  = Standard_False;
   Standard_Integer i;
   Standard_Integer n=this->NbPoints();
 
@@ -240,12 +233,7 @@ void IntCurve_IntPolyPolyGen::Perform( c
 
   for(i=1;i<=n;i++) { 
     IntRes2d_Position Pos1 = this->Point(i).TransitionOfFirst().PositionOnCurve();
-    if(Pos1 == IntRes2d_Head) HeadOn1 = Standard_True;
-    else if(Pos1 == IntRes2d_End) EndOn1 = Standard_True;
-
     IntRes2d_Position Pos2 =  this->Point(i).TransitionOfSecond().PositionOnCurve();
-    if(Pos2 == IntRes2d_Head) HeadOn2 = Standard_True;
-    else if(Pos2 == IntRes2d_End) EndOn2 = Standard_True;
 
     if(Pos1 == IntRes2d_Head) { 
       if(Pos2 == IntRes2d_Head)     PosSegment|=1;
@@ -260,12 +248,7 @@ void IntCurve_IntPolyPolyGen::Perform( c
   n=this->NbSegments();
   for(i=1;i<=n;i++) { 
     IntRes2d_Position Pos1 = this->Segment(i).FirstPoint().TransitionOfFirst().PositionOnCurve();
-    if(Pos1 == IntRes2d_Head)     HeadOn1 = Standard_True;
-    else if(Pos1 == IntRes2d_End) EndOn1  = Standard_True;
-    
     IntRes2d_Position Pos2 =  this->Segment(i).FirstPoint().TransitionOfSecond().PositionOnCurve();
-    if(Pos2 == IntRes2d_Head)      HeadOn2 = Standard_True;
-    else if(Pos2 == IntRes2d_End)  EndOn2  = Standard_True;
 
     if(Pos1 == IntRes2d_Head) { 
       if(Pos2 == IntRes2d_Head)     PosSegment|=1;
@@ -277,12 +260,7 @@ void IntCurve_IntPolyPolyGen::Perform( c
     }
 
     Pos1 = this->Segment(i).LastPoint().TransitionOfFirst().PositionOnCurve();
-    if(Pos1 == IntRes2d_Head)     HeadOn1 = Standard_True;
-    else if(Pos1 == IntRes2d_End) EndOn1  = Standard_True;
-    
     Pos2 =  this->Segment(i).LastPoint().TransitionOfSecond().PositionOnCurve();
-    if(Pos2 == IntRes2d_Head)     HeadOn2 = Standard_True;
-    else if(Pos2 == IntRes2d_End) EndOn2  = Standard_True;
 
     if(Pos1 == IntRes2d_Head) { 
       if(Pos2 == IntRes2d_Head)     PosSegment|=1;
Index: oce/src/IntCurve/IntCurve_Polygon2dGen.gxx
===================================================================
--- oce.orig/src/IntCurve/IntCurve_Polygon2dGen.gxx
+++ oce/src/IntCurve/IntCurve_Polygon2dGen.gxx
@@ -318,20 +318,9 @@ void IntCurve_Polygon2dGen::ComputeWithB
 		TheParams.SetValue(MaxIndexUsed,u);
 		
 		Standard_Real u1m = 0.5*(u+TheParams.Value(TheIndex.Value(i-1)));
-		Standard_Real um2 = 0.5*(u+TheParams.Value(TheIndex.Value(i+1)));
 		gp_Pnt2d P1m = TheCurveTool::Value(C,u1m);
-#ifdef DEB
-		gp_Pnt2d Pm2 = TheCurveTool::Value(C,um2);
-#else
-                TheCurveTool::Value(C,um2);
-#endif
-		gp_Lin2d L1m(P1,gp_Dir2d(gp_Vec2d(P1,Pm)));
-#ifdef DEB
-		gp_Lin2d Lm2(Pm,gp_Dir2d(gp_Vec2d(Pm,ThePnts.Value(TheIndex.Value(i+1)))));
-#else
-                ThePnts.Value(TheIndex.Value(i+1));
-#endif
-		t = L1m.Distance(P1m);
+        gp_Lin2d L1m(P1,gp_Dir2d(gp_Vec2d(P1,Pm)));
+        t = L1m.Distance(P1m);
 		i--; 
 	      }
 	    }
Index: oce/src/IntImpParGen/IntImpParGen_Intersector.gxx
===================================================================
--- oce.orig/src/IntImpParGen/IntImpParGen_Intersector.gxx
+++ oce/src/IntImpParGen/IntImpParGen_Intersector.gxx
@@ -58,8 +58,6 @@ void IntImpParGen_Intersector::And_Domai
   NbResultats=0;
   
   for(Standard_Integer i=1; i<=Nb_Bornes_Intersection; i+=2) {
-    Standard_Boolean aReverse=Standard_False;
-    
     Standard_Real param1=Inter1.Value(i);
     Standard_Real param2=Inter1.Value(i+1);
 
@@ -70,7 +68,6 @@ void IntImpParGen_Intersector::And_Domai
       Standard_Real t=param1; param1=param2; param2=t;
       indice_1=i+1;
       indice_2=i;
-      aReverse=Standard_True;
     }
 
     gp_Pnt2d Pt1=TheImpTool.Value(param1);
@@ -78,10 +75,8 @@ void IntImpParGen_Intersector::And_Domai
     gp_Pnt2d Pt;
 
     Standard_Boolean IsOnTheImpCurveDomain1=Standard_True;
-    Standard_Boolean IsOnABoundary1=Standard_False;
 
     Standard_Boolean IsOnTheImpCurveDomain2=Standard_True;
-    Standard_Boolean IsOnABoundary2=Standard_False;
     //--------------------------------------------------------------------
     if(TheImpCurveDomain.HasFirstPoint()) { 
       if(param1<TheImpCurveDomain.FirstParameter()) {             
@@ -89,7 +84,6 @@ void IntImpParGen_Intersector::And_Domai
 	   > TheImpCurveDomain.FirstTolerance()) {
 	  IsOnTheImpCurveDomain1=Standard_False; 
 	}
-	else { 	  IsOnABoundary1=Standard_True; 	}
       }
     }
     if(IsOnTheImpCurveDomain1 && TheImpCurveDomain.HasLastPoint()) {
@@ -98,7 +92,6 @@ void IntImpParGen_Intersector::And_Domai
 	   > TheImpCurveDomain.FirstTolerance()) {
 	  IsOnTheImpCurveDomain1=Standard_False; 
 	}
-	else {	  IsOnABoundary1=Standard_True; 	}
       }
     }
     //--------------------------------------------------------------------
@@ -108,7 +101,6 @@ void IntImpParGen_Intersector::And_Domai
 	   > TheImpCurveDomain.FirstTolerance()) {
 	  IsOnTheImpCurveDomain2=Standard_False; 
 	}
-	else { 	  IsOnABoundary2=Standard_True; 	}
       }
     }
     if(IsOnTheImpCurveDomain2 && TheImpCurveDomain.HasLastPoint()) {
@@ -117,7 +109,6 @@ void IntImpParGen_Intersector::And_Domai
 	   > TheImpCurveDomain.FirstTolerance()) {
 	  IsOnTheImpCurveDomain2=Standard_False; 
 	}
-	else {	  IsOnABoundary2=Standard_True; 	}
       }
     }
 
Index: oce/src/IntPatch/IntPatch_ALineToWLine.cxx
===================================================================
--- oce.orig/src/IntPatch/IntPatch_ALineToWLine.cxx
+++ oce/src/IntPatch/IntPatch_ALineToWLine.cxx
@@ -51,17 +51,13 @@ static
 			     const Handle_Adaptor2d_HCurve2d& C2);
 
 static 
-  void RecadreMemePeriode(const IntSurf_Quadric aQuad1,
-			  const IntSurf_Quadric aQuad2,
-			  Standard_Real& u1,
+  void RecadreMemePeriode(Standard_Real& u1,
 			  Standard_Real& u2,
 			  const Standard_Real anu1,
 			  const Standard_Real anu2);
 
 static
   void CorrectFirstPartOfLine(Handle(IntSurf_LineOn2S)& LinOn2S,
-			      const IntSurf_Quadric aQuad1,
-			      const IntSurf_Quadric aQuad2,
 			      const Standard_Real ref_u1,
 			      const Standard_Real ref_u2,
 			      Standard_Real& new_u1,
@@ -485,7 +481,7 @@ static
     //// Modified by jgv, 17.09.09 for OCC21255 ////
     if (!Corrected && U >= refpar)
       {
-	CorrectFirstPartOfLine(LinOn2S, quad1, quad2, ref_u1, ref_u2, anu1, anu2);
+	CorrectFirstPartOfLine(LinOn2S, ref_u1, ref_u2, anu1, anu2);
 	Corrected = Standard_True;
       }
     ////////////////////////////////////////////////
@@ -495,7 +491,7 @@ static
       Pnt3d = aline->Value(U);
       quad1.Parameters(Pnt3d,u1,v1);
       quad2.Parameters(Pnt3d,u2,v2);
-      RecadreMemePeriode(quad1, quad2, u1,u2,anu1,anu2);
+      RecadreMemePeriode(u1,u2,anu1,anu2);
       anu1 = u1;
       anu2 = u2;
       POn2S.SetValue(Pnt3d,u1,v1,u2,v2);
@@ -527,7 +523,7 @@ static
   //
   RefineParameters(aline, firstparam, lastparam, lastparam, -1, quad2, 10.*myTol3D, u2,v2);
   //
-  RecadreMemePeriode(quad1, quad2, u1,u2,anu1,anu2);
+  RecadreMemePeriode(u1,u2,anu1,anu2);
   POn2S.SetValue(Pnt3d,u1,v1,u2,v2);
   LinOn2S->Add(POn2S);
   nbpwline++;
@@ -535,7 +531,7 @@ static
   //// Modified by jgv, 17.09.09 for OCC21255 ////
   if (!Corrected && 
       (lastparam >= refpar || refpar-lastparam < Precision::Confusion()))
-    CorrectFirstPartOfLine(LinOn2S, quad1, quad2, ref_u1, ref_u2, anu1, anu2);
+    CorrectFirstPartOfLine(LinOn2S, ref_u1, ref_u2, anu1, anu2);
   ////////////////////////////////////////////////
 
   //
@@ -630,7 +626,7 @@ static
   do { 
     Standard_Boolean RemoveVtxo, RemoveVtx;
     Standard_Integer vo, voo;
-    Standard_Real ponl, ponlo, ponloo, aDist13, aDist23;
+    Standard_Real ponl, ponlo, aDist13, aDist23;
     //
     APointHasBeenRemoved = Standard_False;
     RemoveVtxo = Standard_False;
@@ -656,7 +652,6 @@ static
 		  if(voo!=v && voo!=vo) {
 		    if(newparamvertex(voo)>=0.) { 
 		      const IntPatch_Point& Vtxoo = aline->Vertex(voo);
-		      ponloo = Vtxoo.ParameterOnLine();
 		      const gp_Pnt& aPoo=Vtxoo.Value();
 		      //
 		      aDist13=aP.Distance(aPoo);
@@ -804,7 +799,7 @@ static
       //
       if(v==1) { 
 	ParamVtxPrecedent=refpointonwline;
-	RecadreMemePeriode(quad1, quad2, u1,u2,anu1,anu2);
+	RecadreMemePeriode(u1,u2,anu1,anu2);
 	NewPoint.SetParameter(refpointonwline);
 	//
 	NewPoint.SetParameters(u1,v1,u2,v2);
@@ -816,7 +811,7 @@ static
 	  //-- 2 vertex renseignent le meme point de la LineOn2S
 	  //-- On insere un nv point  =  vtx
 	  //-- On decale tous les vtx apres de 1 
-	  RecadreMemePeriode(quad1, quad2, u1,u2,anu1,anu2);
+	  RecadreMemePeriode(u1,u2,anu1,anu2);
 	  POn2S.SetValue(Pnt3d,u1,v1,u2,v2);
 	  LinOn2S->InsertBefore(refpointonwline+1, POn2S);
 	  nbpwline++;
@@ -834,7 +829,7 @@ static
 	}
 	//
 	else { 
-	  RecadreMemePeriode(quad1, quad2, u1,u2, anu1, anu2);
+	  RecadreMemePeriode(u1,u2, anu1, anu2);
 	  NewPoint.SetParameter(refpointonwline);
 	  //
 	  NewPoint.SetParameters(u1, v1, u2, v2);
@@ -922,19 +917,11 @@ Standard_Boolean SameCurve(const Handle_
 //function : RecadreMemePeriode
 //purpose  : 
 //=======================================================================
-void RecadreMemePeriode(const IntSurf_Quadric aQuad1,
-			const IntSurf_Quadric aQuad2,
-			Standard_Real& u1,
+void RecadreMemePeriode(Standard_Real& u1,
 			Standard_Real& u2,
 			const Standard_Real anu1,
 			const Standard_Real anu2) 
 { 
-  Standard_Boolean bBothCylinders;
-  GeomAbs_SurfaceType aType1, aType2;
-  //
-  aType1=aQuad1.TypeQuadric();
-  aType2=aQuad2.TypeQuadric();
-  bBothCylinders=(aType1==GeomAbs_Cylinder && aType2==GeomAbs_Cylinder);
   //
   while(anu1-u1 > 5.0) {
     u1+=M_PI+M_PI;
@@ -981,8 +968,6 @@ void RecadreMemePeriode(const IntSurf_Qu
 //purpose  : 
 //=======================================================================
 void CorrectFirstPartOfLine(Handle(IntSurf_LineOn2S)& LinOn2S,
-			    const IntSurf_Quadric aQuad1,
-			    const IntSurf_Quadric aQuad2,
 			    const Standard_Real ref_u1,
 			    const Standard_Real ref_u2,
 			    Standard_Real& new_u1,
@@ -996,7 +981,7 @@ void CorrectFirstPartOfLine(Handle(IntSu
 
   new_u1 = u1;
   new_u2 = u2;
-  RecadreMemePeriode(aQuad1, aQuad2, new_u1, new_u2, ref_u1, ref_u2);
+  RecadreMemePeriode(new_u1, new_u2, ref_u1, ref_u2);
   OffsetOnS1 = new_u1 - u1;
   OffsetOnS2 = new_u2 - u2;
   if (Abs(OffsetOnS1) > 1. || Abs(OffsetOnS2) > 1.) //recadre on n*2*PI is done
Index: oce/src/IntPatch/IntPatch_ImpImpIntersection_2.gxx
===================================================================
--- oce.orig/src/IntPatch/IntPatch_ImpImpIntersection_2.gxx
+++ oce/src/IntPatch/IntPatch_ImpImpIntersection_2.gxx
@@ -562,10 +562,8 @@ void IntPatch_ImpImpIntersection::Perfor
     gp_Pnt P;
     IntPatch_Point point;
     Standard_Real u1,v1,u2,v2; 
-    Standard_Integer nbv;
     if(slin.Value(i)->ArcType() == IntPatch_Circle) { 
       const Handle(IntPatch_GLine)& glin = *((Handle(IntPatch_GLine)*)&slin.Value(i));
-      nbv = glin->NbVertex();
       if(glin->NbVertex() == 0) { 
 	gp_Circ Circ = glin->Circle();
 	P=ElCLib::Value(0.0,Circ);
@@ -588,7 +586,6 @@ void IntPatch_ImpImpIntersection::Perfor
     
     else if(slin.Value(i)->ArcType() == IntPatch_Ellipse) { 
       const Handle(IntPatch_GLine)& glin = *((Handle(IntPatch_GLine)*)&slin.Value(i));
-      nbv = glin->NbVertex();
       if(glin->NbVertex() == 0) { 
 	gp_Elips Elips = glin->Ellipse();
 	P=ElCLib::Value(0.0,Elips);
Index: oce/src/IntPatch/IntPatch_ImpImpIntersection_4.gxx
===================================================================
--- oce.orig/src/IntPatch/IntPatch_ImpImpIntersection_4.gxx
+++ oce/src/IntPatch/IntPatch_ImpImpIntersection_4.gxx
@@ -906,7 +906,6 @@ Standard_Boolean IntCyCo(const IntSurf_Q
       IntAna_Curve aC;
       IntAna_ListOfCurve aLC;
       IntAna_ListIteratorOfListOfCurve aIt;
-      Standard_Boolean bToSplit;
       
       //
       NbSol = anaint.NbCurve();
@@ -915,7 +914,7 @@ Standard_Boolean IntCyCo(const IntSurf_Q
 	//curvsol = anaint.Curve(i);
 	aC=anaint.Curve(i);
 	aLC.Clear();
-	bToSplit=ExploreCurve(Cy, Co, aC, 10.*Tol, aLC);
+	ExploreCurve(Cy, Co, aC, 10.*Tol, aLC);
 	//
 	aIt.Initialize(aLC);
 	for (; aIt.More(); aIt.Next()) {
Index: oce/src/IntPatch/IntPatch_ImpImpIntersection_5.gxx
===================================================================
--- oce.orig/src/IntPatch/IntPatch_ImpImpIntersection_5.gxx
+++ oce/src/IntPatch/IntPatch_ImpImpIntersection_5.gxx
@@ -203,7 +203,6 @@ Standard_Boolean IntCoCo(const IntSurf_Q
 
   case IntAna_Circle:
     {
-      Standard_Real para;
       IntPatch_Point aPtsol;
       gp_Vec Tgt;
       gp_Pnt ptref;
@@ -229,7 +228,6 @@ Standard_Boolean IntCoCo(const IntSurf_Q
 	  Quad2.Parameters(aPChar, U2, V2);
 	  aPtsol.SetValue(aPChar, Tol, Standard_False);
 	  aPtsol.SetParameters(U1, V1, U2, V2);
-	  para = ElCLib::Parameter(cirsol, aPChar);
 	  aPtsol.SetParameter(0.);
 	  glig->AddVertex(aPtsol);
 	}
@@ -241,7 +239,6 @@ Standard_Boolean IntCoCo(const IntSurf_Q
 
   case IntAna_Ellipse:
     {
-      Standard_Real para;
       IntPatch_Point aPtsol;
       gp_Elips elipsol = inter.Ellipse(1);
       
@@ -268,7 +265,6 @@ Standard_Boolean IntCoCo(const IntSurf_Q
 	Quad2.Parameters(aPChar, U2, V2);
 	aPtsol.SetValue(aPChar, Tol, Standard_False);
 	aPtsol.SetParameters(U1, V1, U2, V2);
-	para = ElCLib::Parameter(elipsol, aPChar);
 	aPtsol.SetParameter(0.);
 	glig->AddVertex(aPtsol);
       }
@@ -280,7 +276,6 @@ Standard_Boolean IntCoCo(const IntSurf_Q
 
   case IntAna_Hyperbola:
     {
-      Standard_Real para;
       IntPatch_Point aPtsol;
       gp_Vec Tgt;
       gp_Pnt ptref;
@@ -306,7 +301,6 @@ Standard_Boolean IntCoCo(const IntSurf_Q
 	  Quad2.Parameters(aPChar, U2, V2);
 	  aPtsol.SetValue(aPChar, Tol, Standard_False);
 	  aPtsol.SetParameters(U1, V1, U2, V2);
-	  para = ElCLib::Parameter(hyprsol, aPChar);
 	  aPtsol.SetParameter(0.);
 	  glig->AddVertex(aPtsol);
 	}
@@ -317,7 +311,6 @@ Standard_Boolean IntCoCo(const IntSurf_Q
     
   case IntAna_Parabola:
     {
-      Standard_Real para;
       IntPatch_Point aPtsol;
       gp_Parab parabsol = inter.Parabola(1);
       
@@ -343,7 +336,6 @@ Standard_Boolean IntCoCo(const IntSurf_Q
 	Quad2.Parameters(aPChar, U2, V2);
 	aPtsol.SetValue(aPChar, Tol, Standard_False);
 	aPtsol.SetParameters(U1, V1, U2, V2);
-	para = ElCLib::Parameter(parabsol, aPChar);
 	aPtsol.SetParameter(0.);
 	glig->AddVertex(aPtsol);
       }
Index: oce/src/IntPatch/IntPatch_ImpPrmIntersection.cxx
===================================================================
--- oce.orig/src/IntPatch/IntPatch_ImpPrmIntersection.cxx
+++ oce/src/IntPatch/IntPatch_ImpPrmIntersection.cxx
@@ -1802,7 +1802,6 @@ static void ToSmooth(Handle(IntSurf_Line
   Standard_Integer Index3 = (IsFirst) ? 3 : (Line->NbPoints()-2);
 
   Standard_Boolean doU = Standard_False;
-  Standard_Boolean doV = Standard_False;
 
   Standard_Real U1 = 0., U2 = 0., V1 = 0., V2 = 0., U3 = 0., V3 = 0.;
 
@@ -1842,8 +1841,6 @@ static void ToSmooth(Handle(IntSurf_Line
     }
   }
 
-  if(fabs(fabs(V1)-fabs(V2)) > DDV) doV = Standard_True;
-
   if(doU) {
     Standard_Real dU = Min((DDU/10.),5.e-8);
     Standard_Real U = (U2 > U3) ? (U2 + dU) : (U2 - dU);
@@ -2327,7 +2324,7 @@ void DecomposeResult(Handle(IntPatch_Lin
   Standard_Real BAPEX = M_PI/16.;  // delta U crossing apex
   
   Standard_Integer k = 0;
-  Standard_Real U1 = 0., U2 = 0., V1 = 0., V2 = 0., AnU1 = 0., AnV1 = 0., DU1 = 0., DV1 = 0.;
+  Standard_Real U1 = 0., U2 = 0., V1 = 0., V2 = 0., AnU1 = 0.;
   Standard_Integer Findex = 1, Lindex = NbPnts, Bindex = 0;
 
   gp_Pnt aPnt, aSPnt;
@@ -2346,8 +2343,7 @@ void DecomposeResult(Handle(IntPatch_Lin
 
   // reset variables
   Standard_Boolean isDecomposited = Standard_False;
-  Standard_Boolean is2PIDecomposed = Standard_False;
-  U1 = 0.; V1 = 0.; U2 = 0.; V2 = 0.; AnU1 = 0.; AnV1 = 0.; DU1 = 0.; DV1 = 0.;
+  U1 = 0.; V1 = 0.; U2 = 0.; V2 = 0.; AnU1 = 0.;
 
   // analyze other points
   for(k = Findex; k <= Lindex; k++) {
@@ -2361,7 +2357,6 @@ void DecomposeResult(Handle(IntPatch_Lin
 	SSLine->Value(k).ParametersOnS1(AnU1,V1);    // S1 - quadric, set U,V by Pnt3D
       }
       sline->Add(SSLine->Value(k));
-      AnV1 = V1;
       continue;
     }
 
@@ -2376,7 +2371,6 @@ void DecomposeResult(Handle(IntPatch_Lin
     if(DeltaU > BSEAM) {
       Bindex = k;
       isDecomposited = Standard_True;
-      is2PIDecomposed = Standard_True;
       break;
     }
     else if((DeltaU > BAPEX) && (k >= (Findex+10) && k <= (Lindex-10))) {
@@ -2388,7 +2382,6 @@ void DecomposeResult(Handle(IntPatch_Lin
 
     sline->Add(SSLine->Value(k));
     AnU1=U1;
-    AnV1=V1;
   }
  
   IntSurf_PntOn2S aVF,aVL;
Index: oce/src/IntPatch/IntPatch_LineConstructor.cxx
===================================================================
--- oce.orig/src/IntPatch/IntPatch_LineConstructor.cxx
+++ oce/src/IntPatch/IntPatch_LineConstructor.cxx
@@ -1068,7 +1068,7 @@ static void TestWLineToRLine(const IntPa
 	// check that the middle point is on arc
 	(WLine->Point(midInd).*piParOnS)(utst,vtst);
 	if (midInd == ParamMinOnLine) {
-	  Standard_Real utst1,vtst1;
+	  Standard_Real utst1=0.0,vtst1=0.0;
 	  (WLine->Point(midInd+1).*piParOnS)(utst1,vtst1);
 	  utst = (utst+utst1)*0.5;
 	  vtst = (vtst+vtst1)*0.5;
Index: oce/src/IntPatch/IntPatch_Polyhedron.cxx
===================================================================
--- oce.orig/src/IntPatch/IntPatch_Polyhedron.cxx
+++ oce/src/IntPatch/IntPatch_Polyhedron.cxx
@@ -508,11 +508,10 @@ Standard_Integer IntPatch_Polyhedron::Tr
 #if MSG_DEBUG
     cout<<" Probleme ds IntCurveSurface_Polyhedron : OtherP et PEdge Confondus "<<endl;
 #endif
-    Standard_Integer TempTri,TempOtherP;
-    TempTri = TriCon;
-    TempOtherP = OtherP;
-
     return(0); //-- BUG NON CORRIGE ( a revoir le role de nbdeltaU et nbdeltaV)
+//    Standard_Integer TempTri,TempOtherP;
+//    TempTri = TriCon;
+//    TempOtherP = OtherP;
 //    return(TriConnex(TempTri,Pivot,TempOtherP,TriCon,OtherP));
   }
   return TriCon;
Index: oce/src/IntPatch/IntPatch_PrmPrmIntersection.cxx
===================================================================
--- oce.orig/src/IntPatch/IntPatch_PrmPrmIntersection.cxx
+++ oce/src/IntPatch/IntPatch_PrmPrmIntersection.cxx
@@ -2812,7 +2812,7 @@ void IntPatch_PrmPrmIntersection::PointD
   //modified by NIZNHY-PKV Wed May 25 06:47:12 2011t
   Standard_Integer iC15, SU1, SV1, SU2, SV2;
   Standard_Real U0, U1, V0, V1, U, V;
-  Standard_Real resu0,resu1,resv0,resv1;
+  Standard_Real resu0,resv0;
   Standard_Real  du1,du2,dv1,dv2, dmaxOn1, dmaxOn2;
   Standard_Real x0,y0,z0, x1,y1,z1,d;
   Bnd_Box Box1, Box2;
@@ -2842,8 +2842,6 @@ void IntPatch_PrmPrmIntersection::PointD
   V1 = S1->LastVParameter();
   //
   resu0=U0;
-  resu1=U1;
-  resv1=V1;
   resv0=V0;
   //
   dmaxOn1 = 0.0;
Index: oce/src/IntPatch/IntPatch_RLine.cxx
===================================================================
--- oce.orig/src/IntPatch/IntPatch_RLine.cxx
+++ oce/src/IntPatch/IntPatch_RLine.cxx
@@ -104,9 +104,6 @@ void IntPatch_RLine::ComputeVertexParame
 {
   Standard_Integer i,j,nbvtx;//k;
   
-  Standard_Real ParamMinOnLine,ParamMaxOnLine;
-  if(fipt) { ParamMinOnLine = Vertex(indf).ParameterOnLine(); } else { ParamMinOnLine = -100000.0; } 
-  if(lapt) { ParamMaxOnLine = Vertex(indl).ParameterOnLine(); } else { ParamMaxOnLine =  100000.0; } 
   Standard_Boolean APointDeleted = Standard_False;
   //----------------------------------------------------------
   //--     F i l t r e   s u r   r e s t r i c t i o n s   --
Index: oce/src/IntPatch/IntPatch_RstInt.cxx
===================================================================
--- oce.orig/src/IntPatch/IntPatch_RstInt.cxx
+++ oce/src/IntPatch/IntPatch_RstInt.cxx
@@ -699,13 +699,15 @@ void IntPatch_RstInt::PutVertexOnLine (H
 	      (!Domain->Has3d() && Standard_Integer(nptCh)+1 < Nbptlin);
 	    if (!isNptLow && !IsSegment2dSmall(Brise,UMinAr,UMaxAr,tolU,tolV)) {
 	      // treat both ends
-	      Standard_Real UMinChP,UMaxChP,UMinArP,UMaxArP;
-	      UMinChP = IntegerPart(UMinCh); UMinArP = IntegerPart(UMinAr);
-	      UMaxChP = IntegerPart(UMaxCh); UMaxArP = IntegerPart(UMaxAr);
-	      Standard_Integer irangCh1,irangCh2,irangAr1,irangAr2;
-	      irangCh1 = Standard_Integer(UMinChP)+1; irangCh2 = Standard_Integer(UMaxChP)+1;
-	      irangAr1 = Standard_Integer(UMinArP)+1; irangAr2 = Standard_Integer(UMaxArP)+1;
-	      UMinChP = UMinCh - UMinChP; UMinArP = UMinAr - UMinArP;
+	      Standard_Real UMinChP,UMinArP,UMaxArP;
+	      UMinChP = IntegerPart(UMinCh);
+              UMinArP = IntegerPart(UMinAr);
+              UMaxArP = IntegerPart(UMaxAr);
+	      Standard_Integer irangAr1,irangAr2;
+	      irangAr1 = Standard_Integer(UMinArP)+1;
+              irangAr2 = Standard_Integer(UMaxArP)+1;
+	      UMinChP = UMinCh - UMinChP;
+              UMinArP = UMinAr - UMinArP;
 	      //UMaxChP = UMaxCh - UMaxChP; UMaxArP = UMaxAr - UMaxArP;
 	      const Standard_Real eps = 1e-10;
 //	      Standard_Boolean isChExtr1 = irangCh1==1 && UMinChP<eps;
Index: oce/src/IntPatch/IntPatch_WLine.cxx
===================================================================
--- oce.orig/src/IntPatch/IntPatch_WLine.cxx
+++ oce/src/IntPatch/IntPatch_WLine.cxx
@@ -247,9 +247,6 @@ void IntPatch_WLine::ComputeVertexParame
   Standard_Integer indicevertexonline;
   Standard_Real    indicevertex;
 
-  Standard_Real ParamMinOnLine,ParamMaxOnLine;
-  if(fipt) { ParamMinOnLine = Vertex(indf).ParameterOnLine(); } else { ParamMinOnLine = -100000.0; } 
-  if(lapt) { ParamMaxOnLine = Vertex(indl).ParameterOnLine(); } else { ParamMaxOnLine =  100000.0; } 
   Standard_Boolean APointDeleted = Standard_False;
   //----------------------------------------------------------
   //--     F i l t r e   s u r   r e s t r i c t i o n s   --
Index: oce/src/IntPolyh/IntPolyh_MaillageAffinage.cxx
===================================================================
--- oce.orig/src/IntPolyh/IntPolyh_MaillageAffinage.cxx
+++ oce/src/IntPolyh/IntPolyh_MaillageAffinage.cxx
@@ -372,7 +372,7 @@ void IntPolyh_MaillageAffinage::FillArra
   Standard_Boolean bDegI, bDeg;
   Standard_Integer aNbU, aNbV, iCnt, i, j;
   Standard_Integer aID1, aID2, aJD1, aJD2;
-  Standard_Real Tol, resol, u0, v0, u1, v1, aU, aV, aMag;
+  Standard_Real Tol, resol, aU, aV, aMag;
   Standard_Real aX, aY, aZ;
   gp_Pnt aP;
   gp_Vec aDU, aDV, aNorm;
@@ -384,10 +384,6 @@ void IntPolyh_MaillageAffinage::FillArra
   IntPolyh_ArrayOfPoints &TPoints=(SurfID==1)? TPoints1:TPoints2;
   //
   resol = gp::Resolution();
-  u0 = Upars(1);
-  v0 = Vpars(1);
-  u1 = Upars(aNbU);
-  v1 = Vpars(aNbV);
   //
   IntCurveSurface_ThePolyhedronOfHInter polyhedron(aS, Upars, Vpars);
   Tol=polyhedron.DeflectionOverEstimation();
Index: oce/src/IntStart/IntStart_SearchOnBoundaries.gxx
===================================================================
--- oce.orig/src/IntStart/IntStart_SearchOnBoundaries.gxx
+++ oce/src/IntStart/IntStart_SearchOnBoundaries.gxx
@@ -720,7 +720,7 @@ Standard_Integer TreatLC (const TheArc&
     return anExitCode;
   }
   
-  Standard_Real f, l, U1f, U1l, U2f, U2l, U1, UEgde, TOL, aDist, aR, aRRel, Tol;
+  Standard_Real f, l, U1f, U1l, U2f, U2l, UEgde, TOL, aDist, aR, aRRel, Tol;
   Handle(Geom_Curve) aCEdge=BRep_Tool::Curve(*anE, f, l);
   
   gp_Cylinder aCyl=aQuadric.Cylinder();
@@ -758,7 +758,6 @@ Standard_Integer TreatLC (const TheArc&
   P1   =PC1.Value();
   PEdge=PC2.Value();
   
-  U1=PC1.Parameter();
   UEgde=PC2.Parameter();
   
   aDist=PEdge.Distance(P1);
Index: oce/src/IntTools/IntTools.cxx
===================================================================
--- oce.orig/src/IntTools/IntTools.cxx
+++ oce/src/IntTools/IntTools.cxx
@@ -234,14 +234,13 @@
 				 const Standard_Real myEpsNull)
 {
   Standard_Integer aType, j, aNbRoots;
-  Standard_Real t, t1, t2, f1, f2, absf1, absf2;
+  Standard_Real t1, t2, f1, f2, absf2;
 
   aNbRoots=mySequenceOfRoots.Length();
 
   for (j=1; j<=aNbRoots; j++) {
     IntTools_Root& aR=mySequenceOfRoots.ChangeValue(j);
     
-    t=aR.Root();
     aR.Interval (t1, t2, f1, f2);
 
     aType=aR.Type();
@@ -263,7 +262,6 @@
       break;
       
     case 2: // Smart;
-      absf1=fabs(f1);
       absf2=fabs(f2);
       if (absf2 < myEpsNull) {
 	aR.SetStateAfter (TopAbs_ON);
Index: oce/src/IntTools/IntTools_BeanBeanIntersector.cxx
===================================================================
--- oce.orig/src/IntTools/IntTools_BeanBeanIntersector.cxx
+++ oce/src/IntTools/IntTools_BeanBeanIntersector.cxx
@@ -1277,10 +1277,9 @@ Standard_Integer FindMaxDistPC(const Sta
 			       Standard_Real& aDmax, 
 			       Standard_Real& aT1max) 
 {
-  Standard_Integer iErr, iCnt;
-  Standard_Real aGS, aXP, aA, aB, aXL, aYP, aYL, aT2P, aT2L, aX0;
+  Standard_Integer iErr;
+  Standard_Real aGS, aXP, aA, aB, aXL, aYP, aYL, aT2P, aT2L;
   //
-  iCnt=0;
   iErr=0;
   aDmax=0.;
   //
@@ -1324,7 +1323,6 @@ Standard_Integer FindMaxDistPC(const Sta
     }
     //
     if ((aB-aA)<aEps1) {
-      aX0=0.5*(aA+aB);
       break;
     }
   }// while(1) {
Index: oce/src/IntTools/IntTools_EdgeEdge.cxx
===================================================================
--- oce.orig/src/IntTools/IntTools_EdgeEdge.cxx
+++ oce/src/IntTools/IntTools_EdgeEdge.cxx
@@ -699,7 +699,7 @@ Standard_Integer IntTools_EdgeEdge::Find
   //
   //
   Standard_Boolean aVFlag1, aVFlag2, aGeomFlag1, aGeomFlag2;
-  Standard_Real Df2m2, Dm2l2, Df2l2, df2m2, dm2l2, df2l2, df1m1, dm1l1, df1l1;
+  Standard_Real Df2m2, Dm2l2, Df2l2, df2m2, dm2l2, df2l2, df1l1;
   Standard_Real tV1, tV2;
   //
   // parametric differences for C2
@@ -735,8 +735,6 @@ Standard_Integer IntTools_EdgeEdge::Find
   }
   //
   // geometric distances for C1
-  df1m1=aPf1.Distance(aPm1);
-  dm1l1=aPm1.Distance(aPl1);
   df1l1=aPf1.Distance(aPl1);
   //
   // if geometric distances between boundaries is less than myCriteria
@@ -862,7 +860,7 @@ Standard_Integer IntTools_EdgeEdge::Find
   void IntTools_EdgeEdge::IsIntersection (const Standard_Real ta, 
 					  const Standard_Real tb) 
 {
-  Standard_Integer i, aNb, pri;
+  Standard_Integer i, aNb;
   Standard_Real t, f;
   GeomAbs_CurveType aCT1, aCT2;
   IntTools_CArray1OfReal anArgs, aFunc;
@@ -918,7 +916,7 @@ Standard_Integer IntTools_EdgeEdge::Find
   }
   //
   // Prepare values of arguments for the interval [ta, tb]
-  pri=IntTools::PrepareArgs (myCFrom, tb, ta, myDiscret, myDeflection, anArgs);
+  IntTools::PrepareArgs (myCFrom, tb, ta, myDiscret, myDeflection, anArgs);
   aNb=anArgs.Length();
 
   aFunc.Resize(aNb);
@@ -942,7 +940,7 @@ Standard_Integer IntTools_EdgeEdge::Find
 					     const IntTools_CArray1OfReal& f)  
 {
   Standard_Integer i, n, k;
-  Standard_Real fr, tr, anEpsNull;
+  Standard_Real tr, anEpsNull;
   IntTools_CArray1OfReal fd;
   TColStd_SequenceOfReal aTSeq, aFSeq;
   
@@ -989,7 +987,6 @@ Standard_Integer IntTools_EdgeEdge::Find
     //aa
     if (fd1*fd2 < 0.) {
       tr=FindSimpleRoot(2, t1, t2, fd1);
-      fr=DistanceFunction(tr);
       myPar1=tr;
       myParallel=Standard_False;
       break;
@@ -997,7 +994,6 @@ Standard_Integer IntTools_EdgeEdge::Find
     
     if (!bF1 && bF2) {
       tr=t2;
-      fr=fd2;
       myPar1=tr;
       myParallel=Standard_False;
       break;
@@ -1005,7 +1001,6 @@ Standard_Integer IntTools_EdgeEdge::Find
     
     if (bF1 && !bF2) {
       tr=t1;
-      fr=fd1;
       myPar1=tr;
       myParallel=Standard_False;
       break;
@@ -1248,7 +1243,7 @@ Standard_Integer IntTools_EdgeEdge::Find
   Standard_Real aTFR1, aTLR1, aTFR2, aTLR2;
   Standard_Real aTL1, aTL2, aTC1, aTC2;
   Standard_Real aRC, aDLC, aD2, aC2, aTLx, aTCx;
-  GeomAbs_CurveType aTFrom, aTTo;
+  GeomAbs_CurveType aTFrom;
   gp_Circ aCirc;
   gp_Lin  aLine;
   gp_Pnt aPC, aPLx, aPCx;
@@ -1258,7 +1253,6 @@ Standard_Integer IntTools_EdgeEdge::Find
   (aCP.Ranges2())(1).Range(aTFR2, aTLR2);
   //
   aTFrom=myCFrom.GetType();
-  aTTo  =myCTo.GetType();
   //
   aTL1=aTFR1;
   aTL2=aTLR1;
@@ -1434,13 +1428,12 @@ Standard_Integer IntTools_EdgeEdge::Find
      (myCFrom.GetType() == GeomAbs_Circle && myCTo.GetType() == GeomAbs_Line))
   {
     Standard_Real aRadius;
-    GeomAbs_CurveType aTFrom, aTTo;
+    GeomAbs_CurveType aTFrom;
     gp_Circ aCirc;
     gp_Lin  aLine;
     gp_Pnt aPCenter, aPOnLine;
 
     aTFrom=myCFrom.GetType();
-    aTTo  =myCTo.GetType();
     
     if (aTFrom==GeomAbs_Circle) {
       aCirc=myCFrom.Circle();
Index: oce/src/IntTools/IntTools_EdgeEdge_1.cxx
===================================================================
--- oce.orig/src/IntTools/IntTools_EdgeEdge_1.cxx
+++ oce/src/IntTools/IntTools_EdgeEdge_1.cxx
@@ -765,11 +765,9 @@ void IntTools_DistCC::FindMaxLocal(const
 				   Standard_Real& aDx,
 				   Standard_Real& aTx)
 {
-  Standard_Integer iErr;
   Standard_Real aA, aB, aCf, aX1, aX2, aF1, aF2, aX, aF;
   //
   myErrorStatus=0;
-  iErr=0;
   aDx=0.;
   aTx=0.;
   //
Index: oce/src/IntTools/IntTools_EdgeFace.cxx
===================================================================
--- oce.orig/src/IntTools/IntTools_EdgeFace.cxx
+++ oce/src/IntTools/IntTools_EdgeFace.cxx
@@ -424,7 +424,8 @@ Standard_Boolean IntTools_EdgeFace::IsPr
 //=======================================================================
 Standard_Real IntTools_EdgeFace::DistanceFunction(const Standard_Real t)
 {
-  Standard_Real Umin, Usup, Vmin, Vsup, aD;
+  Standard_Real aD;
+
   //
   gp_Pnt P;
   myC.D0(t, P);
@@ -437,11 +438,6 @@ Standard_Real IntTools_EdgeFace::Distanc
     return aD; 
   }
   
-  Umin=myS.FirstUParameter();
-  Usup=myS.LastUParameter();
-  Vmin=myS.FirstVParameter();
-  Vsup=myS.LastVParameter ();
-  
   //
   Standard_Boolean bFlag = Standard_False;
 
@@ -610,9 +606,6 @@ Standard_Real IntTools_EdgeFace::Distanc
 
   k=n-1;
   for (i=1; i<k; i++) {
-    Standard_Real ti, ti1;
-    ti=t(i);
-    ti1=t(i-1);
     fd(i)=.5*(f(i+1)-f(i-1))/(t(i)-t(i-1));
     if (fabs(fd(i)) < dEpsNull){
       fd(i)=0.;
@@ -916,13 +909,13 @@ Standard_Real IntTools_EdgeFace::Distanc
 					  const Standard_Real tb) 
 {
   IntTools_CArray1OfReal anArgs, aFunc;
-  Standard_Integer i, aNb, pri, aCnt=0;
+  Standard_Integer i, aNb, aCnt=0;
   //
   Standard_Integer aCntIncreasing=1, aCntDecreasing=1;
   Standard_Real t, f, f1;
   //
   // Prepare values of arguments for the interval [ta, tb]
-  pri=IntTools::PrepareArgs (myC, tb, ta, myDiscret, myDeflection, anArgs);
+  IntTools::PrepareArgs (myC, tb, ta, myDiscret, myDeflection, anArgs);
   aNb=anArgs.Length();
   
   aFunc.Resize(aNb);
@@ -983,7 +976,7 @@ Standard_Real IntTools_EdgeFace::Distanc
 					     const IntTools_CArray1OfReal& f)  
 {
   Standard_Integer i, n, k;
-  Standard_Real fr, tr;
+  Standard_Real tr;
   IntTools_CArray1OfReal fd;
   TColStd_SequenceOfReal aTSeq, aFSeq;  
   
@@ -1030,7 +1023,7 @@ Standard_Real IntTools_EdgeFace::Distanc
     //
     if (fd1*fd2 < 0.) {
       tr=FindSimpleRoot(2, t1, t2, fd1);
-      fr=DistanceFunction(tr);
+      DistanceFunction(tr);
       myPar1=tr;
       myParallel=Standard_False;
       break;
@@ -1038,7 +1031,6 @@ Standard_Real IntTools_EdgeFace::Distanc
     
     if (!bF1 && bF2) {
       tr=t2;
-      fr=fd2;
       myPar1=tr;
       myParallel=Standard_False;
       break;
@@ -1046,7 +1038,6 @@ Standard_Real IntTools_EdgeFace::Distanc
     
     if (bF1 && !bF2) {
       tr=t1;
-      fr=fd1;
       myPar1=tr;
       myParallel=Standard_False;
       break;
@@ -1524,17 +1515,14 @@ Standard_Integer AdaptiveDiscret (const
 
   iDiscretNew=iDiscret;
 
-  GeomAbs_CurveType   aCType;
   GeomAbs_SurfaceType aSType;
 
-  aCType=aCurve.GetType();
   aSType=aSurface.GetType();
     
   if (aSType==GeomAbs_Cylinder) {
-   Standard_Real aELength, aRadius, dL, dLR;
+   Standard_Real aELength, aRadius, dLR;
 
    aELength=IntTools::Length(aCurve.Edge());
-   dL=aELength/iDiscret;
    
    gp_Cylinder aCylinder=aSurface.Cylinder();
    aRadius=aCylinder.Radius();
Index: oce/src/IntWalk/IntWalk_PWalking_1.gxx
===================================================================
--- oce.orig/src/IntWalk/IntWalk_PWalking_1.gxx
+++ oce/src/IntWalk/IntWalk_PWalking_1.gxx
@@ -420,7 +420,6 @@ void IntWalk_PWalking::Perform(const TCo
   //xf
   Standard_Integer i, NbPasOKConseq;
   Standard_Real UFirst1, VFirst1, ULast1, VLast1, UFirst2, VFirst2, ULast2, VLast2;
-  Standard_Real pasMaxSV[4], aTmp;
   TColStd_Array1OfReal Param(1,4);
   IntImp_ConstIsoparametric ChoixIso;
   //xt
@@ -468,13 +467,12 @@ void IntWalk_PWalking::Perform(const TCo
   line = new IntSurf_LineOn2S ();
   //
   for (i=1; i<=4; ++i) {
-    aTmp=ParDep(i);
     Param(i)=ParDep(i);
   }
   //-- reproduce steps uv connected to surfaces Caro1 and Caro2
   //-- pasuv[] and pasSav[] are modified during the marching
   for(i = 0; i < 4; ++i) { 
-    pasMaxSV[i] = pasSav[i] = pasuv[i] = pasInit[i]; 
+    pasSav[i] = pasuv[i] = pasInit[i];
   }
 
   //-- calculate the first solution point
Index: oce/src/Intf/Intf_InterferencePolygonPolyhedron.gxx
===================================================================
--- oce.orig/src/Intf/Intf_InterferencePolygonPolyhedron.gxx
+++ oce/src/Intf/Intf_InterferencePolygonPolyhedron.gxx
@@ -779,7 +779,6 @@ void Intf_InterferencePolygonPolyhedron:
   gp_XYZ segO=EndO.XYZ()-BegO.XYZ();
   segO.Normalize();
   Standard_Boolean NoIntersectionWithTriangle = Standard_False;
-  Standard_Boolean PolygonCutsPlane           = Standard_True;
 
   Standard_Real param;
   t = dBegTri-dEndTri;
@@ -799,7 +798,6 @@ void Intf_InterferencePolygonPolyhedron:
       NoIntersectionWithTriangle = Standard_False;
     }
     if (param<0. || param>1.) {
-      PolygonCutsPlane = Standard_False;
       NoIntersectionWithTriangle = Standard_True;
     }
   }
@@ -1061,7 +1059,6 @@ void Intf_InterferencePolygonPolyhedron:
 //   Standard_Real dEndTri=(triNor*EndO.XYZ())-triDp; // Distance <EndO> plan
 
   Standard_Boolean NoIntersectionWithTriangle = Standard_False;
-  Standard_Boolean PolygonCutsPlane           = Standard_True;
 
   Standard_Real param;
   t = dBegTri-dEndTri;
@@ -1081,7 +1078,6 @@ void Intf_InterferencePolygonPolyhedron:
       NoIntersectionWithTriangle = Standard_False;
     }
     if (param<0. || param>1.) {
-      PolygonCutsPlane = Standard_False;
       NoIntersectionWithTriangle = Standard_True;
     }
   }
Index: oce/src/Intf/Intf_InterferencePolyhedron.gxx
===================================================================
--- oce.orig/src/Intf/Intf_InterferencePolyhedron.gxx
+++ oce/src/Intf/Intf_InterferencePolyhedron.gxx
@@ -743,8 +743,6 @@ Standard_Boolean Intf_InterferencePolyhe
     tOP[nou]= Intf_EXTERNAL;
     tTP[nou]= Intf_EXTERNAL;
   }
-  Standard_Integer iOP[4];
-  Standard_Integer iTP[4];
 
   Standard_Integer nbpInt=0;
   Intf_SeqOfSectionPoint Tpi;
@@ -759,8 +757,8 @@ Standard_Boolean Intf_InterferencePolyhe
 				     Intf_VERTEX, OI[nob], 0, 0., 
 				     Intf_VERTEX, TI[nou], 0, 0.,
 				     1.));
-	tOP[nob]=Intf_VERTEX; iOP[nob]=nbpInt;
-	tTP[nou]=Intf_VERTEX; iTP[nou]=nbpInt;
+	tOP[nob]=Intf_VERTEX;
+	tTP[nou]=Intf_VERTEX;
 	nbpInt++;
 	break;
       }
@@ -773,7 +771,7 @@ Standard_Boolean Intf_InterferencePolyhe
 					Intf_EDGE, Min(TI[nou], TI[nou2]),
 					Max(TI[nou], TI[nou2]), par,
 					1.));
-	  tOP[nob]=Intf_EDGE; iOP[nob]=nbpInt;
+	  tOP[nob]=Intf_EDGE;
 	  nbpInt++;
 	  break;
 	}
@@ -788,7 +786,7 @@ Standard_Boolean Intf_InterferencePolyhe
 				     Intf_VERTEX, OI[nob],  0, 0., 
 				     Intf_FACE,   Tri2, 0, 0.,
 				     1.));
-	tOP[nob]=Intf_FACE; iOP[nob]=nbpInt;
+	tOP[nob]=Intf_FACE;
 	nbpInt++;
       }
     }
@@ -811,7 +809,7 @@ Standard_Boolean Intf_InterferencePolyhe
 					   Intf_EDGE, Min(OI[nob], OI[nob2]),
 					   Max(OI[nob], OI[nob2]), par, 
 					   Intf_VERTEX, TI[nou], 0, 0., 1.));
-	      tTP[nou]=Intf_EDGE;iTP[nou]=nbpInt;
+	      tTP[nou]=Intf_EDGE;
 	      nbpInt++;
 	      break;
 	    }
@@ -826,7 +824,7 @@ Standard_Boolean Intf_InterferencePolyhe
 					 Intf_FACE,   Tri1, 0, 0.,
 					 Intf_VERTEX, TI[nou], 0, 0., 
 					 1.));
-	    tTP[nou]=Intf_FACE; iTP[nou]=nbpInt;
+	    tTP[nou]=Intf_FACE;
 	    nbpInt++;
 	  }
 	}
Index: oce/src/LDOM/LDOMParser.cxx
===================================================================
--- oce.orig/src/LDOM/LDOMParser.cxx
+++ oce/src/LDOM/LDOMParser.cxx
@@ -159,7 +159,6 @@ Standard_Boolean LDOMParser::ParseDocume
 {
   Standard_Boolean      isError   = Standard_False;
   Standard_Boolean      isElement = Standard_False;
-  Standard_Boolean      isHeader  = Standard_False;
   Standard_Boolean      isDoctype = Standard_False;
 
   for(;;) {
@@ -171,7 +170,6 @@ Standard_Boolean LDOMParser::ParseDocume
         isError = Standard_True;
         break;
       }
-      isHeader = Standard_True;
       continue;
     case LDOM_XmlReader::XML_DOCTYPE:
       if (isElement) {
Index: oce/src/LocOpe/LocOpe.cxx
===================================================================
--- oce.orig/src/LocOpe/LocOpe.cxx
+++ oce/src/LocOpe/LocOpe.cxx
@@ -165,7 +165,6 @@ Standard_Boolean LocOpe::TgtFaces(const
   gp_Vec d1,d2;
 
   Standard_Real uu, vv;
-  Standard_Real angle[21];
 
   Standard_Integer i;
   for(i = 0; i <= 20; i++){
@@ -180,7 +179,6 @@ Standard_Boolean LocOpe::TgtFaces(const
     d2 = (du.Crossed(dv)).Normalized();
     if(rev2) d2.Reverse();
     ang = d1.Angle(d2);
-    angle[i] = ang;
     if(ang <= angmin) angmin = ang;
     if(ang >= angmax) angmax = ang;
   }
Index: oce/src/LocOpe/LocOpe_BuildWires.cxx
===================================================================
--- oce.orig/src/LocOpe/LocOpe_BuildWires.cxx
+++ oce/src/LocOpe/LocOpe_BuildWires.cxx
@@ -161,7 +161,6 @@ void LocOpe_BuildWires::Perform(const To
 
     TopoDS_Wire newWire;
     B.MakeWire(newWire);
-    Standard_Integer BorneInf;
 
     if (mapV.Contains(VL)) { // on sort avec une boucle a recreer
       TopoDS_Vertex Vf;
@@ -180,14 +179,12 @@ void LocOpe_BuildWires::Perform(const To
 	}
 	mapV.Remove(Vf);
       }
-      BorneInf = j;
       for (; j<= mapE.Extent(); j++) {
 	B.Add(newWire,mapE(j));
       }
       newWire.Closed(Standard_True);
     }
     else { // on sort sur un bord : wire ouvert...
-      BorneInf = 1;
       mapV.Add(VL);
       for (Standard_Integer j = 1; j <= mapE.Extent(); j++) {
 	B.Add(newWire,mapE(j));
Index: oce/src/LocOpe/LocOpe_Generator.cxx
===================================================================
--- oce.orig/src/LocOpe/LocOpe_Generator.cxx
+++ oce/src/LocOpe/LocOpe_Generator.cxx
@@ -240,7 +240,7 @@ void LocOpe_Generator::Perform(const Han
   TopTools_ListOfShape RebuildFace;
   TopTools_MapOfShape mapTreated;
   TopTools_DataMapOfShapeShape DontFuse;
-  TopAbs_Orientation orient,orface,orsav;
+  TopAbs_Orientation orient,orface;
 
   for (itf.Reset(); itf.More(); itf.Next()) {
     const TopoDS_Face& fac = TopoDS::Face(itf.Key());
@@ -456,7 +456,6 @@ void LocOpe_Generator::Perform(const Han
   for (itf.Reset();itf.More(); itf.Next()) {
     const TopoDS_Face& fac = TopoDS::Face(itf.Key());
     Standard_Boolean ModFace = Standard_False;
-    Standard_Boolean HasWire = Standard_False;
     TopTools_ListOfShape listofedg;
 
     EdgAdded.Clear();
@@ -491,7 +490,6 @@ void LocOpe_Generator::Perform(const Han
 	for (exp2.Init(wir,TopAbs_EDGE); exp2.More(); exp2.Next()) {
 	  listofedg.Append(exp2.Current());
 	}
-	HasWire = Standard_True;
       }
       else {
 	if (!ModFace) { 
@@ -583,19 +581,16 @@ void LocOpe_Generator::Perform(const Han
 		  }
 		}
 //		B.Add(newface,theNew);
-		HasWire = Standard_True;
 	      }
 	    }
 	  }
 	  ModFace = Standard_True;
 	}
 	
-	orsav = wir.Orientation();
 	// reconstruction du wire
 	//B.MakeWire(newwire);
 
 	Handle(Geom2d_Curve) C2d,C2d1;
-	Standard_Boolean EmptyWire = Standard_True;
     
 //	for (exp2.Init(wir.Oriented(TopAbs_FORWARD),TopAbs_EDGE); 
 	for (exp2.Init(wir,TopAbs_EDGE); exp2.More(); exp2.Next()) {
@@ -605,7 +600,6 @@ void LocOpe_Generator::Perform(const Han
 //	    B.Add(newwire,edg.Oriented(or));
 //            listofedg.Append(edg.Oriented(or));
             listofedg.Append(edg);
-	    EmptyWire = Standard_False;
 	  }
 	  else if (myModShapes.IsBound(edg) || theEEMap.IsBound(edg)) {
 	    if (myModShapes.IsBound(edg)) {
@@ -616,7 +610,6 @@ void LocOpe_Generator::Perform(const Han
 	    }
 //	    B.Add(newwire,newedg.Oriented(or));
 	    listofedg.Append(newedg.Oriented(orient));
-	    EmptyWire = Standard_False;
 	    C = BRep_Tool::Curve(newedg,loc,f,l);
 	    if (!loc.IsIdentity()) {
 	      Handle(Geom_Geometry) GG = C->Transformed(loc.Transformation());
@@ -863,7 +856,6 @@ void LocOpe_Generator::Perform(const Han
 		orient = TopAbs::Compose(orface,edg.Orientation());
 		//		B.Add(newwire,edg.Oriented(or));
 		listofedg.Append(edg.Oriented(orient));
-		EmptyWire = Standard_False;
 		EdgAdded.Add(edg);
 		if (P.IsNull()) {  
 		  // on met les courbes 2d si on n`est pas sur un plan
Index: oce/src/LocOpe/LocOpe_SplitDrafts.cxx
===================================================================
--- oce.orig/src/LocOpe/LocOpe_SplitDrafts.cxx
+++ oce/src/LocOpe/LocOpe_SplitDrafts.cxx
@@ -1603,10 +1603,9 @@ static TopoDS_Edge  NewEdge(const TopoDS
   Standard_Real prmf=0,prml=0;
   GeomAdaptor_Curve TheCurve;
 	
-  Standard_Integer i,imin,k;
+  Standard_Integer i,k;
   gp_Pnt pvf = BRep_Tool::Pnt(V1);
   gp_Pnt pvl = BRep_Tool::Pnt(V2);
-  imin = 0;
   for (i=1; i<= i2s.NbLines(); i++) {
     TheCurve.Load(i2s.Line(i));
     Extrema_ExtPC myExtPC(pvf,TheCurve);
Index: oce/src/MAT2d/MAT2d_Circuit.cxx
===================================================================
--- oce.orig/src/MAT2d/MAT2d_Circuit.cxx
+++ oce/src/MAT2d/MAT2d_Circuit.cxx
@@ -531,8 +531,8 @@ void  MAT2d_Circuit::InsertCorner (TColG
   if (AffichCircuit) {
     if (Insert) {
       Curve      = Handle(Geom2d_TrimmedCurve)::DownCast(Line.Value(isuiv));
-      gp_Pnt2d P = Curve->StartPoint();
 #ifdef DRAW
+      gp_Pnt2d P = Curve->StartPoint();
       Handle(Draw_Marker2D) dr = new Draw_Marker2D(P,Draw_Plus,Draw_vert); 
       dout << dr;
       dout.Flush();
@@ -798,22 +798,19 @@ static Standard_Boolean IsSharpCorner (c
 #ifdef DEB
   static Standard_Boolean Affich = 0;
   if (Affich) {
+#ifdef DRAW
     Standard_Real DU1 = (OC1.LastParameter() - OC1.FirstParameter())/9.;
     Standard_Real DU2 = (OC2.LastParameter() - OC2.FirstParameter())/9.;
     for (Standard_Integer ki = 0; ki <= 9; ki++) {
       gp_Pnt2d P1 = OC1.Value(OC1.FirstParameter()+ki*DU1);
       gp_Pnt2d P2 = OC2.Value(OC2.FirstParameter()+ki*DU2);
-#ifdef DRAW
       Handle(Draw_Marker2D) dr1 = new Draw_Marker2D(P1,Draw_Plus,Draw_vert);
       Handle(Draw_Marker2D) dr2 = new Draw_Marker2D(P2,Draw_Plus,Draw_rouge); 
       dout << dr1;
       dout << dr2;
     }
     dout.Flush();
-#else
-  }
 #endif
-  
   }
 #endif
   
Index: oce/src/MAT2d/MAT2d_Tool2d.cxx
===================================================================
--- oce.orig/src/MAT2d/MAT2d_Tool2d.cxx
+++ oce/src/MAT2d/MAT2d_Tool2d.cxx
@@ -406,8 +406,7 @@ void MAT2d_Tool2d::TrimBisec (      Bise
   
   //gp_Vec2d             Tan1,Tan2;
   gp_Pnt2d             Ori; //PEdge;
-  Standard_Integer     IPrec,INext;
-  IPrec = (IndexEdge == 1)  ? theCircuit->NumberOfItems() : (IndexEdge - 1);
+  Standard_Integer     INext;
   INext = (IndexEdge == theCircuit->NumberOfItems()) ? 1  : (IndexEdge + 1);
   
   Handle(Standard_Type) EdgeType = theCircuit->Value(IndexEdge)->DynamicType();
@@ -535,7 +534,6 @@ Standard_Boolean MAT2d_Tool2d::Projectio
   Handle(Standard_Type)       Type   = Elt->DynamicType();	
   Handle(Geom2d_TrimmedCurve) Curve; 
   Standard_Integer            INext;   
-  Standard_Real               ParameterOnC;
   Standard_Real               Eps = MAT2d_TOLCONF;//*10.;
 
   if (Type == STANDARD_TYPE(Geom2d_CartesianPoint)) {	
@@ -586,7 +584,6 @@ Standard_Boolean MAT2d_Tool2d::Projectio
       if (Extremas.NbExt() == 0 ) return Standard_False; // Pas de solution!
       for (Standard_Integer i = 1; i <= Extremas.NbExt(); i++) {
 	if (Extremas.SquareDistance(i) < Distance * Distance) {
-	  ParameterOnC  = Extremas.Point(i).Parameter();
 	  Distance      = sqrt (Extremas.SquareDistance(i));
 	}
       }
Index: oce/src/MeshTest/MeshTest.cxx
===================================================================
--- oce.orig/src/MeshTest/MeshTest.cxx
+++ oce/src/MeshTest/MeshTest.cxx
@@ -1133,12 +1133,6 @@ Standard_Integer tri2d(Draw_Interpretor&
 
   T = BRep_Tool::Triangulation(F, L);
   if (!T.IsNull()) {
-#ifdef DEB
-    gp_Trsf tr  = L.Transformation();
-#else
-    L.Transformation();
-#endif
-
     // Build the connect tool
     Poly_Connect pc(T);
 
Index: oce/src/MeshVS/MeshVS_ElementalColorPrsBuilder.cxx
===================================================================
--- oce.orig/src/MeshVS/MeshVS_ElementalColorPrsBuilder.cxx
+++ oce/src/MeshVS/MeshVS_ElementalColorPrsBuilder.cxx
@@ -173,8 +173,6 @@ void MeshVS_ElementalColorPrsBuilder::Bu
   }
 
   //Now we are ready to draw faces with equal colors
-  Aspect_InteriorStyle aStyle;
-  Standard_Integer     aStyleInt;
   Aspect_TypeOfLine    anEdgeType = Aspect_TOL_SOLID;
   Aspect_TypeOfLine    aLineType = Aspect_TOL_SOLID;
   Standard_Integer     anEdgeInt, aLineInt;
@@ -193,9 +191,6 @@ void MeshVS_ElementalColorPrsBuilder::Bu
   aDrawer->GetBoolean( MeshVS_DA_ColorReflection, IsReflect );
   aDrawer->GetBoolean( MeshVS_DA_SmoothShading, IsMeshSmoothShading );
 
-  if ( aDrawer->GetInteger ( MeshVS_DA_InteriorStyle, aStyleInt) )
-    aStyle = (Aspect_InteriorStyle) aStyleInt;
-
   if ( aDrawer->GetInteger ( MeshVS_DA_EdgeType, anEdgeInt) )
     anEdgeType = (Aspect_TypeOfLine) anEdgeInt;
 
Index: oce/src/NCollection/NCollection_BaseAllocator.cxx
===================================================================
--- oce.orig/src/NCollection/NCollection_BaseAllocator.cxx
+++ oce/src/NCollection/NCollection_BaseAllocator.cxx
@@ -169,6 +169,11 @@ Standard_EXPORT void StandardCallBack_Re
   StandardCallBack_CatchID() = 0;
 }
 
+namespace {
+  // dummy function for break point
+  inline void place_for_break_point () {}
+};
+
 //=======================================================================
 //function : StandardCallBack
 //purpose  : Callback function to register alloc/free calls
@@ -200,7 +205,6 @@ void NCollection_BaseAllocator::Standard
     // statistics by alive objects
     NCollection_DataMap<Standard_Address, Standard_Size>& aStIDMap = StorageIDMap();
     NCollection_Map<Standard_Size>& aStIDSet = StorageIDSet();
-    int a;
     if (theIsAlloc)
     {
       aStIDMap.Bind(theStorage, ++CurrentID);
@@ -208,7 +212,7 @@ void NCollection_BaseAllocator::Standard
       if (CurrentID == StandardCallBack_CatchID())
       {
         // Place for break point for allocation of investigated ID
-        a = 1;
+        place_for_break_point();
       }
     }
     else
@@ -220,7 +224,7 @@ void NCollection_BaseAllocator::Standard
         if (anID == StandardCallBack_CatchID())
         {
           // Place for break point for freeing of investigated ID
-          a = 0;
+          place_for_break_point();
         }
       }
     }
Index: oce/src/OSD/OSD.cxx
===================================================================
--- oce.orig/src/OSD/OSD.cxx
+++ oce/src/OSD/OSD.cxx
@@ -116,13 +116,12 @@ void OSD::MilliSecSleep(const Standard_I
 
 void OSD::MilliSecSleep(const Standard_Integer aDelay)
 {
-  int fdn ;
   struct timeval timeout ;
 
   timeout.tv_sec = aDelay / 1000 ;
   timeout.tv_usec = (aDelay % 1000) * 1000 ;
 
-  fdn = select(0,NULL,NULL,NULL,&timeout) ;
+  select(0,NULL,NULL,NULL,&timeout) ;
 }
 
 #endif
Index: oce/src/OpenGl/OpenGl_Trihedron.cxx
===================================================================
--- oce.orig/src/OpenGl/OpenGl_Trihedron.cxx
+++ oce/src/OpenGl/OpenGl_Trihedron.cxx
@@ -440,10 +440,8 @@ void OpenGl_Trihedron::redrawZBuffer (co
   /* Position des Axes */
   GLdouble TriedronAxeX[3] = { 1.0, 0.0, 0.0 };
   GLdouble TriedronAxeY[3] = { 0.0, 1.0, 0.0 };
-  GLdouble TriedronAxeZ[3] = { 0.0, 0.0, 1.0 };
   TriedronAxeX[0] = L;
   TriedronAxeY[1] = L;
-  TriedronAxeZ[2] = L;
 
   glMatrixMode(GL_MODELVIEW);
 
Index: oce/src/Primitives/Primitives_Wedge.gxx
===================================================================
--- oce.orig/src/Primitives/Primitives_Wedge.gxx
+++ oce/src/Primitives/Primitives_Wedge.gxx
@@ -605,10 +605,8 @@ const TheWire& Primitives_Wedge::Wire
       dd3 = Primitives_YMax;
       dd4 = Primitives_XMin;
       break;
-#ifndef DEB
     default:
       break;
-#endif
     };
 
     myBuilder.MakeWire(myWires[i]);
@@ -665,26 +663,19 @@ gp_Lin Primitives_Wedge::Line
   gp_Vec VX = myAxes.XDirection();
   gp_Vec VY = myAxes.YDirection();
   gp_Vec VZ = myAxes.Direction();
-  Primitives_Direction dd1,dd2;
   
   switch (i/4) {
     
   case 0 :
     D = myAxes.Direction();
-    dd1 = Primitives_ZMin;
-    dd2 = Primitives_ZMax;
     break;
     
   case 1 :
     D = myAxes.XDirection();
-    dd1 = Primitives_XMin;
-    dd2 = Primitives_XMax;
     break;
     
   case 2 :
     D = myAxes.YDirection();
-    dd1 = Primitives_YMin;
-    dd2 = Primitives_YMax;
     break;
     
   };
@@ -827,10 +818,9 @@ const TheEdge& Primitives_Wedge::Edge
       dd1 = Primitives_YMin;
       dd2 = Primitives_YMax;
       break;
-#ifndef DEB
+
     default:
       break;
-#endif
     };
     
     gp_Lin L = Line(d1,d2);
Index: oce/src/ProjLib/ProjLib_ComputeApprox.cxx
===================================================================
--- oce.orig/src/ProjLib/ProjLib_ComputeApprox.cxx
+++ oce/src/ProjLib/ProjLib_ComputeApprox.cxx
@@ -432,11 +432,9 @@ static void Function_SetUVBounds(Standar
       //       (1) (3) (4) : equation de la couture.
       Standard_Integer NbSolutions = 0;
       Standard_Real A, B, C, D, R, Tol = 1.e-10;
-      Standard_Real U1, U2, V1, V2, aTPC;
+      Standard_Real U1, U2, V1, V2;
       gp_Trsf Trsf;
       //
-      aTPC=Precision::PConfusion();
-      //
       gp_Circ Circle = myCurve->Circle();
       Trsf.SetTransformation(SP.Position());
       Circle.Transform(Trsf);
Index: oce/src/ProjLib/ProjLib_ComputeApproxOnPolarSurface.cxx
===================================================================
--- oce.orig/src/ProjLib/ProjLib_ComputeApproxOnPolarSurface.cxx
+++ oce/src/ProjLib/ProjLib_ComputeApproxOnPolarSurface.cxx
@@ -1544,16 +1544,16 @@ Handle(Geom2d_BSplineCurve)
   }
   Handle(Geom2d_BSplineCurve) DummyC2d =
     new Geom2d_BSplineCurve(DummyPoles, DummyKnots, DummyMults, 1);
-  Standard_CString Temp = "bs2d";
 #ifdef DRAW
+  Standard_CString Temp = "bs2d";
   DrawTrSurf::Set(Temp,DummyC2d);
 #endif
 //  DrawTrSurf::Set((Standard_CString ) "bs2d",DummyC2d);
   Handle(Geom2dAdaptor_HCurve) DDD = 
     Handle(Geom2dAdaptor_HCurve)::DownCast(InitCurve2d);
   
-  Temp = "initc2d";
 #ifdef DRAW
+  Temp = "initc2d";
   DrawTrSurf::Set(Temp,DDD->ChangeCurve2d().Curve());
 #endif
 //  DrawTrSurf::Set((Standard_CString ) "initc2d",DDD->ChangeCurve2d().Curve());
Index: oce/src/ProjLib/ProjLib_ProjectedCurve.cxx
===================================================================
--- oce.orig/src/ProjLib/ProjLib_ProjectedCurve.cxx
+++ oce/src/ProjLib/ProjLib_ProjectedCurve.cxx
@@ -529,10 +529,9 @@ void ProjLib_ProjectedCurve::Load(const
 
 	if(IsTrimmed[0] || IsTrimmed[1]) {
 	  // Treatment only for surface of revolution
-	  Standard_Real u1, u2, v1, v2;
+	  Standard_Real u1, u2, v2;
 	  u1 = mySurface->FirstUParameter();
 	  u2 = mySurface->LastUParameter();
-	  v1 = mySurface->FirstVParameter();
 	  v2 = mySurface->LastVParameter();
 	  
 	  if(IsTrimmed[0]) {
Index: oce/src/QABugs/QABugs_2.cxx
===================================================================
--- oce.orig/src/QABugs/QABugs_2.cxx
+++ oce/src/QABugs/QABugs_2.cxx
@@ -88,7 +88,6 @@ static Standard_Integer OCC527(Draw_Inte
       aFaceBox.Get(X1,Y1,Z1,X2,Y2,Z2);
 
       // Build sections from Zmin to Zmax with step aStep
-      Standard_Boolean wasBuilt = Standard_False;
       double gmaxdist = 0.0, gzmax = Zmax;
       for (double zcur = Zmax; zcur > Zmin; zcur -= aStep)
       {
@@ -138,7 +137,6 @@ static Standard_Integer OCC527(Draw_Inte
               Standard_Real  toler = BRep_Tool::Tolerance(aV);
               double dist = pl.Distance(BRep_Tool::Pnt(aV));
               if (dist > lmaxdist) lmaxdist = dist;
-              wasBuilt = Standard_True;
       // If section was built check distance beetwen vertexes and plane of the one
       str[0] =0;
 //       if (wasBuilt) 
Index: oce/src/QABugs/QABugs_3.cxx
===================================================================
--- oce.orig/src/QABugs/QABugs_3.cxx
+++ oce/src/QABugs/QABugs_3.cxx
@@ -938,10 +938,9 @@ static Standard_Integer BUC60856(Draw_In
   }
 
   gp_Ax2  Cone_Ax;                                                                
-  double R1=8, R2=16, angle;                                       
+  double R1=8, R2=16;
   gp_Pnt P0(0,0,0),                                                              
   P1(0,0,20), P2(0,0,45);                                                        
-  angle = 2*M_PI;                                                                  
   Handle(Geom_RectangularTrimmedSurface) S = GC_MakeTrimmedCone (P1, P2, R1, R2).Value();
   TopoDS_Shape myshape = BRepBuilderAPI_MakeFace(S, Precision::Confusion()).Shape();
   Handle(AIS_Shape) ais1 = new AIS_Shape(myshape);
Index: oce/src/QABugs/QABugs_9.cxx
===================================================================
--- oce.orig/src/QABugs/QABugs_9.cxx
+++ oce/src/QABugs/QABugs_9.cxx
@@ -33,9 +33,8 @@
 static Standard_Integer BUC60857 (Draw_Interpretor& di, Standard_Integer /*argc*/,const char ** argv)
 {
   gp_Ax2  Cone_Ax;
-  double R1=8, R2=16, angle;
+  double R1=8, R2=16;
   gp_Pnt P0(0,0,0), P1(0,0,20), P2(0,0,45);
-  angle = 2*M_PI;
 
   Handle(AIS_InteractiveContext) aContext = ViewerTest::GetAISContext();
   if(aContext.IsNull()) {
Index: oce/src/QANewModTopOpe/QANewModTopOpe_Tools.cxx
===================================================================
--- oce.orig/src/QANewModTopOpe/QANewModTopOpe_Tools.cxx
+++ oce/src/QANewModTopOpe/QANewModTopOpe_Tools.cxx
@@ -267,7 +267,7 @@ Standard_Boolean QANewModTopOpe_Tools::I
   if(theEdge.IsNull() || (theEdge.ShapeType() != TopAbs_EDGE))
     return Standard_False;
 
-  Standard_Integer index, nSp;
+  Standard_Integer index;
   //
   const BOPDS_PDS& pDS = theDSFiller->PDS();
   index = pDS->Index(theEdge);
@@ -280,7 +280,6 @@ Standard_Boolean QANewModTopOpe_Tools::I
   aPBIt.Initialize(aLPB);
   for (; aPBIt.More(); aPBIt.Next()) {
     const Handle(BOPDS_PaveBlock)& aPB = aPBIt.Value();
-    nSp = aPB->Edge();
 
     TopAbs_State aSplitState = GetEdgeState(pDS, aPB);
 
Index: oce/src/RWHeaderSection/RWHeaderSection_RWFileDescription.cxx
===================================================================
--- oce.orig/src/RWHeaderSection/RWHeaderSection_RWFileDescription.cxx
+++ oce/src/RWHeaderSection/RWHeaderSection_RWFileDescription.cxx
@@ -51,8 +51,7 @@ void RWHeaderSection_RWFileDescription::
 	// --- own field : implementationLevel ---
 
 	Handle(TCollection_HAsciiString) aImplementationLevel;
-	Standard_Boolean stat2;
-	stat2 = data->ReadString (num,2,"implementation_level",ach,aImplementationLevel);
+	data->ReadString (num,2,"implementation_level",ach,aImplementationLevel);
 
 	//--- Initialisation of the read entity ---
 
Index: oce/src/RWHeaderSection/RWHeaderSection_RWFileName.cxx
===================================================================
--- oce.orig/src/RWHeaderSection/RWHeaderSection_RWFileName.cxx
+++ oce/src/RWHeaderSection/RWHeaderSection_RWFileName.cxx
@@ -32,14 +32,12 @@ void RWHeaderSection_RWFileName::ReadSte
 	// --- own field : name ---
 
 	Handle(TCollection_HAsciiString) aName;
-	Standard_Boolean stat1;
-	stat1 = data->ReadString (num,1,"name",ach,aName);
+	data->ReadString (num,1,"name",ach,aName);
 
 	// --- own field : timeStamp ---
 
 	Handle(TCollection_HAsciiString) aTimeStamp;
-	Standard_Boolean stat2;
-	stat2 = data->ReadString (num,2,"time_stamp",ach,aTimeStamp);
+	data->ReadString (num,2,"time_stamp",ach,aTimeStamp);
 
 	// --- own field : author ---
 
@@ -82,20 +80,17 @@ void RWHeaderSection_RWFileName::ReadSte
 	// --- own field : preprocessorVersion ---
 
 	Handle(TCollection_HAsciiString) aPreprocessorVersion;
-	Standard_Boolean stat5;
-	stat5 = data->ReadString (num,5,"preprocessor_version",ach,aPreprocessorVersion);
+	data->ReadString (num,5,"preprocessor_version",ach,aPreprocessorVersion);
 
 	// --- own field : originatingSystem ---
 
 	Handle(TCollection_HAsciiString) aOriginatingSystem;
-	Standard_Boolean stat6;
-	stat6 = data->ReadString (num,6,"originating_system",ach,aOriginatingSystem);
+	data->ReadString (num,6,"originating_system",ach,aOriginatingSystem);
 
 	// --- own field : authorisation ---
 
 	Handle(TCollection_HAsciiString) aAuthorisation;
-	Standard_Boolean stat7;
-	stat7 = data->ReadString (num,7,"authorisation",ach,aAuthorisation);
+	data->ReadString (num,7,"authorisation",ach,aAuthorisation);
 
 	//--- Initialisation of the read entity ---
 
Index: oce/src/RWStepDimTol/RWStepDimTol_RWCommonDatum.cxx
===================================================================
--- oce.orig/src/RWStepDimTol/RWStepDimTol_RWCommonDatum.cxx
+++ oce/src/RWStepDimTol/RWStepDimTol_RWCommonDatum.cxx
@@ -46,13 +46,9 @@ void RWStepDimTol_RWCommonDatum::ReadSte
   data->ReadString (num, 1, "shape_aspect.name", ach, aShapeAspect_Name);
 
   Handle(TCollection_HAsciiString) aShapeAspect_Description;
-  Standard_Boolean hasShapeAspect_Description = Standard_True;
   if ( data->IsParamDefined (num,2) ) {
     data->ReadString (num, 2, "shape_aspect.description", ach, aShapeAspect_Description);
   }
-  else {
-    hasShapeAspect_Description = Standard_False;
-  }
 
   Handle(StepRepr_ProductDefinitionShape) aShapeAspect_OfShape;
   data->ReadEntity (num, 3, "shape_aspect.of_shape", ach, STANDARD_TYPE(StepRepr_ProductDefinitionShape), aShapeAspect_OfShape);
Index: oce/src/RWStepRepr/RWStepRepr_RWCompositeShapeAspect.cxx
===================================================================
--- oce.orig/src/RWStepRepr/RWStepRepr_RWCompositeShapeAspect.cxx
+++ oce/src/RWStepRepr/RWStepRepr_RWCompositeShapeAspect.cxx
@@ -45,13 +45,9 @@ void RWStepRepr_RWCompositeShapeAspect::
   data->ReadString (num, 1, "shape_aspect.name", ach, aShapeAspect_Name);
 
   Handle(TCollection_HAsciiString) aShapeAspect_Description;
-  Standard_Boolean hasShapeAspect_Description = Standard_True;
   if ( data->IsParamDefined (num,2) ) {
     data->ReadString (num, 2, "shape_aspect.description", ach, aShapeAspect_Description);
   }
-  else {
-    hasShapeAspect_Description = Standard_False;
-  }
 
   Handle(StepRepr_ProductDefinitionShape) aShapeAspect_OfShape;
   data->ReadEntity (num, 3, "shape_aspect.of_shape", ach, STANDARD_TYPE(StepRepr_ProductDefinitionShape), aShapeAspect_OfShape);
Index: oce/src/RWStepRepr/RWStepRepr_RWDerivedShapeAspect.cxx
===================================================================
--- oce.orig/src/RWStepRepr/RWStepRepr_RWDerivedShapeAspect.cxx
+++ oce/src/RWStepRepr/RWStepRepr_RWDerivedShapeAspect.cxx
@@ -45,13 +45,9 @@ void RWStepRepr_RWDerivedShapeAspect::Re
   data->ReadString (num, 1, "shape_aspect.name", ach, aShapeAspect_Name);
 
   Handle(TCollection_HAsciiString) aShapeAspect_Description;
-  Standard_Boolean hasShapeAspect_Description = Standard_True;
   if ( data->IsParamDefined (num,2) ) {
     data->ReadString (num, 2, "shape_aspect.description", ach, aShapeAspect_Description);
   }
-  else {
-    hasShapeAspect_Description = Standard_False;
-  }
 
   Handle(StepRepr_ProductDefinitionShape) aShapeAspect_OfShape;
   data->ReadEntity (num, 3, "shape_aspect.of_shape", ach, STANDARD_TYPE(StepRepr_ProductDefinitionShape), aShapeAspect_OfShape);
Index: oce/src/RWStepRepr/RWStepRepr_RWExtension.cxx
===================================================================
--- oce.orig/src/RWStepRepr/RWStepRepr_RWExtension.cxx
+++ oce/src/RWStepRepr/RWStepRepr_RWExtension.cxx
@@ -45,13 +45,9 @@ void RWStepRepr_RWExtension::ReadStep (c
   data->ReadString (num, 1, "shape_aspect.name", ach, aShapeAspect_Name);
 
   Handle(TCollection_HAsciiString) aShapeAspect_Description;
-  Standard_Boolean hasShapeAspect_Description = Standard_True;
   if ( data->IsParamDefined (num,2) ) {
     data->ReadString (num, 2, "shape_aspect.description", ach, aShapeAspect_Description);
   }
-  else {
-    hasShapeAspect_Description = Standard_False;
-  }
 
   Handle(StepRepr_ProductDefinitionShape) aShapeAspect_OfShape;
   data->ReadEntity (num, 3, "shape_aspect.of_shape", ach, STANDARD_TYPE(StepRepr_ProductDefinitionShape), aShapeAspect_OfShape);
Index: oce/src/ShapeAnalysis/ShapeAnalysis_FreeBounds.cxx
===================================================================
--- oce.orig/src/ShapeAnalysis/ShapeAnalysis_FreeBounds.cxx
+++ oce/src/ShapeAnalysis/ShapeAnalysis_FreeBounds.cxx
@@ -220,8 +220,7 @@ ShapeAnalysis_FreeBounds::ShapeAnalysis_
     aBox.SetGap(tolerance);
     aTreeFiller.Add(inbW, aBox);
   }
-  Standard_Integer nbFill;
-  nbFill = aTreeFiller.Fill();
+  aTreeFiller.Fill();
   Standard_Integer nsel;
   
   ShapeAnalysis_Edge sae; //szv#4:S4163:12Mar99 moved
@@ -363,7 +362,6 @@ static void SplitWire(const TopoDS_Wire&
       Standard_Boolean SearchBackward = Standard_True;
 
       for(;;) {
-	Standard_Integer ei = ces.Last(); //ei-edge index, number of current edge analyzed for connection
 	Standard_Boolean found;
 	TopoDS_Edge edge;
 	TopoDS_Vertex lvertex;
@@ -403,7 +401,6 @@ static void SplitWire(const TopoDS_Wire&
     
 	//searching for connection among free edges
 	found = Standard_False;
-	ei = ces.Last();
 	edge = sewd->Edge (ces.Last());
 	lvertex = sae.LastVertex (edge);
 	lpoint = BRep_Tool::Pnt (lvertex);
Index: oce/src/ShapeUpgrade/ShapeUpgrade_WireDivide.cxx
===================================================================
--- oce.orig/src/ShapeUpgrade/ShapeUpgrade_WireDivide.cxx
+++ oce/src/ShapeUpgrade/ShapeUpgrade_WireDivide.cxx
@@ -472,7 +472,6 @@ void ShapeUpgrade_WireDivide::Perform ()
       Standard_Integer numE =0;
       gp_Pnt pntV1 = BRep_Tool::Pnt(V1);
       //gp_Pnt pntV2 = BRep_Tool::Pnt(V2); // pntV2 not used - see below (skl)
-      Standard_Real V1Tol = LimitTolerance( BRep_Tool::Tolerance(V1) );
       //Standard_Real V2Tol = LimitTolerance( BRep_Tool::Tolerance(V2) ); // V2Tol not used - see below (skl)
       
       Handle(ShapeUpgrade_FixSmallCurves) FixSmallCurveTool = GetFixSmallCurveTool(); //gka Precision
@@ -582,7 +581,6 @@ void ShapeUpgrade_WireDivide::Perform ()
 	  if(icurv != nbc)  {
 	    B.MakeVertex (V, P, TolEdge); //tolerance of the edge
 	    pntV1 = P;
-	    V1Tol = LimitTolerance( TolEdge );
 	  }
 	  else V = V2;
 	 // else  V2;
Index: oce/src/StlTransfer/StlTransfer.cxx
===================================================================
--- oce.orig/src/StlTransfer/StlTransfer.cxx
+++ oce/src/StlTransfer/StlTransfer.cxx
@@ -117,7 +117,6 @@ void StlTransfer::BuildIncrementalMesh (
     Standard_ConstructionError::Raise ("StlTransfer::BuildIncrementalMesh");
     }
   
-  Standard_Integer NbVertices, NbTriangles;
   BRepMesh_IncrementalMesh aMesher(Shape, Deflection, Standard_False, 0.5, InParallel);
   for (TopExp_Explorer itf(Shape,TopAbs_FACE); itf.More(); itf.Next()) {
     TopoDS_Face face = TopoDS::Face(itf.Current());
@@ -141,7 +140,7 @@ void StlTransfer::BuildIncrementalMesh (
       gp_Pnt p = thePoints.Value(i);
       p.Transform(Loc.Transformation());
       p.Coord (X1, Y1, Z1);
-      NbVertices = Mesh->AddVertex (X1, Y1, Z1);
+      Mesh->AddVertex (X1, Y1, Z1);
     }
     try {
       OCC_CATCH_SIGNALS
@@ -174,7 +173,7 @@ void StlTransfer::BuildIncrementalMesh (
 	    A=V1;B=V2;C=V3;
 	  }
 	}
-	NbTriangles = Mesh->AddTriangle (A, B, C, average.X(), average.Y(), average.Z());
+	Mesh->AddTriangle (A, B, C, average.X(), average.Y(), average.Z());
       }
     }
     catch(Standard_Failure)
Index: oce/src/TDF/TDF_CopyLabel.cxx
===================================================================
--- oce.orig/src/TDF/TDF_CopyLabel.cxx
+++ oce/src/TDF/TDF_CopyLabel.cxx
@@ -80,7 +80,6 @@ void TDF_CopyLabel::ExternalReferences(c
 				       Handle(TDF_DataSet)& ds)
 {
 //  TCollection_AsciiString entr1,entr2; //d
-  Standard_Boolean extRefFound = Standard_False;
   for (TDF_AttributeIterator itr(aLabel); itr.More(); itr.Next()) {
     itr.Value()->References(ds);
     const TDF_AttributeMap& attMap = ds->Attributes(); //attMap
@@ -96,7 +95,6 @@ void TDF_CopyLabel::ExternalReferences(c
         if (aFilter.IsKept(att) && att->Label().IsDifferent(aRefLabel) &&
 	    !att->Label().IsDescendant(aRefLabel)) {
           aExternals.Add(att);
-	  extRefFound = Standard_True;
         }
       }
     }
@@ -117,7 +115,6 @@ void TDF_CopyLabel::ExternalReferences(c
 //       }
 //     }
 
-    extRefFound = Standard_False;
     ds->Clear();
   }
 }
Index: oce/src/TDF/TDF_Delta.cxx
===================================================================
--- oce.orig/src/TDF/TDF_Delta.cxx
+++ oce/src/TDF/TDF_Delta.cxx
@@ -154,17 +154,17 @@ void TDF_Delta::Apply()
 
 void TDF_Delta::Labels(TDF_LabelList& aLabelList) const
 {
-  Standard_Boolean inList;
   TDF_LabelMap labMap;
   // If <aLabelList> is not empty...
 #ifdef DEB_DELTA
+  Standard_Boolean inList;
   if (aLabelList.Extent() > 0) cout<<"Previously added as modified label(s) ";
 #endif
   for (TDF_ListIteratorOfLabelList it1(aLabelList);
        it1.More(); it1.Next()) {
+#ifdef DEB_DELTA
     const TDF_Label& lab1 = it1.Value();
     inList = labMap.Add(lab1);
-#ifdef DEB_DELTA
     if (!inList) {
       lab1.EntryDump(cout);cout<<" | ";
     }
@@ -181,9 +181,9 @@ void TDF_Delta::Labels(TDF_LabelList& aL
   for (TDF_ListIteratorOfAttributeDeltaList it2(myAttDeltaList);
        it2.More();
        it2.Next()) {
+#ifdef DEB_DELTA
     const TDF_Label& lab1 = it2.Value()->Label();
     inList = labMap.Add(lab1);
-#ifdef DEB_DELTA
     if (!inList) {
       lab1.EntryDump(cout);cout<<" | ";
     }
Index: oce/src/TNaming/TNaming.cxx
===================================================================
--- oce.orig/src/TNaming/TNaming.cxx
+++ oce/src/TNaming/TNaming.cxx
@@ -279,18 +279,17 @@ void TNaming::Update(const TDF_Label& L,
   L.Root().FindAttribute(TNaming_UsedShapes::GetID(),US);
   TNaming_DataMapOfShapePtrRefShape& amap = US->Map();
 
-  Standard_Boolean Change = Standard_False;
   for (TNaming_Iterator it(L); it.More(); it.Next()) {
     if (!it.OldShape().IsNull()) {
       const TopoDS_Shape& S = it.OldShape();
       if (!M.IsBound(S))
-	if (Rebuild (S,M)) Change = Standard_True;
+	Rebuild (S,M);
       SubstituteShape(S,M(S),amap);
     }
     if (!it.NewShape().IsNull()) {
       const TopoDS_Shape& S = it.NewShape();
       if (!M.IsBound(S)) 
-	if (Rebuild (S,M)) Change = Standard_True;
+	Rebuild (S,M);
       SubstituteShape(S,M(S),amap);
     }
   }
Index: oce/src/TPrsStd/TPrsStd_ConstraintTools.cxx
===================================================================
--- oce.orig/src/TPrsStd/TPrsStd_ConstraintTools.cxx
+++ oce/src/TPrsStd/TPrsStd_ConstraintTools.cxx
@@ -1753,7 +1753,6 @@ void TPrsStd_ConstraintTools::ComputeOff
   TCollection_ExtendedString txt;
   Handle(AIS_LengthDimension) ais;
   //Handle(AIS_Drawer) aDrawer;
-  Standard_Boolean NotNull = Standard_False;
 
   if (nbgeom == 1)
   {
@@ -1761,7 +1760,6 @@ void TPrsStd_ConstraintTools::ComputeOff
     if (!anAIS.IsNull())
     {
       ais = Handle(AIS_LengthDimension)::DownCast(anAIS);
-      NotNull = Standard_True; 
     }
 
     if (S1.ShapeType() == TopAbs_FACE && S2.ShapeType() == TopAbs_FACE)
@@ -1875,7 +1873,6 @@ void TPrsStd_ConstraintTools::ComputeOff
       }
     }
     S2 = nearest;
-    if( !anAIS.IsNull() ) NotNull = Standard_True; 
     ais = Handle(AIS_LengthDimension)::DownCast(anAIS);
     if (ais.IsNull()) {
       ais = new AIS_LengthDimension (S1,S2,aplane->Pln());
Index: oce/src/TestTopOpe/TestTopOpe_CORCommands.cxx
===================================================================
--- oce.orig/src/TestTopOpe/TestTopOpe_CORCommands.cxx
+++ oce/src/TestTopOpe/TestTopOpe_CORCommands.cxx
@@ -110,10 +110,7 @@ static void FUN_test_draw(TCollection_As
   Standard_Boolean coldef = Standard_False;
   TopExp_Explorer ex(F,TopAbs_EDGE);
   Draw_Color col;
-#ifdef DEB
-  Draw_Color savecol =
-#endif
-                       DrawTrSurf_CurveColor(Draw_Color(Draw_rouge));
+  DrawTrSurf_CurveColor(Draw_Color(Draw_rouge));
   for (; ex.More(); ex.Next()) 
     if (E.IsEqual(ex.Current())) 
       {col = DBRep_ColorOrientation(ex.Current().Orientation()); 
@@ -608,13 +605,19 @@ static Standard_Integer classifBnd2d(Dra
 
   if (w1.IsNull() || w2.IsNull() || Fref.IsNull()) return 1;
 
-  Standard_Integer sta = classi.ClassiBnd2d(w1,w2,toluv,Standard_True);
+#ifdef DEB
+  Standard_Integer sta =
+#endif
+    classi.ClassiBnd2d(w1,w2,toluv,Standard_True);
   di <<"wires classification : checklarge=true ";
 #ifdef DEB
   FUN_tool_coutsta(sta,1,2);
 #endif
 
-  sta = classi.ClassiBnd2d(w1,w2,toluv,Standard_False);
+#ifdef DEB
+  sta =
+#endif
+    classi.ClassiBnd2d(w1,w2,toluv,Standard_False);
   di <<"wires classification : checklarge=false ";
 #ifdef DEB
   FUN_tool_coutsta(sta,1,2);
@@ -841,7 +844,6 @@ static Standard_Integer curvature(Draw_I
   
   Standard_Real tol = Precision::Confusion();
   BRepLProp_SLProps props(BS,2,tol);
-  Standard_Real Cur1=0., Cur2=0.;
   gp_Dir Norm,D1,D2;  
   for (Standard_Integer i = 1; i <= npnts; i++) {
     gp_Pnt p = intcs.Point(i);
@@ -852,14 +854,11 @@ static Standard_Integer curvature(Draw_I
     if (!curdef) {di<<"!IsCurvatureDefined"<<"\n"; continue;}
     Standard_Boolean umbilic = props.IsUmbilic();
     if (umbilic) { 
-      Cur1 = Cur2 = props.MeanCurvature();
       D1 = gp_Dir(0,0,1);
       D2 = gp_Dir(0,1,0);   
       di<<"umbilic";
     }
     else {
-      Cur1 = props.MaxCurvature();
-      Cur2 = props.MinCurvature();
       props.CurvatureDirections(D1,D2);
     }
     Norm = gp_Dir(D1^D2); 
Index: oce/src/TestTopOpe/TestTopOpe_HDSCommands.cxx
===================================================================
--- oce.orig/src/TestTopOpe/TestTopOpe_HDSCommands.cxx
+++ oce/src/TestTopOpe/TestTopOpe_HDSCommands.cxx
@@ -247,13 +247,6 @@ static void SetCurve
   const Handle(Geom_Curve) GC = DSC.Curve();
   if ( GC.IsNull() ) { cout<<"Curve() nulle"<<endl; return; }
   
-#ifdef DEB
-  static Standard_Integer Cdiscret = 16;
-  static Standard_Real Cdeflect = 0.01;
-  static Standard_Integer Cdrawmod = 1;
-  static Standard_Boolean Cdisplayorigin = Standard_True;
-#endif
-  
   Standard_Real f = GC->FirstParameter();
   Standard_Real l = GC->LastParameter();
   
@@ -823,11 +816,10 @@ void AddShapeKI
 (TColStd_ListOfInteger& LOK,TColStd_ListOfInteger& LOI,
  const TopOpeBRepDS_Kind K,const Standard_Integer I)
 {
-  TopAbs_ShapeEnum TS;
   Standard_Boolean isshape,isgeome; isshape = isgeome = Standard_False;
   isshape = TopOpeBRepDS::IsTopology(K);
-  if (isshape) TS = TopOpeBRepDS::KindToShape(K);
-  else isgeome = TopOpeBRepDS::IsGeometry(K);
+  if (!isshape)
+    isgeome = TopOpeBRepDS::IsGeometry(K);
   
   if (LOK.IsEmpty() && LOI.IsEmpty()) { 
     LOK.Append((Standard_Integer)K); LOI.Append(I); 
@@ -1314,7 +1306,7 @@ Standard_Integer tdsri(Draw_Interpretor&
   if ( strcasecmp(a[i1arg + 2],"i") ) return 0;
   Standard_Integer ii = Draw::Atoi(a[i1arg + 3]);  
 //  Standard_Integer ia,is,ig;
-  Standard_Integer is,ig;
+  Standard_Integer is;
   if ( Tpar.isshap() ) {
     is = Draw::Atoi(a[i1arg + 1]);
     const TopoDS_Shape& s = GetShape(is,Tpar.TS()); if (s.IsNull()) return 0;
@@ -1328,9 +1320,6 @@ Standard_Integer tdsri(Draw_Interpretor&
       else it.Next();
     }
   }
-  else if ( Tpar.isgeom() ) { 
-    ig = Draw::Atoi(a[i1arg + 1]);
-  }
   return 0;
 } // tdsri
 
Index: oce/src/TestTopOpe/TestTopOpe_OtherCommands.cxx
===================================================================
--- oce.orig/src/TestTopOpe/TestTopOpe_OtherCommands.cxx
+++ oce/src/TestTopOpe/TestTopOpe_OtherCommands.cxx
@@ -199,13 +199,11 @@ Standard_Integer MKSOLSHE(Draw_Interpret
 
   // take all the SHELL args, place them in the solid <sol>
   TopoDS_Solid sol; BB.MakeSolid(sol);
-  Standard_Boolean yashell = Standard_False;
   for (i = i1; i < i2; i++) {
     const TopoDS_Shape& S = DBRep::Get(a[i]);
     if (S.IsNull()) continue;
     if (S.ShapeType() == TopAbs_SHELL) {
       BB.Add(sol,S);
-      yashell = Standard_True;
     }
   }
 
@@ -230,7 +228,7 @@ Standard_Integer MKSOLSHE(Draw_Interpret
 Standard_Integer GRILLE(Draw_Interpretor& di, Standard_Integer narg, const char** a)
 {
   if (narg != 10) return 1;
-  Standard_Real xmin,ymin,zmin,xmax,ymax,zmax,dx,dy,dz;
+  Standard_Real xmin,ymin,zmin,xmax,ymax,zmax,dx,dy;
   Standard_Integer nbx,nby,nbz;
   xmin = Draw::Atof(a[1]);
   ymin = Draw::Atof(a[2]);
@@ -245,7 +243,6 @@ Standard_Integer GRILLE(Draw_Interpretor
     return 1;
   if(nbx) dx = (xmax-xmin)/nbx; else dx=0;
   if(nby) dy = (ymax-ymin)/nby; else dy=0;
-  if(nbz) dz = (zmax-zmin)/nbz; else dz=0;
   di<<"compound CE"<<"\n";
   for(Standard_Real x=xmin; x<xmax; x+=dx) { 
     for(Standard_Real y=ymin; y<ymax; y+=dx) { 
Index: oce/src/TopOpeBRep/TopOpeBRep_EdgesFiller.cxx
===================================================================
--- oce.orig/src/TopOpeBRep/TopOpeBRep_EdgesFiller.cxx
+++ oce/src/TopOpeBRep/TopOpeBRep_EdgesFiller.cxx
@@ -101,8 +101,8 @@ void TopOpeBRep_EdgesFiller::Insert(cons
     const TopOpeBRep_Point2d P2D = myPEI->Point();
     Standard_Real par1 = P2D.Parameter(1);
     Standard_Real par2 = P2D.Parameter(2);
-    Standard_Integer if1 = 0; if ( ! myF1.IsNull() ) if1 = myPDS->AddShape(myF1,1);
-    Standard_Integer if2 = 0; if ( ! myF2.IsNull() ) if2 = myPDS->AddShape(myF2,2);
+    if ( ! myF1.IsNull() ) myPDS->AddShape(myF1,1);
+    if ( ! myF2.IsNull() ) myPDS->AddShape(myF2,2);
 
 #ifdef DEB
     Standard_Boolean pointofsegment = P2D.IsPointOfSegment();
Index: oce/src/TopOpeBRep/TopOpeBRep_EdgesIntersector.cxx
===================================================================
--- oce.orig/src/TopOpeBRep/TopOpeBRep_EdgesIntersector.cxx
+++ oce/src/TopOpeBRep/TopOpeBRep_EdgesIntersector.cxx
@@ -539,7 +539,9 @@ Standard_Boolean EdgesIntersector_checkT
       TopOpeBRepDS_Transition& T1 = P2D.ChangeTransition(1);
       TopOpeBRepDS_Transition& T2 = P2D.ChangeTransition(2);
       
+#ifdef DEB
       Standard_Boolean newT1=Standard_False, newT2=Standard_False;
+#endif
       Standard_Boolean isvertex12 = isvertex1 && isvertex2;
       Standard_Boolean isvertex22 = isvertex2 && !isvertex12;
       Standard_Boolean isvertex11 = isvertex1 && !isvertex12;
@@ -549,8 +551,10 @@ Standard_Boolean EdgesIntersector_checkT
       if (T1INT && isvertex2 && !isvertex1) {
 	const TopoDS_Vertex& V2 = P2D.Vertex(2);	
 	TopOpeBRepDS_Transition newT; Standard_Boolean computed = ::EdgesIntersector_checkT1D(myEdge1,myEdge2,V2,newT);
-	if (!computed) newT1 = Standard_False;
-	else           T1.Set(newT.Orientation(TopAbs_IN));
+	if (computed) T1.Set(newT.Orientation(TopAbs_IN));
+#ifdef DEB
+	else          newT1 = Standard_False;
+#endif
       }
 
       Standard_Boolean T2INT = (T2.Orientation(TopAbs_IN) == TopAbs_INTERNAL);
@@ -559,8 +563,10 @@ Standard_Boolean EdgesIntersector_checkT
       if (INTEXT2 && isvertex1 && !isvertex2) {
 	const TopoDS_Vertex& V1 = P2D.Vertex(1);
 	TopOpeBRepDS_Transition newT; Standard_Boolean computed = ::EdgesIntersector_checkT1D(myEdge2,myEdge1,V1,newT);
-	if (!computed) newT2 = Standard_False;
-	else           T2.Set(newT.Orientation(TopAbs_IN));
+	if (computed) T2.Set(newT.Orientation(TopAbs_IN));
+#ifdef DEB
+	else          newT2 = Standard_False;
+#endif
       }      
       
       // xpu121098 : cto900I7 (e12on,vG14)
Index: oce/src/TopOpeBRep/TopOpeBRep_FaceEdgeFiller.cxx
===================================================================
--- oce.orig/src/TopOpeBRep/TopOpeBRep_FaceEdgeFiller.cxx
+++ oce/src/TopOpeBRep/TopOpeBRep_FaceEdgeFiller.cxx
@@ -256,7 +256,9 @@ void TopOpeBRep_FaceEdgeFiller::StoreInt
   // append I to list LI
   LI.Append(I);
 
+#ifdef DEB
   Standard_Boolean appendtoG = Standard_False;
+#endif
   Standard_Integer G = I->Geometry();
 
   // append I to list of interference connected to G = I->Geometry()
@@ -269,12 +271,16 @@ void TopOpeBRep_FaceEdgeFiller::StoreInt
     break;
     
   case TopOpeBRepDS_SURFACE :
+#ifdef DEB
     appendtoG = Standard_True;
+#endif
     BDS.ChangeSurfaceInterferences(G).Append(I);
     break;
     
   case TopOpeBRepDS_CURVE :
+#ifdef DEB
     appendtoG = Standard_True;
+#endif
     BDS.ChangeCurveInterferences(G).Append(I);
     break;
     
Index: oce/src/TopOpeBRep/TopOpeBRep_FaceEdgeIntersector.cxx
===================================================================
--- oce.orig/src/TopOpeBRep/TopOpeBRep_FaceEdgeIntersector.cxx
+++ oce/src/TopOpeBRep/TopOpeBRep_FaceEdgeIntersector.cxx
@@ -98,10 +98,6 @@ void TopOpeBRep_FaceEdgeIntersector::Per
   TopLoc_Location loc;
   const Handle(Geom_Curve) C = BRep_Tool::Curve(myEdge,loc,f,l);
   
-#ifdef DEB
-  gp_Trsf Tao1 =
-#endif
-                 loc.Transformation();
   Handle(Geom_Geometry) GGao1 = C->Transformed(loc.Transformation());
   Handle(Geom_Curve)* PGCao1 = (Handle(Geom_Curve)*)&GGao1;
   myCurve.Load(*PGCao1,f,l);
Index: oce/src/TopOpeBRep/TopOpeBRep_FacesIntersector.cxx
===================================================================
--- oce.orig/src/TopOpeBRep/TopOpeBRep_FacesIntersector.cxx
+++ oce/src/TopOpeBRep/TopOpeBRep_FacesIntersector.cxx
@@ -1439,13 +1439,12 @@ static Standard_Boolean IsPointOK(const
   Extrema_ExtPS extPS(theTestPnt,theTestSurface,ExtTol,ExtTol);
   if( extPS.IsDone() && extPS.NbExt() > 0 )
     {
-      Standard_Integer i = 0, minext = 1;
+      Standard_Integer i = 0;
       Standard_Real MinDist2 = 1.e+200;
       for(i = 1; i <= extPS.NbExt(); i++)
 	{
 	  if( extPS.SquareDistance(i) < MinDist2 )
 	    {
-	      minext = i;
 	      MinDist2 = extPS.SquareDistance(i);
 	    }
 	}
Index: oce/src/TopOpeBRep/TopOpeBRep_kpart.cxx
===================================================================
--- oce.orig/src/TopOpeBRep/TopOpeBRep_kpart.cxx
+++ oce/src/TopOpeBRep/TopOpeBRep_kpart.cxx
@@ -352,7 +352,6 @@ Standard_Boolean FUNBREP_topowalki
     lastinin = lastinin && (lasttransLine.After() == TopAbs_IN);
   }
   
-  Standard_Boolean LIdefinie = Standard_False;
   Standard_Boolean LITdefinie = Standard_False;
   Standard_Boolean LITonsort = Standard_False;
   TopOpeBRepDS_Transition LIT;
@@ -360,7 +359,6 @@ Standard_Boolean FUNBREP_topowalki
   Standard_Boolean nointerf = DSCIL.IsEmpty();
   if (!nointerf) {
     I = DSCIL.Last();
-    LIdefinie = Standard_True;
     LIT = I->Transition();
     LITdefinie = ! LIT.IsUnknown();
     if (LITdefinie) LITonsort = (LIT.Orientation(TopAbs_OUT) == TopAbs_FORWARD);
@@ -587,9 +585,9 @@ Standard_Boolean FUNBREP_topogline_new
 } // FUNBREP_topogline_new
 
 //----------------------------------------------------------------------
-Standard_Boolean FUNBREP_topogline
+static Standard_Boolean FUNBREP_topogline
 (const Handle(TopOpeBRepDS_Interference)& Ifound,const TopOpeBRepDS_ListOfInterference& DSCIL,const TopOpeBRep_LineInter& L,
- const TopOpeBRep_VPointInter& VP,const TopOpeBRepDS_Transition& lasttransLine,
+ const TopOpeBRep_VPointInter& VP,
  const TopOpeBRepDS_DataStructure& BDS,const TopoDS_Shape& E,
 // const TopoDS_Shape& F,
  const TopoDS_Shape& ,
@@ -624,9 +622,6 @@ Standard_Boolean FUNBREP_topogline
     if (iVP == iINONn) transLine = TopOpeBRepDS_Transition(TopAbs_IN,TopAbs_OUT);    
   }
   Standard_Boolean onsort = (transLine.Orientation(TopAbs_OUT) == TopAbs_FORWARD);
-  Standard_Boolean lastdefinie = ! lasttransLine.IsUnknown();
-  Standard_Boolean lastonsort = Standard_False;
-  if (lastdefinie) lastonsort = (lasttransLine.Orientation(TopAbs_OUT) == TopAbs_FORWARD);
 
   Standard_Boolean LITdefinie = Standard_False;
   Standard_Boolean LITonsort = Standard_False;
@@ -764,7 +759,8 @@ Standard_EXPORT Standard_Boolean FUNBREP
   if (!CPIfound) samepar = Standard_False;
   else           samepar = CPIfound ? TopoParameter(L,Ifound,parline,couture) : Standard_False;
 
-  TopOpeBRepDS_Transition lasttransLine; if (!DSCIL.IsEmpty()) lasttransLine = DSCIL.Last()->Transition(); // xpu12-12-97
+  TopOpeBRepDS_Transition lasttransLine;
+  if (!DSCIL.IsEmpty()) lasttransLine = DSCIL.Last()->Transition(); // xpu12-12-97
 #ifdef DEB
   if (TopOpeBRepDS_GettraceDSF()) {
     FUNBREP_topokpartDEB(Ifound,DSCIL,L,VP,lasttransLine,BDS,E,F,toluv,
@@ -784,7 +780,7 @@ Standard_EXPORT Standard_Boolean FUNBREP
 			     CPIfound,samepar,couture,parline,transLine);
   }
   else {
-    keep = FUNBREP_topogline(Ifound,DSCIL,L,VP,lasttransLine,BDS,E,F,toluv,
+    keep = FUNBREP_topogline(Ifound,DSCIL,L,VP,BDS,E,F,toluv,
 			     CPIfound,samepar,couture,parline,transLine);
   }
   return keep;  
Index: oce/src/TopOpeBRep/TopOpeBRep_mergePDS.cxx
===================================================================
--- oce.orig/src/TopOpeBRep/TopOpeBRep_mergePDS.cxx
+++ oce/src/TopOpeBRep/TopOpeBRep_mergePDS.cxx
@@ -83,23 +83,21 @@ void BREP_mergePDS(const Handle(TopOpeBR
       //**!
       const TopOpeBRepDS_Point& PDS = BDS.Point(GI);
 
-      Standard_Integer ivp1; TopoDS_Shape v1; Standard_Boolean newv1 = Standard_False; TopOpeBRepDS_Kind k1=TopOpeBRepDS_UNKNOWN; Standard_Integer iv1 = 0;
+      Standard_Integer ivp1; TopoDS_Shape v1; TopOpeBRepDS_Kind k1=TopOpeBRepDS_UNKNOWN; Standard_Integer iv1 = 0;
 
       ivp1 = BREP_findPDSamongIDMOVP(PDS,Mvp1);
       if (ivp1) {
 	v1 = Mvp1.FindKey(ivp1);
-	newv1 = !BDS.HasShape(v1);
 	iv1 = BDS.AddShape(v1);
 	k1 = TopOpeBRepDS_VERTEX;
       }
       
 
-      Standard_Integer ivp2; TopoDS_Shape v2; Standard_Boolean newv2 = Standard_False; TopOpeBRepDS_Kind k2=TopOpeBRepDS_UNKNOWN; Standard_Integer iv2 = 0;
+      Standard_Integer ivp2; TopoDS_Shape v2; TopOpeBRepDS_Kind k2=TopOpeBRepDS_UNKNOWN; Standard_Integer iv2 = 0;
 
       ivp2 = BREP_findPDSamongIDMOVP(PDS,Mvp2);
       if (ivp2) {
 	v2 = Mvp2.FindKey(ivp2);
-	newv2 = !BDS.HasShape(v2);
 	iv2 = BDS.AddShape(v2);
 	k2 = TopOpeBRepDS_VERTEX;
       }
@@ -117,14 +115,14 @@ void BREP_mergePDS(const Handle(TopOpeBR
 	if (ivp1 != 0) {
 	  cout<<TopOpeBRepDS::SPrint(TopOpeBRepDS_CURVE,ic,"# BREP_mergePDS "," : ");
 	  cout<<TopOpeBRepDS::SPrint(GK,GI,""," = ");
-	  TCollection_AsciiString str; if (newv1) str = "new "; else str = "old ";
+	  TCollection_AsciiString str (BDS.HasShape(v1) ? "old" : "new ");
 	  cout<<TopOpeBRepDS::SPrint(k1,iv1,str);
 	  cout<<TopOpeBRepDS::SPrint(TopOpeBRepDS::ShapeToKind(f1.ShapeType()),if1," de ")<<endl;
 	}
 	if (ivp2 != 0) {
 	  cout<<TopOpeBRepDS::SPrint(TopOpeBRepDS_CURVE,ic,"# BREP_mergePDS "," : ");
 	  cout<<TopOpeBRepDS::SPrint(GK,GI,""," = ");
-	  TCollection_AsciiString str; if (newv2) str = "new "; else str = "old ";
+	  TCollection_AsciiString str (BDS.HasShape(v2) ? "old" : "new ");
 	  cout<<TopOpeBRepDS::SPrint(k2,iv2,str);
 	  cout<<TopOpeBRepDS::SPrint(TopOpeBRepDS::ShapeToKind(f2.ShapeType()),if2," de ")<<endl;
 	}
Index: oce/src/TopOpeBRep/TopOpeBRep_vpr.cxx
===================================================================
--- oce.orig/src/TopOpeBRep/TopOpeBRep_vpr.cxx
+++ oce/src/TopOpeBRep/TopOpeBRep_vpr.cxx
@@ -982,9 +982,6 @@ void TopOpeBRep_FacesFiller::ProcessVPon
     }
   }//myLineINL
 
-  TopOpeBRepDS_Kind SKEPI; if(EPIfound) SKEPI=IEPI->SupportType();
-  TopOpeBRepDS_Kind SKCPI; if(CPIfound) SKCPI=ICPI->SupportType();
-
   // Gfound = VP corresponds with an existing geometry of ShapeIndex
   Standard_Boolean Gfound = ( EPIfound || CPIfound );  
 #ifdef DEB
Index: oce/src/TopOpeBRep/TopOpeBRep_vprclo.cxx
===================================================================
--- oce.orig/src/TopOpeBRep/TopOpeBRep_vprclo.cxx
+++ oce/src/TopOpeBRep/TopOpeBRep_vprclo.cxx
@@ -171,24 +171,25 @@ void TopOpeBRep_FacesFiller::ProcessVPon
   if (iOOFace == 0) iOOFace = myDS->AddShape(OOFace,OOShapeIndex);
 
   // current VPoint is on <edge>
+#ifdef DEB
   Standard_Integer SIedgeIndex = 0;
+#endif
   const TopoDS_Edge& edge = TopoDS::Edge(VP.Edge(ShapeIndex));
-  if (myDS->HasShape(edge)) SIedgeIndex = myDS->Shape(edge);
-  else                      myDS->AddShape(edge,ShapeIndex);
+  if (!myDS->HasShape(edge)) myDS->AddShape(edge,ShapeIndex);
+#ifdef DEB
+  else                       SIedgeIndex = myDS->Shape(edge);
+#endif
 
   Standard_Real paredge = VP.EdgeParameter(ShapeIndex);
   
   // dummy if !<hasOOedge>
   Standard_Integer OOedgeIndex = 0; 
-  Standard_Boolean OOclosing,OOisrest; OOclosing = OOisrest = Standard_False;
   TopoDS_Edge OOedge;
   if ( hasOOedge ) {
     TopoDS_Shape OOe;
     if (on2edges) OOe = VP.Edge(OOShapeIndex);
     else          OOe = VP.EdgeON(OOShapeIndex);
     OOedge = TopoDS::Edge(OOe);
-    OOisrest = myDS->IsSectionEdge(OOedge);
-    OOclosing = TopOpeBRepTool_ShapeTool::Closed(OOedge,OOFace);
     if (myDS->HasShape(OOedge)) OOedgeIndex = myDS->Shape(OOedge);
     else                        OOedgeIndex = myDS->AddShape(OOedge,OOShapeIndex);
   }
Index: oce/src/TopOpeBRepBuild/TopOpeBRepBuild_BuildEdges.cxx
===================================================================
--- oce.orig/src/TopOpeBRepBuild/TopOpeBRepBuild_BuildEdges.cxx
+++ oce/src/TopOpeBRepBuild/TopOpeBRepBuild_BuildEdges.cxx
@@ -88,7 +88,6 @@ void TopOpeBRepBuild_Builder::BuildEdges
   TopOpeBRepDS_DataStructure& BDS = HDS->ChangeDS();
 
   myNewEdges.Clear();
-  Standard_Integer nc = BDS.NbCurves();
   TopOpeBRepDS_CurveExplorer cex;
 
   Standard_Integer ick = 0;
@@ -106,7 +105,6 @@ void TopOpeBRepBuild_Builder::BuildEdges
     BDS.ChangeNbCurves(ick-1);
   }
 
-  nc = BDS.NbCurves();
   for (cex.Init(BDS,Standard_False); cex.More(); cex.Next()) {
     Standard_Integer ic = cex.Index();
     Standard_Integer im = cex.Curve(ic).Mother();
Index: oce/src/TopOpeBRepBuild/TopOpeBRepBuild_Builder1.cxx
===================================================================
--- oce.orig/src/TopOpeBRepBuild/TopOpeBRepBuild_Builder1.cxx
+++ oce/src/TopOpeBRepBuild/TopOpeBRepBuild_Builder1.cxx
@@ -770,7 +770,6 @@ void TopOpeBRepBuild_Builder1::GFillEdge
   //1) Get split parts of edge with state TB
   const TopTools_ListOfShape& LSE = myDataStructure -> DS().GetShapeWithState(EOR).Part(TB);
   TopTools_ListIteratorOfListOfShape  it (LSE);
-  Standard_Boolean first = Standard_True;
   for(; it.More(); it.Next()) {
 
     TopoDS_Edge newE = TopoDS::Edge(it.Value());
@@ -795,7 +794,6 @@ void TopOpeBRepBuild_Builder1::GFillEdge
   
   //2) Get ON parts of the edge and define to keep it or not
   const TopTools_ListOfShape& LSEOn = myDataStructure -> DS().GetShapeWithState(EOR).Part(TopAbs_ON);
-  first = Standard_True;
   it.Initialize(LSEOn);
   for(; it.More(); it.Next()) {
     
@@ -1023,14 +1021,10 @@ void TopOpeBRepBuild_Builder1::PerformON
 
   Standard_Integer iref = myDataStructure -> DS().AncestorRank(FOR1);
     
-  Standard_Boolean RevOri;
-
   if(iref == 1) {//object
     FTB = FTB1;
-    RevOri = G1.IsToReverse1();
   }
   else {//tool
-    RevOri = G1.IsToReverse2();
     FTB = FTB2;
   }
 
Index: oce/src/TopOpeBRepBuild/TopOpeBRepBuild_BuilderON.cxx
===================================================================
--- oce.orig/src/TopOpeBRepBuild/TopOpeBRepBuild_BuilderON.cxx
+++ oce/src/TopOpeBRepBuild/TopOpeBRepBuild_BuilderON.cxx
@@ -255,25 +255,31 @@ Standard_Boolean FUN_keepEON(const TopOp
   Standard_Boolean tFSEG=DEBTEFOR(B,iFS,iEG);if (tFSEG) debfillonfemess(iFS,iEG);
 #endif
   
+#ifdef DEB
   Standard_Boolean keep1=Standard_True;
   Standard_Boolean keep2=Standard_True;
+#endif
   Standard_Boolean keep3=Standard_True;
   Standard_Boolean isclosedFF=BRep_Tool::IsClosed(EG,FF);
   if (isclosedFF) {
+#ifdef DEB
     keep1=Standard_True;
     keep2=Standard_True;
+#endif
     keep3=Standard_True;
   }
   else {
     TopAbs_Orientation oEGFF=TopAbs_FORWARD;
     FUN_tool_orientEinF(EG,FF,oEGFF);
 
+#ifdef DEB
     TopAbs_Orientation omatFS1=TFE.Orientation(TB1);
     if (oEGFF == TopAbs_REVERSED) omatFS1=TopAbs::Complement(omatFS1);
     keep1=(omatFS1 == TopAbs_FORWARD);
 
     TopAbs_Orientation omatFS2=TFE.Orientation(TB1);
     keep2=(omatFS2 == oEGFF);
+#endif
 
     TopAbs_State tfeb=TFE.Before();
     TopAbs_State tfea=TFE.After();
@@ -1181,11 +1187,11 @@ void TopOpeBRepBuild_BuilderON::GFillONP
     }
 
     TopOpeBRepDS_Transition TFEe3; TopAbs_State TFEe3bef = TFEe3.Before(); TopAbs_State TFEe3aft = TFEe3.After();
-    TopAbs_Orientation oe3FORF = TopAbs_FORWARD; Standard_Boolean e3BoundFOR = Standard_False;
+    TopAbs_Orientation oe3FORF = TopAbs_FORWARD;
     if (ssif) {
       TFEe3 = ssie3->Transition();
       TFEe3bef = TFEe3.Before();
-      e3BoundFOR = FUN_tool_orientEinFFORWARD(e3,FOR,oe3FORF);	
+      FUN_tool_orientEinFFORWARD(e3,FOR,oe3FORF);	
     }
 
     if (FFinSDSO) {
Index: oce/src/TopOpeBRepBuild/TopOpeBRepBuild_CorrectFace2d.cxx
===================================================================
--- oce.orig/src/TopOpeBRepBuild/TopOpeBRepBuild_CorrectFace2d.cxx
+++ oce/src/TopOpeBRepBuild/TopOpeBRepBuild_CorrectFace2d.cxx
@@ -344,7 +344,6 @@ TopOpeBRepBuild_CorrectFace2d::TopOpeBRe
   //
   // 2. Define the First Edge on the Wire from aCopyAvoidMap
   Standard_Integer i, aNbEdges=0, aNbAvoidEdgesOnWire;
-  Standard_Boolean IsAllAvoidEdgesDegenerated=Standard_False;
   Standard_Real aDMax=0, aR;
 
   TopExp_Explorer aWExp; 
@@ -383,7 +382,6 @@ TopOpeBRepBuild_CorrectFace2d::TopOpeBRe
     // All of anAvoidMap edges are degenerated
     // So take the edge with max dist. between 
     //First and Last 2d points as the First edge
-    IsAllAvoidEdgesDegenerated=Standard_True;
     //if(aNbAvoidEdgesOnWire != 1)
      // return 1; //in case of several degenerated edges we cannot connect wire by right way
     for (i=1; i<=aNbAvoidEdgesOnWire; i++) {
@@ -686,7 +684,7 @@ TopOpeBRepBuild_CorrectFace2d::TopOpeBRe
   void TopOpeBRepBuild_CorrectFace2d::CheckList (const TopoDS_Face& aFace,
 						 TopTools_ListOfShape&  HeadList)
 {
-  TopAbs_Orientation r1, r2;
+  TopAbs_Orientation r1;
   Standard_Real aDTolerance=Precision::Confusion();
   TopTools_SequenceOfShape aSeq;
   TopTools_ListIteratorOfListOfShape anIt(HeadList);
@@ -695,7 +693,6 @@ TopOpeBRepBuild_CorrectFace2d::TopOpeBRe
   }
 
   r1=aSeq(1).Orientation();
-  r2=aSeq(2).Orientation();
   Standard_Integer i, aNb=aSeq.Length();
 //modified by NIZNHY-PKV Mon Apr 24 14:43:57 2000f
   Standard_Boolean aFirstCheck=Standard_False;
@@ -729,7 +726,6 @@ TopOpeBRepBuild_CorrectFace2d::TopOpeBRe
 //modified by NIZNHY-PKV Mon Apr 24 14:43:59 2000t
 
   r1=aSeq(1).Orientation();
-  r2=aSeq(2).Orientation();
 
   TopoDS_Vertex aV1R, aV2F;
   
Index: oce/src/TopOpeBRepBuild/TopOpeBRepBuild_FREGU.cxx
===================================================================
--- oce.orig/src/TopOpeBRepBuild/TopOpeBRepBuild_FREGU.cxx
+++ oce/src/TopOpeBRepBuild/TopOpeBRepBuild_FREGU.cxx
@@ -291,8 +291,6 @@ void TopOpeBRepBuild_Builder::Regularize
 //	Standard_Integer nlspfsdFFe = lspfsdFFe.Extent();
 #endif    
 	  
-        Standard_Integer nDEB2=0 ;
-	
 	for (TopTools_ListIteratorOfListOfShape it(lspfsdFFe);it.More();it.Next()) {
 	  
 	  // fsdFFe (Cf supra E) a ete splittee, espfdsFFe = arete splittee de fsdFFe
@@ -313,7 +311,6 @@ void TopOpeBRepBuild_Builder::Regularize
 	    
 	    // son decoupage lresplit est stocke dans la DS du Builder
 	    const TopTools_ListOfShape& lresplit = myESplits.Find(espfsdFFe); //Cf supra E''
-	    nDEB2 = lresplit.Extent();
 	    
 	    // on memorise que espfsdFFe est redecoupee ...
 	    myMemoSplit.Add(espfsdFFe);
@@ -321,7 +318,6 @@ void TopOpeBRepBuild_Builder::Regularize
 	    // on stocke le nouveau decoupage de espfsdFFe dans la DS du builder ...
 	    TopTools_ListOfShape& lsp = ChangeSplit(espfsdFFe,stafsdFFe);  
 	    GCopyList(lresplit,lsp);
-	    nDEB2 = lsp.Extent();
 	  }
 	} // it.More
       } // iiista
Index: oce/src/TopOpeBRepBuild/TopOpeBRepBuild_FuseFace.cxx
===================================================================
--- oce.orig/src/TopOpeBRepBuild/TopOpeBRepBuild_FuseFace.cxx
+++ oce/src/TopOpeBRepBuild/TopOpeBRepBuild_FuseFace.cxx
@@ -154,7 +154,7 @@ void TopOpeBRepBuild_FuseFace::PerformFa
     
   TopTools_ListIteratorOfListOfShape it2,it3,it4;
   TopTools_DataMapIteratorOfDataMapOfShapeListOfShape itt1,itt2,itt3;
-  TopAbs_Orientation ori,ori1;
+  TopAbs_Orientation ori1;
 
   Standard_Boolean Ori3dReversed = Standard_False;
   Standard_Boolean Ori3dForward = Standard_False;
@@ -292,7 +292,6 @@ void TopOpeBRepBuild_FuseFace::PerformFa
 	  TopTools_ListOfShape myWireLE;
 	  for (itt3.Initialize(mapEdgLEdg); itt3.More(); itt3.Next()) {
 	    const TopoDS_Shape& edg = itt3.Key();
-	    ori = edg.Orientation();
 	    const TopTools_ListOfShape& LEdg1 = mapEdgLEdg.Find(edg);
 	    Standard_Boolean OriReversed = Standard_False;
 	    Standard_Boolean OriForward = Standard_False;
Index: oce/src/TopOpeBRepBuild/TopOpeBRepBuild_Grid.cxx
===================================================================
--- oce.orig/src/TopOpeBRepBuild/TopOpeBRepBuild_Grid.cxx
+++ oce/src/TopOpeBRepBuild/TopOpeBRepBuild_Grid.cxx
@@ -260,16 +260,8 @@ void TopOpeBRepBuild_Builder::GFindSamDo
     else if ( o != oref && !GContains(s,LLDO) ) LLDO.Append(s);
   }
   
-  Standard_Integer nso,ndo;
-  
-  nso = LLSO.Extent();
-  ndo = LLDO.Extent();
-  
   LSO = LLSO;
   LDO = LLDO;
-  
-  nso = LSO.Extent();
-  ndo = LDO.Extent();
 }
 
 //=======================================================================
Index: oce/src/TopOpeBRepBuild/TopOpeBRepBuild_GridEE.cxx
===================================================================
--- oce.orig/src/TopOpeBRepBuild/TopOpeBRepBuild_GridEE.cxx
+++ oce/src/TopOpeBRepBuild/TopOpeBRepBuild_GridEE.cxx
@@ -166,9 +166,8 @@ void TopOpeBRepBuild_Builder::GFillEdgeP
                                            const TopOpeBRepBuild_GTopo& G,
                                            TopOpeBRepBuild_PaveSet& PVS)
 {
-  TopAbs_ShapeEnum t1,t2,ShapeInterf;
+  TopAbs_ShapeEnum t1,t2;
   G.Type(t1,t2);
-  ShapeInterf = t1;
   TopAbs_State TB1,TB2;
   G.StatesON(TB1,TB2);
   
@@ -356,7 +355,7 @@ void TopOpeBRepBuild_Builder::GFillPoint
   // BUC60093 :  only 2 G : 1 point && 1 vertex  
   // deleting interfs on G = vertex sdm && closingE  
   TopoDS_Vertex vclo; Standard_Boolean closedE = TopOpeBRepTool_TOOL::ClosedE(TopoDS::Edge(E),vclo);
-  Standard_Integer kp1 = 0; Standard_Integer ikp1 = 0; 
+  Standard_Integer kp1 = 0;
   if (closedE) {
     tki.Init();
     Standard_Integer nG = 0;
@@ -369,7 +368,7 @@ void TopOpeBRepBuild_Builder::GFillPoint
       TopoDS_Shape oov;
       FUN_ds_getoov(v,myDataStructure,oov);
       Standard_Boolean samev = v.IsSame(vclo), sameoov = oov.IsSame(vclo);
-      if (samev || sameoov) {ikp1 = Gcur; kp1 = Gcur;}
+      if (samev || sameoov) {kp1 = Gcur;}
       tki.Next();
     }
     if (nG == 1) kp1 = 0; // we have only one interf on vGclo -> keep the interf
@@ -413,8 +412,8 @@ void TopOpeBRepBuild_Builder::GFillPoint
 	      aa += TCollection_AsciiString(Gcur); DSD.DumpLOI(LICur,cout,aa);}
 #endif
 
-    Standard_Boolean Ghsd = Standard_False; TopoDS_Shape vGsd; 
-    if (vertex) Ghsd = FUN_ds_getoov(BDS.Shape(Gcur), myDataStructure, vGsd); //xpu221098
+    TopoDS_Shape vGsd; 
+    if (vertex) FUN_ds_getoov(BDS.Shape(Gcur), myDataStructure, vGsd); //xpu221098
 
     // recall : I3d=(I3dF,I3dFE) : I3dF=(T(F),G,F), I3dFE=(T(F),G,E)
     //          I2d=I2dFE
@@ -507,8 +506,7 @@ void TopOpeBRepBuild_Builder::GFillPoint
     // - kp3 -
     // xpu200598 interference 2d at GPOINT
     Standard_Boolean kp3 = (n2d > 0) && point;
-    TopAbs_Orientation Okp3 = TopAbs_EXTERNAL; 
-    if (kp3) Okp3=l2dFEcur.First()->Transition().Orientation(TopAbs_IN);
+    if (kp3) l2dFEcur.First()->Transition().Orientation(TopAbs_IN);
 
 
     TopOpeBRepDS_PointIterator itCur(LICur); Standard_Integer iICur=0;
Index: oce/src/TopOpeBRepBuild/TopOpeBRepBuild_GridFF.cxx
===================================================================
--- oce.orig/src/TopOpeBRepBuild/TopOpeBRepBuild_GridFF.cxx
+++ oce/src/TopOpeBRepBuild/TopOpeBRepBuild_GridFF.cxx
@@ -1055,8 +1055,8 @@ void debmergee(const Standard_Integer /*
 					   const TopOpeBRepBuild_GTopo& G1,
 					   const TopTools_ListOfShape& LSclass)
 {
-  TopAbs_ShapeEnum t1,t2,ShapeInterf;
-  G1.Type(t1,t2); ShapeInterf = t1;
+  TopAbs_ShapeEnum t1,t2;
+  G1.Type(t1,t2);
   TopAbs_State TB1,TB2; G1.StatesON(TB1,TB2);
   // work on a FORWARD edge <EF>
   TopoDS_Shape EF = EOR; EF.Orientation(TopAbs_FORWARD);
Index: oce/src/TopOpeBRepBuild/TopOpeBRepBuild_GridSS.cxx
===================================================================
--- oce.orig/src/TopOpeBRepBuild/TopOpeBRepBuild_GridSS.cxx
+++ oce/src/TopOpeBRepBuild/TopOpeBRepBuild_GridSS.cxx
@@ -408,8 +408,11 @@ void TopOpeBRepBuild_Builder::GFillSurfa
                                                       TopOpeBRepBuild_ShellFaceSet& /*SFS*/)
 {
   TopAbs_State TB1,TB2; G1.StatesON(TB1,TB2);
-  TopAbs_ShapeEnum t1,t2,ShapeInterf;
-  G1.Type(t1,t2); ShapeInterf = t1;
+  TopAbs_ShapeEnum t1,t2;
+  G1.Type(t1,t2);
+#ifdef DEB
+  TopAbs_ShapeEnum ShapeInterf = t1;
+#endif
   
 #ifdef DEB
   Standard_Integer iSO; Standard_Boolean tSPS = GtraceSPS(SO1,iSO);
@@ -493,20 +496,15 @@ void TopOpeBRepBuild_Builder::GFillShell
       cout<<endl;}
 #endif
   
-  Standard_Integer nlsfs = SFS.ChangeStartShapes().Extent();
   TopOpeBRepTool_ShapeExplorer exFace;
-  Standard_Integer ifor = 0;
   
   // 1/ : toutes les faces HasSameDomain
   for (exFace.Init(SH,TopAbs_FACE); exFace.More(); exFace.Next()) {
-    nlsfs = SFS.ChangeStartShapes().Extent();
     const TopoDS_Shape& FOR = exFace.Current();
-    ifor = myDataStructure->Shape(FOR);
     Standard_Boolean hsd = myDataStructure->HasSameDomain(FOR);
     if ( hsd ) {
       GFillFaceSFS(FOR,LSO2,G1,SFS);
     } // hsd
-    nlsfs = SFS.ChangeStartShapes().Extent();
   } // exFace.More()
   
 #ifdef DEB
@@ -517,14 +515,11 @@ void TopOpeBRepBuild_Builder::GFillShell
   
   // 2/ : toutes les faces non HasSameDomain
   for (exFace.Init(SH,TopAbs_FACE); exFace.More(); exFace.Next()) {
-    nlsfs = SFS.ChangeStartShapes().Extent();
     const TopoDS_Shape& FOR = exFace.Current();
-    ifor = myDataStructure->Shape(FOR);
     Standard_Boolean hsd = myDataStructure->HasSameDomain(FOR);
     if ( !hsd ) {
       GFillFaceSFS(FOR,LSO2,G1,SFS);
     } // hsd
-    nlsfs = SFS.ChangeStartShapes().Extent();
   }
   
 } // GFillShellSFS
Index: oce/src/TopOpeBRepBuild/TopOpeBRepBuild_KPart.cxx
===================================================================
--- oce.orig/src/TopOpeBRepBuild/TopOpeBRepBuild_KPart.cxx
+++ oce/src/TopOpeBRepBuild/TopOpeBRepBuild_KPart.cxx
@@ -672,15 +672,12 @@ void TopOpeBRepBuild_Builder::MergeKPart
   TopTools_ListOfShape& lmergesha1 = ChangeMerged(myShape1,myState1);
 /*  TopTools_ListOfShape& lmergesha2 =*/ ChangeMerged(myShape2,myState2);
   
-  Standard_Boolean traite = Standard_True;
-
   Standard_Boolean soldisj = Standard_False;
   TopOpeBRepTool_ShapeExplorer exsol1(myShape1,TopAbs_SOLID);
   Standard_Boolean hassol1 = exsol1.More();
   TopOpeBRepTool_ShapeExplorer exsol2(myShape2,TopAbs_SOLID);
   Standard_Boolean hassol2 = exsol2.More();
   soldisj = (hassol1 && hassol2);
-  traite = soldisj;
 
 //modified by NIZHNY-MKK  Fri May 19 16:18:12 2000.BEGIN  
   Standard_Boolean hasnotsol1=Standard_False;
@@ -695,7 +692,6 @@ void TopOpeBRepBuild_Builder::MergeKPart
       hasnotsol2 = Standard_True;
   }
   soldisj = !(hasnotsol1 || hasnotsol2);
-  traite = soldisj;
 //modified by NIZHNY-MKK  Fri May 19 16:18:16 2000.END
   
   TopoDS_Solid sol1; TopoDS_Shell outsha1;
Index: oce/src/TopOpeBRepBuild/TopOpeBRepBuild_PaveSet.cxx
===================================================================
--- oce.orig/src/TopOpeBRepBuild/TopOpeBRepBuild_PaveSet.cxx
+++ oce/src/TopOpeBRepBuild/TopOpeBRepBuild_PaveSet.cxx
@@ -390,12 +390,12 @@ Standard_Boolean  TopOpeBRepBuild_PaveSe
   }
 
   if ( !myHasEqualParameters ) {
-    Standard_Boolean rd; Standard_Real f=0,l;
+    Standard_Boolean rd; Standard_Real f=0;
     {
       TopLoc_Location loc; Standard_Real ff,ll;
       Handle(Geom_Curve) CmyEdge = BRep_Tool::Curve(myEdge,loc,ff,ll);
       if ( CmyEdge.IsNull() ) rd = Standard_False;
-      else { f = ff; l = ll; rd = Standard_True; }
+      else { f = ff; rd = Standard_True; }
     }
     if (rd) {
       for (it1.Initialize(myVertices); 
Index: oce/src/TopOpeBRepBuild/TopOpeBRepBuild_SREGU.cxx
===================================================================
--- oce.orig/src/TopOpeBRepBuild/TopOpeBRepBuild_SREGU.cxx
+++ oce/src/TopOpeBRepBuild/TopOpeBRepBuild_SREGU.cxx
@@ -258,7 +258,6 @@ void TopOpeBRepBuild_Builder::Regularize
 //      Standard_Integer nlspssdSSf = lspssdSSf.Extent();
 #endif    
 
-      Standard_Integer nDEB2=0;      
       TopTools_ListOfShape newlspssdSSf; // nouvel ensemble de faces splittees de ssdSSf
 
       for (TopTools_ListIteratorOfListOfShape it(lspssdSSf);it.More();it.Next()) {
@@ -279,7 +278,6 @@ void TopOpeBRepBuild_Builder::Regularize
 
 	  // son decoupage lrfsplit est stocke dans la DS du Builder
 	  const TopTools_ListOfShape& lrfsplit = myFSplits.Find(fspssdSSf);//Cf supra E''
-	  nDEB2 = lrfsplit.Extent();
 
 	  // on memorise que fspssdSSf est redecoupee ...
 	  myMemoSplit.Add(fspssdSSf);
@@ -287,7 +285,6 @@ void TopOpeBRepBuild_Builder::Regularize
 	  // on stocke le nouveau decoupage de fspssdSSf dans la DS du builder ...
 	  TopTools_ListOfShape& lsp = ChangeSplit(fspssdSSf,stassdSSf);  
 	  GCopyList(lrfsplit,lsp);
-	  nDEB2 = lsp.Extent();
 	}	
       } // lspssdSSf.More()
     } // explore(ssdSS,TopAbs_FACE)
Index: oce/src/TopOpeBRepBuild/TopOpeBRepBuild_SplitEdge.hxx
===================================================================
--- oce.orig/src/TopOpeBRepBuild/TopOpeBRepBuild_SplitEdge.hxx
+++ oce/src/TopOpeBRepBuild/TopOpeBRepBuild_SplitEdge.hxx
@@ -47,26 +47,6 @@ void TopOpeBRepBuild_Builder::SplitEdge1
 {
   // work on a FORWARD edge <Eforward>
 
-#ifdef DEB
-  TopAbs_Orientation Eori =
-#endif
-                            Eoriented.Orientation();
-#ifdef DEB
-  Standard_Integer io = 0;
-  if      ( Eori == TopAbs_FORWARD  ) {
-    io = 1;
-  }
-  else if ( Eori == TopAbs_REVERSED ) {
-    io = 2;
-  }
-  else if ( Eori == TopAbs_INTERNAL ) {
-    io = 3;
-  }
-  else if ( Eori == TopAbs_EXTERNAL ) {
-    io = 4;
-  }
-#endif
-
   TopoDS_Shape Eforward = Eoriented; 
   Eforward.Orientation(TopAbs_FORWARD);
 
@@ -83,8 +63,8 @@ void TopOpeBRepBuild_Builder::SplitEdge1
   
   if ( ! tosplit ) return;
 
-  Standard_Boolean RevOri1 = Reverse(ToBuild1,ToBuild2);
-  Standard_Boolean RevOri2 = Reverse(ToBuild2,ToBuild1);
+  Reverse(ToBuild1,ToBuild2);
+  Reverse(ToBuild2,ToBuild1);
   Standard_Boolean ConnectTo1 = Standard_True;
   Standard_Boolean ConnectTo2 = Standard_False;
   
@@ -92,8 +72,6 @@ void TopOpeBRepBuild_Builder::SplitEdge1
   TopTools_ListOfShape LE1,LE2;
   LE1.Append(Eforward);
   FindSameDomain(LE1,LE2);
-  Standard_Integer n1 = LE1.Extent();
-  Standard_Integer n2 = LE2.Extent();
 
 #ifdef DEB
   if(tSPS){GdumpSAMDOM(LE1, (char *) "1 : ");}
@@ -106,8 +84,6 @@ void TopOpeBRepBuild_Builder::SplitEdge1
   
   // SplitEdge on a edge having other same domained edges on the
   // other shape : do not reverse orientation of edges in FillEdge
-  if (!n2) RevOri1 = Standard_False;
-  if (!n1) RevOri2 = Standard_False;
     
   // Make a PaveSet <PVS> on edge <Eforward>
   TopOpeBRepBuild_PaveSet PVS(Eforward);
Index: oce/src/TopOpeBRepBuild/TopOpeBRepBuild_Tools.cxx
===================================================================
--- oce.orig/src/TopOpeBRepBuild/TopOpeBRepBuild_Tools.cxx
+++ oce/src/TopOpeBRepBuild/TopOpeBRepBuild_Tools.cxx
@@ -543,10 +543,8 @@ const Standard_Real PAR_T = 0.43213918;
 {
   TopoDS_Edge aEd=anEdgeObj;
   TopoDS_Face aFS=aFObj;
-  Standard_Real tolE = 0., f2 = 0., l2 = 0., tolpc = 0., tol = 0., f = 0., l = 0., par = 0.;
-  tolE=BRep_Tool::Tolerance(aEd);
+  Standard_Real f2 = 0., l2 = 0., tolpc = 0., f = 0., l = 0., par = 0.;
   Handle(Geom2d_Curve) C2D=FC2D_CurveOnSurface(aEd,aFS,f2,l2,tolpc, Standard_True);
-  tol = Max(tolE,tolpc);
 
   BRepAdaptor_Curve  aCA(aEd);
   f=aCA.FirstParameter();
Index: oce/src/TopOpeBRepBuild/TopOpeBRepBuild_Tools2d.cxx
===================================================================
--- oce.orig/src/TopOpeBRepBuild/TopOpeBRepBuild_Tools2d.cxx
+++ oce/src/TopOpeBRepBuild/TopOpeBRepBuild_Tools2d.cxx
@@ -190,14 +190,10 @@ static
 //=======================================================================
   void TopOpeBRepBuild_Tools2d::DumpMapOfShapeVertexInfo(const TopOpeBRepBuild_IndexedDataMapOfShapeVertexInfo& M)
 {
-  Standard_Integer i, aNb, aNbEdgesIn, aNbEdgesOut;
+  Standard_Integer i, aNb;
   aNb=M.Extent();
   for (i=1; i<=aNb; i++) {
     const TopOpeBRepBuild_VertexInfo& aVInfo=M(i);
-    const TopTools_IndexedMapOfOrientedShape& EdgesIn   =aVInfo.EdgesIn();
-    const TopTools_IndexedMapOfOrientedShape& EdgesOut  =aVInfo.EdgesOut();
-    aNbEdgesIn   =EdgesIn.Extent();
-    aNbEdgesOut  =EdgesOut.Extent();
     
     printf(" Vert.#%d, ", i);
     const TopTools_ListOfShape& aList=aVInfo.ListPassed();
Index: oce/src/TopOpeBRepBuild/TopOpeBRepBuild_VertexInfo.cxx
===================================================================
--- oce.orig/src/TopOpeBRepBuild/TopOpeBRepBuild_VertexInfo.cxx
+++ oce/src/TopOpeBRepBuild/TopOpeBRepBuild_VertexInfo.cxx
@@ -202,9 +202,8 @@ TopOpeBRepBuild_VertexInfo::TopOpeBRepBu
   const TopoDS_Edge& TopOpeBRepBuild_VertexInfo::CurrentOut () 
 {
 
-  Standard_Integer i, aNbOut, aNbPassed ;
+  Standard_Integer i, aNbOut;
   aNbOut =myLocalEdgesOut.Extent();
-  aNbPassed=myEdgesPassed.Extent();
   
   TopTools_IndexedMapOfOrientedShape aMapPassed;
   TopTools_ListIteratorOfListOfShape anIt(myEdgesPassed);
Index: oce/src/TopOpeBRepBuild/TopOpeBRepBuild_WireEdgeSet.cxx
===================================================================
--- oce.orig/src/TopOpeBRepBuild/TopOpeBRepBuild_WireEdgeSet.cxx
+++ oce/src/TopOpeBRepBuild/TopOpeBRepBuild_WireEdgeSet.cxx
@@ -519,12 +519,6 @@ void TopOpeBRepBuild_WireEdgeSet::IsUVIS
   PC = FC2D_CurveOnSurface(E,F,fE,lE,tolpc,trim3d);
   if (PC.IsNull()) Standard_ProgramError::Raise("TopOpeBRepBuild_WireEdgeSet::IsUVISO");
 
-#ifdef DEB
-  Standard_Integer iE = 0, iF = 0;
-  if (LOCAL_PBUILDER_DEB != NULL) iE = LOCAL_PBUILDER_DEB->DataStructure()->Shape(E);
-  if (LOCAL_PBUILDER_DEB != NULL) iF = LOCAL_PBUILDER_DEB->DataStructure()->Shape(F);
-#endif
-
   Handle(Standard_Type) TheType = PC->DynamicType();
   if (TheType == STANDARD_TYPE(Geom2d_Line)) {
     const Handle(Geom2d_Line)& HL = *((Handle(Geom2d_Line)*)&PC);
Index: oce/src/TopOpeBRepBuild/TopOpeBRepBuild_ffsfs.cxx
===================================================================
--- oce.orig/src/TopOpeBRepBuild/TopOpeBRepBuild_ffsfs.cxx
+++ oce/src/TopOpeBRepBuild/TopOpeBRepBuild_ffsfs.cxx
@@ -399,7 +399,7 @@ void TopOpeBRepBuild_Builder::GFillFaceS
       GLOBAL_SplitAnc->Clear(); // xpu280598
 
       // FuseFace
-      Standard_Integer nlsfs = SFS.ChangeStartShapes().Extent();
+      SFS.ChangeStartShapes().Extent();
       if (performfufa) {	
 #ifdef DEB
 	if(tSPS) debffflo(iF);
@@ -438,7 +438,6 @@ void TopOpeBRepBuild_Builder::GFillFaceS
 #endif
 	  SFS.AddStartElement(flfr2);
 	}
-	nlsfs = SFS.ChangeStartShapes().Extent();
       } // performfufa (context)
       
     } // makemerge
Index: oce/src/TopOpeBRepBuild/TopOpeBRepBuild_kpkole.cxx
===================================================================
--- oce.orig/src/TopOpeBRepBuild/TopOpeBRepBuild_kpkole.cxx
+++ oce/src/TopOpeBRepBuild/TopOpeBRepBuild_kpkole.cxx
@@ -752,7 +752,6 @@ Standard_EXPORT Standard_Boolean FUNKP_K
   TopTools_ListOfShape lfhg; 
   Standard_Integer nfhg = BU.KPlhg(sol,TopAbs_FACE,lfhg);
   if ( nfhg != 0 ) {
-    Standard_Boolean hasgeominterf = Standard_False; // DEB
     TopTools_ListIteratorOfListOfShape its(lfhg);
     for(; its.More(); its.Next()) {
       TopOpeBRepDS_ListIteratorOfListOfInterference iti(BDS.ShapeInterferences(its.Value()));
@@ -760,7 +759,6 @@ Standard_EXPORT Standard_Boolean FUNKP_K
 	Handle(TopOpeBRepDS_ShapeShapeInterference) ssi;
 	ssi = Handle(TopOpeBRepDS_ShapeShapeInterference)::DownCast(iti.Value());
 	if (ssi.IsNull()) {
-	  hasgeominterf = Standard_True; // DEB
 	  return Standard_False;
 	}
       }
Index: oce/src/TopOpeBRepDS/TopOpeBRepDS_Dumper.cxx
===================================================================
--- oce.orig/src/TopOpeBRepDS/TopOpeBRepDS_Dumper.cxx
+++ oce/src/TopOpeBRepDS/TopOpeBRepDS_Dumper.cxx
@@ -266,7 +266,7 @@ Standard_OStream& TopOpeBRepDS_Dumper::P
                                              )
 {
 #ifdef DEB
-  Standard_Integer i,l,lb,n;
+  Standard_Integer i,l,lb=-1,n;
   
   Standard_Integer degree   = B->Degree();
   Standard_Integer nbpoles  = B->NbPoles();
Index: oce/src/TopOpeBRepDS/TopOpeBRepDS_EIR.cxx
===================================================================
--- oce.orig/src/TopOpeBRepDS/TopOpeBRepDS_EIR.cxx
+++ oce/src/TopOpeBRepDS/TopOpeBRepDS_EIR.cxx
@@ -415,7 +415,9 @@ static void FUN_reclSE2(const Standard_I
 //  I2 = (IN/OU(SE),VG,SE))} -> Ir = (IN/IN(SE),VG,SE)
 {
   reducedLI.Clear();
+#ifdef DEB
   Standard_Integer nI = LI.Extent(); // DEB
+#endif
 
   const TopoDS_Edge& E = TopoDS::Edge(BDS.Shape(SIX));
 
@@ -456,14 +458,18 @@ static void FUN_reclSE2(const Standard_I
 	if (O2 != cO1) {it2.Next(); continue;}
 	
 	LI.Remove(it2);
+#ifdef DEB
 	nI = LI.Extent(); // DEB
+#endif
 	hascO = Standard_True; break;
       } //it2
       
       if (hascO) {
 	I1->ChangeTransition().Set(TopAbs_INTERNAL);
 	reducedLI.Append(I1); LI.Remove(it1);
+#ifdef DEB
 	nI = LI.Extent(); // DEB
+#endif
       }
       else it1.Next();
     } //it1
@@ -747,15 +753,13 @@ static void FUN_ProcessEdgeInterferences
   }
 #endif
 
-  Standard_Integer nF = 0, nE = 0, nFE = 0;
-
   // LI -> (lF + lFE) + lE + [LI]
   // lF  = {interference on edge <EIX> :  (T(face),G=POINT/VERTEX,S)
   // lFE = {interference on edge <EIX> :  (T(face),G=POINT/VERTEX,S=EDGE)
   // lE  = {interference on edge <EIX> :  (T(edge),G=POINT/VERTEX,S)
-  TopOpeBRepDS_ListOfInterference lF; nF = FUN_selectTRASHAinterference(LI,TopAbs_FACE,lF);
-  TopOpeBRepDS_ListOfInterference lFE; nFE = FUN_selectSKinterference(lF,TopOpeBRepDS_EDGE,lFE);
-  TopOpeBRepDS_ListOfInterference lE; nE = FUN_selectTRASHAinterference(LI,TopAbs_EDGE,lE);
+  TopOpeBRepDS_ListOfInterference lF; FUN_selectTRASHAinterference(LI,TopAbs_FACE,lF);
+  TopOpeBRepDS_ListOfInterference lFE; FUN_selectSKinterference(lF,TopOpeBRepDS_EDGE,lFE);
+  TopOpeBRepDS_ListOfInterference lE; FUN_selectTRASHAinterference(LI,TopAbs_EDGE,lE);
 
 #ifdef DEB 
   TopOpeBRepDS_Dumper DSD(HDS);	      
@@ -984,7 +988,6 @@ void TopOpeBRepDS_EIR::ProcessEdgeInterf
     for (tki.Init(); tki.More(); tki.Next()) {
       TopOpeBRepDS_Kind K; Standard_Integer G; tki.Value(K,G);
       TopOpeBRepDS_ListOfInterference& loi = tki.ChangeValue(K,G);
-      Standard_Integer nloi = loi.Extent();
       if (K != TopOpeBRepDS_POINT) {
 	LI.Append(loi);
 	continue;
@@ -1030,7 +1033,6 @@ void TopOpeBRepDS_EIR::ProcessEdgeInterf
 	if (curvefound) break;
       } // itlfx.More()
       
-      nloi = loi.Extent();
 #ifdef DEB
 //      Standard_Integer nLI = LI.Extent();
 #endif
Index: oce/src/TopOpeBRepDS/TopOpeBRepDS_EXPORT.cxx
===================================================================
--- oce.orig/src/TopOpeBRepDS/TopOpeBRepDS_EXPORT.cxx
+++ oce/src/TopOpeBRepDS/TopOpeBRepDS_EXPORT.cxx
@@ -299,10 +299,6 @@ Standard_EXPORT Standard_Boolean FDS_Edg
 (const TopoDS_Shape& E,const Handle(TopOpeBRepDS_HDataStructure)& HDS)  // not used
 //----------------------------------------------------
 {
-#ifdef DEB
-  Standard_Integer if1 = 0, if2 = 0;
-#endif
-
   const TopOpeBRepDS_DataStructure& BDS = HDS->DS();
   const TopTools_ListOfShape& lf = FDSCNX_EdgeConnexitySameShape(E,HDS);
   Standard_Integer nlf = lf.Extent();
@@ -315,9 +311,6 @@ Standard_EXPORT Standard_Boolean FDS_Edg
     TopTools_ListIteratorOfListOfShape i2(i1);
     for(;i2.More();i2.Next()) {
       const TopoDS_Shape& f2 = i2.Value();
-#ifdef DEB
-      if1 = BDS.Shape(f1);if2 = BDS.Shape(f2);
-#endif
       samdom = FDS_aresamdom(BDS,E,f1,f2);
       if (samdom) break;
     }
@@ -1741,8 +1734,8 @@ Standard_EXPORT void FUN_ds_completeforS
 	    else if (M_EXTERNAL(O))                 {newT.Set(O);}
 	    else if (M_INTERNAL(O))                 {
 	      Standard_Real parEsd   = BRep_Tool::Parameter(vG,Esd);
-	      gp_Vec tgEsd; Standard_Boolean ok = TopOpeBRepTool_TOOL::TggeomE(parEsd,Esd,tgEsd); // dir
-	      gp_Vec tgE  ;     ok = TopOpeBRepTool_TOOL::TggeomE(parE,SE,tgE);      // dir
+	      gp_Vec tgEsd; TopOpeBRepTool_TOOL::TggeomE(parEsd,Esd,tgEsd); // dir
+	      gp_Vec tgE  ; TopOpeBRepTool_TOOL::TggeomE(parE,SE,tgE);      // dir
 	      Standard_Real dot = tgEsd.Dot(tgE);
 #ifdef DEB
 	      Standard_Real tola = Precision::Angular();
Index: oce/src/TopOpeBRepDS/TopOpeBRepDS_EdgeInterferenceTool.cxx
===================================================================
--- oce.orig/src/TopOpeBRepDS/TopOpeBRepDS_EdgeInterferenceTool.cxx
+++ oce/src/TopOpeBRepDS/TopOpeBRepDS_EdgeInterferenceTool.cxx
@@ -107,12 +107,16 @@ void TopOpeBRepDS_EdgeInterferenceTool::
   }
 
   // V est un sommet de E ?
+#ifdef DEB
   Standard_Boolean VofE = Standard_False;
+#endif
   TopoDS_Iterator it(E,Standard_False);
   for ( ; it.More(); it.Next() ) {
     const TopoDS_Shape& S = it.Value();
     if ( S.IsSame(V) ) {
+#ifdef DEB
       VofE = Standard_True; 
+#endif
       break;
     }
   }
Index: oce/src/TopOpeBRepDS/TopOpeBRepDS_FIR.cxx
===================================================================
--- oce.orig/src/TopOpeBRepDS/TopOpeBRepDS_FIR.cxx
+++ oce/src/TopOpeBRepDS/TopOpeBRepDS_FIR.cxx
@@ -534,16 +534,20 @@ void TopOpeBRepDS_FIR::ProcessFaceInterf
   TopOpeBRepDS_ListOfInterference& LI = BDS.ChangeShapeInterferences(SIX);
   TopOpeBRepDS_ListOfInterference lw, lE, lFE, lFEF, lF; lw.Assign(LI);
 
-  Standard_Integer nF = ::FUN_selectTRASHAinterference(lw,TopAbs_FACE,lF);
-  Standard_Integer nFE = ::FUN_selectGKinterference(lF,MDSke,lFE);
-  Standard_Integer nFEF = ::FUN_selectSKinterference(lFE,MDSkf,lFEF);
-  Standard_Integer nE = ::FUN_selectTRASHAinterference(lw,TopAbs_EDGE,lE);
+#ifdef DEB
+  Standard_Integer nF, nFE, nFEF, nE;
+#endif
 
+  ::FUN_selectTRASHAinterference(lw,TopAbs_FACE,lF);
+  ::FUN_selectGKinterference(lF,MDSke,lFE);
+  ::FUN_selectSKinterference(lFE,MDSkf,lFEF);
+  ::FUN_selectTRASHAinterference(lw,TopAbs_EDGE,lE);
+
+#ifdef DEB
   nF = lF.Extent();
   nFE = lFE.Extent();
   nFEF = lFEF.Extent();
   nE = lE.Extent();
-#ifdef DEB
   if(TRC){
     if(nF||nFE||nFEF||nE){cout<<endl;cout<<"-----------------------"<<endl;}
     if(nF) {cout<<"FACE "<<SIX<<" (FACE) : "<<nF<<endl;FDS_dumpLI(lF,"  ");}
@@ -555,11 +559,11 @@ void TopOpeBRepDS_FIR::ProcessFaceInterf
 
   FUN_reduceEDGEgeometry(lFEF,BDS,SIX,MEsp);
 
+#ifdef DEB
   nF = lF.Extent();
   nFE = lFE.Extent();
   nFEF = lFEF.Extent();
   nE = lE.Extent();
-#ifdef DEB
   if(TRC){
     if(nF||nFE||nFEF||nE)cout<<endl;
     if(nF) {cout<<"FACE "<<SIX<<" (FACE) : "<<nF<<endl;FDS_dumpLI(lF,"  ");}
Index: oce/src/TopOpeBRepDS/TopOpeBRepDS_FilterFaceInterferences.cxx
===================================================================
--- oce.orig/src/TopOpeBRepDS/TopOpeBRepDS_FilterFaceInterferences.cxx
+++ oce/src/TopOpeBRepDS/TopOpeBRepDS_FilterFaceInterferences.cxx
@@ -112,13 +112,20 @@ void TopOpeBRepDS_Filter::ProcessFaceInt
   lw.Append(lall);
   lw.Append(lUU);
 
-  Standard_Integer nF = ::FUN_selectTRASHAinterference(lw,TopAbs_FACE,lF);
-  Standard_Integer nFE = ::FUN_selectGKinterference(lF,TopOpeBRepDS_EDGE,lFE);
-  Standard_Integer nFEF = ::FUN_selectSKinterference(lFE,TopOpeBRepDS_FACE,lFEF);
-  Standard_Integer nE = ::FUN_selectTRASHAinterference(lw,TopAbs_EDGE,lE);
+#ifdef DEB
+  Standard_Integer nF, nFE, nFEF, nE;
+#endif
 
+  ::FUN_selectTRASHAinterference(lw,TopAbs_FACE,lF);
+  ::FUN_selectGKinterference(lF,TopOpeBRepDS_EDGE,lFE);
+  ::FUN_selectSKinterference(lFE,TopOpeBRepDS_FACE,lFEF);
+  ::FUN_selectTRASHAinterference(lw,TopAbs_EDGE,lE);
 
 #ifdef DEB
+  nF = lF.Extent();
+  nFE = lFE.Extent();
+  nFEF = lFEF.Extent();
+  nE = lE.Extent();
   if(TRC){
     if(nF||nFE||nFEF||nE){cout<<endl;cout<<"-----------------------"<<endl;}
     if(nUU) {cout<<"FACE "<<SIX<<" UNKNOWN : "<<nUU<<endl;FDS_dumpLI(lUU,"  ");}
@@ -131,11 +138,11 @@ void TopOpeBRepDS_Filter::ProcessFaceInt
 
   ::FUN_FilterFace(lFEF,BDS,SIX);
 
+#ifdef DEB
   nF = lF.Extent();
   nFE = lFE.Extent();
   nFEF = lFEF.Extent();
   nE = lE.Extent();
-#ifdef DEB
   if(TRC){
     if(nF||nFE||nFEF||nE)cout<<endl;
     if(nF) {cout<<"FACE "<<SIX<<" (FACE) : "<<nF<<endl;FDS_dumpLI(lF,"  ");}
Index: oce/src/TopOpeBRepDS/TopOpeBRepDS_HDataStructure.cxx
===================================================================
--- oce.orig/src/TopOpeBRepDS/TopOpeBRepDS_HDataStructure.cxx
+++ oce/src/TopOpeBRepDS/TopOpeBRepDS_HDataStructure.cxx
@@ -763,7 +763,9 @@ void TopOpeBRepDS_HDataStructure::StoreI
   // append I to list LI
   LI.Append(I);
 
+#ifdef DEB
   Standard_Boolean appendtoG = Standard_False;
+#endif
   Standard_Integer G = I->Geometry();
 
   // append I to list of interference connected to G = I->Geometry()
@@ -776,12 +778,16 @@ void TopOpeBRepDS_HDataStructure::StoreI
     break;
     
   case TopOpeBRepDS_SURFACE :
+#ifdef DEB
     appendtoG = Standard_True;
+#endif
     myDS.ChangeSurfaceInterferences(G).Append(I);
     break;
     
   case TopOpeBRepDS_CURVE :
+#ifdef DEB
     appendtoG = Standard_True;
+#endif
     myDS.ChangeCurveInterferences(G).Append(I);
     break;
     
Index: oce/src/TopOpeBRepDS/TopOpeBRepDS_ProcessEdgeInterferences.cxx
===================================================================
--- oce.orig/src/TopOpeBRepDS/TopOpeBRepDS_ProcessEdgeInterferences.cxx
+++ oce/src/TopOpeBRepDS/TopOpeBRepDS_ProcessEdgeInterferences.cxx
@@ -106,14 +106,13 @@ static Standard_Boolean FUN_keepEinterfe
   //  Standard_Boolean k4I = (((shab == TopAbs_FACE) && (stab == TopAbs_OUT)) &&
 //		((shaa == TopAbs_FACE) && (staa == TopAbs_OUT))); 
 #endif
-    Standard_Boolean k4C = Standard_False;
     {
       TopoDS_Vertex Vf,Vr; TopExp::Vertices(TopoDS::Edge(E),Vf,Vr);
       TopTools_ListIteratorOfListOfShape it(DS.ShapeSameDomain(VG));
       for (; it.More(); it.Next()) {
 	const TopoDS_Shape& Vsd = it.Value();
-	if      ( Vsd.IsSame(Vf) ) { k4C = Standard_True; break; }
-	else if ( Vsd.IsSame(Vr) ) { k4C = Standard_True; break; }
+	if      ( Vsd.IsSame(Vf) ) { break; }
+	else if ( Vsd.IsSame(Vr) ) { break; }
       }
     }
 #ifdef DEB
Index: oce/src/TopOpeBRepDS/TopOpeBRepDS_ProcessFaceInterferences.cxx
===================================================================
--- oce.orig/src/TopOpeBRepDS/TopOpeBRepDS_ProcessFaceInterferences.cxx
+++ oce/src/TopOpeBRepDS/TopOpeBRepDS_ProcessFaceInterferences.cxx
@@ -294,10 +294,6 @@ Standard_EXPORT void FUN_resolveFUNKNOWN
 
     const TopoDS_Face& FS = TopoDS::Face(BDS.Shape(S1));
 
-    Standard_Boolean isclosedFF = BRep_Tool::IsClosed(EE,FF);
-    Standard_Boolean isclosedFS = BRep_Tool::IsClosed(EE,FS);
-    Standard_Boolean go = Standard_True;
-    go = (isclosedFF || isclosedFS);
 //    if (!go) continue;
 
     // la face FF transitionne par la transition T1.IsUnknown()
Index: oce/src/TopOpeBRepTool/TopOpeBRepTool_REGUS.cxx
===================================================================
--- oce.orig/src/TopOpeBRepTool/TopOpeBRepTool_REGUS.cxx
+++ oce/src/TopOpeBRepTool/TopOpeBRepTool_REGUS.cxx
@@ -710,9 +710,6 @@ Standard_Boolean TopOpeBRepTool_REGUS::N
   Standard_Real tola = Precision::Angular()*1.e3; //gp_Dir xapp,yapp; Standard_Boolean refapp = Standard_False;
   gp_Dir x,y; Standard_Boolean ok = ::FUN_vectors(fref,e,pare,y,x,tola,Standard_False);
   if (!ok) {FUN_Raise(); return Standard_False;}
-#ifdef DEB
-  gp_Dir z = x^y;    
-#endif
   
   // initializing
   // ------------
Index: oce/src/TopOpeBRepTool/TopOpeBRepTool_ShapeTool.cxx
===================================================================
--- oce.orig/src/TopOpeBRepTool/TopOpeBRepTool_ShapeTool.cxx
+++ oce/src/TopOpeBRepTool/TopOpeBRepTool_ShapeTool.cxx
@@ -312,9 +312,6 @@ Standard_Real TopOpeBRepTool_ShapeTool::
 
   Standard_Real Ufirst,Ulast,Vfirst,Vlast;
   Surf->Bounds(Ufirst,Ulast,Vfirst,Vlast);
-  Standard_Real Uperiod = 0., Vperiod = 0.;
-  if (isUperio) Uperiod = Ulast - Ufirst;
-  if (isVperio) Vperiod = Vlast - Vfirst;
 
   Standard_Real first,last,tolpc;
   const Handle(Geom2d_Curve) PC = FC2D_CurveOnSurface(E,F,first,last,tolpc);
Index: oce/src/TopOpeBRepTool/TopOpeBRepTool_TOOL.cxx
===================================================================
--- oce.orig/src/TopOpeBRepTool/TopOpeBRepTool_TOOL.cxx
+++ oce/src/TopOpeBRepTool/TopOpeBRepTool_TOOL.cxx
@@ -512,7 +512,6 @@ Standard_Boolean TopOpeBRepTool_TOOL::Tg
 
   if ((!inbounds) && (!onf) && (!onl)) return Standard_False;
   Standard_Real thepar = par;
-//  if (apoles && (onf || onl)) thepar = onf ? (thepar+tolp) : (thepar-tolp);
 
   gp_Pnt thepnt; BC.D1(thepar, thepnt, Tg);
   Tg.Normalize(); 
Index: oce/src/Transfer/Transfer_TransferInput.cxx
===================================================================
--- oce.orig/src/Transfer/Transfer_TransferInput.cxx
+++ oce/src/Transfer/Transfer_TransferInput.cxx
@@ -39,9 +39,7 @@ Transfer_TransferInput::Transfer_Transfe
 // Vrai resultat : doit etre transient (simple ou liste)
     DeclareAndCast(Transfer_SimpleBinderOfTransient,transb,binder);
     DeclareAndCast(Transfer_MultipleBinder,multi,binder);
-    Standard_Boolean OK = Standard_False;
     if (!transb.IsNull()) {
-      OK = Standard_True;
       if (transb->HasResult()) iter.AddItem(transb->Result());
     }
     else if (!multi.IsNull()) {
Index: oce/src/Transfer/Transfer_TransferProcess.gxx
===================================================================
--- oce.orig/src/Transfer/Transfer_TransferProcess.gxx
+++ oce/src/Transfer/Transfer_TransferProcess.gxx
@@ -1249,7 +1249,7 @@ void Transfer_TransferProcess::StartTrac
 
   if (!binder.IsNull()) {   // old: if IsNull sout <<endl<< "  ---  Not Bound";
     Handle(Transfer_Binder) bnd = binder;
-    Standard_Boolean hasres = Standard_False, isused = Standard_False;
+    Standard_Boolean hasres = Standard_False;
     while (!bnd.IsNull()) {
       if (bnd->Status() != Transfer_StatusVoid) {
 // ---  Result Type: binder->ResultType()  ---  Binder : binder->DynamicType();
@@ -1263,7 +1263,6 @@ void Transfer_TransferProcess::StartTrac
           Msg2075.AddString(bnd->ResultTypeName());
           Msg2075.TraceEver();  */
 	hasres = Standard_True;
-	if (bnd->Status() == Transfer_StatusUsed) isused = Standard_True;
       }
       bnd = bnd->NextResult();
     }
Index: oce/src/Units/Units_Sentence.cxx
===================================================================
--- oce.orig/src/Units/Units_Sentence.cxx
+++ oce/src/Units/Units_Sentence.cxx
@@ -53,9 +53,7 @@ Units_Sentence::Units_Sentence(const Han
 			       const Standard_CString astring)
 {
   Standard_Integer index;
-  Standard_Integer k,l;
   Standard_Size i,limchain;
-  char chain[255];
   Handle(Units_Token) token;
   Handle(Units_Token) referencetoken;
   
@@ -63,10 +61,6 @@ Units_Sentence::Units_Sentence(const Han
   Handle(Units_TokensSequence) lstlexicon=alexicon->Sequence();
   Units_NoSuchType_Raise_if(lstlexicon.IsNull(),"BAD LEXICON descriptor");
   limchain=strlen(astring);
-  k=0;
-  for(l=0; l<255; l++) {
-    chain[l]=0;
-  }
   i=0;
 
   TCollection_AsciiString tmpstr = astring;
@@ -125,45 +119,6 @@ Units_Sentence::Units_Sentence(const Han
     i = i + LastWord.Length();
     tmpstr.Remove(1,LastWord.Length());
   }
-
-//  for(i=1; i<=thesequenceoftokens->Length(); i++) {
-//    token = thesequenceoftokens->Value(i);
-//    cout<<"i="<<i<<"  token:  "<<token->Word().ToCString()<<"   "<<token->Mean().ToCString()
-//      <<"   "<<token->Value()<<endl;
-//  }
-
-/*
-  while(i < limchain) {
-    Standard_Integer itrouv=0;
-    for(index=1; index<=lstlexicon->Length(); index++) {
-      referencetoken = lstlexicon->Value(index);
-      if(i+referencetoken->Length() <= limchain) {
-        if(referencetoken <= &astring[i]) {
-          if(k) {
-            token = new Units_Token(chain,"0");
-            thesequenceoftokens->Append(token);
-            k=0;
-            for(l=0; l<255; l++) {
-              chain[l]=0;
-            }
-          }
-          token = referencetoken->Creates();
-          thesequenceoftokens->Append(token);
-          i = i + token->Length();
-          itrouv=1;
-          break;
-        }
-      }
-    }
-    if(!itrouv) {
-      chain[k++]=astring[i++];
-    }
-  }
-  if(k) {
-    token = new Units_Token(chain, "0");
-    thesequenceoftokens->Append(token);
-  }
-*/
 }
 
 
Index: oce/src/V3d/V3d_PerspectiveView.cxx
===================================================================
--- oce.orig/src/V3d/V3d_PerspectiveView.cxx
+++ oce/src/V3d/V3d_PerspectiveView.cxx
@@ -119,13 +119,13 @@ Standard_Real V3d_PerspectiveView::Angle
 void V3d_PerspectiveView::SetPerspective(const Standard_Real Angle, const Standard_Real UVRatio,
                                          const Standard_Real ZNear, const Standard_Real ZFar)
 {
-  Standard_Real Umin,Vmin,Umax,Vmax,Xrp,Yrp,Zrp,du,dv;
+  Standard_Real Umin,Vmin,Umax,Vmax,Yrp,Zrp,du,dv;
 
   V3d_BadValue_Raise_if ( ZNear <= 0. || ZFar <= 0. || ZNear >= ZFar, "V3d_PerspectiveView::SetPerspective, bad distances");
   V3d_BadValue_Raise_if ( Angle <= 0. || Angle >= M_PI, "V3d_PerspectiveView::SetAngle, bad angle");
 
   Graphic3d_Vertex PRP = MyViewMapping.ProjectionReferencePoint() ;
-  Xrp = Yrp = Zrp = 0.;
+  Yrp = Zrp = 0.;
 
   PRP.SetCoord(Zrp, Yrp, Zrp);
   MyViewMapping.SetProjectionReferencePoint(PRP);
Index: oce/src/ViewerTest/ViewerTest_FilletCommands.cxx
===================================================================
--- oce.orig/src/ViewerTest/ViewerTest_FilletCommands.cxx
+++ oce/src/ViewerTest/ViewerTest_FilletCommands.cxx
@@ -74,10 +74,6 @@ static Standard_Real tapp_angle = 1.e-2;
 static GeomAbs_Shape blend_cont = GeomAbs_C1;
 
 static BRepFilletAPI_MakeFillet* Rakk = 0;
-#ifdef DEB
-static BRepFilletAPI_MakeFillet* Rake = 0;
-static char name[100];
-#endif
 
 
 static void printtolblend(Draw_Interpretor& di)
Index: oce/src/ViewerTest/ViewerTest_ObjectCommands.cxx
===================================================================
--- oce.orig/src/ViewerTest/ViewerTest_ObjectCommands.cxx
+++ oce/src/ViewerTest/ViewerTest_ObjectCommands.cxx
@@ -2582,7 +2582,6 @@ Handle( Poly_Triangulation ) Calculation
 
   int i, j;
   int jStart, jEnd, numOffset;
-  int numPts, numPolys;
   double x[3], n[3], deltaPhi, deltaTheta, phi, theta, radius;
   double startTheta, endTheta, startPhi, endPhi;
   int base, numPoles=0, thetaResolution, phiResolution;
@@ -2612,9 +2611,6 @@ Handle( Poly_Triangulation ) Calculation
   localStartTheta = localStartTheta + (double)(start) * deltaTheta;
   localThetaResolution = end - start;
 
-  numPts =  mPhiResolution * localThetaResolution + 2;
-  numPolys =  mPhiResolution * 2 * localThetaResolution;
-
   // Create north pole if needed
   int number_point = 0;
   int number_pointArray = 0;
Index: oce/src/ViewerTest/ViewerTest_RelationCommands.cxx
===================================================================
--- oce.orig/src/ViewerTest/ViewerTest_RelationCommands.cxx
+++ oce/src/ViewerTest/ViewerTest_RelationCommands.cxx
@@ -1454,10 +1454,6 @@ static int VLenghtDimension(Draw_Interpr
       // On recupere les deux vertexes extremites de l'edge de face B
       TopoDS_Vertex  Vb,Vc;
       TopExp::Vertices(EdFromB,Vb,Vc);
-#ifdef DEB
-      gp_Pnt B=
-#endif
-               BRep_Tool::Pnt(Vb);
       gp_Pnt C=BRep_Tool::Pnt(Vc);
       
       // On projette le point B sur la Face car il 
Index: oce/src/Visual3d/Visual3d_ViewManager.cxx
===================================================================
--- oce.orig/src/Visual3d/Visual3d_ViewManager.cxx
+++ oce/src/Visual3d/Visual3d_ViewManager.cxx
@@ -661,14 +661,9 @@ TColStd_Array2OfReal TMap_Matrix_Inv (0,
 
 Standard_Real Dx, Dy, Ratio;
 Visual3d_SetIteratorOfSetOfView MyIterator(MyDefinedView);
-Standard_Integer j;
 
 Standard_Integer stop = 0;
 
-Standard_Boolean BResult;
-
-		j = MyDefinedView.Extent ();
-
 		while ((! stop) && (MyIterator.More ())) {
 		    if (TheCView.ViewId ==
 			(MyIterator.Value ())->Identification ()) {
@@ -684,10 +679,10 @@ Standard_Boolean BResult;
 		}
 
 		// View Mapping Transformation and View Clip, inversion
-		BResult = Aspect::Inverse (TMap_Matrix, TMap_Matrix_Inv);
+		Aspect::Inverse (TMap_Matrix, TMap_Matrix_Inv);
 
 		// View Orientation Transformation, inversion
-		BResult = Aspect::Inverse (TOri_Matrix, TOri_Matrix_Inv);
+		Aspect::Inverse (TOri_Matrix, TOri_Matrix_Inv);
 
 		// (AU, AV) : Device Coordinate Space
 		// DCS -> NPCS Normalized Projection Coordinate Space
@@ -798,14 +793,9 @@ TColStd_Array2OfReal TMap_Matrix_Inv (0,
 
 Standard_Real Dx, Dy, Ratio;
 Visual3d_SetIteratorOfSetOfView MyIterator(MyDefinedView);
-Standard_Integer j;
 
 Standard_Integer stop = 0;
 
-Standard_Boolean BResult;
-
-		j = MyDefinedView.Extent ();
-
 		while ((! stop) && (MyIterator.More ())) {
 		    if (TheCView.ViewId ==
 			(MyIterator.Value ())->Identification ()) {
@@ -821,10 +811,10 @@ Standard_Boolean BResult;
 		}
 
 		// View Mapping Transformation and View Clip, inversion
-		BResult = Aspect::Inverse (TMap_Matrix, TMap_Matrix_Inv);
+		Aspect::Inverse (TMap_Matrix, TMap_Matrix_Inv);
 
 		// View Orientation Transformation, inversion
-		BResult = Aspect::Inverse (TOri_Matrix, TOri_Matrix_Inv);
+		Aspect::Inverse (TOri_Matrix, TOri_Matrix_Inv);
 
 		// (AU, AV) : Device Coordinate Space
 		// DCS -> NPCS Normalized Projection Coordinate Space
Index: oce/src/math/math_BracketedRoot.cxx
===================================================================
--- oce.orig/src/math/math_BracketedRoot.cxx
+++ oce/src/math/math_BracketedRoot.cxx
@@ -28,12 +28,11 @@ math_BracketedRoot::math_BracketedRoot (
 
     Standard_Real Fa,Fc,a,c=0,d=0,e=0;
     Standard_Real min1,min2,p,q,r,s,tol1,xm;
-    Standard_Boolean Ok;
   
     a = Bound1;
     TheRoot = Bound2;
-    Ok = F.Value(a,Fa);
-    Ok = F.Value(TheRoot,TheError);
+    F.Value(a,Fa);
+    F.Value(TheRoot,TheError);
     if (Fa*TheError > 0.) { Done = Standard_False;}
     else {
       Fc = TheError ;
@@ -95,7 +94,7 @@ math_BracketedRoot::math_BracketedRoot (
           else {
              TheRoot += (xm > 0. ? Abs(tol1) : -Abs(tol1));
           }
-          Ok = F.Value(TheRoot,TheError);
+          F.Value(TheRoot,TheError);
       }  
      Done = Standard_False;
     }  
Index: oce/src/math/math_FunctionAllRoots.cxx
===================================================================
--- oce.orig/src/math/math_FunctionAllRoots.cxx
+++ oce/src/math/math_FunctionAllRoots.cxx
@@ -40,11 +40,11 @@ math_FunctionAllRoots::math_FunctionAllR
     Standard_Real DebNul,FinNul;
     Standard_Integer Indd,Indf;
     Standard_Real cst,val,valsav=0,valbid;
-    Standard_Boolean bid,fini;
+    Standard_Boolean fini;
     Standard_Integer Nbp,i;
 
     Nbp=S.NbPoints();
-    bid=F.Value(S.GetParameter(1),val);
+    F.Value(S.GetParameter(1),val);
     PNul=Abs(val)<=EpsNul;
     if (!PNul) {valsav=val;}
     InterNul=Standard_False;
@@ -56,7 +56,7 @@ math_FunctionAllRoots::math_FunctionAllR
 
     while (!fini) {
 
-      bid=F.Value(S.GetParameter(i),val);
+      F.Value(S.GetParameter(i),val);
       Nul=Abs(val)<=EpsNul;
       if (!Nul) {
 	valsav=val;
@@ -100,7 +100,7 @@ math_FunctionAllRoots::math_FunctionAllR
 	InterNul=Standard_True;
 	if (i==2) {
 	  DebNul=S.GetParameter(1);
-	  bid = F.Value(DebNul,valbid);
+	  F.Value(DebNul,valbid);
 	  Indd = F.GetStateNumber();
 	  Nuld=Standard_True;
 	}
@@ -142,7 +142,7 @@ math_FunctionAllRoots::math_FunctionAllR
       pdeb.Append(DebNul);
       ideb.Append(Indd);
       FinNul = S.GetParameter(Nbp);
-      bid = F.Value(FinNul,valbid);
+      F.Value(FinNul,valbid);
       Indf = F.GetStateNumber();
       pfin.Append(FinNul);
       ifin.Append(Indf);
Index: oce/src/math/math_FunctionRoot.cxx
===================================================================
--- oce.orig/src/math/math_FunctionRoot.cxx
+++ oce/src/math/math_FunctionRoot.cxx
@@ -72,7 +72,6 @@ class math_MyFunctionSetWithDerivatives
                                         const Standard_Real Guess, 
                                         const Standard_Real Tolerance, 
                                         const Standard_Integer NbIterations ){
-     Standard_Boolean Ok;
      math_Vector V(1,1), Tol(1,1);
      math_MyFunctionSetWithDerivatives Ff(F);
      V(1)=Guess;
@@ -83,7 +82,7 @@ class math_MyFunctionSetWithDerivatives
        F.GetStateNumber();
        TheRoot = Sol.Root()(1);
        TheDerivative = Sol.Derivative()(1,1);
-       Ok = F.Value(TheRoot,TheError);
+       F.Value(TheRoot,TheError);
        NbIter = Sol.NbIterations();
      }       
    }
@@ -93,7 +92,6 @@ class math_MyFunctionSetWithDerivatives
                                         const Standard_Real A,
                                         const Standard_Real B,
                                         const Standard_Integer NbIterations ){
-     Standard_Boolean Ok;
      math_Vector V(1,1),Aa(1,1),Bb(1,1), Tol(1,1);
      math_MyFunctionSetWithDerivatives Ff(F);
      V(1)=Guess;
@@ -106,7 +104,7 @@ class math_MyFunctionSetWithDerivatives
        F.GetStateNumber();
        TheRoot = Sol.Root()(1);
        TheDerivative = Sol.Derivative()(1,1);
-       Ok = F.Value(TheRoot,TheError);
+       F.Value(TheRoot,TheError);
        NbIter = Sol.NbIterations();
      }
    }
Index: oce/src/math/math_Powell.cxx
===================================================================
--- oce.orig/src/math/math_Powell.cxx
+++ oce/src/math/math_Powell.cxx
@@ -112,7 +112,6 @@ void math_Powell::Perform(math_MultipleV
 
 
   Done = Standard_False;
-  Standard_Boolean Ok;
   Standard_Integer i, ibig, j;
   Standard_Real t, fptt, del;
   Standard_Integer n = TheLocation.Length();
@@ -130,12 +129,12 @@ void math_Powell::Perform(math_MultipleV
 
 
   for(Iter = 1; Iter<= Itermax; Iter++) {
-    Ok = F.Value(TheLocation, PreviousMinimum);
+    F.Value(TheLocation, PreviousMinimum);
     ibig = 0;
     del = 0.0;
     for (i = 1; i <= n; i++){
       for(j =1; j<= n; j++) xit(j) = TheDirections(j,i);
-      Ok = F.Value(TheLocation, fptt); 
+      F.Value(TheLocation, fptt); 
       Standard_Boolean IsGood = MinimizeDirection(TheLocation, xit, 
 					 TheMinimum, F_Dir);
 
@@ -171,7 +170,7 @@ void math_Powell::Perform(math_MultipleV
     
     // Valeur de la fonction au point extrapole:
 
-    Ok = F.Value(ptt, fptt);
+    F.Value(ptt, fptt);
 
     if (fptt < PreviousMinimum) {
       t = 2.0 *(PreviousMinimum -2.0*TheMinimum +fptt)*
Index: oce/src/math/math_Recipes.cxx
===================================================================
--- oce.orig/src/math/math_Recipes.cxx
+++ oce/src/math/math_Recipes.cxx
@@ -662,11 +662,9 @@ Standard_Integer DACTCL_Solve(const math
      Standard_Integer jr, jd, jh, is, k, id;
      Standard_Integer jh1, idot, idot1, idot2;
      Standard_Real aa, d, dot;
-     Standard_Boolean diag;
 
      jr = 0;
      for (j = 1; j <= Neq; j++) {
-       diag = Standard_False;
        jd = indx(j);
        jh = jd-jr;
        is = j-jh+2;
Index: oce/src/math/math_TrigonometricFunctionRoots.cxx
===================================================================
--- oce.orig/src/math/math_TrigonometricFunctionRoots.cxx
+++ oce/src/math/math_TrigonometricFunctionRoots.cxx
@@ -132,7 +132,7 @@ void math_TrigonometricFunctionRoots::Pe
   Standard_Real Teta, X;
   Standard_Real Eps, Tol1 = 1.e-15;
   TColStd_Array1OfReal ko(1,5), Zer(1,4);
-  Standard_Boolean Flag3, Flag4;
+  Standard_Boolean Flag4;
   InfiniteStatus = Standard_False;
   Done = Standard_True;
 
@@ -345,7 +345,6 @@ void math_TrigonometricFunctionRoots::Pe
     X = Teta -MyBorneInf;
     if ((X >= (-Epsilon(Delta))) && (X <= Delta+ Epsilon(Delta))) {
       X = Teta;
-      Flag3 = Standard_False;
 
       // Appel de Newton:
       //OCC541(apo):  Standard_Real TetaNewton=0;  
