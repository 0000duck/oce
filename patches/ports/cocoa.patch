From a8c5f1927698ddfd76128d8a443fdb822412f9e3 Mon Sep 17 00:00:00 2001
From: bugmaster <bugmaster@opencascade.com>
Date: Mon, 24 Dec 2012 17:46:07 +0400
Subject: [PATCH 1/6] [OCCT] 0023243: Adapt OpenGL viewer for using in Cocoa
 applications on Mac OS X

Cocoa_Window draft
OpenGl_Context and OpenGl_Window - added support for Cocoa OpenGL context
TKV3d - accept Cocoa_Window
Draft version of ViewerInit method for Mac OS X
Added ViewerTest_CocoaEventManagerView
ViewerTest - attach events to Cocoa window
Cocoa_Window - disable autorelease on close
Fix for OpenGl_Context::Init method
Cocoa_Window - convert top-left coordinates to bottom-left
Added selection with rubber band (rubber band drawing still should be implemented)
Fixed OpenGl_Display initialization on Mac OS X
Fixed OpenGl includes

  Cherry-picked from
    http://git.dev.opencascade.org/gitweb/?p=occt.git;a=commit;h=4fe5661
  Conflicts resolved in the following files:
    src/OpenGl/OpenGl_Display.cxx
    src/OpenGl/OpenGl_Display_1.cxx
    src/OpenGl/OpenGl_Workspace_2.cxx
    src/TKService/EXTERNLIB
    src/ViewerTest/ViewerTest_ViewerCommands.cxx
---
 adm/UDLIST                                    |    1 +
 inc/Cocoa_LocalPool.hxx                       |   36 ++
 inc/Cocoa_Window.hxx                          |  234 ++++++++++
 inc/InterfaceGraphic.hxx                      |   12 +-
 inc/InterfaceGraphic_Cocoa.hxx                |   40 ++
 inc/OpenGl_Context.hxx                        |    4 +
 inc/OpenGl_GlCore11.hxx                       |    3 -
 src/Cocoa/Cocoa_LocalPool.mm                  |   45 ++
 src/Cocoa/Cocoa_Window.mm                     |  607 +++++++++++++++++++++++++
 src/Cocoa/EXTERNLIB                           |    3 +
 src/Cocoa/FILES                               |    4 +
 src/InterfaceGraphic/FILES                    |    1 +
 src/OpenGl/EXTERNLIB                          |    3 +
 src/OpenGl/FILES                              |    2 +
 src/OpenGl/OpenGl_Context.cxx                 |   20 +-
 src/OpenGl/OpenGl_Context_1.mm                |   90 ++++
 src/OpenGl/OpenGl_Display.cxx                 |   10 +-
 src/OpenGl/OpenGl_Display_1.cxx               |   33 +-
 src/OpenGl/OpenGl_Window.cxx                  |   13 +-
 src/OpenGl/OpenGl_Window_1.mm                 |  160 +++++++
 src/OpenGl/OpenGl_Workspace_2.cxx             |   46 +-
 src/TKOpenGl/EXTERNLIB                        |    3 +
 src/TKService/EXTERNLIB                       |    3 +
 src/TKService/PACKAGES                        |    2 +
 src/TKViewerTest/EXTERNLIB                    |    3 +
 src/ViewerTest/EXTERNLIB                      |    3 +
 src/ViewerTest/FILES                          |    2 +
 src/ViewerTest/ViewerTest_ViewerCommands.cxx  |  434 ++++++++++--------
 src/ViewerTest/ViewerTest_ViewerCommands_1.mm |  247 ++++++++++
 src/Visual3d/Visual3d_View.cxx                |   48 +-
 30 files changed, 1831 insertions(+), 281 deletions(-)
 create mode 100644 inc/Cocoa_LocalPool.hxx
 create mode 100644 inc/Cocoa_Window.hxx
 create mode 100755 inc/InterfaceGraphic_Cocoa.hxx
 create mode 100644 src/Cocoa/Cocoa_LocalPool.mm
 create mode 100644 src/Cocoa/Cocoa_Window.mm
 create mode 100755 src/Cocoa/EXTERNLIB
 create mode 100755 src/Cocoa/FILES
 create mode 100644 src/OpenGl/OpenGl_Context_1.mm
 create mode 100644 src/OpenGl/OpenGl_Window_1.mm
 create mode 100755 src/ViewerTest/EXTERNLIB
 create mode 100644 src/ViewerTest/ViewerTest_ViewerCommands_1.mm

From 54fd902e6849ac4140fa5c4b5f9f6a2334c3b482 Mon Sep 17 00:00:00 2001
From: dbv <dbv@opencascade.com>
Date: Fri, 18 Jan 2013 15:04:50 +0400
Subject: [PATCH 2/6] [OCCT] 0023682: Implement Draw_Window with Cocoa
 framework

Implemented most Draw_Window functions with Cocoa. Still should be implemented: drawing rectangle when zooming, window screenshot function in QAxwd
Added workaround for drawing rectangle when zooming
Added small fixes

  Cherry-picked from
    http://git.dev.opencascade.org/gitweb/?p=occt.git;a=commit;h=67d97f0
  Conflicts resolved in:
    src/Draw/Draw_Window.cxx
    src/Draw/EXTERNLIB
    src/TKDraw/EXTERNLIB
---
 inc/Draw_Window.hxx       |  129 +++++++++-
 src/Draw/Draw_Viewer.cxx  |   59 ++++-
 src/Draw/Draw_Window.cxx  |  106 ++++----
 src/Draw/Draw_Window_1.mm |  612 +++++++++++++++++++++++++++++++++++++++++++++
 src/Draw/EXTERNLIB        |    4 +-
 src/Draw/FILES            |    1 +
 src/TKDraw/EXTERNLIB      |    3 +
 7 files changed, 853 insertions(+), 61 deletions(-)
 create mode 100644 src/Draw/Draw_Window_1.mm

From 189f64c540a6bc985b80d742018e1d55ce700c87 Mon Sep 17 00:00:00 2001
From: tpaviot <tpaviot@gmail.com>
Date: Thu, 28 Feb 2013 14:34:20 +0100
Subject: [PATCH 3/6] Updated CMake files to support Cocoa on OSX

A flag OCE_OSX_USE_COCOA was added, enabled by default. This
makes OCE use native Cocoa OpenGl implementation as well as
the Tcl/Tk Cocoa provided with OSX/XCode.

This flag should be set to OFF if ever OSX users still need X11 backend.
---
 CMakeLists.txt                     |   36 ++++++++++++++++++++++--------------
 adm/cmake/BuildToolkit.cmake       |   11 ++++++++++-
 adm/cmake/TKService/CMakeLists.txt |   20 ++++++++++++++------
 oce_build_config.h.cmake           |    2 ++
 oce_install_config.h.cmake         |    3 +++
 5 files changed, 51 insertions(+), 21 deletions(-)

From 94b28877319ee85fecb522da787a782fd161c055 Mon Sep 17 00:00:00 2001
From: tpaviot <tpaviot@gmail.com>
Date: Thu, 28 Feb 2013 14:50:28 +0100
Subject: [PATCH 4/6] Modified headers/source files to handle the
 MACOSX_USE_GLX option

---
 inc/InterfaceGraphic.hxx                      |    6 +++++-
 inc/OpenGl_GlCore11.hxx                       |   15 ++++++++++++---
 inc/OpenGl_GlCore12.hxx                       |   12 ++++++++++++
 src/NIS/NIS_DrawList.cxx                      |    3 ++-
 src/NIS/NIS_SurfaceDrawer.cxx                 |    3 ++-
 src/NIS/NIS_TriangulatedDrawer.cxx            |    3 ++-
 src/NIS/NIS_View.cxx                          |    3 ++-
 src/OpenGl/OpenGl_FontMgr.cxx                 |    2 +-
 src/OpenGl/OpenGl_GraduatedTrihedron.cxx      |    1 -
 src/OpenGl/OpenGl_GraphicDriver_Layer.cxx     |    1 -
 src/OpenGl/OpenGl_Polygon.cxx                 |    1 -
 src/OpenGl/OpenGl_Text.cxx                    |    1 -
 src/OpenGl/OpenGl_TextureBox.cxx              |    1 -
 src/OpenGl/OpenGl_Trihedron.cxx               |    1 -
 src/OpenGl/OpenGl_View.cxx                    |    1 -
 src/OpenGl/OpenGl_View_1.cxx                  |    1 -
 src/OpenGl/OpenGl_View_2.cxx                  |    1 -
 src/OpenGl/OpenGl_Window.cxx                  |    1 -
 src/OpenGl/OpenGl_Workspace_2.cxx             |    1 -
 src/ViewerTest/ViewerTest_ViewerCommands_1.mm |    4 ++++
 src/Visual3d/Visual3d_View.cxx                |    4 ++++
 21 files changed, 46 insertions(+), 20 deletions(-)
 mode change 100755 => 100644 inc/InterfaceGraphic_Cocoa.hxx

From bd5a00034dfe9ddc35786f71dc6fe399400ae441 Mon Sep 17 00:00:00 2001
From: tpaviot <tpaviot@gmail.com>
Date: Fri, 1 Mar 2013 15:31:55 +0100
Subject: [PATCH 5/6] Removed X specific (and unuseful) code causing OSX
 compilation issues when OCE_OSX_USE_COCOA is enabled.

---
 src/QADraw/QADraw.cxx                            |    5 +++++
 src/Viewer2dTest/Viewer2dTest_ViewerCommands.cxx |   10 ++++++++++
 2 files changed, 15 insertions(+)

From 499521576387ec99e916214bc55d70a9313ac01f Mon Sep 17 00:00:00 2001
From: tpaviot <tpaviot@gmail.com>
Date: Sat, 2 Mar 2013 10:39:34 +0100
Subject: [PATCH 6/6] [clang-warning-fix][extra-token]

In file included from [...]/oce/inc/InterfaceGraphic.hxx:29:
[...]/oce/inc/InterfaceGraphic_Cocoa.hxx:38:8: warning: extra
      tokens at end of #endif directive [-Wextra-tokens]
endif InterfaceGraphic_CocoaHeader
---
 inc/InterfaceGraphic_Cocoa.hxx |    2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

Index: oce/adm/UDLIST
===================================================================
--- oce.orig/adm/UDLIST
+++ oce/adm/UDLIST
@@ -241,6 +241,7 @@ p Visual3d
 p Voxel
 p WNT
 p Xw
+p Cocoa
 r FontMFT
 r Textures
 t TKMeshVS
Index: oce/inc/Cocoa_LocalPool.hxx
===================================================================
--- /dev/null
+++ oce/inc/Cocoa_LocalPool.hxx
@@ -0,0 +1,36 @@
+// Copyright (c) 2012 OPEN CASCADE SAS
+//
+// The content of this file is subject to the Open CASCADE Technology Public
+// License Version 6.5 (the "License"). You may not use the content of this file
+// except in compliance with the License. Please obtain a copy of the License
+// at http://www.opencascade.org and read it completely before using this file.
+//
+// The Initial Developer of the Original Code is Open CASCADE S.A.S., having its
+// main offices at: 1, place des Freres Montgolfier, 78280 Guyancourt, France.
+//
+// The Original Code and all software distributed under the License is
+// distributed on an "AS IS" basis, without warranty of any kind, and the
+// Initial Developer hereby disclaims all such warranties, including without
+// limitation, any warranties of merchantability, fitness for a particular
+// purpose or non-infringement. Please see the License for the specific terms
+// and conditions governing the rights and limitations under the License.
+
+#ifndef __Cocoa_LocalPool_h_
+#define __Cocoa_LocalPool_h_
+
+//! Auxiliary class to create
+class Cocoa_LocalPool
+{
+
+public:
+
+  Cocoa_LocalPool();
+  ~Cocoa_LocalPool();
+
+private:
+
+  void* myPoolObj;
+
+};
+
+#endif // __Cocoa_LocalPool_h_
Index: oce/inc/Cocoa_Window.hxx
===================================================================
--- /dev/null
+++ oce/inc/Cocoa_Window.hxx
@@ -0,0 +1,234 @@
+// Created on: 2012-11-12
+// Created by: Kirill GAVRILOV
+// Copyright (c) 2012 OPEN CASCADE SAS
+//
+// The content of this file is subject to the Open CASCADE Technology Public
+// License Version 65 (the "License") You may not use the content of this file
+// except in compliance with the License Please obtain a copy of the License
+// at http://wwwopencascadeorg and read it completely before using this file
+//
+// The Initial Developer of the Original Code is Open CASCADE SAS, having its
+// main offices at: 1, place des Freres Montgolfier, 78280 Guyancourt, France
+//
+// The Original Code and all software distributed under the License is
+// distributed on an "AS IS" basis, without warranty of any kind, and the
+// Initial Developer hereby disclaims all such warranties, including without
+// limitation, any warranties of merchantability, fitness for a particular
+// purpose or non-infringement Please see the License for the specific terms
+// and conditions governing the rights and limitations under the License
+
+#ifndef _Cocoa_Window_H__
+#define _Cocoa_Window_H__
+
+#ifdef __OBJC__
+  @class NSView;
+  @class NSWindow;
+#else
+  struct NSView;
+  struct NSWindow;
+#endif
+
+#include <Aspect_Window.hxx>
+
+#include <Standard.hxx>
+#include <Standard_DefineHandle.hxx>
+
+#include <Aspect_FillMethod.hxx>
+#include <Aspect_GradientFillMethod.hxx>
+#include <Aspect_Handle.hxx>
+#include <Aspect_TypeOfResize.hxx>
+#include <Quantity_NameOfColor.hxx>
+#include <Quantity_Parameter.hxx>
+#include <Quantity_Ratio.hxx>
+
+class Aspect_WindowDefinitionError;
+class Aspect_WindowError;
+class Aspect_Background;
+class Quantity_Color;
+class Aspect_GradientBackground;
+
+//! This class defines Cocoa window
+class Cocoa_Window : public Aspect_Window
+{
+
+public:
+
+  //! Creates a NSWindow and NSView defined by his position and size in pixels
+  Standard_EXPORT Cocoa_Window (const Standard_CString theTitle,
+                                const Standard_Integer thePxLeft,
+                                const Standard_Integer thePxTop,
+                                const Standard_Integer thePxWidth,
+                                const Standard_Integer thePxHeight);
+
+  //! Creates a wrapper over existing NSView handle
+  Standard_EXPORT Cocoa_Window (NSView* theViewNS);
+
+  //! Destroies the Window and all resourses attached to it
+  Standard_EXPORT virtual  void Destroy();
+
+  ~Cocoa_Window()
+  {
+    Destroy();
+  }
+
+  //! Modifies the window background
+  Standard_EXPORT virtual void SetBackground (const Aspect_Background& theBackground);
+
+  //! Modifies the window background
+  Standard_EXPORT virtual void SetBackground (const Quantity_NameOfColor theBackColor);
+
+  //! Modifies the window background
+  Standard_EXPORT virtual void SetBackground (const Quantity_Color& theColor);
+
+  //! Modifies the window background
+  Standard_EXPORT void SetBackground (const Aspect_Handle theBackPixmap);
+
+  //! Loads the window background from an image file
+  Standard_EXPORT Standard_Boolean SetBackground (const Standard_CString  theName,
+                                                  const Aspect_FillMethod theMethod = Aspect_FM_CENTERED);
+
+  //! Modifies the window gradient background
+  Standard_EXPORT virtual void SetBackground (const Aspect_GradientBackground& theBackground);
+
+  //! Modifies the window gradient background
+  Standard_EXPORT void SetBackground (const Quantity_Color& theCol1,
+                                      const Quantity_Color& theCol2,
+                                      const Aspect_GradientFillMethod theMethod = Aspect_GFM_HOR);
+
+  //! Activates/Deactivates the Double Buffering capability for this window
+  Standard_EXPORT virtual void SetDoubleBuffer (const Standard_Boolean theDBmode);
+
+  //! Flushes all graphics to the screen and Swap the Double buffer
+  Standard_EXPORT virtual void Flush() const;
+
+  //! Opens the window <me>
+  Standard_EXPORT virtual void Map() const;
+
+  //! Closes the window <me>
+  Standard_EXPORT virtual void Unmap() const;
+
+  //! Applies the resizing to the window <me>
+  Standard_EXPORT virtual Aspect_TypeOfResize DoResize() const;
+
+  //! Apply the mapping change to the window <me>
+  Standard_EXPORT virtual Standard_Boolean DoMapping() const;
+
+  //! Clears the Window in the Background color
+  Standard_EXPORT virtual void Clear() const;
+
+  //! Clears the Window Area defined by his center and PIXEL size in the Background color
+  Standard_EXPORT virtual void ClearArea (const Standard_Integer theCenterX,
+                                          const Standard_Integer theCenterY,
+                                          const Standard_Integer theWidth,
+                                          const Standard_Integer theHeight) const;
+
+  //! Restores The Window from the BackingStored Window
+  Standard_EXPORT virtual void Restore() const;
+
+  //! Restores The Window Area defined by his center and PIXEL size from the BackingStored Window
+  Standard_EXPORT virtual void RestoreArea (const Standard_Integer theCenterX,
+                                            const Standard_Integer theCenterY,
+                                            const Standard_Integer theWidth,
+                                            const Standard_Integer theHeight) const;
+
+  //! Dumps the Window to file
+  Standard_EXPORT virtual Standard_Boolean Dump (const Standard_CString theFilename,
+                                                 const Standard_Real    theGammaValue = 1.0) const;
+
+  //! Dumps the Window Area defined by his center and PIXEL size to an image file
+  Standard_EXPORT virtual Standard_Boolean DumpArea (const Standard_CString theFilename,
+                                                     const Standard_Integer theCenterX,
+                                                     const Standard_Integer theCenterY,
+                                                     const Standard_Integer theWidth,
+                                                     const Standard_Integer theHeight,
+                                                     const Standard_Real    theGammaValue = 1.0) const;
+
+  //! Loads the image file to this Window
+  //! @return TRUE if the loading occurs normaly
+  Standard_EXPORT virtual Standard_Boolean Load (const Standard_CString theFilename) const;
+
+  //! Loads the image file to Window Area
+  Standard_EXPORT virtual Standard_Boolean LoadArea (const Standard_CString theFilename,
+                                                     const Standard_Integer theCenterX,
+                                                     const Standard_Integer theCenterY,
+                                                     const Standard_Integer theWidth,
+                                                     const Standard_Integer theHeight) const;
+
+  //! Returns the BackingStore capability for this Window
+  Standard_EXPORT virtual Standard_Boolean BackingStore() const;
+
+  //! Returns the DoubleBuffer state
+  Standard_EXPORT virtual Standard_Boolean DoubleBuffer() const;
+
+  //! Returns True if the window <me> is opened
+  Standard_EXPORT virtual Standard_Boolean IsMapped() const;
+
+  //! Returns The Window RATIO equal to the physical WIDTH/HEIGHT dimensions
+  Standard_EXPORT virtual Quantity_Ratio Ratio() const;
+
+  //! Returns The Window POSITION in DSU
+  Standard_EXPORT virtual void Position (Quantity_Parameter& X1,
+                                         Quantity_Parameter& Y1,
+                                         Quantity_Parameter& X2,
+                                         Quantity_Parameter& Y2) const;
+
+  //! Returns The Window POSITION in PIXEL
+  Standard_EXPORT virtual void Position (Standard_Integer& X1,
+                                         Standard_Integer& Y1,
+                                         Standard_Integer& X2,
+                                         Standard_Integer& Y2) const;
+
+  //! Returns The Window SIZE in DSU
+  Standard_EXPORT virtual void Size (Quantity_Parameter& theWidth,
+                                     Quantity_Parameter& theHeight) const;
+
+  //! Returns The Window SIZE in PIXEL
+  Standard_EXPORT virtual void Size (Standard_Integer& theWidth,
+                                     Standard_Integer& theHeight) const;
+
+  //! Returns The Window SIZE in MM
+  Standard_EXPORT virtual void MMSize (Standard_Real& theWidth,
+                                       Standard_Real& theHeight) const;
+
+  //! Returns the DSU value depending of the PIXEL value
+  Standard_EXPORT virtual Quantity_Parameter Convert (const Standard_Integer PV) const;
+
+  //! Returns the PIXEL value depending of the DSU value
+  Standard_EXPORT virtual Standard_Integer Convert (const Quantity_Parameter DV) const;
+
+  //! Returns the DSU position depending of the PIXEL position
+  Standard_EXPORT virtual void Convert (const Standard_Integer PX,
+                                        const Standard_Integer PY,
+                                        Quantity_Parameter&    DX,
+                                        Quantity_Parameter&    DY) const;
+
+  //! Returns the PIXEL position depending of the DSU position
+  Standard_EXPORT virtual void Convert (const Quantity_Parameter DX,
+                                        const Quantity_Parameter DY,
+                                        Standard_Integer&        PX,
+                                        Standard_Integer&        PY) const;
+
+  //! @return associated NSView
+  Standard_EXPORT NSView* HView() const;
+
+  //! Setup new NSView.
+  Standard_EXPORT void SetHView (NSView* theView);
+
+protected:
+
+  NSWindow*        myHWindow;
+  NSView*          myHView;
+  Standard_Integer myXLeft;
+  Standard_Integer myYTop;
+  Standard_Integer myXRight;
+  Standard_Integer myYBottom;
+
+public:
+
+  DEFINE_STANDARD_RTTI(Cocoa_Window)
+
+};
+
+DEFINE_STANDARD_HANDLE(Cocoa_Window, Aspect_Window)
+
+#endif // _Cocoa_Window_H__
Index: oce/inc/Draw_Window.hxx
===================================================================
--- oce.orig/inc/Draw_Window.hxx
+++ oce/inc/Draw_Window.hxx
@@ -25,7 +25,7 @@
 #include <Standard_Boolean.hxx>
 #include <Standard_Integer.hxx>
 
-#ifndef WNT
+#if !defined(_WIN32) && !defined(__WIN32__) && (!defined(__APPLE__) || defined(MACOSX_USE_GLX))
 
 const Standard_Integer MAXCOLOR = 15;
 
@@ -189,7 +189,134 @@ void Destroy_Appli();
 //======================================================
 void GetNextEvent(Event&);
 
+#elif defined(__APPLE__) && !defined(MACOSX_USE_GLX)
+
+const Standard_Integer MAXCOLOR = 15;
+
+struct Segment
+{
+  Standard_Integer myXStart;
+  Standard_Integer myYStart;
+  Standard_Integer myXEnd;
+  Standard_Integer myYEnd;
+
+  void Init(short theXStart, short theYStart, short theXEnd, short theYEnd) {
+    myXStart = theXStart; myYStart = theYStart; myXEnd = theXEnd; myYEnd = theYEnd;
+  }
+
+};
+
+#ifdef __OBJC__
+  @class NSView;
+  @class NSWindow;
+  @class NSImage;
+  @class Draw_CocoaView;
+#else
+  struct NSView;
+  struct NSWindow;
+  struct NSImage;
+  struct Draw_CocoaView;
+#endif
+
+
+class Draw_Window
+{
+  public :
+
+  Draw_Window (); // the window is not initialized
+  Draw_Window (Standard_CString        theTitle,
+               const Standard_Integer& theXLeft = 0,  const Standard_Integer& theYTop   = 0,
+               const Standard_Integer& theWidth = 50, const Standard_Integer& theHeight = 50);
+
+  Draw_Window (NSWindow*               theWindow,     Standard_CString        theTitle,
+               const Standard_Integer& theXLeft = 0,  const Standard_Integer& theYTop   = 0,
+               const Standard_Integer& theWidth = 50, const Standard_Integer& theHeight = 50);
+
+  void Init (const Standard_Integer& theXLeft = 0,  const Standard_Integer& theYLeft  = 0,
+             const Standard_Integer& theWidth = 50, const Standard_Integer& theHeight = 50);
+
+  virtual ~Draw_Window ();
+
+  void SetPosition (const Standard_Integer& theNewXpos,
+                    const Standard_Integer& theNewYpos);
+
+  void SetDimension (const Standard_Integer& theNewWidth,
+                     const Standard_Integer& theNewHeight);
+
+  void GetPosition (Standard_Integer &thePosX,
+                    Standard_Integer &thePosY);
+
+  Standard_Integer HeightWin() const;
+  Standard_Integer WidthWin()  const;
+
+  void  SetTitle (Standard_CString theTitle);
+  Standard_CString GetTitle ();
+
+  void DisplayWindow();
+  void Hide();
+  void Destroy();
+  void Clear();
+
+  void InitBuffer();
+
+  static Standard_Boolean DefineColor (const Standard_Integer&, Standard_CString);
+  void SetColor     (const Standard_Integer& theColor);
+  void SetMode      (const Standard_Integer& theMode);
+  void DrawString   (const Standard_Integer& theX, const Standard_Integer& theY, char* theText);
+  void DrawSegments (Segment* theSegment, const Standard_Integer& theNumberOfElements);
+  void Redraw();
+  static void Flush();
+  
+  // save snapshot
+  Standard_Boolean Save (Standard_CString theFileName) const;
+  
+  Standard_Boolean IsEqualWindows (const Standard_Integer& theWindowNumber);
+
+private:
+  NSWindow*        myWindow;
+  Draw_CocoaView*  myView;
+  NSImage*         myImageBuffer;
+  Standard_Boolean myUseBuffer;
+  Standard_Integer myCurrentColor;
+
+  static Draw_Window* firstWindow;
+  Draw_Window*        nextWindow;
+  Draw_Window*        previousWindow;
+
+};
+
+//======================================================
+// funtion : Run_Appli
+// purpose : run the application
+//           interp will be called to interpret a command
+//           and return True if the command is complete
+//======================================================
+
+void Run_Appli(Standard_Boolean (*inteprete) (const char*));
+
+//======================================================
+// funtion : Init_Appli
+// purpose :
+//======================================================
+Standard_Boolean Init_Appli();
+
+//======================================================
+// funtion : Destroy_Appli()
+// purpose :
+//======================================================
+void Destroy_Appli();
+
+//======================================================
+// funtion : GetNextEvent()
+// purpose :
+//======================================================
+void GetNextEvent (Standard_Boolean  theWait,
+                   Standard_Integer& theWindowNumber,
+                   Standard_Integer& theX,
+                   Standard_Integer& theY,
+                   Standard_Integer& theButton);
 #else
+
 // Specifique WNT
 
 #include <windows.h>
Index: oce/inc/InterfaceGraphic.hxx
===================================================================
--- oce.orig/inc/InterfaceGraphic.hxx
+++ oce/inc/InterfaceGraphic.hxx
@@ -17,12 +17,18 @@
 // and conditions governing the rights and limitations under the License.
 
 #ifndef __INTERFACE_GRAPHIC_HXX
-# define __INTERFACE_GRAPHIC_HXX
+#define __INTERFACE_GRAPHIC_HXX
+
+#ifdef HAVE_CONFIG_H
+# include <oce-config.h>
+#endif
 
 #ifdef WNT
-# include <InterfaceGraphic_WNT.hxx>
+  #include <InterfaceGraphic_WNT.hxx>
+#elif defined(__APPLE__) && !defined(MACOSX_USE_GLX)
+  #include <InterfaceGraphic_Cocoa.hxx>
 #else
-# include <InterfaceGraphic_X11.hxx>
-#endif //WNT
+  #include <InterfaceGraphic_X11.hxx>
+#endif
 
-#endif  /* __INTERFACE_GRAPHIC_HXX */
+#endif // __INTERFACE_GRAPHIC_HXX
Index: oce/inc/InterfaceGraphic_Cocoa.hxx
===================================================================
--- /dev/null
+++ oce/inc/InterfaceGraphic_Cocoa.hxx
@@ -0,0 +1,40 @@
+// Copyright (c) 2012 OPEN CASCADE SAS
+//
+// The content of this file is subject to the Open CASCADE Technology Public
+// License Version 6.5 (the "License"). You may not use the content of this file
+// except in compliance with the License. Please obtain a copy of the License
+// at http://www.opencascade.org and read it completely before using this file.
+//
+// The Initial Developer of the Original Code is Open CASCADE S.A.S., having its
+// main offices at: 1, place des Freres Montgolfier, 78280 Guyancourt, France.
+//
+// The Original Code and all software distributed under the License is
+// distributed on an "AS IS" basis, without warranty of any kind, and the
+// Initial Developer hereby disclaims all such warranties, including without
+// limitation, any warranties of merchantability, fitness for a particular
+// purpose or non-infringement. Please see the License for the specific terms
+// and conditions governing the rights and limitations under the License.
+
+#ifdef __APPLE__
+
+#ifndef InterfaceGraphic_CocoaHeader
+#define InterfaceGraphic_CocoaHeader
+
+#include <stdio.h>
+
+#define WINDOW     void*
+#define DISPLAY    void*
+#define GLCONTEXT  void*
+#define GLDRAWABLE void*
+
+#define GET_GL_CONTEXT()       NULL
+#define GET_GLDEV_CONTEXT()    NULL
+#define GL_MAKE_CURRENT(a,b,c) {}
+
+#ifndef EXPORT
+  #define EXPORT
+#endif
+
+#endif // InterfaceGraphic_CocoaHeader
+
+#endif // __APPLE__
Index: oce/inc/OpenGl_Context.hxx
===================================================================
--- oce.orig/inc/OpenGl_Context.hxx
+++ oce/inc/OpenGl_Context.hxx
@@ -101,6 +101,8 @@ public:
   Standard_EXPORT Standard_Boolean Init (const Aspect_Handle           theWindow,
                                          const Aspect_Handle           theWindowDC,
                                          const Aspect_RenderingContext theGContext);
+#elif defined(__APPLE__) && !defined(MACOSX_USE_GLX)
+  Standard_EXPORT Standard_Boolean Init (const void*                   theGContext);
 #else
   Standard_EXPORT Standard_Boolean Init (const Aspect_Drawable         theWindow,
                                          const Aspect_Display          theDisplay,
@@ -245,6 +247,8 @@ private: // system-dependent fields
   Aspect_Handle           myWindow;   //!< window handle (owner of GL context) : HWND
   Aspect_Handle           myWindowDC; //!< Device Descriptor handle : HDC
   Aspect_RenderingContext myGContext; //!< Rendering Context handle : HGLRC
+#elif defined(__APPLE__) && !defined(MACOSX_USE_GLX)
+  void*                   myGContext; //!< Rendering Context handle : NSOpenGLContext
 #else
   Aspect_Drawable         myWindow;   //!< window handle (owner of GL context) : GLXDrawable
   Aspect_Display          myDisplay;  //!< connection to the X-server : Display*
Index: oce/inc/OpenGl_GlCore11.hxx
===================================================================
--- oce.orig/inc/OpenGl_GlCore11.hxx
+++ oce/inc/OpenGl_GlCore11.hxx
@@ -22,6 +22,10 @@
 #ifndef _OpenGl_GlCore11_H__
 #define _OpenGl_GlCore11_H__
 
+#ifdef HAVE_CONFIG_H
+# include <oce-config.h>
+#endif
+
 // required for correct APIENTRY definition
 #if defined(_WIN32) && !defined(APIENTRY) && !defined(__CYGWIN__) && !defined(__SCITECH_SNAP__)
 #define WIN32_LEAN_AND_MEAN
@@ -38,22 +42,18 @@
   #define GLAPI extern
 #endif
 
-// current TKOpenGl implementation is incompatible with native OpenGL on MacOS X
-#define MACOSX_USE_GLX
-
 // exclude modern definitions and system-provided glext.h, should be defined before gl.h inclusion
 #define GL_GLEXT_LEGACY
 
 // include main OpenGL header provided with system
-#if defined(__APPLE__)
+#if defined(__APPLE__) && !defined(MACOSX_USE_GLX)
   #include <OpenGL/gl.h>
   #include <OpenGL/glu.h>
-  #define __X_GL_H // prevent chaotic gl.h inclusions to avoid compile errors
+  #define _X_GL_H // prevent chaotic gl.h inclusions to avoid compile errors
 #else
   #include <GL/gl.h>
   #include <GL/glu.h>
 #endif
-
 #include <InterfaceGraphic.hxx>
 #include <InterfaceGraphic_tgl_all.hxx>
 #include <InterfaceGraphic_telem.hxx>
Index: oce/inc/OpenGl_GlCore12.hxx
===================================================================
--- oce.orig/inc/OpenGl_GlCore12.hxx
+++ oce/inc/OpenGl_GlCore12.hxx
@@ -22,8 +22,20 @@
 #ifndef _OpenGl_GlCore12_H__
 #define _OpenGl_GlCore12_H__
 
+#ifdef HAVE_CONFIG_H
+# include <oce-config.h>
+#endif
+
 #include <OpenGl_GlCore11.hxx>
 
+#if defined(__APPLE__) && !defined(MACOSX_USE_GLX)
+  #undef GL_VERSION_1_2
+  #undef GL_VERSION_1_3
+  #undef GL_VERSION_1_4
+  #undef GL_VERSION_1_5
+  #undef GL_VERSION_2_0
+#endif
+
 #include <OpenGl_glext.h>
 
 //! Function list for GL1.2 core functionality.
Index: oce/oce_build_config.h.cmake
===================================================================
--- oce.orig/oce_build_config.h.cmake
+++ oce/oce_build_config.h.cmake
@@ -270,3 +270,5 @@
 #cmakedefine OCE_DEFAULT_CSF_GraphicShr "@OCE_DEFAULT_CSF_GraphicShr@"
 #endif
 
+/* Define MACOSX_USE_GLX to use X11 OpenGL on OSX */
+#cmakedefine MACOSX_USE_GLX
Index: oce/oce_install_config.h.cmake
===================================================================
--- oce.orig/oce_install_config.h.cmake
+++ oce/oce_install_config.h.cmake
@@ -23,3 +23,6 @@
 #cmakedefine OCE_HAVE_LIMITS 1
 #cmakedefine OCE_HAVE_CLIMITS 1
 #cmakedefine OCE_HAVE_LIMITS_H 1
+
+#cmakedefine MACOSX_USE_GLX
+
Index: oce/src/Cocoa/Cocoa_LocalPool.mm
===================================================================
--- /dev/null
+++ oce/src/Cocoa/Cocoa_LocalPool.mm
@@ -0,0 +1,45 @@
+// Copyright (c) 2012 OPEN CASCADE SAS
+//
+// The content of this file is subject to the Open CASCADE Technology Public
+// License Version 6.5 (the "License"). You may not use the content of this file
+// except in compliance with the License. Please obtain a copy of the License
+// at http://www.opencascade.org and read it completely before using this file.
+//
+// The Initial Developer of the Original Code is Open CASCADE S.A.S., having its
+// main offices at: 1, place des Freres Montgolfier, 78280 Guyancourt, France.
+//
+// The Original Code and all software distributed under the License is
+// distributed on an "AS IS" basis, without warranty of any kind, and the
+// Initial Developer hereby disclaims all such warranties, including without
+// limitation, any warranties of merchantability, fitness for a particular
+// purpose or non-infringement. Please see the License for the specific terms
+// and conditions governing the rights and limitations under the License.
+
+#if (defined(__APPLE__))
+
+#include <Cocoa_LocalPool.hxx>
+
+#import <Cocoa/Cocoa.h>
+
+// =======================================================================
+// function : Cocoa_LocalPool
+// purpose  :
+// =======================================================================
+Cocoa_LocalPool::Cocoa_LocalPool()
+: myPoolObj ([[NSAutoreleasePool alloc] init])
+{
+  //
+}
+
+// =======================================================================
+// function : ~Cocoa_LocalPool
+// purpose  :
+// =======================================================================
+Cocoa_LocalPool::~Cocoa_LocalPool()
+{
+  NSAutoreleasePool* aPool = (NSAutoreleasePool* )myPoolObj;
+  //[aPool drain];
+  [aPool release];
+}
+
+#endif // __APPLE__
Index: oce/src/Cocoa/Cocoa_Window.mm
===================================================================
--- /dev/null
+++ oce/src/Cocoa/Cocoa_Window.mm
@@ -0,0 +1,607 @@
+// Created on: 2012-11-12
+// Created by: Kirill GAVRILOV
+// Copyright (c) 2012 OPEN CASCADE SAS
+//
+// The content of this file is subject to the Open CASCADE Technology Public
+// License Version 6.5 (the "License"). You may not use the content of this file
+// except in compliance with the License. Please obtain a copy of the License
+// at http://www.opencascade.org and read it completely before using this file.
+//
+// The Initial Developer of the Original Code is Open CASCADE S.A.S., having its
+// main offices at: 1, place des Freres Montgolfier, 78280 Guyancourt, France.
+//
+// The Original Code and all software distributed under the License is
+// distributed on an "AS IS" basis, without warranty of any kind, and the
+// Initial Developer hereby disclaims all such warranties, including without
+// limitation, any warranties of merchantability, fitness for a particular
+// purpose or non-infringement. Please see the License for the specific terms
+// and conditions governing the rights and limitations under the License.
+
+#import <Cocoa/Cocoa.h>
+
+#include <Cocoa_Window.hxx>
+
+#include <Cocoa_LocalPool.hxx>
+
+#include <Image_AlienPixMap.hxx>
+#include <Aspect_Convert.hxx>
+#include <Aspect_GraphicDevice.hxx>
+#include <Aspect_WindowDefinitionError.hxx>
+
+IMPLEMENT_STANDARD_HANDLE (Cocoa_Window, Aspect_Window)
+IMPLEMENT_STANDARD_RTTIEXT(Cocoa_Window, Aspect_Window)
+
+//! Dummy device class implementation
+class Cocoa_GraphicDevice : public Aspect_GraphicDevice
+{
+
+public:
+
+  virtual Handle_Aspect_GraphicDriver GraphicDriver() const
+  {
+    return NULL;
+  }
+
+  DEFINE_STANDARD_RTTI(Cocoa_GraphicDevice)
+
+};
+
+DEFINE_STANDARD_HANDLE(Cocoa_GraphicDevice, Aspect_GraphicDevice)
+
+IMPLEMENT_STANDARD_HANDLE (Cocoa_GraphicDevice, Aspect_GraphicDevice)
+IMPLEMENT_STANDARD_RTTIEXT(Cocoa_GraphicDevice, Aspect_GraphicDevice)
+
+static Standard_Integer getScreenBottom()
+{
+  Cocoa_LocalPool aLocalPool;
+  NSArray* aScreens = [NSScreen screens];
+  if (aScreens == NULL || [aScreens count] == 0)
+  {
+    return 0;
+  }
+
+  NSScreen* aScreen = (NSScreen* )[aScreens objectAtIndex: 0];
+  NSDictionary* aDict = [aScreen deviceDescription];
+  NSNumber* aNumber = [aDict objectForKey: @"NSScreenNumber"];
+  if (aNumber == NULL
+  || [aNumber isKindOfClass: [NSNumber class]] == NO)
+  {
+    return 0;
+  }
+
+  CGDirectDisplayID aDispId = [aNumber unsignedIntValue];
+  CGRect aRect = CGDisplayBounds(aDispId);
+  return Standard_Integer(aRect.origin.y + aRect.size.height);
+}
+
+// =======================================================================
+// function : Cocoa_Window
+// purpose  :
+// =======================================================================
+Cocoa_Window::Cocoa_Window (const Standard_CString theTitle,
+                            const Standard_Integer thePxLeft,
+                            const Standard_Integer thePxTop,
+                            const Standard_Integer thePxWidth,
+                            const Standard_Integer thePxHeight)
+: Aspect_Window (new Cocoa_GraphicDevice()),
+  myHWindow (NULL),
+  myHView   (NULL),
+  myXLeft   (thePxLeft),
+  myYTop    (thePxTop),
+  myXRight  (thePxLeft + thePxWidth),
+  myYBottom (thePxTop + thePxHeight)
+{
+  if (thePxWidth <= 0 || thePxHeight <= 0)
+  {
+    Aspect_WindowDefinitionError::Raise ("Coordinate(s) out of range");
+  }
+  else if (NSApp == NULL)
+  {
+    Aspect_WindowDefinitionError::Raise ("Cocoa application should be instantiated before window");
+    return;
+  }
+
+  // convert top-bottom coordinates to bottom-top (Cocoa)
+  myYTop    = getScreenBottom() - myYBottom;
+  myYBottom = myYTop + thePxHeight;
+
+  Cocoa_LocalPool aLocalPool;
+  NSUInteger aWinStyle = NSTitledWindowMask | NSClosableWindowMask | NSResizableWindowMask;
+  NSRect aRectNs = NSMakeRect (float(myXLeft), float(myYTop), float(thePxWidth), float(thePxHeight));
+  myHWindow = [[NSWindow alloc] initWithContentRect: aRectNs
+                                          styleMask: aWinStyle
+                                            backing: NSBackingStoreBuffered
+                                              defer: NO];
+  if (myHWindow == NULL)
+  {
+    Aspect_WindowDefinitionError::Raise ("Unable to create window");
+  }
+  myHView = [[myHWindow contentView] retain];
+
+  NSString* aTitleNs = [[NSString alloc] initWithUTF8String: theTitle];
+  [myHWindow setTitle: aTitleNs];
+  [aTitleNs release];
+
+  // do not destroy NSWindow on close - we didn't handle it!
+  [myHWindow setReleasedWhenClosed: NO];
+}
+
+// =======================================================================
+// function : Cocoa_Window
+// purpose  :
+// =======================================================================
+Cocoa_Window::Cocoa_Window (NSView* theViewNS)
+: Aspect_Window (new Cocoa_GraphicDevice()),
+  myHWindow (NULL),
+  myHView   ([theViewNS retain]),
+  myXLeft   (0),
+  myYTop    (0),
+  myXRight  (512),
+  myYBottom (512)
+{
+  DoResize();
+}
+
+// =======================================================================
+// function : Destroy
+// purpose  :
+// =======================================================================
+void Cocoa_Window::Destroy()
+{
+  Cocoa_LocalPool aLocalPool;
+  if (myHWindow != NULL)
+  {
+    //[myHWindow close];
+    [myHWindow release];
+    myHWindow = NULL;
+  }
+  if (myHView != NULL)
+  {
+    [myHView release];
+    myHView = NULL;
+  }
+}
+
+// =======================================================================
+// function : HView
+// purpose  :
+// =======================================================================
+NSView* Cocoa_Window::HView() const
+{
+  return myHView;
+}
+
+// =======================================================================
+// function : SetHView
+// purpose  :
+// =======================================================================
+void Cocoa_Window::SetHView (NSView* theView)
+{
+  if (myHWindow != NULL)
+  {
+    [myHWindow setContentView: theView];
+  }
+  if (myHView != NULL)
+  {
+    [myHView release];
+    myHView = NULL;
+  }
+  myHView = [theView retain];
+}
+
+// =======================================================================
+// function : DoubleBuffer
+// purpose  :
+// =======================================================================
+Standard_Boolean Cocoa_Window::DoubleBuffer() const
+{
+  return Standard_True;
+}
+
+// =======================================================================
+// function : SetBackground
+// purpose  :
+// =======================================================================
+void Cocoa_Window::SetBackground (const Aspect_Background& theBackground)
+{
+  SetBackground (theBackground.Color());
+}
+
+// =======================================================================
+// function : SetBackground
+// purpose  :
+// =======================================================================
+void Cocoa_Window::SetBackground (const Quantity_NameOfColor theBackColor)
+{
+  SetBackground (Quantity_Color (theBackColor));
+}
+
+// =======================================================================
+// function : SetBackground
+// purpose  :
+// =======================================================================
+void Cocoa_Window::SetBackground (const Aspect_Handle theBackPixmap)
+{
+  //
+}
+
+// =======================================================================
+// function : SetBackground
+// purpose  :
+// =======================================================================
+Standard_Boolean Cocoa_Window::SetBackground (const Standard_CString  theFileName,
+                                              const Aspect_FillMethod theMethod)
+{
+  return Standard_False;
+}
+
+// =======================================================================
+// function : SetBackground
+// purpose  :
+// =======================================================================
+void Cocoa_Window::SetBackground (const Quantity_Color& theColor)
+{
+  //
+}
+
+// =======================================================================
+// function : SetBackground
+// purpose  :
+// =======================================================================
+void Cocoa_Window::SetBackground (const Aspect_GradientBackground& theGrBackground)
+{
+  Quantity_Color aColor1, aColor2;
+  theGrBackground.Colors (aColor1, aColor2);
+  SetBackground (aColor1, aColor2, theGrBackground.BgGradientFillMethod());
+}
+
+// =======================================================================
+// function : SetBackground
+// purpose  :
+// =======================================================================
+void Cocoa_Window::SetBackground (const Quantity_Color&           theColor1,
+                                  const Quantity_Color&           theColor2,
+                                  const Aspect_GradientFillMethod theMethod)
+{
+  //
+}
+
+// =======================================================================
+// function : SetDoubleBuffer
+// purpose  :
+// =======================================================================
+void Cocoa_Window::SetDoubleBuffer (const Standard_Boolean )
+{
+  //
+}
+
+// =======================================================================
+// function : Flush
+// purpose  :
+// =======================================================================
+void Cocoa_Window::Flush() const
+{
+  Restore();
+}
+
+// =======================================================================
+// function : IsMapped
+// purpose  :
+// =======================================================================
+Standard_Boolean Cocoa_Window::IsMapped() const
+{
+  if (IsVirtual())
+  {
+    return Standard_True;
+  }
+
+  return (myHView != NULL) &&  [[myHView window] isVisible];
+}
+
+// =======================================================================
+// function : Map
+// purpose  :
+// =======================================================================
+void Cocoa_Window::Map() const
+{
+  if (IsVirtual())
+  {
+    return;
+  }
+
+  if (myHView != NULL)
+  {
+    [[myHView window] orderFront: NULL];
+  }
+}
+
+// =======================================================================
+// function : Unmap
+// purpose  :
+// =======================================================================
+void Cocoa_Window::Unmap() const
+{
+  if (myHView != NULL)
+  {
+    [[myHView window] orderOut: NULL];
+  }
+}
+
+// =======================================================================
+// function : DoResize
+// purpose  :
+// =======================================================================
+Aspect_TypeOfResize Cocoa_Window::DoResize() const
+{
+  if (myHView == NULL)
+  {
+    return Aspect_TOR_UNKNOWN;
+  }
+
+  NSRect aBounds = [myHView bounds];
+  Standard_Integer aMask = 0;
+  Aspect_TypeOfResize aMode = Aspect_TOR_UNKNOWN;
+
+  if (Abs ((Standard_Integer )aBounds.origin.x                         - myXLeft  ) > 2) aMask |= 1;
+  if (Abs ((Standard_Integer )(aBounds.origin.x + aBounds.size.width)  - myXRight ) > 2) aMask |= 2;
+  if (Abs ((Standard_Integer )aBounds.origin.y                         - myYTop   ) > 2) aMask |= 4;
+  if (Abs ((Standard_Integer )(aBounds.origin.y + aBounds.size.height) - myYBottom) > 2) aMask |= 8;
+  switch (aMask)
+  {
+    case 0:  aMode = Aspect_TOR_NO_BORDER;               break;
+    case 1:  aMode = Aspect_TOR_LEFT_BORDER;             break;
+    case 2:  aMode = Aspect_TOR_RIGHT_BORDER;            break;
+    case 4:  aMode = Aspect_TOR_TOP_BORDER;              break;
+    case 5:  aMode = Aspect_TOR_LEFT_AND_TOP_BORDER;     break;
+    case 6:  aMode = Aspect_TOR_TOP_AND_RIGHT_BORDER;    break;
+    case 8:  aMode = Aspect_TOR_BOTTOM_BORDER;           break;
+    case 9:  aMode = Aspect_TOR_BOTTOM_AND_LEFT_BORDER;  break;
+    case 10: aMode = Aspect_TOR_RIGHT_AND_BOTTOM_BORDER; break;
+    default: break;
+  }
+
+  *((Standard_Integer* )&myXLeft   ) = (Standard_Integer )aBounds.origin.x;
+  *((Standard_Integer* )&myXRight  ) = (Standard_Integer )(aBounds.origin.x + aBounds.size.width);
+  *((Standard_Integer* )&myYTop    ) = (Standard_Integer )aBounds.origin.y;
+  *((Standard_Integer* )&myYBottom ) = (Standard_Integer )(aBounds.origin.y + aBounds.size.height);
+  return aMode;
+}
+
+// =======================================================================
+// function : DoMapping
+// purpose  :
+// =======================================================================
+Standard_Boolean Cocoa_Window::DoMapping() const
+{
+  return Standard_True;
+}
+
+// =======================================================================
+// function : Clear
+// purpose  :
+// =======================================================================
+void Cocoa_Window::Clear() const
+{
+  //
+}
+
+// =======================================================================
+// function : ClearArea
+// purpose  :
+// =======================================================================
+void Cocoa_Window::ClearArea (const Standard_Integer Xc,
+                              const Standard_Integer Yc,
+                              const Standard_Integer Width,
+                              const Standard_Integer Height) const
+{
+  //
+}
+
+// =======================================================================
+// function : Restore
+// purpose  :
+// =======================================================================
+void Cocoa_Window::Restore() const
+{
+  //
+}
+
+// =======================================================================
+// function : RestoreArea
+// purpose  :
+// =======================================================================
+void Cocoa_Window::RestoreArea (const Standard_Integer Xc,
+                                const Standard_Integer Yc,
+                                const Standard_Integer Width,
+                                const Standard_Integer Height) const
+{
+  //
+}
+
+// =======================================================================
+// function : Dump
+// purpose  :
+// =======================================================================
+Standard_Boolean Cocoa_Window::Dump (const Standard_CString theFilename,
+                                     const Standard_Real    theGammaValue) const
+{
+  /*Image_AlienPixMap anImg;
+  if (!ToPixMap (anImg) || anImg.IsEmpty())
+  {
+    return Standard_False;
+  }
+  if (Abs (theGammaValue - 1.0) > 0.001)
+  {
+    anImg.AdjustGamma (theGammaValue);
+  }
+  return anImg.Save (theFilename);*/
+  return Standard_False;
+}
+
+// =======================================================================
+// function : DumpArea
+// purpose  :
+// =======================================================================
+Standard_Boolean Cocoa_Window::DumpArea (const Standard_CString theFilename,
+                                         const Standard_Integer theCenterX,
+                                         const Standard_Integer theCenterY,
+                                         const Standard_Integer theWidth,
+                                         const Standard_Integer theHeight,
+                                         const Standard_Real    theGammaValue) const
+{
+  return Standard_False;
+}
+
+// =======================================================================
+// function : ToPixMap
+// purpose  :
+// =======================================================================
+/*Standard_Boolean Cocoa_Window::ToPixMap (Image_PixMap& thePixMap) const
+{
+  return Standard_False;
+}*/
+
+// =======================================================================
+// function : Load
+// purpose  :
+// =======================================================================
+Standard_Boolean Cocoa_Window::Load (const Standard_CString theFilename) const
+{
+  return Standard_False;
+}
+
+// =======================================================================
+// function : LoadArea
+// purpose  :
+// =======================================================================
+Standard_Boolean Cocoa_Window::LoadArea (const Standard_CString theFilename,
+                                         const Standard_Integer theCenterX,
+                                         const Standard_Integer theCenterY,
+                                         const Standard_Integer theWidth,
+                                         const Standard_Integer theHeight) const
+{
+  return Standard_False;
+}
+
+// =======================================================================
+// function : BackingStore
+// purpose  :
+// =======================================================================
+Standard_Boolean Cocoa_Window::BackingStore() const
+{
+  return Standard_False;
+}
+
+// =======================================================================
+// function : Ratio
+// purpose  :
+// =======================================================================
+Quantity_Ratio Cocoa_Window::Ratio() const
+{
+  if (myHView == NULL)
+  {
+    return 1.0;
+  }
+
+  NSRect aBounds = [myHView bounds];
+  return Quantity_Ratio (aBounds.size.width / aBounds.size.height);
+}
+
+// =======================================================================
+// function : Position
+// purpose  :
+// =======================================================================
+void Cocoa_Window::Position (Quantity_Parameter& X1, Quantity_Parameter& Y1,
+                             Quantity_Parameter& X2, Quantity_Parameter& Y2) const
+{
+  //
+}
+
+// =======================================================================
+// function : Position
+// purpose  :
+// =======================================================================
+void Cocoa_Window::Position (Standard_Integer& X1, Standard_Integer& Y1,
+                             Standard_Integer& X2, Standard_Integer& Y2) const
+{
+  //
+}
+
+// =======================================================================
+// function : Size
+// purpose  :
+// =======================================================================
+void Cocoa_Window::Size (Quantity_Parameter& theWidth,
+                         Quantity_Parameter& theHeight) const
+{
+  //
+}
+
+// =======================================================================
+// function : Size
+// purpose  :
+// =======================================================================
+void Cocoa_Window::Size (Standard_Integer& theWidth,
+                         Standard_Integer& theHeight) const
+{
+  if (myHView == NULL)
+  {
+    return;
+  }
+
+  NSRect aBounds = [myHView bounds];
+  theWidth  = (Standard_Integer )aBounds.size.width;
+  theHeight = (Standard_Integer )aBounds.size.height;
+}
+
+// =======================================================================
+// function : MMSize
+// purpose  :
+// =======================================================================
+void Cocoa_Window::MMSize (Standard_Real& theWidth,
+                           Standard_Real& theHeight) const
+{
+  //
+}
+
+// =======================================================================
+// function : Convert
+// purpose  :
+// =======================================================================
+Quantity_Parameter Cocoa_Window::Convert (const Standard_Integer PV) const
+{
+  return 0.0; ///
+}
+
+// =======================================================================
+// function : Convert
+// purpose  :
+// =======================================================================
+Standard_Integer Cocoa_Window::Convert (const Quantity_Parameter DV) const
+{
+  return 0; ////
+}
+
+// =======================================================================
+// function : Convert
+// purpose  :
+// =======================================================================
+void Cocoa_Window::Convert (const Standard_Integer PX,
+                            const Standard_Integer PY,
+                            Quantity_Parameter&    DX,
+                            Quantity_Parameter&    DY) const
+{
+  //
+}
+
+// =======================================================================
+// function : Convert
+// purpose  :
+// =======================================================================
+void Cocoa_Window::Convert (const Quantity_Parameter DX,
+                            const Quantity_Parameter DY,
+                            Standard_Integer&        PX,
+                            Standard_Integer&        PY) const
+{
+  //
+}
Index: oce/src/Cocoa/EXTERNLIB
===================================================================
--- /dev/null
+++ oce/src/Cocoa/EXTERNLIB
@@ -0,0 +1,3 @@
+CSF_objc
+CSF_Appkit
+CSF_IOKit
Index: oce/src/Cocoa/FILES
===================================================================
--- /dev/null
+++ oce/src/Cocoa/FILES
@@ -0,0 +1,4 @@
+Cocoa_LocalPool.hxx
+Cocoa_LocalPool.mm
+Cocoa_Window.hxx
+Cocoa_Window.mm
Index: oce/src/Draw/Draw_Viewer.cxx
===================================================================
--- oce.orig/src/Draw/Draw_Viewer.cxx
+++ oce/src/Draw/Draw_Viewer.cxx
@@ -77,7 +77,7 @@ class Draw_View : public Draw_Window {
 	      Standard_Integer W,
 	      Standard_Integer H);
 
-#ifdef WNT
+#if defined(_WIN32) || defined(__WIN32__)
     Draw_View(Standard_Integer i,
 	      Draw_Viewer* v,
 	      Standard_Integer X,
@@ -85,6 +85,14 @@ class Draw_View : public Draw_Window {
 	      Standard_Integer W,
 	      Standard_Integer H,
         HWND win);
+#elif defined(__APPLE__) && !defined(MACOSX_USE_GLX)
+  Draw_View(Standard_Integer i,
+            Draw_Viewer* v,
+            Standard_Integer X,
+            Standard_Integer Y,
+            Standard_Integer W,
+            Standard_Integer H,
+            NSWindow* theWindow);
 #endif
 
   Draw_View(Standard_Integer i,
@@ -139,7 +147,7 @@ Draw_View::Draw_View(Standard_Integer i,
   Framex0=Framey0=Framex1=Framey1=0;
 }
 
-#ifdef WNT
+#if defined(_WIN32) || defined(__WIN32__)
 //=======================================================================
 //function : Draw_View
 //purpose  :
@@ -154,16 +162,24 @@ Draw_View::Draw_View(Standard_Integer i,
 {
   Framex0=Framey0=Framex1=Framey1=0;
 }
+#elif defined(__APPLE__) && !defined(MACOSX_USE_GLX)
+Draw_View::Draw_View(Standard_Integer i, Draw_Viewer* v,
+                     Standard_Integer X,
+                     Standard_Integer Y,
+                     Standard_Integer W,
+                     Standard_Integer H,
+                     NSWindow* theWindow) :
+Draw_Window(theWindow, "Win", X, Y, W, H), id(i), viewer(v)
+{
+  Framex0=Framey0=Framex1=Framey1=0;
+}
 #endif
 
 //=======================================================================
 //function : Draw_View
 //purpose  :
 //=======================================================================
-
-// Portage WNT
-
-#ifdef WNT
+#if defined(_WIN32) || defined (__WIN32__) || (defined(__APPLE__) && !defined(MACOSX_USE_GLX))
 Draw_View::Draw_View(Standard_Integer i, Draw_Viewer* v, const char* w)
 #else
 Draw_View::Draw_View(Standard_Integer i, Draw_Viewer* v, const char* w) :
@@ -1034,9 +1050,9 @@ unsigned long Draw_Viewer::GetWindow (co
 {
   if (Draw_Batch) return 0;
   if (myViews[id]) {
-    #ifdef WNT
+  #if defined(_WIN32) || defined(__WIN32__)
     return (unsigned long)(myViews[id]->win);
-	#else
+	#elif !defined(__APPLE__) || defined(MACOSX_USE_GLX)
     return myViews[id]->win;
 	#endif
   }
@@ -1240,7 +1256,7 @@ void Draw_Viewer::Select (Standard_Integ
 {
   if (Draw_Batch) return;
   Flush();
-#ifndef WNT
+#if !defined(_WIN32) && !defined(__WIN32__) && (!defined(__APPLE__) || defined(MACOSX_USE_GLX))
   if (!wait) {
     if (id >=0 && id < MAXVIEW) {
       if (myViews[id]) myViews[id]->Wait(wait);
@@ -1298,6 +1314,31 @@ void Draw_Viewer::Select (Standard_Integ
     Y = -Y - myViews[id]->dY;
   }
   if (!wait) myViews[id]->Wait(!wait);
+#elif defined(__APPLE__) && !defined(MACOSX_USE_GLX)
+  Standard_Integer aWindowNumber;
+
+  id = MAXVIEW;
+  while (id >= MAXVIEW)
+  {
+    GetNextEvent(wait, aWindowNumber, X, Y, Button);
+    
+    if (Y < 0)
+    {
+      continue; // mouse clicked on window title
+    }
+
+    for (Standard_Integer anIter = 0; anIter < MAXVIEW; anIter++)
+    {
+      if (myViews[anIter] && myViews[anIter]->IsEqualWindows (aWindowNumber))
+      {
+        id = anIter;
+      }
+    }
+  }
+
+  X =  X - myViews[id]->dX;
+  Y = -Y - myViews[id]->dY;
+
 #else
   HANDLE hWnd;
 
Index: oce/src/Draw/Draw_Window.cxx
===================================================================
--- oce.orig/src/Draw/Draw_Window.cxx
+++ oce/src/Draw/Draw_Window.cxx
@@ -97,7 +97,7 @@ defaultPrompt:
     }
 }
 
-#ifndef WNT
+#if !defined(_WIN32) && !defined(__WIN32__)
 
 #ifdef HAVE_CONFIG_H
 # include <config.h>
@@ -186,7 +186,7 @@ Standard_Boolean Draw_BlackBackGround =
 //======================================================
 Draw_Window* Draw_Window::firstWindow = NULL;
 
-
+#if !defined(__APPLE__) || defined(MACOSX_USE_GLX)
 //=======================================================================
 //function : Draw_Window
 //purpose  :
@@ -756,6 +756,25 @@ Standard_Boolean Draw_Window::Save (cons
 }
 
 //=======================================================================
+//function : Wait
+//purpose  :
+//=======================================================================
+
+void Draw_Window::Wait (Standard_Boolean wait)
+{
+  Flush();
+  if (!wait) {
+    XSelectInput(Draw_WindowDisplay,win,
+                 ButtonPressMask|ExposureMask | StructureNotifyMask |
+                 PointerMotionMask);
+  }
+  else {
+    XSelectInput(Draw_WindowDisplay,win,
+                 ButtonPressMask|ExposureMask | StructureNotifyMask);
+  }
+}
+
+//=======================================================================
 //function : ProcessEvent
 //purpose  :
 //=======================================================================
@@ -877,25 +896,6 @@ void Draw_Window::WConfigureNotify(const
 }
 
 //=======================================================================
-//function : Wait
-//purpose  :
-//=======================================================================
-
-void Draw_Window::Wait (Standard_Boolean wait)
-{
-  Flush();
-  if (!wait) {
-        XSelectInput(Draw_WindowDisplay,win,
-                     ButtonPressMask|ExposureMask | StructureNotifyMask |
-                     PointerMotionMask);
-  }
-  else {
-        XSelectInput(Draw_WindowDisplay,win,
-                     ButtonPressMask|ExposureMask | StructureNotifyMask);
-  }
-}
-
-//=======================================================================
 //function : WUnmapNotify
 //purpose  :
 //=======================================================================
@@ -939,6 +939,35 @@ static void ProcessEvents(ClientData,int
 }
 
 //======================================================
+// funtion : GetNextEvent()
+// purpose :
+//======================================================
+void GetNextEvent(Event& ev)
+{
+  XEvent xev;
+  XNextEvent(Draw_WindowDisplay, &xev);
+  switch(xev.type)
+  {
+    case ButtonPress :
+      ev.type = 4;
+      ev.window = xev.xbutton.window;
+      ev.button = xev.xbutton.button;
+      ev.x = xev.xbutton.x;
+      ev.y = xev.xbutton.y;
+      break;
+
+    case MotionNotify :
+      ev.type = 6;
+      ev.window = xev.xmotion.window;
+      ev.button = 0;
+      ev.x = xev.xmotion.x;
+      ev.y = xev.xmotion.y;
+      break;
+  }
+}
+#endif //__APPLE__
+
+//======================================================
 // funtion :Run_Appli
 // purpose :
 //======================================================
@@ -972,6 +1001,7 @@ void Run_Appli(Standard_Boolean (*interp
   // ConnectionNumber(Draw_WindowDisplay) is an int 32 bits
   //                    (void*) is a pointer      64 bits ???????
 
+#if !defined(__APPLE__) || defined(MACOSX_USE_GLX)
 #if TCL_MAJOR_VERSION  < 8
     Tk_CreateFileHandler((void*) ConnectionNumber(Draw_WindowDisplay),
                          TK_READABLE, ProcessEvents,(ClientData) 0 );
@@ -979,6 +1009,7 @@ void Run_Appli(Standard_Boolean (*interp
     Tk_CreateFileHandler(ConnectionNumber(Draw_WindowDisplay),
                          TK_READABLE, ProcessEvents,(ClientData) 0 );
 #endif
+#endif // __APPLE__
 
 #endif
 
@@ -1057,6 +1088,7 @@ Standard_Boolean Init_Appli()
 
   Tk_GeometryRequest(mainWindow, 200, 200);
 
+#if !defined(__APPLE__) || defined(MACOSX_USE_GLX)
   if (Draw_WindowDisplay == NULL) {
     Draw_WindowDisplay = Tk_Display(mainWindow);
   }
@@ -1077,6 +1109,8 @@ Standard_Boolean Init_Appli()
   Draw_WindowScreen   = DefaultScreen(Draw_WindowDisplay);
   Draw_WindowColorMap = DefaultColormap(Draw_WindowDisplay,
                                         Draw_WindowScreen);
+#endif // __APPLE__
+
   tty = isatty(0);
   Tcl_SetVar(interp,"tcl_interactive",(char*)(tty ? "1" : "0"), TCL_GLOBAL_ONLY);
 //  Tcl_SetVar(interp,"tcl_interactive",tty ? "1" : "0", TCL_GLOBAL_ONLY);
@@ -1092,34 +1126,6 @@ void Destroy_Appli()
   //XCloseDisplay(Draw_WindowDisplay);
 }
 
-//======================================================
-// funtion : GetNextEvent()
-// purpose :
-//======================================================
-void GetNextEvent(Event& ev)
-{
-  XEvent xev;
-  XNextEvent(Draw_WindowDisplay, &xev);
-  switch(xev.type)
-  {
-      case ButtonPress :
-           ev.type = 4;
-           ev.window = xev.xbutton.window;
-           ev.button = xev.xbutton.button;
-           ev.x = xev.xbutton.x;
-           ev.y = xev.xbutton.y;
-           break;
-
-      case MotionNotify :
-           ev.type = 6;
-           ev.window = xev.xmotion.window;
-           ev.button = 0;
-           ev.x = xev.xmotion.x;
-           ev.y = xev.xmotion.y;
-           break;
-   }
-}
-
 /*
  *----------------------------------------------------------------------
  *
@@ -2015,7 +2021,7 @@ static DWORD WINAPI readStdinThreadFunc(
     while (console_semaphore != WAIT_CONSOLE_COMMAND)
       Sleep(100);
     //if (gets(console_command))
-	if (fgets(console_command,COMMAND_SIZE,stdin)) 
+	if (fgets(console_command,COMMAND_SIZE,stdin))
       {
         console_semaphore = HAS_CONSOLE_COMMAND;
       }
Index: oce/src/Draw/Draw_Window_1.mm
===================================================================
--- /dev/null
+++ oce/src/Draw/Draw_Window_1.mm
@@ -0,0 +1,612 @@
+// Copyright 2012 OPEN CASCADE SAS
+//
+// The content of this file is subject to the Open CASCADE Technology Public
+// License Version 6.5 (the "License"). You may not use the content of this file
+// except in compliance with the License. Please obtain a copy of the License
+// at http://www.opencascade.org and read it completely before using this file.
+//
+// The Initial Developer of the Original Code is Open CASCADE S.A.S., having its
+// main offices at: 1, place des Freres Montgolfier, 78280 Guyancourt, France.
+//
+// The Original Code and all software distributed under the License is
+// distributed on an "AS IS" basis, without warranty of any kind, and the
+// Initial Developer hereby disclaims all such warranties, including without
+// limitation, any warranties of merchantability, fitness for a particular
+// purpose or non-infringement. Please see the License for the specific terms
+// and conditions governing the rights and limitations under the License.
+
+#if defined(__APPLE__) && !defined(MACOSX_USE_GLX)
+
+#import <Cocoa/Cocoa.h>
+
+#include <Draw_Window.hxx>
+#include <Cocoa_LocalPool.hxx>
+
+@interface Draw_CocoaView : NSView
+{
+  NSImage* myImage;
+}
+
+- (void )setImage: (NSImage* )theImage;
+- (void )redraw;
+@end
+
+@implementation Draw_CocoaView
+
+- (void )setImage: (NSImage* )theImage
+{
+  [theImage retain];
+  [myImage release];
+  myImage = theImage;
+}
+
+- (BOOL )isFlipped
+{
+  return YES; // for drawing image from left-top corner
+}
+
+- (void )redraw
+{
+  [self setNeedsDisplay: YES];
+}
+
+- (void )drawRect: (NSRect )theRect
+{
+
+  NSRect aBounds = NSMakeRect (0.0, 0.0, myImage.size.width, myImage.size.height);
+
+  [myImage drawInRect: aBounds
+             fromRect: NSZeroRect
+            operation: NSCompositeSourceOver
+             fraction: 1
+       respectFlipped: YES
+                hints: nil];
+}
+
+- (void )dealloc
+{
+  [myImage release];
+  [super dealloc];
+}
+@end
+
+static Standard_Integer getScreenBottom()
+{
+  NSRect aRect = [[[NSScreen screens] objectAtIndex:0] frame];
+  Standard_Integer aScreenBottom = Standard_Integer(aRect.size.height + aRect.origin.y);
+  return aScreenBottom;
+}
+
+extern Standard_Boolean Draw_VirtualWindows;
+static Standard_Boolean Draw_IsInZoomingMode = Standard_False;
+
+Standard_Real Draw_RGBColorsArray[MAXCOLOR][3] = {{1.0,  1.0,  1.0},
+                                                  {1.0,  0.0,  0.0},
+                                                  {0.0,  1.0,  0.0},
+                                                  {0.0,  0.0,  1.0},
+                                                  {0.0,  1.0,  1.0},
+                                                  {1.0,  0.84, 0.0},
+                                                  {1.0,  0.0,  1.0},
+                                                  {1.0,  0.2,  0.7},
+                                                  {1.0,  0.65, 0.0},
+                                                  {1.0,  0.89, 0.88},
+                                                  {1.0,  0.63, 0.48},
+                                                  {0.78, 0.08, 0.52},
+                                                  {1.0,  1.0,  0.0},
+                                                  {0.94, 0.9,  0.55},
+                                                  {1.0,  0.5,  0.31}};
+
+//=======================================================================
+//function : Draw_Window
+//purpose  :
+//=======================================================================
+Draw_Window::Draw_Window() :
+  myWindow (NULL),
+  myView (NULL),
+  myImageBuffer (NULL),
+  myUseBuffer (Standard_False),
+  nextWindow (firstWindow),
+  previousWindow (NULL)
+{
+  if (firstWindow != NULL) firstWindow->previousWindow = this;
+  firstWindow = this;
+}
+
+//=======================================================================
+//function : Draw_Window
+//purpose  :
+//=======================================================================
+Draw_Window::Draw_Window (Standard_CString theTitle,
+                          const Standard_Integer& theXLeft, const Standard_Integer& theYTop,
+                          const Standard_Integer& theWidth, const Standard_Integer& theHeight):
+  myWindow (NULL),
+  myView (NULL),
+  myImageBuffer (NULL),
+  myUseBuffer (Standard_False),
+  nextWindow (firstWindow),
+  previousWindow (NULL)
+{
+  if (firstWindow != NULL) firstWindow->previousWindow = this;
+  firstWindow = this;
+  Init (theXLeft, theYTop, theWidth, theHeight);
+  SetTitle (theTitle);
+}
+
+Draw_Window::Draw_Window (NSWindow*               theWindow, Standard_CString        theTitle,
+                          const Standard_Integer& theXLeft,  const Standard_Integer& theYTop,
+                          const Standard_Integer& theWidth,  const Standard_Integer& theHeight):
+  myWindow (NULL),
+  myView (NULL),
+  myImageBuffer (NULL),
+  myUseBuffer (Standard_False),
+  nextWindow (firstWindow),
+  previousWindow (NULL)
+{
+  myWindow = [theWindow retain];
+  if (firstWindow != NULL) firstWindow->previousWindow = this;
+  firstWindow = this;
+  Init (theXLeft, theYTop, theWidth, theHeight);
+  SetTitle (theTitle);
+}
+
+//=======================================================================
+//function : ~Draw_Window
+//purpose  :
+//=======================================================================
+Draw_Window::~Draw_Window()
+{
+  if (previousWindow != NULL)
+  {
+    previousWindow->nextWindow = nextWindow;
+  }
+  else
+  {
+    firstWindow = nextWindow;
+  }
+
+  if (nextWindow != NULL)
+  {
+    nextWindow->previousWindow = previousWindow;
+  }
+
+  if (myWindow != NULL)
+  { 
+    [myWindow release];
+    myWindow = NULL;
+  }
+
+  if (myView != NULL)
+  {
+    [myView release];
+    myView = NULL;
+  }
+
+  if (myImageBuffer != NULL)
+  {
+    [myImageBuffer release];
+    myImageBuffer = NULL;
+  }
+}
+
+//=======================================================================
+//function : Init
+//purpose  :
+//=======================================================================
+void Draw_Window::Init (const Standard_Integer& theXLeft, const Standard_Integer& theYTop,
+                        const Standard_Integer& theWidth, const Standard_Integer& theHeight)
+{
+  Cocoa_LocalPool aLocalPool;
+
+  // converting left-bottom coordinate to left-top coordinate
+  Standard_Integer anYTop = getScreenBottom() - theYTop - theHeight;
+
+  if (myWindow == NULL)
+  {
+    NSRect     aRectNs   = NSMakeRect (theXLeft, anYTop, theWidth, theHeight);
+    NSUInteger aWinStyle = NSTitledWindowMask | NSClosableWindowMask | NSResizableWindowMask;
+
+    myWindow = [[NSWindow alloc] initWithContentRect: aRectNs
+                                           styleMask: aWinStyle
+                                             backing: NSBackingStoreBuffered
+                                               defer: NO];
+  }
+
+  if (myView == NULL)
+  {
+    NSRect aBounds = [[myWindow contentView] bounds];
+    
+    myView = [[Draw_CocoaView alloc] initWithFrame: aBounds];
+    [myWindow setContentView: myView];
+  }
+
+  if (myImageBuffer == NULL)
+  {
+    NSRect aRectNs = [myView bounds];
+    myImageBuffer  = [[NSImage alloc] initWithSize: aRectNs.size];
+  }
+
+  [myView setImage: myImageBuffer];
+
+  myUseBuffer = Draw_VirtualWindows;
+
+  myCurrentColor = 3;
+
+  [myWindow setBackgroundColor: NSColor.blackColor];
+  [myWindow setReleasedWhenClosed: NO];
+}
+
+//=======================================================================
+//function : InitBuffer
+//purpose  :
+//=======================================================================
+void Draw_Window::InitBuffer()
+{
+  //
+}
+
+//=======================================================================
+//function : SetPosition
+//purpose  :
+//=======================================================================
+void Draw_Window::SetPosition (const Standard_Integer& theNewXpos,
+                               const Standard_Integer& theNewYpos)
+{
+  NSPoint aNewPosition = NSMakePoint (theNewXpos, theNewYpos);
+  [myWindow setFrameTopLeftPoint: aNewPosition];
+}
+
+//=======================================================================
+//function : SetDimension
+//purpose  :
+//=======================================================================
+void Draw_Window::SetDimension (const Standard_Integer& theNewWidth,
+                                const Standard_Integer& theNewHeight)
+{
+  NSRect aWindowRect = [myWindow frame];
+  Standard_Integer aNewY = aWindowRect.origin.y + aWindowRect.size.height - theNewHeight;
+  NSRect aNewContentRect = NSMakeRect (aWindowRect.origin.x, aNewY,
+                                       theNewWidth, theNewHeight);
+  [myWindow setFrame: aNewContentRect display: YES];
+}
+
+//=======================================================================
+//function : GetPosition
+//purpose  :
+//=======================================================================
+void Draw_Window::GetPosition (Standard_Integer &thePosX,
+                               Standard_Integer &thePosY)
+{
+  NSRect aWindowRect = [myWindow frame];
+  thePosX = aWindowRect.origin.x;
+  thePosY = getScreenBottom() - aWindowRect.origin.y - aWindowRect.size.height;
+}
+
+//=======================================================================
+//function : HeightWin
+//purpose  :
+//=======================================================================
+Standard_Integer Draw_Window::HeightWin() const
+{
+  NSRect aViewBounds = [myView bounds];
+  return aViewBounds.size.height;
+}
+
+//=======================================================================
+//function : WidthWin
+//purpose  :
+//=======================================================================
+Standard_Integer Draw_Window::WidthWin() const
+{
+  NSRect aViewBounds = [myView bounds];
+  return aViewBounds.size.width;
+}
+
+//=======================================================================
+//function : SetTitle
+//purpose  :
+//=======================================================================
+void Draw_Window::SetTitle (Standard_CString theTitle)
+{
+  NSString* aTitleNs = [[NSString alloc] initWithUTF8String: theTitle];
+  [myWindow setTitle: aTitleNs];
+  [aTitleNs release];
+}
+
+//=======================================================================
+//function : GetTitle
+//purpose  :
+//=======================================================================
+Standard_CString Draw_Window::GetTitle()
+{
+  Standard_CString aTitle = [[myWindow title] UTF8String];
+  return aTitle;
+}
+
+//=======================================================================
+//function :DefineColor
+//purpose  :
+//=======================================================================
+Standard_Boolean Draw_Window::DefineColor (const Standard_Integer&, Standard_CString)
+{
+  return Standard_True; // unused
+}
+
+//=======================================================================
+//function : DisplayWindow
+//purpose  :
+//=======================================================================
+void Draw_Window::DisplayWindow()
+{
+  if (Draw_VirtualWindows)
+  {
+    return;
+  }
+
+  if (myWindow != NULL)
+  {
+    [myWindow orderFront: NULL];
+  }
+}
+
+//=======================================================================
+//function : Hide
+//purpose  :
+//=======================================================================
+void Draw_Window::Hide()
+{
+  if (myWindow != NULL)
+  {
+    [myWindow orderOut: NULL];
+  }
+}
+
+//=======================================================================
+//function : Destroy
+//purpose  :
+//=======================================================================
+void Draw_Window::Destroy()
+{  
+  if (myWindow != NULL)
+  { 
+    [myWindow release];
+    myWindow = NULL;
+  }
+
+  if (myView != NULL)
+  {
+    [myView release];
+    myView = NULL;
+  }
+
+  if (myImageBuffer != NULL)
+  {
+    [myImageBuffer release];
+    myImageBuffer = NULL;
+  }
+}
+
+//=======================================================================
+//function : Clear
+//purpose  :
+//=======================================================================
+void Draw_Window::Clear()
+{
+  [myImageBuffer lockFocus];
+  [[NSColor blackColor] set];
+  NSRect anImageBounds = NSMakeRect (0.0, 0.0, myImageBuffer.size.width, myImageBuffer.size.height);
+  NSRectFill (anImageBounds);
+  [myImageBuffer unlockFocus];
+
+  if (!myUseBuffer)
+  {
+    [myView redraw];
+  }
+}
+
+//=======================================================================
+//function : Flush
+//purpose  :
+//=======================================================================
+void Draw_Window::Flush()
+{
+  //
+}
+
+//=======================================================================
+//function : DrawString
+//purpose  :
+//=======================================================================
+void Draw_Window::DrawString (const Standard_Integer& theXLeft, const Standard_Integer& theYTop, char* theText)
+{
+  Cocoa_LocalPool aLocalPool;
+
+  NSString* aTextNs = [[[NSString alloc] initWithUTF8String: theText] autorelease];
+  NSColor*  aColor  = [NSColor colorWithDeviceRed: Draw_RGBColorsArray[myCurrentColor][0]
+                                            green: Draw_RGBColorsArray[myCurrentColor][1]
+                                             blue: Draw_RGBColorsArray[myCurrentColor][2]
+                                            alpha: 1.0f];
+  NSDictionary* anAttributes = [[[NSDictionary alloc] initWithObjectsAndKeys: aColor, NSForegroundColorAttributeName, nil] autorelease];
+
+  [myImageBuffer lockFocus];
+  [aTextNs drawAtPoint: NSMakePoint (theXLeft, myImageBuffer.size.height - theYTop) withAttributes: anAttributes];
+  [myImageBuffer unlockFocus];
+
+  if (!myUseBuffer)
+  {
+    [myView redraw];
+  }
+}
+
+//=======================================================================
+//function : DrawSegments
+//purpose  :
+//=======================================================================
+void Draw_Window::DrawSegments (Segment *theSegment, const Standard_Integer& theNumberOfElements)
+{
+  Cocoa_LocalPool aLocalPool;
+
+  NSBezierPath* aPath = [[[NSBezierPath alloc] init] autorelease];
+
+  NSImage* anImage;
+  Standard_Integer anIter = 0;
+  
+  if (Draw_IsInZoomingMode)
+  {
+    // workaround for rectangle drawing when zooming
+    anImage = [[myImageBuffer copy] autorelease];
+    anIter  = 4;
+  }
+  else
+  {
+    anImage = myImageBuffer;
+  }
+
+
+  for (; anIter < theNumberOfElements; anIter++)
+  {
+    NSPoint aPoint = NSMakePoint (theSegment[anIter].myXStart, myImageBuffer.size.height - theSegment[anIter].myYStart);
+    [aPath moveToPoint: aPoint];
+    aPoint = NSMakePoint (theSegment[anIter].myXEnd, myImageBuffer.size.height - theSegment[anIter].myYEnd);
+    [aPath lineToPoint: aPoint];
+  }
+
+  [anImage lockFocus];
+  NSColor* aColor = [NSColor colorWithDeviceRed: Draw_RGBColorsArray[myCurrentColor][0]
+                                          green: Draw_RGBColorsArray[myCurrentColor][1]
+                                           blue: Draw_RGBColorsArray[myCurrentColor][2]
+                                          alpha: 1.0f];
+  [aColor set];
+  [aPath stroke];
+  [anImage unlockFocus];
+
+  if (!myUseBuffer)
+  {
+    [myView setImage: anImage];
+    [myView redraw];
+  }
+  
+  Draw_IsInZoomingMode = Standard_False;
+}
+
+//=======================================================================
+//function : Redraw
+//purpose  :
+//=======================================================================
+void Draw_Window::Redraw()
+{
+  if (myUseBuffer)
+  {
+    [myView redraw];
+  }
+}
+
+//=======================================================================
+//function : SetColor
+//purpose  :
+//=======================================================================
+void Draw_Window::SetColor (const Standard_Integer& theColor)
+{
+  myCurrentColor = theColor;
+}
+
+//=======================================================================
+//function : SetMode
+//purpose  :
+//=======================================================================
+void Draw_Window::SetMode (const Standard_Integer& theMode)
+{
+  //
+}
+
+//=======================================================================
+//function : Save
+//purpose  :
+//=======================================================================
+Standard_Boolean Draw_Window::Save (Standard_CString theFileName) const
+{
+  Cocoa_LocalPool aLocalPool;
+
+  NSString* aFileName = [[[NSString alloc] initWithUTF8String: theFileName] autorelease];
+  NSString* aFileExtension = [[aFileName pathExtension] lowercaseString];
+
+  NSDictionary* aFileTypeDict = [NSDictionary dictionaryWithObjectsAndKeys:
+                                  [NSNumber numberWithInt: NSPNGFileType],  @"png",
+                                  [NSNumber numberWithInt: NSBMPFileType],  @"bmp",
+                                  [NSNumber numberWithInt: NSJPEGFileType], @"jpg",
+                                  [NSNumber numberWithInt: NSGIFFileType],  @"gif",
+                                  nil];
+
+  NSBitmapImageFileType aFileType;
+
+  if ([aFileTypeDict valueForKey: aFileExtension] != nil)
+  {
+    aFileType = [[aFileTypeDict valueForKey: aFileExtension] intValue];
+  }
+  else
+  {
+    return Standard_False; // unsupported image extension
+  }
+
+  NSBitmapImageRep* anImageRep = [NSBitmapImageRep imageRepWithData: [myImageBuffer TIFFRepresentation]];
+
+  NSData* aData = [anImageRep representationUsingType: aFileType 
+                                           properties: nil];
+
+  Standard_Boolean isSuccess = [aData writeToFile: aFileName
+                                       atomically: NO];
+
+  return isSuccess;
+}
+
+Standard_Boolean Draw_Window::IsEqualWindows (const Standard_Integer& theWindowNumber)
+{
+  return ([myWindow windowNumber] == theWindowNumber);
+}
+
+void GetNextEvent (Standard_Boolean  theWait,
+                   Standard_Integer& theWindowNumber,
+                   Standard_Integer& theX,
+                   Standard_Integer& theY,
+                   Standard_Integer& theButton)
+{
+  Cocoa_LocalPool aLocalPool;
+
+  unsigned int anEventMatchMask = NSLeftMouseDownMask | NSRightMouseDownMask;
+
+  if (!theWait)
+  {
+    anEventMatchMask = anEventMatchMask | NSMouseMovedMask | NSLeftMouseDraggedMask;
+    Draw_IsInZoomingMode = Standard_True;
+  }
+
+  NSEvent* anEvent = [NSApp nextEventMatchingMask: anEventMatchMask
+                                        untilDate: [NSDate distantFuture]
+                                           inMode: NSEventTrackingRunLoopMode
+                                          dequeue: YES];
+
+  NSWindow* aWindow = [anEvent window];
+  NSView*   aView   = [aWindow contentView];
+  theWindowNumber   = [aWindow windowNumber];
+
+  NSPoint aMouseLoc = [aView convertPoint: [anEvent locationInWindow] fromView: nil];
+  NSRect  aBounds   = [aView bounds];
+
+  theX = Standard_Integer (aMouseLoc.x);
+  theY = Standard_Integer (aMouseLoc.y);
+
+  NSEventType anEventType = [anEvent type];
+
+  if (anEventType == NSLeftMouseDown)
+  {
+    theButton = 1;
+  }
+  else if (anEventType == NSRightMouseDown)
+  {
+    theButton = 3;
+  }
+  else if ((anEventType == NSMouseMoved || anEventType == NSLeftMouseDragged) && !theWait)
+  {
+    theButton = 0;
+  }
+}
+#endif // __APPLE__
Index: oce/src/Draw/EXTERNLIB
===================================================================
--- oce.orig/src/Draw/EXTERNLIB
+++ oce/src/Draw/EXTERNLIB
@@ -3,4 +3,6 @@ CSF_TclTkLibs
 CSF_gdi32
 CSF_advapi32
 CSF_user32
-
+CSF_objc
+CSF_Appkit
+CSF_IOKit
Index: oce/src/Draw/FILES
===================================================================
--- oce.orig/src/Draw/FILES
+++ oce/src/Draw/FILES
@@ -27,3 +27,4 @@ Draw_Main.hxx
 Draw_Main.cxx
 Draw_PluginMacro.hxx
 Draw_PloadCommands.cxx
+Draw_Window_1.mm
Index: oce/src/InterfaceGraphic/FILES
===================================================================
--- oce.orig/src/InterfaceGraphic/FILES
+++ oce/src/InterfaceGraphic/FILES
@@ -6,6 +6,7 @@ InterfaceGraphic_Portability.hxx
 InterfaceGraphic_Visual3d.hxx
 InterfaceGraphic_WNT.hxx
 InterfaceGraphic_X11.hxx
+InterfaceGraphic_Cocoa.hxx
 InterfaceGraphic_XWD.hxx
 InterfaceGraphic_wntio.hxx
 InterfaceGraphic_cPrintf.cxx
Index: oce/src/NIS/NIS_DrawList.cxx
===================================================================
--- oce.orig/src/NIS/NIS_DrawList.cxx
+++ oce/src/NIS/NIS_DrawList.cxx
@@ -24,7 +24,8 @@
 #ifdef WNT
 #include <windows.h>
 #endif
-#include <GL/gl.h>
+
+#include <OpenGl_GlCore11.hxx>
 
 //=======================================================================
 //function : NIS_DrawList()
Index: oce/src/NIS/NIS_SurfaceDrawer.cxx
===================================================================
--- oce.orig/src/NIS/NIS_SurfaceDrawer.cxx
+++ oce/src/NIS/NIS_SurfaceDrawer.cxx
@@ -26,7 +26,8 @@
 #ifdef WNT
 #include <windows.h>
 #endif
-#include <GL/gl.h>
+
+#include <OpenGl_GlCore11.hxx>
 
 static void setColor(GLenum               theFace,
                      Quantity_Parameter * theAmbient,
Index: oce/src/NIS/NIS_TriangulatedDrawer.cxx
===================================================================
--- oce.orig/src/NIS/NIS_TriangulatedDrawer.cxx
+++ oce/src/NIS/NIS_TriangulatedDrawer.cxx
@@ -27,7 +27,8 @@
 #ifdef WNT
 #include <windows.h>
 #endif
-#include <GL/gl.h>
+
+#include <OpenGl_GlCore11.hxx>
 
 // Comment this line if you see no hilighting of triangulations due to negative
 // polygon offsets. Disabling this macro means that all offsets will be created
Index: oce/src/NIS/NIS_View.cxx
===================================================================
--- oce.orig/src/NIS/NIS_View.cxx
+++ oce/src/NIS/NIS_View.cxx
@@ -28,7 +28,8 @@
 #ifdef WNT
 #include <windows.h>
 #endif
-#include <GL/gl.h>
+
+#include <OpenGl_GlCore11.hxx>
 
 IMPLEMENT_STANDARD_HANDLE  (NIS_View, V3d_OrthographicView)
 IMPLEMENT_STANDARD_RTTIEXT (NIS_View, V3d_OrthographicView)
Index: oce/src/OpenGl/EXTERNLIB
===================================================================
--- oce.orig/src/OpenGl/EXTERNLIB
+++ oce/src/OpenGl/EXTERNLIB
@@ -2,6 +2,9 @@ CSF_user32
 CSF_gdi32
 CSF_opengl32
 CSF_glu32
+CSF_objc
+CSF_Appkit
+CSF_IOKit
 CSF_OpenGlLibs
 CSF_AviLibs
 CSF_FREETYPE
Index: oce/src/OpenGl/FILES
===================================================================
--- oce.orig/src/OpenGl/FILES
+++ oce/src/OpenGl/FILES
@@ -77,6 +77,7 @@ OpenGl_Display_2.cxx
 Handle_OpenGl_Window.hxx
 OpenGl_Window.hxx
 OpenGl_Window.cxx
+OpenGl_Window_1.mm
 OpenGl_PriorityList.hxx
 OpenGl_PriorityList.cxx
 OpenGl_AVIWriter.hxx
@@ -103,6 +104,7 @@ OpenGl_tgl_funcs.hxx
 Handle_OpenGl_Context.hxx
 OpenGl_Context.hxx
 OpenGl_Context.cxx
+OpenGl_Context_1.mm
 OpenGl_ArbIns.hxx
 OpenGl_ArbTBO.hxx
 OpenGl_ArbVBO.hxx
Index: oce/src/OpenGl/OpenGl_Context.cxx
===================================================================
--- oce.orig/src/OpenGl/OpenGl_Context.cxx
+++ oce/src/OpenGl/OpenGl_Context.cxx
@@ -1,6 +1,6 @@
 // Created on: 2012-01-26
 // Created by: Kirill GAVRILOV
-// Copyright (c) 2012-2012 OPEN CASCADE SAS
+// Copyright (c) 2012 OPEN CASCADE SAS
 //
 // The content of this file is subject to the Open CASCADE Technology Public
 // License Version 6.5 (the "License"). You may not use the content of this file
@@ -17,7 +17,6 @@
 // purpose or non-infringement. Please see the License for the specific terms
 // and conditions governing the rights and limitations under the License.
 
-
 #if (defined(_WIN32) || defined(__WIN32__))
   #include <windows.h>
 #endif
@@ -143,6 +142,8 @@ void OpenGl_Context::Share (const Handle
   }
 }
 
+#if !defined(__APPLE__) || defined(MACOSX_USE_GLX)
+
 // =======================================================================
 // function : IsCurrent
 // purpose  :
@@ -242,6 +243,8 @@ void OpenGl_Context::SwapBuffers()
 #endif
 }
 
+#endif // __APPLE__
+
 // =======================================================================
 // function : findProc
 // purpose  :
@@ -312,6 +315,8 @@ Standard_Boolean OpenGl_Context::CheckEx
   return Standard_False;
 }
 
+#if !defined(__APPLE__) || defined(MACOSX_USE_GLX)
+
 // =======================================================================
 // function : Init
 // purpose  :
@@ -341,6 +346,8 @@ Standard_Boolean OpenGl_Context::Init()
   return Standard_True;
 }
 
+#endif // __APPLE__
+
 // =======================================================================
 // function : Init
 // purpose  :
@@ -349,6 +356,8 @@ Standard_Boolean OpenGl_Context::Init()
 Standard_Boolean OpenGl_Context::Init (const Aspect_Handle           theWindow,
                                        const Aspect_Handle           theWindowDC,
                                        const Aspect_RenderingContext theGContext)
+#elif defined(__APPLE__) && !defined(MACOSX_USE_GLX)
+Standard_Boolean OpenGl_Context::Init (const void*                   theGContext)
 #else
 Standard_Boolean OpenGl_Context::Init (const Aspect_Drawable         theWindow,
                                        const Aspect_Display          theDisplay,
@@ -356,12 +365,15 @@ Standard_Boolean OpenGl_Context::Init (c
 #endif
 {
   Standard_ProgramError_Raise_if (myIsInitialized, "OpenGl_Context::Init() should be called only once!");
-
+#if (defined(_WIN32) || defined(__WIN32__))
   myWindow   = theWindow;
   myGContext = theGContext;
-#if (defined(_WIN32) || defined(__WIN32__))
   myWindowDC = theWindowDC;
+#elif defined(__APPLE__) && !defined(MACOSX_USE_GLX)
+  myGContext = (void* )theGContext;
 #else
+  myWindow   = theWindow;
+  myGContext = theGContext;
   myDisplay  = theDisplay;
 #endif
   if (myGContext == NULL || !MakeCurrent())
Index: oce/src/OpenGl/OpenGl_Context_1.mm
===================================================================
--- /dev/null
+++ oce/src/OpenGl/OpenGl_Context_1.mm
@@ -0,0 +1,90 @@
+// Created on: 2012-11-12
+// Created by: Kirill GAVRILOV
+// Copyright (c) 2012 OPEN CASCADE SAS
+//
+// The content of this file is subject to the Open CASCADE Technology Public
+// License Version 6.5 (the "License"). You may not use the content of this file
+// except in compliance with the License. Please obtain a copy of the License
+// at http://www.opencascade.org and read it completely before using this file.
+//
+// The Initial Developer of the Original Code is Open CASCADE S.A.S., having its
+// main offices at: 1, place des Freres Montgolfier, 78280 Guyancourt, France.
+//
+// The Original Code and all software distributed under the License is
+// distributed on an "AS IS" basis, without warranty of any kind, and the
+// Initial Developer hereby disclaims all such warranties, including without
+// limitation, any warranties of merchantability, fitness for a particular
+// purpose or non-infringement. Please see the License for the specific terms
+// and conditions governing the rights and limitations under the License.
+
+#if defined(__APPLE__) && !defined(MACOSX_USE_GLX)
+
+#import <Cocoa/Cocoa.h>
+
+#include <OpenGl_GlCore11.hxx>
+#include <OpenGl_Context.hxx>
+
+#include <Standard_ProgramError.hxx>
+
+// =======================================================================
+// function : IsCurrent
+// purpose  :
+// =======================================================================
+Standard_Boolean OpenGl_Context::IsCurrent() const
+{
+  return myGContext != NULL
+      && [NSOpenGLContext currentContext] == (NSOpenGLContext* )myGContext;
+}
+
+// =======================================================================
+// function : MakeCurrent
+// purpose  :
+// =======================================================================
+Standard_Boolean OpenGl_Context::MakeCurrent()
+{
+  if (myGContext == NULL)
+  {
+    Standard_ProgramError_Raise_if (myIsInitialized, "OpenGl_Context::Init() should be called before!");
+    return Standard_False;
+  }
+
+  [(NSOpenGLContext* )myGContext makeCurrentContext];
+  return Standard_True;
+}
+
+// =======================================================================
+// function : SwapBuffers
+// purpose  :
+// =======================================================================
+void OpenGl_Context::SwapBuffers()
+{
+  if (myGContext != NULL)
+  {
+    glFinish();
+    [(NSOpenGLContext* )myGContext flushBuffer];
+  }
+}
+
+// =======================================================================
+// function : Init
+// purpose  :
+// =======================================================================
+Standard_Boolean OpenGl_Context::Init()
+{
+  if (myIsInitialized)
+  {
+    return Standard_True;
+  }
+
+  myGContext = [NSOpenGLContext currentContext];
+  if (myGContext == NULL)
+  {
+    return Standard_False;
+  }
+
+  init();
+  myIsInitialized = Standard_True;
+  return Standard_True;
+}
+
+#endif // __APPLE__
Index: oce/src/OpenGl/OpenGl_Display.cxx
===================================================================
--- oce.orig/src/OpenGl/OpenGl_Display.cxx
+++ oce/src/OpenGl/OpenGl_Display.cxx
@@ -30,7 +30,7 @@
 
 #include <stdio.h>
 
-#if (!defined(_WIN32) && !defined(__WIN32__))
+#if (!defined(_WIN32) && !defined(__WIN32__) && (!defined(__APPLE__) || defined(MACOSX_USE_GLX)))
   #include <X11/Xlib.h> // XOpenDisplay()
 #endif
 
@@ -41,7 +41,7 @@ Handle(OpenGl_Display) openglDisplay;
 
 namespace
 {
-  #if (defined(_WIN32) || defined(__WIN32__))
+  #if (defined(_WIN32) || defined(__WIN32__)) || (defined(__APPLE__) && !defined(MACOSX_USE_GLX))
     static char* TheDummyDisplay = "DISPLAY";
   #endif
 
@@ -67,7 +67,7 @@ OpenGl_Display::OpenGl_Display (const St
   myFont(-1),
   myFontSize(-1)
 {
-#if (defined(_WIN32) || defined(__WIN32__))
+#if (defined(_WIN32) || defined(__WIN32__)) || (defined(__APPLE__) && !defined(MACOSX_USE_GLX))
   myDisplay = TheDummyDisplay;
 #else
   if (theDisplay != NULL && *theDisplay != '\0')
@@ -259,7 +259,7 @@ void OpenGl_Display::Init()
 {
   if (myDisplay != NULL)
   {
-  #if (!defined(_WIN32) && !defined(__WIN32__))
+  #if (!defined(_WIN32) && !defined(__WIN32__) && (!defined(__APPLE__) || defined(MACOSX_USE_GLX)))
     XSynchronize ((Display* )myDisplay, (getenv("CALL_SYNCHRO_X") != NULL) ? 1 : 0);
 
     if (getenv("CSF_GraphicSync") != NULL)
@@ -278,7 +278,7 @@ void OpenGl_Display::Init()
   else
   {
     TCollection_AsciiString msg("OpenGl_Display::Init");
-  #if (!defined(_WIN32) && !defined(__WIN32__))
+  #if (!defined(_WIN32) && !defined(__WIN32__) && (!defined(__APPLE__) || defined(MACOSX_USE_GLX)))
     msg += " : Cannot connect to X server ";
     msg += XDisplayName ((char*) NULL);
   #endif
Index: oce/src/OpenGl/OpenGl_Display_1.cxx
===================================================================
--- oce.orig/src/OpenGl/OpenGl_Display_1.cxx
+++ oce/src/OpenGl/OpenGl_Display_1.cxx
@@ -17,6 +17,7 @@
 // purpose or non-infringement. Please see the License for the specific terms
 // and conditions governing the rights and limitations under the License.
 
+#include <OpenGl_GlCore11.hxx>
 
 #include <InterfaceGraphic.hxx>
 #include <OpenGl_Display.hxx>
@@ -92,9 +93,9 @@ static const FontMapNode myFontMap[] =
 #ifdef HAVE_GL2PS
 static void getGL2PSFontName (const char *src_font, char *ps_font)
 {
-  /* 
+  /*
   Convert font name used for rendering to some "good" font names
-  that produce good vector text 
+  that produce good vector text
   */
   static char const *family[] = {"Helvetica", "Courier", "Times"};
   static char const *italic[] = {"Oblique", "Oblique", "Italic"};
@@ -149,7 +150,7 @@ static void getGL2PSFontName (const char
 /*-----------------------------------------------------------------------------*/
 
 /*
-* Fonctions publiques 
+* Fonctions publiques
 */
 
 /*-----------------------------------------------------------------------------*/
@@ -230,9 +231,9 @@ class MultilineTextRenderer
 {
   private:
 
-  Standard_Integer        myLFNum;        // Number of '\n' (Line Feed) '\x00\x0A' 
+  Standard_Integer        myLFNum;        // Number of '\n' (Line Feed) '\x00\x0A'
   Standard_Integer        myCurrPos;      // Position of the current substring
-  Standard_Integer        myNewStrLen;    // Length of the new string 
+  Standard_Integer        myNewStrLen;    // Length of the new string
   Standard_Integer        mySubstrNum;    // Number of substrings
   wchar_t                 *myNewStr;      // New string
   const wchar_t           *myStrPtr;      // Pointer to the original string
@@ -394,7 +395,7 @@ class MultilineTextRenderer
         anIndex2 += aHelpIndex - 1;
         aTimeVar = 0;
       }
-      else 
+      else
       {
         myNewStr[anIndex2] = *(myStrPtr + anIndex1);
       }
@@ -446,7 +447,7 @@ class MultilineTextRenderer
     case Graphic3d_VTA_CENTER:
       if ( (myLFNum%2) == 0 )   // An odd number of strings
       {
-        theYdis = (GLdouble)((myLFNum/2.0) * theFnt->FaceSize()) + theDescentFont; 
+        theYdis = (GLdouble)((myLFNum/2.0) * theFnt->FaceSize()) + theDescentFont;
       }
       else                      // An even number of strings
       {
@@ -500,7 +501,7 @@ void OpenGl_Display::RenderText (const w
   OpenGl_FontMgr* mgr = OpenGl_FontMgr::instance();
   const FTFont* fnt = mgr->fontById( myFont );
   if ( !fnt )
-    return; 
+    return;
 
   // FTFont changes texture state when it renders and computes size for the text
   glPushAttrib(GL_TEXTURE_BIT);
@@ -556,9 +557,9 @@ void OpenGl_Display::RenderText (const w
       (GLint*)viewport,
       &wx, &wy, &wz );
     glLoadIdentity();
-    gluUnProject( wx, wy, wz, 
+    gluUnProject( wx, wy, wz,
       (GLdouble*)identityMatrix, (GLdouble*)projMatrix, (GLint*)viewport,
-      &x1, &y1 , &z1 );    
+      &x1, &y1 , &z1 );
 
     GLdouble h = (GLdouble)fnt->FaceSize();
 
@@ -568,22 +569,22 @@ void OpenGl_Display::RenderText (const w
 
     h = (y2-y1)/h;
 
-    glTranslated( x1, y1 , z1 );   
+    glTranslated( x1, y1 , z1 );
     glRotated(aspect->Angle(), 0, 0, 1);
-    glTranslated(xdis, ydis, 0);  
+    glTranslated(xdis, ydis, 0);
 
     if( !aspect->IsZoomable() )
     {
 #ifdef WNT
       // if the context has assigned printer context, use it's parameters
-      OpenGl_PrinterContext* aPrinterContext = 
+      OpenGl_PrinterContext* aPrinterContext =
         OpenGl_PrinterContext::GetPrinterContext( GET_GL_CONTEXT() );
       if( aPrinterContext )
       {
         // get printing scaling in x and y dimensions
         GLfloat aTextScalex = 1, aTextScaley = 1;
         aPrinterContext->GetScale( aTextScalex, aTextScaley );
-        
+
         // text should be scaled in all directions with same
         // factor to save its proportions, so use height (y) scaling
         // as it is better for keeping text/3d graphics proportions
@@ -598,9 +599,9 @@ void OpenGl_Display::RenderText (const w
     }
   }
 
-  GLint renderMode;  
+  GLint renderMode;
   glGetIntegerv(GL_RENDER_MODE, &renderMode);
-  if ( renderMode == GL_FEEDBACK ) 
+  if ( renderMode == GL_FEEDBACK )
   {
 #ifdef HAVE_GL2PS
     export_h = (float)fnt->FaceSize() / export_h;
Index: oce/src/OpenGl/OpenGl_FontMgr.cxx
===================================================================
--- oce.orig/src/OpenGl/OpenGl_FontMgr.cxx
+++ oce/src/OpenGl/OpenGl_FontMgr.cxx
@@ -22,7 +22,7 @@
 
 #include <ft2build.h>
 
-#include <GL/gl.h>
+#include <OpenGl_GlCore11.hxx>
 
 #undef TRACE
 
Index: oce/src/OpenGl/OpenGl_GraduatedTrihedron.cxx
===================================================================
--- oce.orig/src/OpenGl/OpenGl_GraduatedTrihedron.cxx
+++ oce/src/OpenGl/OpenGl_GraduatedTrihedron.cxx
@@ -29,7 +29,6 @@
 #include <InterfaceGraphic_Aspect.hxx>
 #include <InterfaceGraphic_Visual3d.hxx>
 
-#include <GL/glu.h> // gluUnProject()
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
Index: oce/src/OpenGl/OpenGl_GraphicDriver_Layer.cxx
===================================================================
--- oce.orig/src/OpenGl/OpenGl_GraphicDriver_Layer.cxx
+++ oce/src/OpenGl/OpenGl_GraphicDriver_Layer.cxx
@@ -28,7 +28,6 @@
 #include <OpenGl_AspectText.hxx>
 #include <OpenGl_TextParam.hxx>
 
-#include <GL/glu.h>
 
 /*----------------------------------------------------------------------*/
 
Index: oce/src/OpenGl/OpenGl_Polygon.cxx
===================================================================
--- oce.orig/src/OpenGl/OpenGl_Polygon.cxx
+++ oce/src/OpenGl/OpenGl_Polygon.cxx
@@ -28,7 +28,6 @@
 #include <OpenGl_AspectFace.hxx>
 #include <OpenGl_Structure.hxx>
 
-#include <GL/glu.h>
 
 #include <stdio.h>
 
Index: oce/src/OpenGl/OpenGl_Text.cxx
===================================================================
--- oce.orig/src/OpenGl/OpenGl_Text.cxx
+++ oce/src/OpenGl/OpenGl_Text.cxx
@@ -23,7 +23,6 @@
 #include <OpenGl_AspectText.hxx>
 #include <OpenGl_Structure.hxx>
 
-#include <GL/glu.h> // gluUnProject()
 
 /*----------------------------------------------------------------------*/
 
Index: oce/src/OpenGl/OpenGl_TextureBox.cxx
===================================================================
--- oce.orig/src/OpenGl/OpenGl_TextureBox.cxx
+++ oce/src/OpenGl/OpenGl_TextureBox.cxx
@@ -77,7 +77,6 @@
 #include <OpenGl_ResourceTexture.hxx>
 #include <OpenGl_Context.hxx>
 
-#include <GL/glu.h> // gluBuild2DMipmaps()
 
 #include <NCollection_Vector.hxx>
 
Index: oce/src/OpenGl/OpenGl_Trihedron.cxx
===================================================================
--- oce.orig/src/OpenGl/OpenGl_Trihedron.cxx
+++ oce/src/OpenGl/OpenGl_Trihedron.cxx
@@ -36,7 +36,6 @@
 #include <OpenGl_View.hxx>
 #include <OpenGl_Trihedron.hxx>
 
-#include <GL/glu.h> // gluNewQuadric()
 
 IMPLEMENT_STANDARD_HANDLE(OpenGl_Trihedron,MMgt_TShared)
 IMPLEMENT_STANDARD_RTTIEXT(OpenGl_Trihedron,MMgt_TShared)
Index: oce/src/OpenGl/OpenGl_View.cxx
===================================================================
--- oce.orig/src/OpenGl/OpenGl_View.cxx
+++ oce/src/OpenGl/OpenGl_View.cxx
@@ -31,7 +31,6 @@
 
 #include <OpenGl_transform_persistence.hxx>
 
-#include <GL/glu.h> // gluUnProject()
 
 IMPLEMENT_STANDARD_HANDLE(OpenGl_View,MMgt_TShared)
 IMPLEMENT_STANDARD_RTTIEXT(OpenGl_View,MMgt_TShared)
Index: oce/src/OpenGl/OpenGl_View_1.cxx
===================================================================
--- oce.orig/src/OpenGl/OpenGl_View_1.cxx
+++ oce/src/OpenGl/OpenGl_View_1.cxx
@@ -28,7 +28,6 @@
 #include <OpenGl_PrinterContext.hxx>
 #include <OpenGl_Workspace.hxx>
 
-#include <GL/glu.h> // gluProject(), gluUnProject()
 
 /*----------------------------------------------------------------------*/
 
Index: oce/src/OpenGl/OpenGl_View_2.cxx
===================================================================
--- oce.orig/src/OpenGl/OpenGl_View_2.cxx
+++ oce/src/OpenGl/OpenGl_View_2.cxx
@@ -38,7 +38,6 @@
 #include <OpenGl_PrinterContext.hxx>
 #include <OpenGl_Structure.hxx>
 
-#include <GL/glu.h> // gluBuild2DMipmaps()
 
 #define EPSI 0.0001
 
Index: oce/src/OpenGl/OpenGl_Window.cxx
===================================================================
--- oce.orig/src/OpenGl/OpenGl_Window.cxx
+++ oce/src/OpenGl/OpenGl_Window.cxx
@@ -17,7 +17,6 @@
 // purpose or non-infringement. Please see the License for the specific terms
 // and conditions governing the rights and limitations under the License.
 
-
 #include <InterfaceGraphic.hxx>
 
 #include <OpenGl_Window.hxx>
@@ -28,11 +27,12 @@
 #include <Aspect_GraphicDeviceDefinitionError.hxx>
 #include <TCollection_AsciiString.hxx>
 
-#include <GL/glu.h> // gluOrtho2D()
 
 IMPLEMENT_STANDARD_HANDLE(OpenGl_Window,MMgt_TShared)
 IMPLEMENT_STANDARD_RTTIEXT(OpenGl_Window,MMgt_TShared)
 
+#if !defined(__APPLE__) || defined(MACOSX_USE_GLX)
+
 namespace
 {
   static const TEL_COLOUR THE_DEFAULT_BG_COLOR = { { 0.F, 0.F, 0.F, 1.F } };
@@ -436,6 +436,8 @@ OpenGl_Window::~OpenGl_Window()
 #endif
 }
 
+#endif // !__APPLE__
+
 // =======================================================================
 // function : Activate
 // purpose  :
@@ -445,6 +447,8 @@ Standard_Boolean OpenGl_Window::Activate
   return myGlContext->MakeCurrent();
 }
 
+#if !defined(__APPLE__) || defined(MACOSX_USE_GLX)
+
 // =======================================================================
 // function : Resize
 // purpose  : call_subr_resize
@@ -470,6 +474,8 @@ void OpenGl_Window::Resize (const CALL_D
   Init();
 }
 
+#endif // !__APPLE__
+
 // =======================================================================
 // function : ReadDepths
 // purpose  : TelReadDepths
@@ -506,6 +512,8 @@ void OpenGl_Window::SetBackgroundColor (
   myBgColor.rgb[2] = theB;
 }
 
+#if !defined(__APPLE__) || defined(MACOSX_USE_GLX)
+
 // =======================================================================
 // function : Init
 // purpose  :
@@ -539,6 +547,8 @@ void OpenGl_Window::Init()
   glDrawBuffer (GL_BACK);
 }
 
+#endif // !__APPLE__
+
 // =======================================================================
 // function : EnablePolygonOffset
 // purpose  : call_subr_enable_polygon_offset
Index: oce/src/OpenGl/OpenGl_Window_1.mm
===================================================================
--- /dev/null
+++ oce/src/OpenGl/OpenGl_Window_1.mm
@@ -0,0 +1,160 @@
+// Created on: 2012-11-12
+// Created by: Kirill Gavrilov
+// Copyright (c) 2012 OPEN CASCADE SAS
+//
+// The content of this file is subject to the Open CASCADE Technology Public
+// License Version 6.5 (the "License"). You may not use the content of this file
+// except in compliance with the License. Please obtain a copy of the License
+// at http://www.opencascade.org and read it completely before using this file.
+//
+// The Initial Developer of the Original Code is Open CASCADE S.A.S., having its
+// main offices at: 1, place des Freres Montgolfier, 78280 Guyancourt, France.
+//
+// The Original Code and all software distributed under the License is
+// distributed on an "AS IS" basis, without warranty of any kind, and the
+// Initial Developer hereby disclaims all such warranties, including without
+// limitation, any warranties of merchantability, fitness for a particular
+// purpose or non-infringement. Please see the License for the specific terms
+// and conditions governing the rights and limitations under the License.
+
+#if defined(__APPLE__) && !defined(MACOSX_USE_GLX)
+
+#import <Cocoa/Cocoa.h>
+
+#include <InterfaceGraphic.hxx>
+
+#include <OpenGl_Window.hxx>
+
+#include <OpenGl_Context.hxx>
+#include <OpenGl_Display.hxx>
+#include <Aspect_GraphicDeviceDefinitionError.hxx>
+#include <Cocoa_LocalPool.hxx>
+#include <TCollection_AsciiString.hxx>
+
+namespace
+{
+  static const TEL_COLOUR THE_DEFAULT_BG_COLOR = { { 0.F, 0.F, 0.F, 1.F } };
+  static const NSOpenGLPixelFormatAttribute THE_DOUBLE_BUFF[] = {
+    //NSOpenGLPFAColorSize, (NSOpenGLPixelFormatAttribute )32,
+    NSOpenGLPFADepthSize,   (NSOpenGLPixelFormatAttribute )24,
+    NSOpenGLPFAStencilSize, (NSOpenGLPixelFormatAttribute )8,
+    NSOpenGLPFADoubleBuffer,
+    NSOpenGLPFAAccelerated,
+    0
+  };
+
+};
+
+// =======================================================================
+// function : OpenGl_Window
+// purpose  :
+// =======================================================================
+OpenGl_Window::OpenGl_Window (const Handle(OpenGl_Display)& theDisplay,
+                              const CALL_DEF_WINDOW&        theCWindow,
+                              Aspect_RenderingContext       theGContext,
+                              const Handle(OpenGl_Context)& theShareCtx)
+: myDisplay (theDisplay),
+  myGlContext (new OpenGl_Context()),
+  myOwnGContext (theGContext == 0),
+  myWidth ((Standard_Integer )theCWindow.dx),
+  myHeight ((Standard_Integer )theCWindow.dy),
+  myBgColor (THE_DEFAULT_BG_COLOR),
+  myDither (theDisplay->Dither()),
+  myBackDither (theDisplay->BackDither())
+{
+  myBgColor.rgb[0] = theCWindow.Background.r;
+  myBgColor.rgb[1] = theCWindow.Background.g;
+  myBgColor.rgb[2] = theCWindow.Background.b;
+
+  Cocoa_LocalPool aLocalPool;
+  //NSOpenGLContext* aGContext = (NSOpenGLContext* )theGContext;
+
+  // all GL context within one OpenGl_GraphicDriver should be shared!
+  NSOpenGLContext*     aGLCtxShare = theShareCtx.IsNull() ? NULL : (NSOpenGLContext* )theShareCtx->myGContext;
+  NSOpenGLPixelFormat* aGLFormat   = [[[NSOpenGLPixelFormat alloc] initWithAttributes: THE_DOUBLE_BUFF] autorelease];
+  NSOpenGLContext*     aGLContext  = [[NSOpenGLContext alloc] initWithFormat: aGLFormat
+                                                                shareContext: aGLCtxShare];
+  if (aGLContext == NULL)
+  {
+    TCollection_AsciiString aMsg ("OpenGl_Window::CreateWindow: NSOpenGLContext creation failed");
+    Aspect_GraphicDeviceDefinitionError::Raise (aMsg.ToCString());
+    return;
+  }
+
+  NSView* aView = (NSView* )theCWindow.XWindow;
+  [aGLContext setView: aView];
+
+  myGlContext->Init (aGLContext);
+  myGlContext->Share (theShareCtx);
+  Init();
+}
+
+// =======================================================================
+// function : ~OpenGl_Window
+// purpose  :
+// =======================================================================
+OpenGl_Window::~OpenGl_Window()
+{
+  NSOpenGLContext* aGLCtx = (NSOpenGLContext* )myGlContext->myGContext;
+  myGlContext.Nullify();
+
+  [NSOpenGLContext clearCurrentContext];
+  if (myOwnGContext)
+  {
+    [aGLCtx clearDrawable];
+    [aGLCtx release];
+  }
+}
+
+// =======================================================================
+// function : Resize
+// purpose  : call_subr_resize
+// =======================================================================
+void OpenGl_Window::Resize (const CALL_DEF_WINDOW& theCWindow)
+{
+  DISPLAY* aDisp = (DISPLAY* )myDisplay->GetDisplay();
+  if (aDisp == NULL)
+  {
+    return;
+  }
+
+  // If the size is not changed - do nothing
+  if ((myWidth == theCWindow.dx) && (myHeight == theCWindow.dy))
+  {
+    return;
+  }
+
+  myWidth  = (Standard_Integer )theCWindow.dx;
+  myHeight = (Standard_Integer )theCWindow.dy;
+
+  Init();
+}
+
+// =======================================================================
+// function : Init
+// purpose  :
+// =======================================================================
+void OpenGl_Window::Init()
+{
+  if (!Activate())
+  {
+    return;
+  }
+
+  NSOpenGLContext* aGLCtx = (NSOpenGLContext* )myGlContext->myGContext;
+  NSRect aBounds = [[aGLCtx view] bounds];
+
+  // we should call this method each time when window is resized
+  [aGLCtx update];
+
+  myWidth  = Standard_Integer(aBounds.size.width);
+  myHeight = Standard_Integer(aBounds.size.height);
+
+  glMatrixMode (GL_MODELVIEW);
+  glViewport (0, 0, myWidth, myHeight);
+
+  glDisable (GL_SCISSOR_TEST);
+  glDrawBuffer (GL_BACK);
+}
+
+#endif // __APPLE__
Index: oce/src/OpenGl/OpenGl_Workspace_2.cxx
===================================================================
--- oce.orig/src/OpenGl/OpenGl_Workspace_2.cxx
+++ oce/src/OpenGl/OpenGl_Workspace_2.cxx
@@ -28,7 +28,7 @@
 # include <config.h>
 #endif
 
-#ifdef HAVE_FREEIMAGE
+#if (defined(_WIN32) || defined(__WIN32__)) && defined(HAVE_FREEIMAGE)
   #include <NCollection_Handle.hxx>
   #include <FreeImagePlus.h>
   typedef NCollection_Handle<fipImage> FipHandle;
@@ -39,7 +39,6 @@
 #include <OpenGl_View.hxx>
 #include <OpenGl_Display.hxx>
 
-#include <GL/glu.h> // gluOrtho2D()
 
 //10-05-96 : CAL ; Ajout d'un nouveau delta dans les copies de pixels (voir CALL_DEF_DELTA)
 #define CALL_DEF_DELTA 10
@@ -68,7 +67,7 @@ static void getMaxFrameSize(Standard_Int
   GLint aTexDim = 2048;
   glGetIntegerv (GL_MAX_VIEWPORT_DIMS, (GLint*) &aVpDim);
   glGetIntegerv (GL_MAX_TEXTURE_SIZE, &aTexDim);
-  (aVpDim[0] >= aTexDim) ? aMaxX = (GLsizei) aTexDim : 
+  (aVpDim[0] >= aTexDim) ? aMaxX = (GLsizei) aTexDim :
                            aMaxX = getNearestPowOfTwo((GLsizei)aVpDim[0]);
   (aVpDim[1] >= aTexDim) ? aMaxY = (GLsizei) aTexDim :
                            aMaxY = getNearestPowOfTwo((GLsizei)aVpDim[1]);
@@ -96,7 +95,7 @@ static void fitDimensionsRatio (Standard
 
 // ---------------------------------------------------------------
 // Function: getDimensionsTiling
-// Purpose:  calculate maximum possible dimensions for framebuffer 
+// Purpose:  calculate maximum possible dimensions for framebuffer
 //           in tiling mode according to the view size
 // ---------------------------------------------------------------
 static void getDimensionsTiling (Standard_Integer& theFrameWidth,
@@ -131,7 +130,7 @@ static void initBufferStretch (Standard_
   Standard_Real aWidthRate  = (Standard_Real)theFrameWidth /theViewWidth;
   Standard_Real aHeightRate = (Standard_Real)theFrameHeight/theViewHeight;
 
-  if ((aWidthRate > 1 && aHeightRate > 1 && aWidthRate >= aHeightRate) || 
+  if ((aWidthRate > 1 && aHeightRate > 1 && aWidthRate >= aHeightRate) ||
       (aWidthRate > 1 && aHeightRate <= 1))
   {
     theFrameWidth  = (Standard_Integer)(theFrameWidth /aWidthRate);
@@ -200,13 +199,13 @@ static void initBitmapBuffer (const HDC
 // Purpose:  copy the data from image buffer to the device context
 // ---------------------------------------------------------------
 static bool imagePasteDC(HDC theDstDC,    FipHandle theImage, int theOffsetX,
-                         int theOffsetY,  int theWidth, int theHeight, 
+                         int theOffsetY,  int theWidth, int theHeight,
                          int theLeft = 0, int theTop = 0)
 {
   // get image parameters
   BITMAPINFO* aBitmapData = theImage->getInfo ();
   SetStretchBltMode (theDstDC, STRETCH_HALFTONE);
- 
+
   // organize blocks data passing if memory isn't enough to pass all the data
   // at once
   int aLinesComplete = 0, aMaxBlockWidth = theHeight, aBlockWidth = 0,
@@ -275,7 +274,7 @@ static bool imageStretchDC(HDC theDstDC,
   unsigned int heightPx   = theImage->getHeight ();
   BITMAPINFO* aBitmapData = theImage->getInfo ();
   SetStretchBltMode (theDstDC, STRETCH_HALFTONE);
-  
+
   // pass lines and check if operation is succesfull
   int aPassed = 0;
   aPassed = StretchDIBits (theDstDC, theOffsetX, theOffsetY, theWidth,
@@ -284,7 +283,7 @@ static bool imageStretchDC(HDC theDstDC,
 
   if (aPassed != heightPx)
     return false;
- 
+
   return true;
 }
 #endif
@@ -295,8 +294,8 @@ static bool imageStretchDC(HDC theDstDC,
 
 //call_togl_print
 Standard_Boolean OpenGl_Workspace::Print
-  (const Graphic3d_CView& ACView, 
-   const Aspect_CLayer2d& ACUnderLayer, 
+  (const Graphic3d_CView& ACView,
+   const Aspect_CLayer2d& ACUnderLayer,
    const Aspect_CLayer2d& ACOverLayer,
    const Aspect_Handle    hPrintDC,// const Aspect_Drawable hPrintDC,
    const Standard_Boolean showBackground,
@@ -419,7 +418,7 @@ Standard_Boolean OpenGl_Workspace::Print
       }
 #else
       // try to allocate compatible bitmap and necessary resources
-      initBitmapBuffer (hMemDC, hViewBitmap, 
+      initBitmapBuffer (hMemDC, hViewBitmap,
                         aFrameWidth, aFrameHeight, aViewBuffer);
       if (!aViewBuffer)
       {
@@ -489,7 +488,7 @@ Standard_Boolean OpenGl_Workspace::Print
           break;
 #else
         // try to allocate compatible bitmap and necessary resources
-        initBitmapBuffer (hMemDC, hViewBitmap, 
+        initBitmapBuffer (hMemDC, hViewBitmap,
                           aFrameWidth, aFrameHeight, aViewBuffer);
         if (!aViewBuffer)
         {
@@ -511,7 +510,7 @@ Standard_Boolean OpenGl_Workspace::Print
       aMaxHeight = aMaxHeight >> 1;
     }
 
-    // check if there are proper dimensions 
+    // check if there are proper dimensions
     if (aMaxWidth <= 1 || aMaxHeight <= 1)
     {
       MessageBox (NULL, "Print failed: can't allocate buffer for printing.",
@@ -529,7 +528,7 @@ Standard_Boolean OpenGl_Workspace::Print
   }
 
   // setup printing context and viewport
-  GLint aViewPortBack[4]; 
+  GLint aViewPortBack[4];
   GLint anAlignBack = 1;
 
   OpenGl_PrinterContext aPrinterContext (GetGContext());
@@ -616,9 +615,9 @@ Standard_Boolean OpenGl_Workspace::Print
     // calculate total count of frames and cropping size
     Standard_Integer aPxCropx = 0;
     Standard_Integer aPxCropy = 0;
-    Standard_Integer aTotalx = 
+    Standard_Integer aTotalx =
                      (Standard_Integer)floor ((float)width /aFrameWidth);
-    Standard_Integer aTotaly = 
+    Standard_Integer aTotaly =
                      (Standard_Integer)floor ((float)height/aFrameHeight);
     if (width %aFrameWidth != 0)
     {
@@ -718,7 +717,7 @@ Standard_Boolean OpenGl_Workspace::Print
       // stop operation if errors
       if (!isDone)
         break;
- 
+
       // calculate new view offset for x-coordinate
       aOffsetx += 2.0;
       aSubLeft += aRight-aLeft;
@@ -738,12 +737,12 @@ Standard_Boolean OpenGl_Workspace::Print
     if (GetObjectType (hPrnDC) == OBJ_DC)
       AbortDoc (hPrnDC);
   }
-  
+
   // return OpenGl to the previous state
   aPrinterContext.Deactivate ();
   glPixelStorei (GL_PACK_ALIGNMENT, anAlignBack);
   aFrameBuffer->UnbindBuffer (GetGlContext());
-  glViewport (aViewPortBack[0], aViewPortBack[1], 
+  glViewport (aViewPortBack[0], aViewPortBack[1],
               aViewPortBack[2], aViewPortBack[3]);
   if (aPrevBuffer)
   {
@@ -772,14 +771,14 @@ Standard_Boolean OpenGl_Workspace::Print
 
 #else // not WNT
   return Standard_False;
-#endif 
+#endif
 }
 
 /*----------------------------------------------------------------------*/
 
 //redrawView
-void OpenGl_Workspace::Redraw1 (const Graphic3d_CView& ACView, 
-                               const Aspect_CLayer2d& ACUnderLayer, 
+void OpenGl_Workspace::Redraw1 (const Graphic3d_CView& ACView,
+                               const Aspect_CLayer2d& ACUnderLayer,
                                const Aspect_CLayer2d& ACOverLayer,
                                const int aswap)
 {
@@ -862,7 +861,7 @@ void OpenGl_Workspace::CopyBuffers (Tint
   GLsizei width = myWidth+1, height = myHeight+1;
   Tfloat xmr = 0, ymr = 0;
 
-  if (flag) 
+  if (flag)
   {
     if (!myView.IsNull()) //szvgl: use vid here!
 	{
Index: oce/src/QADraw/QADraw.cxx
===================================================================
--- oce.orig/src/QADraw/QADraw.cxx
+++ oce/src/QADraw/QADraw.cxx
@@ -18,6 +18,9 @@
 // and conditions governing the rights and limitations under the License.
 
 
+#ifdef HAVE_CONFIG_H
+# include <oce-config.h>
+#endif
 
 #if defined(WNT)
 #include <windows.h>
@@ -1115,6 +1118,7 @@ static int QAxwd (Draw_Interpretor& di,
     GetClientRect((HWND)dout.GetWindow(id), &rc);
     SaveWindowToFile(aGd,(HWND)dout.GetWindow(id),(char*)file,rc.left, rc.top,rc.right-rc.left, rc.bottom-rc.top);
 #else
+#if !defined(__APPLE__) || defined(MACOSX_USE_GLX)
     XSync(Draw_WindowDisplay,True);
 
     XWindowAttributes winAttr;
@@ -1126,6 +1130,7 @@ static int QAxwd (Draw_Interpretor& di,
 
     Xw_save_image_adv(Draw_WindowDisplay,dout.GetWindow(id),winAttr,pximage,Draw_WindowColorMap,256,(char*)file);
 #endif
+#endif
   }
 
   return 0;
Index: oce/src/TKDraw/EXTERNLIB
===================================================================
--- oce.orig/src/TKDraw/EXTERNLIB
+++ oce/src/TKDraw/EXTERNLIB
@@ -14,3 +14,6 @@ CSF_TclTkLibs
 CSF_gdi32
 CSF_advapi32
 CSF_user32
+CSF_objc
+CSF_Appkit
+CSF_IOKit
Index: oce/src/TKOpenGl/EXTERNLIB
===================================================================
--- oce.orig/src/TKOpenGl/EXTERNLIB
+++ oce/src/TKOpenGl/EXTERNLIB
@@ -2,6 +2,9 @@ TKernel
 TKService
 TKV3d
 CSF_OpenGlLibs
+CSF_objc
+CSF_Appkit
+CSF_IOKit
 CSF_FREETYPE
 CSF_FTGL
 CSF_GL2PS
Index: oce/src/TKService/EXTERNLIB
===================================================================
--- oce.orig/src/TKService/EXTERNLIB
+++ oce/src/TKService/EXTERNLIB
@@ -3,4 +3,7 @@ TKMath
 CSF_XwLibs
 CSF_dpsLibs
 CSF_XmuLibs
+CSF_objc
+CSF_Appkit
+CSF_IOKit
 CSF_FreeImagePlus
Index: oce/src/TKService/PACKAGES
===================================================================
--- oce.orig/src/TKService/PACKAGES
+++ oce/src/TKService/PACKAGES
@@ -11,5 +11,7 @@ Image
 PlotMgt
 ImageUtility
 WNT
+Cocoa
 TColQuantity
 Font
+
Index: oce/src/TKViewerTest/EXTERNLIB
===================================================================
--- oce.orig/src/TKViewerTest/EXTERNLIB
+++ oce/src/TKViewerTest/EXTERNLIB
@@ -25,3 +25,6 @@ CSF_TclTkLibs
 CSF_user32
 CSF_gdi32
 CSF_OpenGlLibs
+CSF_objc
+CSF_Appkit
+CSF_IOKit
Index: oce/src/Viewer2dTest/Viewer2dTest_ViewerCommands.cxx
===================================================================
--- oce.orig/src/Viewer2dTest/Viewer2dTest_ViewerCommands.cxx
+++ oce/src/Viewer2dTest/Viewer2dTest_ViewerCommands.cxx
@@ -23,6 +23,10 @@
 #include <windows.h>
 #endif
 
+#ifdef HAVE_CONFIG_H
+# include <oce-config.h>
+#endif
+
 #include <Viewer2dTest.hxx>
 #include <Viewer2dTest_EventManager.hxx>
 #include <Viewer2dTest_DataMapOfText.hxx>
@@ -883,6 +887,7 @@ int ViewerMainLoop2d (Standard_Integer a
 {
   Standard_Boolean pick = argc > 0;
 
+#if !defined(__APPLE__) || defined(MACOSX_USE_GLX)
   // X11 Event loop
   static XEvent report;
 
@@ -993,6 +998,7 @@ int ViewerMainLoop2d (Standard_Integer a
     }
     break;
   }
+#endif
 
   return pick;
 }
@@ -1004,11 +1010,13 @@ int ViewerMainLoop2d (Standard_Integer a
 //==============================================================================
 static void VProcessEvents2d (ClientData, int)
 {
+#if !defined(__APPLE__) || defined(MACOSX_USE_GLX)
   // test for X Event
   while (XPending(display2d))
   {
     ViewerMainLoop2d(0, NULL);
   }
+#endif
 }
 #endif
 
@@ -1019,6 +1027,7 @@ static void VProcessEvents2d (ClientData
 static void OSWindowSetup2d()
 {
 #ifndef WNT
+#if !defined(__APPLE__) || defined(MACOSX_USE_GLX)
   // X11
   Window  window = VT_GetWindow2d()->XWindow();
 
@@ -1042,6 +1051,7 @@ static void OSWindowSetup2d()
                Button1MotionMask | Button2MotionMask | Button3MotionMask);
 
   XSynchronize(display2d, 0);
+#endif
 
 #else
   // WNT
Index: oce/src/ViewerTest/EXTERNLIB
===================================================================
--- /dev/null
+++ oce/src/ViewerTest/EXTERNLIB
@@ -0,0 +1,3 @@
+CSF_objc
+CSF_Appkit
+CSF_IOKit
Index: oce/src/ViewerTest/FILES
===================================================================
--- oce.orig/src/ViewerTest/FILES
+++ oce/src/ViewerTest/FILES
@@ -1,3 +1,4 @@
+EXTERNLIB
 ViewerTest_CMPLRS.edl
 ViewerTest_AviCommands.cxx
 ViewerTest_ViewerCommands.cxx
@@ -6,3 +7,4 @@ ViewerTest_ObjectCommands.cxx
 ViewerTest_FilletCommands.cxx
 ViewerTest_VoxelCommands.cxx
 ViewerTest_OpenGlCommands.cxx
+ViewerTest_ViewerCommands_1.mm
Index: oce/src/ViewerTest/ViewerTest_ViewerCommands.cxx
===================================================================
--- oce.orig/src/ViewerTest/ViewerTest_ViewerCommands.cxx
+++ oce/src/ViewerTest/ViewerTest_ViewerCommands.cxx
@@ -61,25 +61,26 @@
 #include <Visual3d_Layer.hxx>
 #include <cstdlib>
 
-#ifndef WNT
-#include <Graphic3d_GraphicDevice.hxx>
-#include <Xw_GraphicDevice.hxx>
-#include <Xw_WindowQuality.hxx>
-#include <Xw_Window.hxx>
-#include <X11/Xlib.h> /* contains some dangerous #defines such as Status, True etc. */
-#include <X11/Xutil.h>
-#include <tk.h>
-
+#if defined(_WIN32) || defined(__WIN32__)
+  #include <Graphic3d_WNTGraphicDevice.hxx>
+  #include <WNT_WClass.hxx>
+  #include <WNT_Window.hxx>
+
+  #if defined(_MSC_VER)
+    #define _CRT_SECURE_NO_DEPRECATE
+  #endif
+#elif defined(__APPLE__) && !defined(MACOSX_USE_GLX)
+  #include <Graphic3d_GraphicDevice.hxx>
+  #include <Cocoa_Window.hxx>
+  #include <tk.h>
 #else
-
-#include <Graphic3d_WNTGraphicDevice.hxx>
-#include <WNT_WClass.hxx>
-#include <WNT_Window.hxx>
-
-#ifdef _MSC_VER
-#define _CRT_SECURE_NO_DEPRECATE
-#endif
-
+  #include <Graphic3d_GraphicDevice.hxx>
+  #include <Xw_GraphicDevice.hxx>
+  #include <Xw_WindowQuality.hxx>
+  #include <Xw_Window.hxx>
+  #include <X11/Xlib.h> /* contains some dangerous #defines such as Status, True etc. */
+  #include <X11/Xutil.h>
+  #include <tk.h>
 #endif
 
 #ifndef max
@@ -89,8 +90,6 @@
 # define min(a, b)  (((a) < (b)) ? (a) : (b)) 
 #endif
 
-#define OCC120
-
 //==============================================================================
 
 //==============================================================================
@@ -102,7 +101,7 @@ Standard_IMPORT Standard_Boolean Draw_Vi
 Standard_EXPORT int ViewerMainLoop(Standard_Integer , const char** argv);
 extern const Handle(NIS_InteractiveContext)& TheNISContext();
 
-#ifdef WNT
+#if defined(_WIN32) || defined(__WIN32__)
 static Handle(Graphic3d_WNTGraphicDevice)& GetG3dDevice(){
   static Handle(Graphic3d_WNTGraphicDevice) GD;
   return GD;
@@ -112,7 +111,18 @@ static Handle(WNT_Window)& VT_GetWindow(
   static Handle(WNT_Window) WNTWin;
   return WNTWin;
 }
-
+#elif defined(__APPLE__) && !defined(MACOSX_USE_GLX)
+static Handle(Graphic3d_GraphicDevice)& GetG3dDevice()
+{
+  static Handle(Graphic3d_GraphicDevice) aGraphicDevice;
+  return aGraphicDevice;
+}
+static Handle(Cocoa_Window)& VT_GetWindow()
+{
+  static Handle(Cocoa_Window) aWindow;
+  return aWindow;
+}
+extern void ViewerTest_SetCocoaEventManagerView (const Handle(Cocoa_Window)& theWindow);
 #else
 static Handle(Graphic3d_GraphicDevice)& GetG3dDevice(){
   static Handle(Graphic3d_GraphicDevice) GD;
@@ -127,9 +137,7 @@ static Display *display;
 static void VProcessEvents(ClientData,int);
 #endif
 
-#ifdef OCC120
 static Standard_Boolean DegenerateMode = Standard_True;
-#endif
 
 #define ZCLIPWIDTH 1.
 
@@ -141,9 +149,12 @@ static void OSWindowSetup();
 
 static int Start_Rot = 0;
 static int ZClipIsOn = 0;
-static int X_Motion= 0,Y_Motion=0; // Current cursor position
-static int X_ButtonPress = 0, Y_ButtonPress = 0; // Last ButtonPress position
-
+int X_Motion = 0; // Current cursor position
+int Y_Motion = 0;
+int X_ButtonPress = 0; // Last ButtonPress position
+int Y_ButtonPress = 0;
+Standard_Boolean IsDragged = Standard_False;
+Standard_Boolean DragFirst;
 
 //==============================================================================
 
@@ -169,8 +180,9 @@ static LRESULT WINAPI AdvViewerWindowPro
 const Handle(MMgt_TShared)& ViewerTest::WClass()
 {
   static Handle(MMgt_TShared) theWClass;
-#ifdef WNT
-  if (theWClass.IsNull()) {
+#if defined(_WIN32) || defined(__WIN32__)
+  if (theWClass.IsNull())
+  {
     theWClass = new WNT_WClass ("GW3D_Class", AdvViewerWindowProc,
       CS_VREDRAW | CS_HREDRAW, 0, 0,
       ::LoadCursor (NULL, IDC_ARROW));
@@ -190,9 +202,9 @@ void ViewerTest::ViewerInit (const Stand
   static Standard_Boolean isFirst = Standard_True;
 
   // Default position and dimension of the viewer window.
-  // Note that left top corner is set to be sufficiently small to have 
+  // Note that left top corner is set to be sufficiently small to have
   // window fit in the small screens (actual for remote desktops, see #23003).
-  // The position corresponds to the window's client area, thus some 
+  // The position corresponds to the window's client area, thus some
   // gap is added for window frame to be visible.
   Standard_Integer aPxLeft   = 20;
   Standard_Integer aPxTop    = 40;
@@ -209,7 +221,7 @@ void ViewerTest::ViewerInit (const Stand
   if (isFirst)
   {
     // Create the Graphic device
-#ifdef WNT
+#if defined(_WIN32) || defined(__WIN32__)
     if (GetG3dDevice().IsNull()) GetG3dDevice() = new Graphic3d_WNTGraphicDevice();
     if (VT_GetWindow().IsNull())
     {
@@ -222,7 +234,18 @@ void ViewerTest::ViewerInit (const Stand
                                        aPxLeft, aPxTop,
                                        aPxWidth, aPxHeight,
                                        Quantity_NOC_BLACK);
-      VT_GetWindow()->SetVirtual (Draw_VirtualWindows);
+    }
+#elif defined(__APPLE__) && !defined(MACOSX_USE_GLX)
+    if (GetG3dDevice().IsNull())
+    {
+      GetG3dDevice() = new Graphic3d_GraphicDevice (getenv ("DISPLAY"), Xw_TOM_READONLY);
+    }
+    if (VT_GetWindow().IsNull())
+    {
+      VT_GetWindow() = new Cocoa_Window ("Test3d",
+                                         aPxLeft, aPxTop,
+                                         aPxWidth, aPxHeight);
+      ViewerTest_SetCocoaEventManagerView (VT_GetWindow());
     }
 #else
     if (GetG3dDevice().IsNull()) GetG3dDevice() =
@@ -235,9 +258,9 @@ void ViewerTest::ViewerInit (const Stand
                                       aPxWidth, aPxHeight,
                                       Xw_WQ_3DQUALITY,
                                       Quantity_NOC_BLACK);
-      VT_GetWindow()->SetVirtual (Draw_VirtualWindows);
     }
 #endif
+    VT_GetWindow()->SetVirtual (Draw_VirtualWindows);
 
     Handle(V3d_Viewer) a3DViewer, a3DCollector;
     // Viewer and View creation
@@ -274,9 +297,7 @@ void ViewerTest::ViewerInit (const Stand
     Handle (V3d_View) V = ViewerTest::CurrentView();
 
     V->SetDegenerateModeOn();
-#ifdef OCC120
     DegenerateMode = V->DegenerateModeIsOn();
-#endif
     //    V->SetWindow(VT_GetWindow(), NULL, MyViewProc, NULL);
 
     V->SetZClippingDepth(0.5);
@@ -284,19 +305,21 @@ void ViewerTest::ViewerInit (const Stand
     a3DViewer->SetDefaultLights();
     a3DViewer->SetLightOn();
 
-#ifndef WNT
-#if TCL_MAJOR_VERSION  < 8
+  #if !defined(_WIN32) && !defined(__WIN32__) && (!defined(__APPLE__) || defined(MACOSX_USE_GLX))
+  #if TCL_MAJOR_VERSION  < 8
     Tk_CreateFileHandler((void*)ConnectionNumber(display),
       TK_READABLE, VProcessEvents, (ClientData) VT_GetWindow()->XWindow() );
-#else
+  #else
     Tk_CreateFileHandler(ConnectionNumber(display),
       TK_READABLE, VProcessEvents, (ClientData) VT_GetWindow()->XWindow() );
-#endif
-#endif
+  #endif
+  #endif
 
     isFirst = Standard_False;
   }
+
   VT_GetWindow()->Map();
+  ViewerTest::CurrentView()->Redraw();
 }
 
 //==============================================================================
@@ -316,11 +339,10 @@ static int VInit (Draw_Interpretor& , St
 }
 
 //==============================================================================
-//function : ProcessKeyPress
+//function : VT_ProcessKeyPress
 //purpose  : Handle KeyPress event from a CString
 //==============================================================================
-
-static void ProcessKeyPress( char *buf_ret )
+void VT_ProcessKeyPress (const char* buf_ret)
 {
   //cout << "KeyPress" << endl;
   const Handle(V3d_View) aView = ViewerTest::CurrentView();
@@ -345,20 +367,15 @@ static void ProcessKeyPress( char *buf_r
   else if ( !strcasecmp(buf_ret, "H") ) {
     // HLR
     cout << "HLR" << endl;
-#ifdef OCC120
+
     if (aView->DegenerateModeIsOn()) ViewerTest::CurrentView()->SetDegenerateModeOff();
     else aView->SetDegenerateModeOn();
     DegenerateMode = aView->DegenerateModeIsOn();
-#else
-    ViewerTest::CurrentView()->SetDegenerateModeOff();
-#endif
   }
   else if ( !strcasecmp(buf_ret, "S") ) {
     // SHADING
     cout << "passage en mode 1 (shading pour les shapes)" << endl;
-#ifndef OCC120
-    ViewerTest::CurrentView()->SetDegenerateModeOn();
-#endif
+
     Handle(AIS_InteractiveContext) Ctx = ViewerTest::GetAISContext();
     if(Ctx->NbCurrents()==0 ||
       Ctx->NbSelected()==0)
@@ -378,9 +395,7 @@ static void ProcessKeyPress( char *buf_r
   else if ( !strcasecmp(buf_ret, "U") ) {
     // Unset display mode
     cout<<"passage au mode par defaut"<<endl;
-#ifndef OCC120
-    ViewerTest::CurrentView()->SetDegenerateModeOn();
-#endif
+
     Handle(AIS_InteractiveContext) Ctx = ViewerTest::GetAISContext();
     if(Ctx->NbCurrents()==0 ||
       Ctx->NbSelected()==0)
@@ -417,13 +432,7 @@ static void ProcessKeyPress( char *buf_r
 
   else if ( !strcasecmp(buf_ret, "W") ) {
     // WIREFRAME
-#ifndef OCC120
-    ViewerTest::CurrentView()->SetDegenerateModeOn();
-#endif
     cout << "passage en mode 0 (filaire pour les shapes)" << endl;
-#ifndef OCC120
-    ViewerTest::CurrentView()->SetDegenerateModeOn();
-#endif
     Handle(AIS_InteractiveContext) Ctx = ViewerTest::GetAISContext();
     if(Ctx->NbCurrents()==0 ||
       Ctx->NbSelected()==0)
@@ -475,38 +484,44 @@ static void ProcessKeyPress( char *buf_r
 }
 
 //==============================================================================
-//function : ProcessExpose
+//function : VT_ProcessExpose
 //purpose  : Redraw the View on an Expose Event
 //==============================================================================
-
-static void ProcessExpose(  )
-{ //cout << "Expose" << endl;
-  ViewerTest::CurrentView()->Redraw();
+void VT_ProcessExpose()
+{
+  Handle(V3d_View) aView3d = ViewerTest::CurrentView();
+  if (!aView3d.IsNull())
+  {
+    aView3d->Redraw();
+  }
 }
 
 //==============================================================================
-//function : ProcessConfigure
+//function : VT_ProcessConfigure
 //purpose  : Resize the View on an Configure Event
 //==============================================================================
-
-static void ProcessConfigure()
+void VT_ProcessConfigure()
 {
-  Handle(V3d_View) V = ViewerTest::CurrentView();
-  V->MustBeResized();
-  V->Update();
-  V->Redraw();
+  Handle(V3d_View) aView3d = ViewerTest::CurrentView();
+  if (aView3d.IsNull())
+  {
+    return;
+  }
+
+  aView3d->MustBeResized();
+  aView3d->Update();
+  aView3d->Redraw();
 }
 
 //==============================================================================
-//function : ProcessButton1Press
+//function : VT_ProcessButton1Press
 //purpose  : Picking
 //==============================================================================
-
-static Standard_Boolean ProcessButton1Press(
+Standard_Boolean VT_ProcessButton1Press(
   Standard_Integer ,
-  const char** argv,
+  const char**     argv,
   Standard_Boolean pick,
-  Standard_Boolean shift )
+  Standard_Boolean shift)
 {
   Handle(ViewerTest_EventManager) EM = ViewerTest::CurrentEventManager();
   if ( pick ) {
@@ -528,35 +543,50 @@ static Standard_Boolean ProcessButton1Pr
 }
 
 //==============================================================================
-//function : ProcessButton3Press
-//purpose  : Start Rotation
+//function : VT_ProcessButton1Release
+//purpose  : End selecting
 //==============================================================================
+void VT_ProcessButton1Release (Standard_Boolean theIsShift)
+{
+  if (IsDragged)
+  {
+    IsDragged = Standard_False;
+    Handle(ViewerTest_EventManager) EM = ViewerTest::CurrentEventManager();
+    if (theIsShift)
+    {
+      EM->ShiftSelect (Min (X_ButtonPress, X_Motion), Max (Y_ButtonPress, Y_Motion),
+                       Max (X_ButtonPress, X_Motion), Min (Y_ButtonPress, Y_Motion));
+    }
+    else
+    {
+      EM->Select (Min (X_ButtonPress, X_Motion), Max (Y_ButtonPress, Y_Motion),
+                  Max (X_ButtonPress, X_Motion), Min (Y_ButtonPress, Y_Motion));
+    }
+  }
+}
 
-static void ProcessButton3Press()
-
-{ // Start rotation
+//==============================================================================
+//function : VT_ProcessButton3Press
+//purpose  : Start Rotation
+//==============================================================================
+void VT_ProcessButton3Press()
+{
   Start_Rot = 1;
   ViewerTest::CurrentView()->SetDegenerateModeOn();
   ViewerTest::CurrentView()->StartRotation( X_ButtonPress, Y_ButtonPress );
-
 }
+
 //==============================================================================
-//function : ProcessButtonRelease
-//purpose  : Start Rotation
+//function : VT_ProcessButton3Release
+//purpose  : End rotation
 //==============================================================================
-
-static void ProcessButtonRelease()
-
-{ // End rotation
-#ifdef OCC120
-  if (Start_Rot) {
+void VT_ProcessButton3Release()
+{
+  if (Start_Rot)
+  {
     Start_Rot = 0;
     if (!DegenerateMode) ViewerTest::CurrentView()->SetDegenerateModeOff();
   }
-#else
-  Start_Rot = 0;
-  ViewerTest::CurrentView()->SetDegenerateModeOff();
-#endif
 }
 
 //==============================================================================
@@ -613,11 +643,10 @@ static void ProcessControlButton1Motion(
 }
 
 //==============================================================================
-//function : ProcessControlButton2Motion
-//purpose  : Pann
+//function : VT_ProcessControlButton2Motion
+//purpose  : Panning
 //==============================================================================
-
-static void ProcessControlButton2Motion()
+void VT_ProcessControlButton2Motion()
 {
   Quantity_Length dx = ViewerTest::CurrentView()->Convert(X_Motion - X_ButtonPress);
   Quantity_Length dy = ViewerTest::CurrentView()->Convert(Y_Motion - Y_ButtonPress);
@@ -631,21 +660,22 @@ static void ProcessControlButton2Motion(
 }
 
 //==============================================================================
-//function : ProcessControlButton3Motion
+//function : VT_ProcessControlButton3Motion
 //purpose  : Rotation
 //==============================================================================
-
-static void ProcessControlButton3Motion()
+void VT_ProcessControlButton3Motion()
 {
-  if ( Start_Rot ) ViewerTest::CurrentView()->Rotation( X_Motion, Y_Motion);
+  if (Start_Rot)
+  {
+    ViewerTest::CurrentView()->Rotation (X_Motion, Y_Motion);
+  }
 }
 
 //==============================================================================
-//function : ProcessPointerMotion
-//purpose  : Rotation
+//function : VT_ProcessMotion
+//purpose  :
 //==============================================================================
-
-static void ProcessMotion()
+void VT_ProcessMotion()
 {
   //pre-hilights detected objects at mouse position
 
@@ -666,7 +696,7 @@ void ViewerTest::GetMousePosition(Standa
 
 static int ViewProject(Draw_Interpretor& di, const V3d_TypeOfOrientation ori)
 {
-  if ( ViewerTest::CurrentView().IsNull() ) 
+  if ( ViewerTest::CurrentView().IsNull() )
   {
     di<<"Call vinit before this command, please"<<"\n";
     return 1;
@@ -798,14 +828,6 @@ static int VHelp(Draw_Interpretor& di, S
   return 0;
 }
 
-Standard_Boolean IsDragged = Standard_False;
-
-Standard_Integer xx1, yy1, xx2, yy2;
-//the first and last point in viewer co-ordinates
-
-Standard_Boolean DragFirst;
-
-
 #ifdef WNT
 
 static Standard_Boolean Ppick = 0;
@@ -832,17 +854,17 @@ static LRESULT WINAPI AdvViewerWindowPro
         SelectObject( hdc, GetStockObject( WHITE_PEN ) );
         SelectObject( hdc, GetStockObject( HOLLOW_BRUSH ) );
         SetROP2( hdc, R2_NOT );
-        Rectangle( hdc, xx1, yy1, xx2, yy2 );
+        Rectangle( hdc, X_ButtonPress, Y_ButtonPress, X_Motion, Y_Motion );
         ReleaseDC( hwnd, hdc );
 
         const Handle(ViewerTest_EventManager) EM =
           ViewerTest::CurrentEventManager();
         if ( fwKeys & MK_SHIFT )
-          EM->ShiftSelect( min( xx1, xx2 ), max( yy1, yy2 ),
-          max( xx1, xx2 ), min( yy1, yy2 ));
+          EM->ShiftSelect( min( X_ButtonPress, X_Motion ), max( Y_ButtonPress, Y_Motion ),
+          max( X_ButtonPress, X_Motion ), min( Y_ButtonPress, Y_Motion ));
         else
-          EM->Select( min( xx1, xx2 ), max( yy1, yy2 ),
-          max( xx1, xx2 ), min( yy1, yy2 ));
+          EM->Select( min( X_ButtonPress, X_Motion ), max( Y_ButtonPress, Y_Motion ),
+          max( X_ButtonPress, X_Motion ), min( Y_ButtonPress, Y_Motion ));
       }
       return ViewerWindowProc( hwnd, Msg, wParam, lParam );
 
@@ -851,8 +873,8 @@ static LRESULT WINAPI AdvViewerWindowPro
       {
         IsDragged = Standard_True;
         DragFirst = Standard_True;
-        xx1 = LOWORD(lParam);
-        yy1 = HIWORD(lParam);
+        X_ButtonPress = LOWORD(lParam);
+        Y_ButtonPress = HIWORD(lParam);
       }
       return ViewerWindowProc( hwnd, Msg, wParam, lParam );
 
@@ -868,13 +890,13 @@ static LRESULT WINAPI AdvViewerWindowPro
         SetROP2( hdc, R2_NOT );
 
         if( !DragFirst )
-          Rectangle( hdc, xx1, yy1, xx2, yy2 );
+          Rectangle( hdc, X_ButtonPress, Y_ButtonPress, X_Motion, Y_Motion );
 
         DragFirst = Standard_False;
-        xx2 = LOWORD(lParam);
-        yy2 = HIWORD(lParam);
+        X_Motion = LOWORD(lParam);
+        Y_Motion = HIWORD(lParam);
 
-        Rectangle( hdc, xx1, yy1, xx2, yy2 );
+        Rectangle( hdc, X_ButtonPress, Y_ButtonPress, X_Motion, Y_Motion );
 
         SelectObject( hdc, anObj );
 
@@ -913,41 +935,36 @@ static LRESULT WINAPI ViewerWindowProc(
       VT_GetWindow()->Unmap();
       return 0;
     case WM_PAINT:
-      //cout << "\t WM_PAINT" << endl;
       BeginPaint(hwnd, &ps);
       EndPaint(hwnd, &ps);
-      ProcessExpose();
+      VT_ProcessExpose();
       break;
 
     case WM_SIZE:
-      //cout << "\t WM_SIZE" << endl;
-      ProcessConfigure();
+      VT_ProcessConfigure();
       break;
 
     case WM_KEYDOWN:
-      //cout << "\t WM_KEYDOWN " << (int) wParam << endl;
-
-      if ( (wParam != VK_SHIFT) && (wParam != VK_CONTROL) ) {
+      if ((wParam != VK_SHIFT) && (wParam != VK_CONTROL))
+      {
         char c[2];
         c[0] = (char) wParam;
         c[1] = '\0';
-        ProcessKeyPress( c);
+        VT_ProcessKeyPress (c);
       }
       break;
 
     case WM_LBUTTONUP:
     case WM_MBUTTONUP:
     case WM_RBUTTONUP:
-      //cout << "\t WM_xBUTTONUP" << endl;
       Up = 1;
-      ProcessButtonRelease();
+      VT_ProcessButton3Release();
       break;
 
     case WM_LBUTTONDOWN:
     case WM_MBUTTONDOWN:
     case WM_RBUTTONDOWN:
       {
-        //cout << "\t WM_xBUTTONDOWN" << endl;
         WPARAM fwKeys = wParam;
 
         Up = 0;
@@ -955,15 +972,21 @@ static LRESULT WINAPI ViewerWindowProc(
         X_ButtonPress = LOWORD(lParam);
         Y_ButtonPress = HIWORD(lParam);
 
-        if ( Msg == WM_LBUTTONDOWN) {
-          if(fwKeys & MK_CONTROL) {
-            Ppick = ProcessButton1Press( Pargc, Pargv, Ppick,  (fwKeys & MK_SHIFT) );
-          } else
-            ProcessButton1Press( Pargc, Pargv, Ppick,  (fwKeys & MK_SHIFT) );
+        if (Msg == WM_LBUTTONDOWN)
+        {
+          if (fwKeys & MK_CONTROL)
+          {
+            Ppick = VT_ProcessButton1Press (Pargc, Pargv, Ppick, (fwKeys & MK_SHIFT));
+          }
+          else
+          {
+            VT_ProcessButton1Press (Pargc, Pargv, Ppick, (fwKeys & MK_SHIFT));
+          }
         }
-        else if ( Msg == WM_RBUTTONDOWN ) {
+        else if (Msg == WM_RBUTTONDOWN)
+        {
           // Start rotation
-          ProcessButton3Press( );
+          VT_ProcessButton3Press();
         }
       }
       break;
@@ -983,7 +1006,7 @@ static LRESULT WINAPI ViewerWindowProc(
 
             if ( fwKeys & MK_RBUTTON ) {
               // Start rotation
-              ProcessButton3Press();
+              VT_ProcessButton3Press();
             }
           }
 
@@ -994,10 +1017,10 @@ static LRESULT WINAPI ViewerWindowProc(
             else if ( fwKeys & MK_MBUTTON ||
               ((fwKeys&MK_LBUTTON) &&
               (fwKeys&MK_RBUTTON) ) ){
-                ProcessControlButton2Motion();
+                VT_ProcessControlButton2Motion();
               }
             else if ( fwKeys & MK_RBUTTON ) {
-              ProcessControlButton3Motion();
+              VT_ProcessControlButton3Motion();
             }
           }
 #ifdef BUG
@@ -1011,11 +1034,14 @@ static LRESULT WINAPI ViewerWindowProc(
           }
 #endif
           else
-            if (( fwKeys & MK_MBUTTON || ((fwKeys&MK_LBUTTON) && (fwKeys&MK_RBUTTON) ) )){
+            if ((fwKeys & MK_MBUTTON
+            || ((fwKeys & MK_LBUTTON) && (fwKeys & MK_RBUTTON))))
+            {
               ProcessZClipMotion();
             }
-            else {
-              ProcessMotion();
+            else
+            {
+              VT_ProcessMotion();
             }
       }
       break;
@@ -1057,7 +1083,7 @@ int ViewerMainLoop(Standard_Integer argc
 
     //while ( Ppick == -1 ) {
     while ( Ppick == 1 ) {
-      // Wait for a ProcessButton1Press() to toggle pick to 1 or 0
+      // Wait for a VT_ProcessButton1Press() to toggle pick to 1 or 0
       if (GetMessage(&msg, NULL, 0, 0) ) {
         TranslateMessage(&msg);
         DispatchMessage(&msg);
@@ -1071,7 +1097,7 @@ int ViewerMainLoop(Standard_Integer argc
 }
 
 
-#else
+#elif !defined(__APPLE__) || defined(MACOSX_USE_GLX)
 
 int ViewerMainLoop(Standard_Integer argc, const char** argv)
 
@@ -1088,12 +1114,12 @@ XNextEvent( display, &report );
 switch ( report.type ) {
       case Expose:
         {
-          ProcessExpose();
+          VT_ProcessExpose();
         }
         break;
       case ConfigureNotify:
         {
-          ProcessConfigure();
+          VT_ProcessConfigure();
         }
         break;
       case KeyPress:
@@ -1111,8 +1137,9 @@ switch ( report.type ) {
 
           buf_ret[ret_len] = '\0' ;
 
-          if ( ret_len ) {
-            ProcessKeyPress( buf_ret);
+          if (ret_len)
+          {
+            VT_ProcessKeyPress (buf_ret);
           }
         }
         break;
@@ -1122,20 +1149,25 @@ switch ( report.type ) {
           X_ButtonPress = report.xbutton.x;
           Y_ButtonPress = report.xbutton.y;
 
-          if ( report.xbutton.button == Button1 )
-            if(  report.xbutton.state & ControlMask )
-              pick = ProcessButton1Press( argc, argv, pick,
-              ( report.xbutton.state & ShiftMask) );
+          if (report.xbutton.button == Button1)
+          {
+            if (report.xbutton.state & ControlMask)
+            {
+              pick = VT_ProcessButton1Press (argc, argv, pick, (report.xbutton.state & ShiftMask));
+            }
             else
             {
               IsDragged = Standard_True;
-              xx1 = X_ButtonPress;
-              yy1 = Y_ButtonPress;
+              X_ButtonPress = X_ButtonPress;
+              Y_ButtonPress = Y_ButtonPress;
               DragFirst = Standard_True;
             }
-          else if ( report.xbutton.button == Button3 )
+          }
+          else if (report.xbutton.button == Button3)
+          {
             // Start rotation
-            ProcessButton3Press();
+            VT_ProcessButton3Press();
+          }
         }
         break;
       case ButtonRelease:
@@ -1151,7 +1183,7 @@ switch ( report.type ) {
               Aspect_Handle aWindow = VT_GetWindow()->XWindow();
               GC gc = XCreateGC( display, aWindow, 0, 0 );
               //  XSetFunction( display, gc, GXinvert );
-              XDrawRectangle( display, aWindow, gc, min( xx1, xx2 ), min( yy1, yy2 ), abs( xx2-xx1 ), abs( yy2-yy1 ) );
+              XDrawRectangle( display, aWindow, gc, min( X_ButtonPress, X_Motion ), min( Y_ButtonPress, Y_Motion ), abs( X_Motion-X_ButtonPress ), abs( Y_Motion-Y_ButtonPress ) );
             }
 
             Handle( AIS_InteractiveContext ) aContext = ViewerTest::GetAISContext();
@@ -1177,25 +1209,25 @@ switch ( report.type ) {
               else
                 if( ShiftPressed )
                 {
-                  aContext->ShiftSelect( min( xx1, xx2 ), min( yy1, yy2 ),
-                    max( xx1, xx2 ), max( yy1, yy2 ),
+                  aContext->ShiftSelect( min( X_ButtonPress, X_Motion ), min( Y_ButtonPress, Y_Motion ),
+                    max( X_ButtonPress, X_Motion ), max( Y_ButtonPress, Y_Motion ),
                     ViewerTest::CurrentView());
                   //                   cout << "shift select" << endl;
                 }
                 else
                 {
-                  aContext->Select( min( xx1, xx2 ), min( yy1, yy2 ),
-                    max( xx1, xx2 ), max( yy1, yy2 ),
+                  aContext->Select( min( X_ButtonPress, X_Motion ), min( Y_ButtonPress, Y_Motion ),
+                    max( X_ButtonPress, X_Motion ), max( Y_ButtonPress, Y_Motion ),
                     ViewerTest::CurrentView() );
                   //                   cout << "select" << endl;
                 }
             else
-              ProcessButtonRelease();
+              VT_ProcessButton3Release();
 
             IsDragged = Standard_False;
           }
           else
-            ProcessButtonRelease();
+            VT_ProcessButton3Release();
         }
         break;
       case MotionNotify:
@@ -1212,14 +1244,14 @@ switch ( report.type ) {
             XSetFunction( display, gc, GXinvert );
 
             if( !DragFirst )
-              XDrawRectangle( display, aWindow, gc, min( xx1, xx2 ), min( yy1, yy2 ), abs( xx2-xx1 ), abs( yy2-yy1 ) );
+              XDrawRectangle( display, aWindow, gc, min( X_ButtonPress, X_Motion ), min( Y_ButtonPress, Y_Motion ), abs( X_Motion-X_ButtonPress ), abs( Y_Motion-Y_ButtonPress ) );
 
-            xx2 = X_Motion;
-            yy2 = Y_Motion;
+            X_Motion = X_Motion;
+            Y_Motion = Y_Motion;
             DragFirst = Standard_False;
 
-            //cout << "draw rect : " << xx2 << ", " << yy2 << endl;
-            XDrawRectangle( display, aWindow, gc, min( xx1, xx2 ), min( yy1, yy2 ), abs( xx2-xx1 ), abs( yy2-yy1 ) );
+            //cout << "draw rect : " << X_Motion << ", " << Y_Motion << endl;
+            XDrawRectangle( display, aWindow, gc, min( X_ButtonPress, X_Motion ), min( Y_ButtonPress, Y_Motion ), abs( X_Motion-X_ButtonPress ), abs( Y_Motion-Y_ButtonPress ) );
           }
           else
           {
@@ -1263,14 +1295,15 @@ switch ( report.type ) {
                 ProcessControlButton1Motion();
               }
               else if ( report.xmotion.state & Button2Mask ) {
-                ProcessControlButton2Motion();
+                VT_ProcessControlButton2Motion();
               }
               else if ( report.xmotion.state & Button3Mask ) {
-                ProcessControlButton3Motion();
+                VT_ProcessControlButton3Motion();
               }
             }
-            else {
-              ProcessMotion();
+            else
+            {
+              VT_ProcessMotion();
             }
           }
         }
@@ -1306,7 +1339,7 @@ static void VProcessEvents(ClientData,in
 
 static void OSWindowSetup()
 {
-#ifndef WNT
+#if !defined(_WIN32) && !defined(__WIN32__) && (!defined(__APPLE__) || defined(MACOSX_USE_GLX))
   // X11
 
   Window  window   = VT_GetWindow()->XWindow();
@@ -1414,8 +1447,6 @@ while (ViewerMainLoop( argc, argv)) {
 return 0;
 }
 
-
-
 //==============================================================================
 //function : InitViewerTest
 //purpose  : initialisation de toutes les variables static de  ViewerTest (dp)
@@ -1431,7 +1462,7 @@ void ViewerTest_InitViewerTest (const Ha
   ViewerTest::ResetEventManager();
   Handle(Aspect_GraphicDevice) device = viewer->Device();
   Handle(Aspect_Window) window = view->Window();
-#ifndef WNT
+#if !defined(_WIN32) && !defined(__WIN32__) && (!defined(__APPLE__) || defined(MACOSX_USE_GLX))
   // X11
   VT_GetWindow() = Handle(Xw_Window)::DownCast(window);
   GetG3dDevice() = Handle(Graphic3d_GraphicDevice)::DownCast(device);
@@ -1450,7 +1481,6 @@ void ViewerTest_InitViewerTest (const Ha
 #endif
 }
 
-
 //==============================================================================
 //function : VSetBg
 //purpose  : Load image as background
@@ -2013,7 +2043,7 @@ static int VGraduatedTrihedron(Draw_Inte
   // Create 3D view if it doesn't exist
   if ( aV3dView.IsNull() )
   {
-    ViewerTest::ViewerInit(); 
+    ViewerTest::ViewerInit();
     aV3dView = ViewerTest::CurrentView();
     if( aV3dView.IsNull() )
     {
@@ -2089,7 +2119,7 @@ static int VGraduatedTrihedron(Draw_Inte
 //purpose  : Test printing algorithm, print the view to image file with given
 //           width and height. Printing implemented only for WNT.
 //==============================================================================
-static int VPrintView (Draw_Interpretor& di, Standard_Integer argc, 
+static int VPrintView (Draw_Interpretor& di, Standard_Integer argc,
                        const char** argv)
 {
 #ifndef WNT
@@ -2168,7 +2198,7 @@ static int VPrintView (Draw_Interpretor&
 
   Standard_Boolean isSaved = Standard_False, isPrinted = Standard_False;
   if (aBitsOut != NULL)
-  {    
+  {
     if (aMode == 0)
       isPrinted = aView->Print(anDC,1,1,0,Aspect_PA_STRETCH);
     else
@@ -2366,7 +2396,7 @@ V3d_TextItem::V3d_TextItem (const TColle
 
 // render item
 void V3d_TextItem::RedrawLayerPrs ()
-{ 
+{
   if (myLayer.IsNull ())
     return;
 
@@ -2378,14 +2408,14 @@ void V3d_TextItem::RedrawLayerPrs ()
 DEFINE_STANDARD_HANDLE(V3d_LineItem, Visual3d_LayerItem)
 
 // The Visual3d_LayerItem line item for "vlayerline" command
-// it provides a presentation of line with user-defined 
+// it provides a presentation of line with user-defined
 // linewidth, linetype and transparency.
-class V3d_LineItem : public Visual3d_LayerItem 
+class V3d_LineItem : public Visual3d_LayerItem
 {
 public:
   // CASCADE RTTI
-  DEFINE_STANDARD_RTTI(V3d_LineItem) 
-  
+  DEFINE_STANDARD_RTTI(V3d_LineItem)
+
   // constructor
   Standard_EXPORT V3d_LineItem(Standard_Real X1, Standard_Real Y1,
                                Standard_Real X2, Standard_Real Y2,
@@ -2410,7 +2440,7 @@ IMPLEMENT_STANDARD_HANDLE(V3d_LineItem,
 IMPLEMENT_STANDARD_RTTIEXT(V3d_LineItem, Visual3d_LayerItem)
 
 // default constructor for line item
-V3d_LineItem::V3d_LineItem(Standard_Real X1, Standard_Real Y1, 
+V3d_LineItem::V3d_LineItem(Standard_Real X1, Standard_Real Y1,
                            Standard_Real X2, Standard_Real Y2,
                            V3d_LayerMgrPointer theLayerMgr,
                            Aspect_TypeOfLine theType,
@@ -2428,7 +2458,7 @@ V3d_LineItem::V3d_LineItem(Standard_Real
 void V3d_LineItem::RedrawLayerPrs ()
 {
   Handle (Visual3d_Layer) aOverlay;
- 
+
   if (myLayerMgr)
     aOverlay = myLayerMgr->Overlay();
 
@@ -2496,7 +2526,7 @@ static int VLayerLine(Draw_Interpretor&
   if (argc > 7)
   {
     aTransparency = atof(argv[7]);
-    if (aTransparency < 0 || aTransparency > 1.0) 
+    if (aTransparency < 0 || aTransparency > 1.0)
       aTransparency = 1.0;
   }
 
@@ -2525,9 +2555,9 @@ static int VLayerLine(Draw_Interpretor&
   aView->SetLayerMgr(aMgr);
 
   // add line item
-  Handle (V3d_LineItem) anItem = new V3d_LineItem(X1, Y1, X2, Y2, 
+  Handle (V3d_LineItem) anItem = new V3d_LineItem(X1, Y1, X2, Y2,
                                                   aMgr.operator->(),
-                                                  aLineType, aWidth, 
+                                                  aLineType, aWidth,
                                                   aTransparency);
 
   // update view
@@ -2563,7 +2593,7 @@ static int VOverlayText (Draw_Interpreto
     di << "(default=255.0 255.0 255.0)\n";
     return 1;
   }
-  
+
   TCollection_AsciiString aText (argv[1]);
   Standard_Real aPosX = atof(argv[2]);
   Standard_Real aPosY = atof(argv[3]);
@@ -2618,9 +2648,9 @@ static int VOverlayText (Draw_Interpreto
     aView->SetLayerMgr (aMgr);
   }
 
-  Quantity_Color aTextColor (aColorRed, aColorGreen, 
+  Quantity_Color aTextColor (aColorRed, aColorGreen,
     aColorBlue, Quantity_TOC_RGB);
-  Quantity_Color aSubtColor (aSubRed, aSubGreen, 
+  Quantity_Color aSubtColor (aSubRed, aSubGreen,
     aSubBlue, Quantity_TOC_RGB);
 
   // add text item
Index: oce/src/ViewerTest/ViewerTest_ViewerCommands_1.mm
===================================================================
--- /dev/null
+++ oce/src/ViewerTest/ViewerTest_ViewerCommands_1.mm
@@ -0,0 +1,251 @@
+// Copyright (c) 2012 OPEN CASCADE SAS
+//
+// The content of this file is subject to the Open CASCADE Technology Public
+// License Version 6.5 (the "License"). You may not use the content of this file
+// except in compliance with the License. Please obtain a copy of the License
+// at http://www.opencascade.org and read it completely before using this file.
+//
+// The Initial Developer of the Original Code is Open CASCADE S.A.S., having its
+// main offices at: 1, place des Freres Montgolfier, 78280 Guyancourt, France.
+//
+// The Original Code and all software distributed under the License is
+// distributed on an "AS IS" basis, without warranty of any kind, and the
+// Initial Developer hereby disclaims all such warranties, including without
+// limitation, any warranties of merchantability, fitness for a particular
+// purpose or non-infringement. Please see the License for the specific terms
+// and conditions governing the rights and limitations under the License.
+
+#ifdef HAVE_CONFIG_H
+# include <oce-config.h>
+#endif
+
+#if defined(__APPLE__) && !defined(MACOSX_USE_GLX)
+
+#import <Cocoa/Cocoa.h>
+
+#include <Cocoa_Window.hxx>
+#include <ViewerTest.hxx>
+#include <V3d_View.hxx>
+#include <V3d_Viewer.hxx>
+#include <AIS_InteractiveContext.hxx>
+#include <NIS_View.hxx>
+
+//! Custom Cocoa view to handle events
+@interface ViewerTest_CocoaEventManagerView : NSView
+@end
+
+extern void VT_ProcessExpose();
+extern void VT_ProcessConfigure();
+extern void VT_ProcessKeyPress (const char* theBuffer);
+extern void VT_ProcessMotion();
+extern void VT_ProcessButton3Press();
+extern void VT_ProcessButton3Release();
+extern void VT_ProcessControlButton2Motion();
+extern void VT_ProcessControlButton3Motion();
+extern Standard_Boolean VT_ProcessButton1Press (Standard_Integer theArgsNb,
+                                                const char**     theArgsVec,
+                                                Standard_Boolean theToPick,
+                                                Standard_Boolean theIsShift);
+extern void VT_ProcessButton1Release(Standard_Boolean theIsShift);
+
+extern int X_Motion; // Current cursor position
+extern int Y_Motion;
+extern int X_ButtonPress; // Last ButtonPress position
+extern int Y_ButtonPress;
+extern Standard_Boolean IsDragged;
+
+// =======================================================================
+// function : ViewerMainLoop
+// purpose  :
+// =======================================================================
+int ViewerMainLoop (Standard_Integer, const char** )
+{
+  // unused
+  return 0;
+}
+
+// =======================================================================
+// function : ViewerTest_SetCocoaEventManagerView
+// purpose  :
+// =======================================================================
+void ViewerTest_SetCocoaEventManagerView (const Handle(Cocoa_Window)& theWindow)
+{
+  if (theWindow.IsNull())
+  {
+    return;
+  }
+
+  NSWindow* aWin = [theWindow->HView() window];
+  NSRect aBounds = [[aWin contentView] bounds];
+
+  ViewerTest_CocoaEventManagerView* aView = [[ViewerTest_CocoaEventManagerView alloc] initWithFrame: aBounds];
+
+  // replace content view in the window
+  theWindow->SetHView (aView);
+
+  // make view as first responder in winow to capture all useful events
+  [aWin makeFirstResponder: aView];
+  [aWin setAcceptsMouseMovedEvents: YES];
+
+  // should be retained by parent NSWindow
+  [aView release];
+}
+
+// =======================================================================
+// function : getMouseCoords
+// purpose  : Retrieve cursor position
+// =======================================================================
+static void getMouseCoords (NSView*           theView,
+                            NSEvent*          theEvent,
+                            Standard_Integer& theX,
+                            Standard_Integer& theY)
+{
+  NSPoint aMouseLoc = [theView convertPoint: [theEvent locationInWindow] fromView: nil];
+  NSRect  aBounds   = [theView bounds];
+
+  theX = Standard_Integer(aMouseLoc.x);
+  theY = Standard_Integer(aBounds.size.height - aMouseLoc.y);
+}
+
+@implementation ViewerTest_CocoaEventManagerView
+
+// =======================================================================
+// function : setFrameSize
+// purpose  :
+// =======================================================================
+- (void )setFrameSize: (NSSize )theNewSize
+{
+  [super setFrameSize: theNewSize];
+  VT_ProcessConfigure();
+}
+
+// =======================================================================
+// function : drawRect
+// purpose  :
+// =======================================================================
+- (void )drawRect: (NSRect )theDirtyRect
+{
+  VT_ProcessExpose();
+}
+
+// =======================================================================
+// function : mouseMoved
+// purpose  :
+// =======================================================================
+- (void )mouseMoved: (NSEvent* )theEvent
+{
+  getMouseCoords (self, theEvent, X_Motion, Y_Motion);
+  VT_ProcessMotion();
+}
+
+// =======================================================================
+// function : acceptsFirstResponder
+// purpose  :
+// =======================================================================
+- (BOOL )acceptsFirstResponder
+{
+  return YES;
+}
+
+// =======================================================================
+// function : mouseDown
+// purpose  :
+// =======================================================================
+- (void )mouseDown: (NSEvent* )theEvent
+{
+  getMouseCoords (self, theEvent, X_ButtonPress, Y_ButtonPress);
+  VT_ProcessButton1Press (0, NULL, Standard_False, [theEvent modifierFlags] & NSShiftKeyMask);
+}
+
+// =======================================================================
+// function : mouseUp
+// purpose  :
+// =======================================================================
+- (void )mouseUp: (NSEvent* )theEvent
+{
+  getMouseCoords (self, theEvent, X_Motion, Y_Motion);
+  VT_ProcessButton1Release([theEvent modifierFlags] & NSShiftKeyMask);
+}
+
+
+// =======================================================================
+// function : mouseDragged
+// purpose  :
+// =======================================================================
+- (void )mouseDragged: (NSEvent* )theEvent
+{
+  IsDragged = Standard_True;
+  if ([theEvent modifierFlags] & NSControlKeyMask)
+  {
+    getMouseCoords (self, theEvent, X_Motion, Y_Motion);
+    VT_ProcessControlButton2Motion();
+  }
+}
+
+// =======================================================================
+// function : rightMouseDown
+// purpose  :
+// =======================================================================
+- (void )rightMouseDown: (NSEvent* )theEvent
+{
+  getMouseCoords (self, theEvent, X_ButtonPress, Y_ButtonPress);
+  VT_ProcessButton3Press(); // Start rotation
+}
+
+// =======================================================================
+// function : rightMouseUp
+// purpose  :
+// =======================================================================
+- (void )rightMouseUp: (NSEvent* )theEvent
+{
+  VT_ProcessButton3Release();
+}
+
+// =======================================================================
+// function : rightMouseDragged
+// purpose  :
+// =======================================================================
+- (void )rightMouseDragged: (NSEvent* )theEvent
+{
+  if ([theEvent modifierFlags] & NSControlKeyMask)
+  {
+    getMouseCoords (self, theEvent, X_Motion, Y_Motion);
+    VT_ProcessControlButton3Motion();
+  }
+}
+
+// =======================================================================
+// function : scrollWheel
+// purpose  :
+// =======================================================================
+- (void )scrollWheel: (NSEvent* )theEvent
+{
+  float aDelta = [theEvent deltaY];
+  if (Abs (aDelta) < 0.001)
+  {
+    // a lot of values near zero can be generated by touchpad
+    return;
+  }
+
+  ViewerTest::CurrentView()->Zoom (0, 0, aDelta, aDelta);
+}
+
+// =======================================================================
+// function : keyDown
+// purpose  :
+// =======================================================================
+- (void )keyDown: (NSEvent* )theEvent
+{
+  NSString* aStringNs = [theEvent characters];
+  if (aStringNs == NULL || [aStringNs length] == 0)
+  {
+    return;
+  }
+
+  const Standard_CString aString = [aStringNs UTF8String];
+  VT_ProcessKeyPress (aString);
+}
+
+@end
+
+#endif
Index: oce/src/Visual3d/Visual3d_View.cxx
===================================================================
--- oce.orig/src/Visual3d/Visual3d_View.cxx
+++ oce/src/Visual3d/Visual3d_View.cxx
@@ -16,6 +16,10 @@
 // purpose or non-infringement. Please see the License for the specific terms
 // and conditions governing the rights and limitations under the License.
 
+#ifdef HAVE_CONFIG_H
+# include <oce-config.h>
+#endif
+
 /***********************************************************************
 
      FONCTION :
@@ -167,11 +171,13 @@
 
 #include <TColStd_HArray2OfReal.hxx>
 
-#ifndef WNT
-# include <Xw_Window.hxx>
+#if (defined(_WIN32) || defined(__WIN32__))
+  #include <WNT_Window.hxx>
+#elif (defined(__APPLE__) && !defined(MACOSX_USE_GLX))
+  #include <Cocoa_Window.hxx>
 #else
-# include <WNT_Window.hxx>
-#endif  // WNT
+  #include <Xw_Window.hxx>
+#endif
 
 #include <float.h>
 
@@ -472,36 +478,38 @@ void Visual3d_View::SetWindow (const Han
 }
 // RIC120302
 
-void Visual3d_View::SetWindow (const Handle(Aspect_Window)& AWindow) {
+void Visual3d_View::SetWindow (const Handle(Aspect_Window)& theWindow)
+{
 
         if (IsDeleted ()) return;
 
         if (IsDefined ())
                 Visual3d_ViewDefinitionError::Raise ("Window already defined");
 
-        MyWindow        = AWindow;
+        MyWindow        = theWindow;
         MyCView.WsId                    = MyCView.ViewId;
         MyCView.DefWindow.IsDefined     = 1;
-#ifndef WNT
-const Handle(Xw_Window) theWindow = *(Handle(Xw_Window) *) &AWindow;
-        MyCView.DefWindow.XWindow       = theWindow->XWindow ();
-#ifdef RIC120302
-        MyCView.DefWindow.XParentWindow = theWindow->XParentWindow ();
-#endif
+
+#if (defined(_WIN32) || defined(__WIN32__))
+  const Handle(WNT_Window) aWin   = Handle(WNT_Window)::DownCast (theWindow);
+  MyCView.DefWindow.XWindow       = (HWND )(aWin->HWindow());
+  MyCView.DefWindow.XParentWindow = (HWND )(aWin->HParentWindow());
+  WNT_WindowData* aWinData = (WNT_WindowData* )GetWindowLongPtr ((HWND )(aWin->HWindow()), GWLP_USERDATA);
+  aWinData->WNT_WDriver_Ptr = (void* )this;
+  aWinData->WNT_VMgr        = (void* )MyPtrViewManager;
+#elif (defined(__APPLE__) && !defined(MACOSX_USE_GLX))
+  const Handle(Cocoa_Window) aWin = Handle(Cocoa_Window)::DownCast (theWindow);
+  MyCView.DefWindow.XWindow       = (Aspect_Drawable )aWin->HView();
+  MyCView.DefWindow.XParentWindow = NULL;
+  //MyCView.DefWindow.XParentWindow = aWin->HParentWindow();
 #else
-WNT_WindowData* wd;
-const Handle(WNT_Window) theWindow = *(Handle(WNT_Window) *) &AWindow;
-        MyCView.DefWindow.XWindow       = ( HWND )(theWindow->HWindow());
-#ifdef RIC120302
-        MyCView.DefWindow.XParentWindow = ( HWND )(theWindow->HParentWindow());
+  const Handle(Xw_Window) aWin    = Handle(Xw_Window)::DownCast (theWindow);
+  MyCView.DefWindow.XWindow       = aWin->XWindow();
+  MyCView.DefWindow.XParentWindow = aWin->XParentWindow();
 #endif
-        wd = ( WNT_WindowData* )GetWindowLongPtr (( HWND )(theWindow->HWindow()), GWLP_USERDATA);
-        wd -> WNT_WDriver_Ptr = ( void* )this;
-        wd -> WNT_VMgr        = ( void* )MyPtrViewManager;
-#endif  /* WNT */
 
         Standard_Integer Width, Height;
-        AWindow->Size (Width, Height);
+        theWindow->Size (Width, Height);
 
         MyCView.DefWindow.dx    = float( Width );
         MyCView.DefWindow.dy    = float( Height );
