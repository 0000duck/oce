From e3e0c12cd04c7d9b2e46cecbfc4e56f2902633a9 Mon Sep 17 00:00:00 2001
From: Denis Barbier <bouzim@gmail.com>
Date: Tue, 13 Sep 2011 18:11:02 +0200
Subject: [PATCH] Workaround GCC (< 4.4) bugs in gp_Mat and gp_XYZ

Report and patch provided by Roman Lygin at
  http://www.opencascade.org/org/forum/thread_19603/

For instance, Standard_ConstructionError is raised
in gp_Trsf::SetValues, the reason is that gp_Mat::Subtract
does not work as expected (only the first row is
subtracted).

It is not clear what makes GCC buggy, but compilers should
be smart enough to compute multiple array indices when
compiling, so this change should not introduce any performance
problems.  It would be better to go one step further and
remove macros, but it will make this patch much longer.
---
 inc/gp_Mat.lxx |   81 ++++++++++++++++++-------------------------------------
 inc/gp_XYZ.lxx |   14 ++++-----
 2 files changed, 33 insertions(+), 62 deletions(-)

From 883c404c1511f84fac4f448969c96911288c30bb Mon Sep 17 00:00:00 2001
From: tpaviot <tpaviot@gmail.com>
Date: Tue, 27 Sep 2011 06:27:54 +0200
Subject: [PATCH 1/2] Make gp_Mat consistent with commit e3e0c12

This fixes issue #119.
---
 src/gp/gp_Mat.cxx |  165 +++++++++++++++++++++--------------------------------
 1 files changed, 65 insertions(+), 100 deletions(-)

From b0305a306308bbfa05afcc30086484abd1e48a51 Mon Sep 17 00:00:00 2001
From: tpaviot <tpaviot@gmail.com>
Date: Tue, 27 Sep 2011 16:13:38 +0200
Subject: [PATCH 2/2] Propagated gp_Mat changes to gp_Mat2d/gp_XY

---
 inc/gp_Mat2d.lxx    |   53 +++++++--------------------------
 inc/gp_XY.lxx       |   10 ++----
 src/gp/gp_Mat2d.cxx |   80 +++++++++++++++++++--------------------------------
 3 files changed, 46 insertions(+), 97 deletions(-)

Index: oce/inc/gp_Mat2d.lxx
===================================================================
--- oce.orig/inc/gp_Mat2d.lxx
+++ oce/inc/gp_Mat2d.lxx
@@ -3,44 +3,40 @@
 #include <gp.hxx>
 #include <Standard_OutOfRange.hxx>
 
-#define Mat2d00 ((Standard_Real*)M)[0]
-#define Mat2d01 ((Standard_Real*)M)[1]
-#define Mat2d10 ((Standard_Real*)M)[2]
-#define Mat2d11 ((Standard_Real*)M)[3]
-
-#define Nat2d00 ((Standard_Real*)N)[0]
-#define Nat2d01 ((Standard_Real*)N)[1]
-#define Nat2d10 ((Standard_Real*)N)[2]
-#define Nat2d11 ((Standard_Real*)N)[3]
-
-#define Oat2d00 ((Standard_Real*)O)[0]
-#define Oat2d01 ((Standard_Real*)O)[1]
-#define Oat2d10 ((Standard_Real*)O)[2]
-#define Oat2d11 ((Standard_Real*)O)[3]
+#define Mat2d00 matrix[0][0]
+#define Mat2d01 matrix[0][1]
+#define Mat2d10 matrix[1][0]
+#define Mat2d11 matrix[1][1]
+
+#define Nat2d00 NewMat2d.matrix[0][0]
+#define Nat2d01 NewMat2d.matrix[0][1]
+#define Nat2d10 NewMat2d.matrix[1][0]
+#define Nat2d11 NewMat2d.matrix[1][1]
+
+#define Oat2d00 Other.matrix[0][0]
+#define Oat2d01 Other.matrix[0][1]
+#define Oat2d10 Other.matrix[1][0]
+#define Oat2d11 Other.matrix[1][1]
 
 inline gp_Mat2d::gp_Mat2d ()
 {
-  const Standard_Address M = (Standard_Address)&(matrix[0][0]);
   Mat2d00 = Mat2d01 = Mat2d10 = Mat2d11 = 0.0;
 }
 
 inline void gp_Mat2d::SetDiagonal (const Standard_Real X1,
 			    const Standard_Real X2)
 {
-  const Standard_Address M = (Standard_Address)&(matrix[0][0]);
   Mat2d00 = X1; Mat2d11 = X2;
 }
 
 inline void gp_Mat2d::SetIdentity ()
 {
-  const Standard_Address M = (Standard_Address)&(matrix[0][0]);
   Mat2d00 = Mat2d11 = 1.0;
   Mat2d01 = Mat2d10 = 0.0;
 }
 
 inline void gp_Mat2d::SetRotation (const Standard_Real Ang)
 {
-  const Standard_Address M = (Standard_Address)&(matrix[0][0]);
   Standard_Real SinA = sin(Ang);
   Standard_Real CosA = cos(Ang);
   Mat2d00 = Mat2d11 = CosA;
@@ -50,7 +46,6 @@ inline void gp_Mat2d::SetRotation (const
 
 inline void gp_Mat2d::SetScale (const Standard_Real S)
 {
-  const Standard_Address M = (Standard_Address)&(matrix[0][0]);
   Mat2d00 = Mat2d11 = S;
   Mat2d01 = Mat2d10 = 0.0;
 }
@@ -66,7 +61,6 @@ inline void gp_Mat2d::SetValue (const St
 
 inline Standard_Real gp_Mat2d::Determinant () const
 {
-  const Standard_Address M = (Standard_Address)&(matrix[0][0]);
   return  Mat2d00 * Mat2d11 - Mat2d10 * Mat2d01;
 }
 
@@ -96,8 +90,6 @@ inline Standard_Boolean gp_Mat2d::IsSing
 
 inline void gp_Mat2d::Add (const gp_Mat2d& Other)
 {
-  const Standard_Address M = (Standard_Address)&(      matrix[0][0]);
-  const Standard_Address O = (Standard_Address)&(Other.matrix[0][0]);
   Mat2d00 += Oat2d00;
   Mat2d01 += Oat2d01;
   Mat2d10 += Oat2d10;
@@ -107,9 +99,6 @@ inline void gp_Mat2d::Add (const gp_Mat2
 inline gp_Mat2d gp_Mat2d::Added (const gp_Mat2d& Other) const
 {
   gp_Mat2d NewMat2d;
-  const Standard_Address M = (Standard_Address)&(         matrix[0][0]);
-  const Standard_Address N = (Standard_Address)&(NewMat2d.matrix[0][0]);
-  const Standard_Address O = (Standard_Address)&(Other   .matrix[0][0]);
   Nat2d00 = Mat2d00 + Oat2d00;
   Nat2d01 = Mat2d01 + Oat2d01;
   Nat2d10 = Mat2d10 + Oat2d10;
@@ -119,7 +108,6 @@ inline gp_Mat2d gp_Mat2d::Added (const g
 
 inline void gp_Mat2d::Divide (const Standard_Real Scalar)
 {
-  const Standard_Address M = (Standard_Address)&(matrix[0][0]);
   Mat2d00 /= Scalar;
   Mat2d01 /= Scalar;
   Mat2d10 /= Scalar;
@@ -129,8 +117,6 @@ inline void gp_Mat2d::Divide (const Stan
 inline gp_Mat2d gp_Mat2d::Divided (const Standard_Real Scalar) const
 {
   gp_Mat2d NewMat2d;
-  const Standard_Address M = (Standard_Address)&(         matrix[0][0]);
-  const Standard_Address N = (Standard_Address)&(NewMat2d.matrix[0][0]);
   Nat2d00 = Mat2d00 / Scalar;
   Nat2d01 = Mat2d01 / Scalar;
   Nat2d10 = Mat2d10 / Scalar;
@@ -155,8 +141,6 @@ inline gp_Mat2d gp_Mat2d::Multiplied (co
 inline void gp_Mat2d::Multiply (const gp_Mat2d& Other)
 {
   Standard_Real T00,T10;
-  const Standard_Address M = (Standard_Address)&(      matrix[0][0]);
-  const Standard_Address O = (Standard_Address)&(Other.matrix[0][0]);
   T00     = Mat2d00 * Oat2d00 + Mat2d01 * Oat2d10;
   T10     = Mat2d10 * Oat2d00 + Mat2d11 * Oat2d10;
   Mat2d01 = Mat2d00 * Oat2d01 + Mat2d01 * Oat2d11;
@@ -168,8 +152,6 @@ inline void gp_Mat2d::Multiply (const gp
 inline void gp_Mat2d::PreMultiply (const gp_Mat2d& Other)
 {
   Standard_Real T00,T01;
-  const Standard_Address M = (Standard_Address)&(      matrix[0][0]);
-  const Standard_Address O = (Standard_Address)&(Other.matrix[0][0]);
   T00     = Oat2d00 * Mat2d00 + Oat2d01 * Mat2d10;
   Mat2d10 = Oat2d10 * Mat2d00 + Oat2d11 * Mat2d10;
   T01     = Oat2d00 * Mat2d01 + Oat2d01 * Mat2d11;
@@ -181,8 +163,6 @@ inline void gp_Mat2d::PreMultiply (const
 inline gp_Mat2d gp_Mat2d::Multiplied (const Standard_Real Scalar) const
 {
   gp_Mat2d NewMat2d;
-  const Standard_Address M = (Standard_Address)&(         matrix[0][0]);
-  const Standard_Address N = (Standard_Address)&(NewMat2d.matrix[0][0]);
   Nat2d00 = Mat2d00 * Scalar;
   Nat2d01 = Mat2d01 * Scalar;
   Nat2d10 = Mat2d10 * Scalar;
@@ -192,7 +172,6 @@ inline gp_Mat2d gp_Mat2d::Multiplied (co
 
 inline void gp_Mat2d::Multiply (const Standard_Real Scalar)
 {
-  const Standard_Address M = (Standard_Address)&(matrix[0][0]);
   Mat2d00 *= Scalar;
   Mat2d01 *= Scalar;
   Mat2d10 *= Scalar;
@@ -208,8 +187,6 @@ inline gp_Mat2d gp_Mat2d::Powered (const
 
 inline void gp_Mat2d::Subtract (const gp_Mat2d& Other)
 {
-  const Standard_Address M = (Standard_Address)&(      matrix[0][0]);
-  const Standard_Address O = (Standard_Address)&(Other.matrix[0][0]);
   Mat2d00 -= Oat2d00;
   Mat2d01 -= Oat2d01;
   Mat2d10 -= Oat2d10;
@@ -219,9 +196,6 @@ inline void gp_Mat2d::Subtract (const gp
 inline gp_Mat2d gp_Mat2d::Subtracted (const gp_Mat2d& Other) const
 {
   gp_Mat2d NewMat2d;
-  const Standard_Address M = (Standard_Address)&(         matrix[0][0]);
-  const Standard_Address N = (Standard_Address)&(NewMat2d.matrix[0][0]);
-  const Standard_Address O = (Standard_Address)&(Other   .matrix[0][0]);
   Nat2d00 = Mat2d00 - Oat2d00;
   Nat2d01 = Mat2d01 - Oat2d01;
   Nat2d10 = Mat2d10 - Oat2d10;
@@ -231,7 +205,6 @@ inline gp_Mat2d gp_Mat2d::Subtracted (co
 
 inline void gp_Mat2d::Transpose ()
 {
-  const Standard_Address M = (Standard_Address)&(matrix[0][0]);
   Standard_Real Temp;
   Temp     = Mat2d01;
   Mat2d01  = Mat2d10;
@@ -241,8 +214,6 @@ inline void gp_Mat2d::Transpose ()
 inline gp_Mat2d gp_Mat2d::Transposed () const
 {
   gp_Mat2d NewMat2d;
-  const Standard_Address M = (Standard_Address)&(         matrix[0][0]);
-  const Standard_Address N = (Standard_Address)&(NewMat2d.matrix[0][0]);
   Nat2d10 = Mat2d01;
   Nat2d01 = Mat2d10;
   Nat2d00 = Mat2d00;
Index: oce/inc/gp_XY.lxx
===================================================================
--- oce.orig/inc/gp_XY.lxx
+++ oce/inc/gp_XY.lxx
@@ -108,9 +108,8 @@ inline void gp_XY::Multiply (const gp_XY
 
 inline void gp_XY::Multiply (const gp_Mat2d& Matrix)
 {
-  const Standard_Address M = (Standard_Address)&(Matrix.matrix[0][0]);
-  Standard_Real Xresult = Mat2d00 * x + Mat2d01 * y;
-  y                     = Mat2d10 * x + Mat2d11 * y;
+  Standard_Real Xresult = Matrix.matrix[0][0] * x + Matrix.matrix[0][1] * y;
+  y                     = Matrix.matrix[1][0] * x + Matrix.matrix[1][1] * y;
   x                     = Xresult;
 }
 
@@ -124,9 +123,8 @@ inline gp_XY gp_XY::Multiplied (const gp
 
 inline gp_XY gp_XY::Multiplied (const gp_Mat2d& Matrix) const
 {
-  const Standard_Address M = (Standard_Address)&(Matrix.matrix[0][0]);
-  return gp_XY (Mat2d00 * x + Mat2d01 * y,
-		Mat2d10 * x + Mat2d11 * y);
+  return gp_XY (Matrix.matrix[0][0] * x + Matrix.matrix[0][1] * y,
+		Matrix.matrix[1][0] * x + Matrix.matrix[1][1] * y);
 }
 
 inline void gp_XY::Normalize ()
Index: oce/src/gp/gp_Mat.cxx
===================================================================
--- oce.orig/src/gp/gp_Mat.cxx
+++ oce/src/gp/gp_Mat.cxx
@@ -8,49 +8,27 @@
 
 #include <gp_Mat.ixx>
 
-#define M00 ((Standard_Real*)M)[0]
-#define M01 ((Standard_Real*)M)[1]
-#define M02 ((Standard_Real*)M)[2]
-#define M10 ((Standard_Real*)M)[3]
-#define M11 ((Standard_Real*)M)[4]
-#define M12 ((Standard_Real*)M)[5]
-#define M20 ((Standard_Real*)M)[6]
-#define M21 ((Standard_Real*)M)[7]
-#define M22 ((Standard_Real*)M)[8]
-
-#define N00 ((Standard_Real*)N)[0]
-#define N01 ((Standard_Real*)N)[1]
-#define N02 ((Standard_Real*)N)[2]
-#define N10 ((Standard_Real*)N)[3]
-#define N11 ((Standard_Real*)N)[4]
-#define N12 ((Standard_Real*)N)[5]
-#define N20 ((Standard_Real*)N)[6]
-#define N21 ((Standard_Real*)N)[7]
-#define N22 ((Standard_Real*)N)[8]
-
 gp_Mat::gp_Mat (const gp_XYZ& Col1,
 		const gp_XYZ& Col2,
 		const gp_XYZ& Col3)
 {
-  const Standard_Address M = (Standard_Address)&(matrix[0][0]);
-  M00 = Col1.X(); M10 = Col1.Y(); M20 = Col1.Z();
-  M01 = Col2.X(); M11 = Col2.Y(); M21 = Col2.Z();
-  M02 = Col3.X(); M12 = Col3.Y(); M22 = Col3.Z();
+  Mat00 = Col1.X(); Mat10 = Col1.Y(); Mat20 = Col1.Z();
+  Mat01 = Col2.X(); Mat11 = Col2.Y(); Mat21 = Col2.Z();
+  Mat02 = Col3.X(); Mat12 = Col3.Y(); Mat22 = Col3.Z();
 }
 
 void gp_Mat::SetCol (const Standard_Integer Col,
 		     const gp_XYZ& Value) {
 
   Standard_OutOfRange_Raise_if (Col < 1 || Col > 3, " ");
-  const Standard_Address M = (Standard_Address)&(matrix[0][0]);
   if      (Col == 1) {
-    M00 = Value.X(); M10 = Value.Y(); M20 = Value.Z();
+    Mat00 = Value.X(); Mat10 = Value.Y(); Mat20 = Value.Z();
   }
   else if (Col == 2) {
-    M01 = Value.X(); M11 = Value.Y(); M21 = Value.Z();
+    Mat01 = Value.X(); Mat11 = Value.Y(); Mat21 = Value.Z();
   }
   else {
-    M02 = Value.X(); M12 = Value.Y(); M22 = Value.Z();
+    Mat02 = Value.X(); Mat12 = Value.Y(); Mat22 = Value.Z();
   }
 }
 
@@ -66,34 +43,32 @@ void gp_Mat::SetCols (const gp_XYZ& Col1
 
 void gp_Mat::SetCross (const gp_XYZ& Ref)
 {
-  const Standard_Address M = (Standard_Address)&(matrix[0][0]);
   Standard_Real X = Ref.X();
   Standard_Real Y = Ref.Y();
   Standard_Real Z = Ref.Z();
-  M00 = M11 = M22 = 0.0;
-  M01 = - Z;  
-  M02 = Y;
-  M12 = - X;
-  M10 = Z;
-  M20 = - Y;
-  M21 = X;
+  Mat00 = Mat11 = Mat22 = 0.0;
+  Mat01 = - Z;  
+  Mat02 = Y;
+  Mat12 = - X;
+  Mat10 = Z;
+  Mat20 = - Y;
+  Mat21 = X;
 }
 
 void gp_Mat::SetDot (const gp_XYZ& Ref)
 {
-  const Standard_Address M = (Standard_Address)&(matrix[0][0]);
   Standard_Real X = Ref.X();
   Standard_Real Y = Ref.Y();
   Standard_Real Z = Ref.Z();
-  M00 = X * X;
-  M11 = Y * Y;
-  M22 = Z * Z;
-  M01 = X * Y;
-  M02 = X * Z;
-  M12 = Y * Z;
-  M10 = M01;
-  M20 = M02;
-  M21 = M12;
+  Mat00 = X * X;
+  Mat11 = Y * Y;
+  Mat22 = Z * Z;
+  Mat01 = X * Y;
+  Mat02 = X * Z;
+  Mat12 = Y * Z;
+  Mat10 = Mat01;
+  Mat20 = Mat02;
+  Mat21 = Mat12;
 }
 
 void gp_Mat::SetRotation (const gp_XYZ& Axis,
@@ -123,15 +98,14 @@ void gp_Mat::SetRow (const Standard_Inte
 		     const gp_XYZ& Value)
 {
   Standard_OutOfRange_Raise_if (Row < 1 || Row > 3, " ");
-  const Standard_Address M = (Standard_Address)&(matrix[0][0]);
   if      (Row == 1) {
-    M00 = Value.X(); M01 = Value.Y(); M02 = Value.Z();
+    Mat00 = Value.X(); Mat01 = Value.Y(); Mat02 = Value.Z();
   }
   else if (Row == 2) {
-    M10 = Value.X(); M11 = Value.Y(); M12 = Value.Z();
+    Mat10 = Value.X(); Mat11 = Value.Y(); Mat12 = Value.Z();
   }
   else {
-    M20 = Value.X(); M21 = Value.Y(); M22 = Value.Z();
+    Mat20 = Value.X(); Mat21 = Value.Y(); Mat22 = Value.Z();
   }
 }
 
@@ -139,90 +113,81 @@ void gp_Mat::SetRows (const gp_XYZ& Row1
 		      const gp_XYZ& Row2,
 		      const gp_XYZ& Row3)
 {
-  const Standard_Address M = (Standard_Address)&(matrix[0][0]);
-  M00 = Row1.X(); M01 = Row1.Y(); M02 = Row1.Z();
-  M10 = Row2.X(); M11 = Row2.Y(); M12 = Row2.Z();
-  M20 = Row3.X(); M21 = Row3.Y(); M22 = Row3.Z();
+  Mat00 = Row1.X(); Mat01 = Row1.Y(); Mat02 = Row1.Z();
+  Mat10 = Row2.X(); Mat11 = Row2.Y(); Mat12 = Row2.Z();
+  Mat20 = Row3.X(); Mat21 = Row3.Y(); Mat22 = Row3.Z();
 }
 
 gp_XYZ gp_Mat::Column (const Standard_Integer Col) const
 {
   Standard_OutOfRange_Raise_if (Col < 1 || Col > 3, "");
-  const Standard_Address M = (Standard_Address)&(matrix[0][0]);
-  if (Col == 1) return gp_XYZ (M00,M10,M20);
-  if (Col == 2) return gp_XYZ (M01,M11,M21);
-  return gp_XYZ (M02,M12,M22);
+  if (Col == 1) return gp_XYZ (Mat00,Mat10,Mat20);
+  if (Col == 2) return gp_XYZ (Mat01,Mat11,Mat21);
+  return gp_XYZ (Mat02,Mat12,Mat22);
 }
 
 gp_XYZ gp_Mat::Diagonal () const
 {
-  const Standard_Address M = (Standard_Address)&(matrix[0][0]);
-  return gp_XYZ (M00, M11, M22);
+  return gp_XYZ (Mat00, Mat11, Mat22);
 }
 
 gp_XYZ gp_Mat::Row (const Standard_Integer Row) const
 {
   Standard_OutOfRange_Raise_if (Row < 1 || Row > 3, "");
-  const Standard_Address M = (Standard_Address)&(matrix[0][0]);
-  if (Row == 1) return gp_XYZ (M00,M01,M02);
-  if (Row == 2) return gp_XYZ (M10,M11,M12);
-  return gp_XYZ (M20,M21,M22);
+  if (Row == 1) return gp_XYZ (Mat00,Mat01,Mat02);
+  if (Row == 2) return gp_XYZ (Mat10,Mat11,Mat12);
+  return gp_XYZ (Mat20,Mat21,Mat22);
 }
 
 void gp_Mat::Invert ()
 { 
-  Standard_Real new_array[3][3] ;
-  const Standard_Address M = (Standard_Address)&(   matrix[0][0]);
-  const Standard_Address N = (Standard_Address)&(new_array[0][0]);  
-
+  gp_Mat NewMat;    
   //
   // calcul de  la transposee de la commatrice
   //
-  N00 = M11 * M22 - M12 * M21 ;
-  N10 = -(M10 * M22 - M20 * M12) ;
-  N20 = M10 * M21 - M20 * M11 ;
-  N01 = - (M01 * M22 - M21 * M02) ;
-  N11 = M00 * M22 - M20 * M02 ;
-  N21 = -(M00 * M21 - M20 * M01) ;
-  N02 = M01 * M12 - M11 * M02 ;
-  N12 = -(M00 * M12 - M10 * M02) ;
-  N22 = M00 * M11 - M01 * M10 ;
-  Standard_Real det =  M00 * N00 + M01* N10 + M02 * N20 ;
+  Nat00 = Mat11 * Mat22 - Mat12 * Mat21 ;
+  Nat10 = -(Mat10 * Mat22 - Mat20 * Mat12) ;
+  Nat20 = Mat10 * Mat21 - Mat20 * Mat11 ;
+  Nat01 = - (Mat01 * Mat22 - Mat21 * Mat02) ;
+  Nat11 = Mat00 * Mat22 - Mat20 * Mat02 ;
+  Nat21 = -(Mat00 * Mat21 - Mat20 * Mat01) ;
+  Nat02 = Mat01 * Mat12 - Mat11 * Mat02 ;
+  Nat12 = -(Mat00 * Mat12 - Mat10 * Mat02) ;
+  Nat22 = Mat00 * Mat11 - Mat01 * Mat10 ;
+  Standard_Real det =  Mat00 * Nat00 + Mat01* Nat10 + Mat02 * Nat20 ;
   Standard_Real val = det;
   if (val < 0) val = - val;
   Standard_ConstructionError_Raise_if
     (val <= gp::Resolution(),"");
   det = 1.0e0 / det ;
-  M00 = N00;
-  M10 = N10;
-  M20 = N20;
-  M01 = N01;
-  M11 = N11;
-  M21 = N21;
-  M02 = N02;
-  M12 = N12;
-  M22 = N22;
+  Mat00 = Nat00;
+  Mat10 = Nat10;
+  Mat20 = Nat20;
+  Mat01 = Nat01;
+  Mat11 = Nat11;
+  Mat21 = Nat21;
+  Mat02 = Nat02;
+  Mat12 = Nat12;
+  Mat22 = Nat22;
   Multiply(det) ;
 }
 
 gp_Mat gp_Mat::Inverted () const
 { 
   gp_Mat NewMat;
-  const Standard_Address M = (Standard_Address)&(       matrix[0][0]);
-  const Standard_Address N = (Standard_Address)&(NewMat.matrix[0][0]);
   //
   // calcul de  la transposee de la commatrice
   //
-  N00 = M11 * M22 - M12 * M21 ;
-  N10 = -(M10 * M22 - M20 * M12) ;
-  N20 = M10 * M21 - M20 * M11 ;
-  N01 = - (M01 * M22 - M21 * M02) ;
-  N11 = M00 * M22 - M20 * M02 ;
-  N21 = -(M00 * M21 - M20 * M01) ;
-  N02 = M01 * M12 - M11 * M02 ;
-  N12 = -(M00 * M12 - M10 * M02) ;
-  N22 = M00 * M11 - M01 * M10 ;
-  Standard_Real det =  M00 * N00 + M01* N10 + M02 * N20 ;
+  Nat00 = Mat11 * Mat22 - Mat12 * Mat21 ;
+  Nat10 = -(Mat10 * Mat22 - Mat20 * Mat12) ;
+  Nat20 = Mat10 * Mat21 - Mat20 * Mat11 ;
+  Nat01 = - (Mat01 * Mat22 - Mat21 * Mat02) ;
+  Nat11 = Mat00 * Mat22 - Mat20 * Mat02 ;
+  Nat21 = -(Mat00 * Mat21 - Mat20 * Mat01) ;
+  Nat02 = Mat01 * Mat12 - Mat11 * Mat02 ;
+  Nat12 = -(Mat00 * Mat12 - Mat10 * Mat02) ;
+  Nat22 = Mat00 * Mat11 - Mat01 * Mat10 ;
+  Standard_Real det =  Mat00 * Nat00 + Mat01* Nat10 + Mat02 * Nat20 ;
   Standard_Real val = det;
   if (val < 0) val = - val;
   Standard_ConstructionError_Raise_if
Index: oce/src/gp/gp_Mat2d.cxx
===================================================================
--- oce.orig/src/gp/gp_Mat2d.cxx
+++ oce/src/gp/gp_Mat2d.cxx
@@ -9,108 +9,88 @@
 #include <gp_Mat2d.ixx>
 #include <Standard_ConstructionError.hxx>
 
-#define M00 ((Standard_Real*)M)[0]
-#define M01 ((Standard_Real*)M)[1]
-#define M10 ((Standard_Real*)M)[2]
-#define M11 ((Standard_Real*)M)[3]
-
-#define N00 ((Standard_Real*)N)[0]
-#define N01 ((Standard_Real*)N)[1]
-#define N10 ((Standard_Real*)N)[2]
-#define N11 ((Standard_Real*)N)[3]
-
 gp_Mat2d::gp_Mat2d (const gp_XY& Col1, const gp_XY& Col2)
 {
-  const Standard_Address M = (Standard_Address)&(matrix[0][0]);
-  M00 = Col1.X(); M10 = Col1.Y();
-  M01 = Col2.X(); M11 = Col2.Y();
+  Mat2d00 = Col1.X(); Mat2d10 = Col1.Y();
+  Mat2d01 = Col2.X(); Mat2d11 = Col2.Y();
 }
 
 void gp_Mat2d::SetCol (const Standard_Integer Col,
 		       const gp_XY& Value)
 {
   Standard_OutOfRange_Raise_if (Col < 1 || Col > 2,"");
-  const Standard_Address M = (Standard_Address)&(matrix[0][0]);
   if  (Col == 1) {
-    M00 = Value.X();
-    M10 = Value.Y();
+    Mat2d00 = Value.X();
+    Mat2d10 = Value.Y();
   }
   else {
-    M01 = Value.X();
-    M11 = Value.Y();
+    Mat2d01 = Value.X();
+    Mat2d11 = Value.Y();
   }
 }
 
 void gp_Mat2d::SetCols (const gp_XY& Col1,
 			const gp_XY& Col2)
 {
-  const Standard_Address M = (Standard_Address)&(matrix[0][0]);
-  M00 = Col1.X(); M10 = Col1.Y();
-  M01 = Col2.X(); M11 = Col2.Y();
+  Mat2d00 = Col1.X(); Mat2d10 = Col1.Y();
+  Mat2d01 = Col2.X(); Mat2d11 = Col2.Y();
 }
 
 void gp_Mat2d::SetRow (const Standard_Integer Row, const gp_XY& Value)
 {
   Standard_OutOfRange_Raise_if (Row < 1 || Row > 2,"");
-  const Standard_Address M = (Standard_Address)&(matrix[0][0]);
   if (Row == 1) {
-    M00 = Value.X();
-    M01 = Value.Y();
+    Mat2d00 = Value.X();
+    Mat2d01 = Value.Y();
   }
   else {
-    M10 = Value.X();
-    M11 = Value.Y();
+    Mat2d10 = Value.X();
+    Mat2d11 = Value.Y();
   }
 }
 
 void gp_Mat2d::SetRows (const gp_XY& Row1, const gp_XY& Row2)
 {
-  const Standard_Address M = (Standard_Address)&(matrix[0][0]);
-  M00 = Row1.X(); M01 = Row1.Y();
-  M10 = Row2.X(); M11 = Row2.Y();
+  Mat2d00 = Row1.X(); Mat2d01 = Row1.Y();
+  Mat2d10 = Row2.X(); Mat2d11 = Row2.Y();
 }
 
 gp_XY gp_Mat2d::Column (const Standard_Integer Col) const
 {
   Standard_OutOfRange_Raise_if (Col < 1 || Col > 2,"");
-  const Standard_Address M = (Standard_Address)&(matrix[0][0]);
-  if (Col == 1) return gp_XY (M00,M10);
-  return gp_XY (M01,M11);
+  if (Col == 1) return gp_XY (Mat2d00,Mat2d10);
+  return gp_XY (Mat2d01,Mat2d11);
 }
 
 gp_XY gp_Mat2d::Diagonal () const
 { 
-  const Standard_Address M = (Standard_Address)&(matrix[0][0]);
-  return gp_XY (M00,M11);
+  return gp_XY (Mat2d00,Mat2d11);
 }
 
 gp_XY gp_Mat2d::Row (const Standard_Integer Row) const
 {
   Standard_OutOfRange_Raise_if (Row < 1 || Row > 2,"");
-  const Standard_Address M = (Standard_Address)&(matrix[0][0]);
-  if (Row == 1) return gp_XY (M00,M01);
-  return gp_XY (M10,M11);
+  if (Row == 1) return gp_XY (Mat2d00,Mat2d01);
+  return gp_XY (Mat2d10,Mat2d11);
 }
 
 void gp_Mat2d::Invert ()
 {
-  Standard_Real new_matrix[2][2],
-  det ;
-  const Standard_Address N = (Standard_Address)&(new_matrix[0][0]);
-  const Standard_Address M = (Standard_Address)&(    matrix[0][0]);
-  N00 = M11 ;
-  N01 = -M01 ;
-  N10 = -M10 ;
-  N11 = M00  ;
-  det = N00 * N11 - N01 * N10 ;
+  Standard_Real det ;
+  gp_Mat2d NewMat;
+  Nat00 = Mat2d11 ;
+  Nat01 = -Mat2d01 ;
+  Nat10 = -Mat2d10 ;
+  Nat11 = Mat2d00  ;
+  det = Nat00 * Nat11 - Nat01 * Nat10 ;
   Standard_Real val = det;
   if (val < 0) val = - val;
   Standard_ConstructionError_Raise_if (val <= gp::Resolution(),"");
   det = 1.0 / det ;
-  M00 = N00 * det ;
-  M10 = N10 * det ;
-  M01 = N01 * det ;
-  M11 = N11 * det ;
+  Mat2d00 = Nat00 * det ;
+  Mat2d10 = Nat10 * det ;
+  Mat2d01 = Nat01 * det ;
+  Mat2d11 = Nat11 * det ;
 }
 
 void gp_Mat2d::Power (const Standard_Integer N)
