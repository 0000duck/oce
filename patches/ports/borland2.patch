From c1d5d0cfc3edbc8a2772fd81938db2951de43bec Mon Sep 17 00:00:00 2001
From: Fotios Sioutis <sfotis@gmail.com>
Date: Tue, 22 Mar 2011 06:59:13 +0100
Subject: [PATCH 2/9] Templates related fixes needed by BCC

* BCC does not seem to support templates friends
* When a template is instantiated then any reference
  of this template within the template body must be
  followed by its specialization with bcc, otherwise
  there are errors similar to:
    [C++ Error] NCollection_CellFilter.hxx(319):
    E2404 Dependent type qualifier 'MeshAlgo_CellFilter'
    has no member type named 'Cell'
---
 ros/inc/MeshAlgo_CellFilter.hxx        |    8 ++++++++
 ros/inc/NCollection_CellFilter.hxx     |   10 ++++++++++
 ros/inc/NCollection_IndexedDataMap.hxx |    4 ++++
 ros/inc/NCollection_IndexedMap.hxx     |    4 ++++
 4 files changed, 26 insertions(+), 0 deletions(-)

From 430e79b442c6ef08038c90300ab51d83e7f5a07e Mon Sep 17 00:00:00 2001
From: Fotios Sioutis <sfotis@gmail.com>
Date: Fri, 18 Nov 2011 12:04:57 +0200
Subject: [PATCH] Template class issue for bcc32

When a template parameter of type class is used,
implicit call to its destructor requires usage of
the class name and not of its typedef.
---
 inc/NCollection_Vector.hxx |    8 ++++++++
 1 files changed, 8 insertions(+), 0 deletions(-)

Index: oce/src/NCollection/NCollection_CellFilter.hxx
===================================================================
--- oce.orig/src/NCollection/NCollection_CellFilter.hxx
+++ oce/src/NCollection/NCollection_CellFilter.hxx
@@ -324,10 +324,20 @@ protected:
   };
 
   // definition of global functions is needed for map
+#ifdef __BORLANDC__
+  //It seems that Borland compiler does not support template friends ...
+  //If one wants to use the below global functions must instantiate them outside the
+  //class body.See MeshAlgo_CellFilter.hxx file
+  template <class CellContainer>
+  friend Standard_Integer HashCode (const CellContainer::Cell &aCell, const Standard_Integer theUpper);
+  template <class CellContainer>
+  friend Standard_Boolean IsEqual (const CellContainer::Cell &aCell1, const CellContainer::Cell &aCell2);
+#else
   friend Standard_Integer HashCode (const Cell &aCell, const Standard_Integer theUpper)
   { return aCell.HashCode(theUpper); }
   friend Standard_Boolean IsEqual (const Cell &aCell1, const Cell &aCell2)
   { return aCell1.IsEqual(aCell2); }
+#endif
 
 protected:
 
Index: oce/src/NCollection/NCollection_IndexedDataMap.hxx
===================================================================
--- oce.orig/src/NCollection/NCollection_IndexedDataMap.hxx
+++ oce/src/NCollection/NCollection_IndexedDataMap.hxx
@@ -110,7 +110,11 @@ template < class TheKeyType,
       myIndex(0) {}
     //! Constructor
     Iterator (const NCollection_IndexedDataMap& theMap) :
+#ifdef __BORLANDC__
+      myMap((NCollection_IndexedDataMap <TheKeyType, TheItemType, Hasher> *) &theMap),
+#else
       myMap((NCollection_IndexedDataMap *) &theMap),
+#endif
       myIndex(1) {}
     //! Query if the end of collection is reached by iterator
     virtual Standard_Boolean More(void) const
Index: oce/src/NCollection/NCollection_IndexedMap.hxx
===================================================================
--- oce.orig/src/NCollection/NCollection_IndexedMap.hxx
+++ oce/src/NCollection/NCollection_IndexedMap.hxx
@@ -100,7 +100,11 @@ template < class TheKeyType,
       myIndex(0) {}
     //! Constructor
     Iterator (const NCollection_IndexedMap& theMap) :
+#ifdef __BORLANDC__
+      myMap((NCollection_IndexedMap <TheKeyType, Hasher> *) &theMap),
+#else
       myMap((NCollection_IndexedMap *) &theMap),
+#endif
       myIndex(1) {}
     //! Query if the end of collection is reached by iterator
     virtual Standard_Boolean More(void) const
Index: oce/src/NCollection/NCollection_Vector.hxx
===================================================================
--- oce.orig/src/NCollection/NCollection_Vector.hxx
+++ oce/src/NCollection/NCollection_Vector.hxx
@@ -301,7 +301,11 @@ private: //! @name private methods
     {
       for (Standard_Integer anItemIter = 0; anItemIter < theBlock.Size; ++anItemIter)
       {
+#ifdef __BORLANDC__
+        ((TheItemType* )theBlock.DataPtr)[anItemIter].~TheItemType();
+#else
         ((TheItemType* )theBlock.DataPtr)[anItemIter].~TheItemTypeD();
+#endif
       }
       anAllocator->Free (theBlock.DataPtr);
       theBlock.DataPtr = NULL;
