Index: oce/src/AdvApp2Var/AdvApp2Var_SysBase.hxx
===================================================================
--- oce.orig/src/AdvApp2Var/AdvApp2Var_SysBase.hxx
+++ oce/src/AdvApp2Var/AdvApp2Var_SysBase.hxx
@@ -110,8 +110,14 @@ private:
      multi-threaded execution). Previous number of 1000 was excessive but
      tolerable when used for static memory.
   */
+#ifdef __BORLANDC__
+public:
+#endif
   static const int MAX_ALLOC_NB = 32;
-  
+#ifdef __BORLANDC__
+private:
+#endif
+
   enum {
     static_allocation = 0, /* indicates static allocation, currently not used */
     heap_allocation   = 1  /* indicates heap allocation */
Index: oce/src/BOPCol/BOPCol_Array1.hxx
===================================================================
--- oce.orig/src/BOPCol/BOPCol_Array1.hxx
+++ oce/src/BOPCol/BOPCol_Array1.hxx
@@ -177,7 +177,11 @@ template <class Type> class BOPCol_Array
     while(pBlock) {
       pNext=pBlock->Next();
       //
+#if defined(__BORLANDC__)
+      pBlock->~BOPCol_MemBlock<Type>();
+#else
       pBlock->~BOPCol_XMemBlock();
+#endif
       myAllocator->Free(pBlock);
       //
       pBlock=pNext;
Index: oce/src/DsgPrs/DsgPrs_LengthPresentation.cxx
===================================================================
--- oce.orig/src/DsgPrs/DsgPrs_LengthPresentation.cxx
+++ oce/src/DsgPrs/DsgPrs_LengthPresentation.cxx
@@ -55,7 +55,7 @@ void DsgPrs_LengthPresentation::Add (con
   gp_Lin L2 (AttachmentPoint2,aDirection);
   gp_Pnt Proj1 = ElCLib::Value(ElCLib::Parameter(L1,OffsetPoint),L1);
   gp_Pnt Proj2 = ElCLib::Value(ElCLib::Parameter(L2,OffsetPoint),L2);
-  gp_Lin L3 = Proj1.IsEqual(Proj2,Precision::Confusion())? gp_Lin(Proj1,aDirection) : gce_MakeLin(Proj1,Proj2);
+  gp_Lin L3 = Proj1.IsEqual(Proj2,Precision::Confusion())? gp_Lin(Proj1,aDirection) : (gp_Lin) gce_MakeLin(Proj1,Proj2);
   Standard_Real parmin,parmax,parcur;
   parmin = ElCLib::Parameter(L3,Proj1);
   parmax = parmin;
@@ -211,7 +211,7 @@ void DsgPrs_LengthPresentation::Add (con
   gp_Lin L2 (AttachmentPoint2,aDirection);
   gp_Pnt Proj1 = ElCLib::Value(ElCLib::Parameter(L1,OffsetPoint),L1);
   gp_Pnt Proj2 = ElCLib::Value(ElCLib::Parameter(L2,OffsetPoint),L2);
-  gp_Lin L3 = Proj1.IsEqual(Proj2,Precision::Confusion())? gp_Lin(Proj1,aDirection) : gce_MakeLin(Proj1,Proj2);
+  gp_Lin L3 = Proj1.IsEqual(Proj2,Precision::Confusion())? gp_Lin(Proj1,aDirection) : (gp_Lin) gce_MakeLin(Proj1,Proj2);
   Standard_Real parmin,parmax,parcur;
   parmin = ElCLib::Parameter(L3,Proj1);
   parmax = parmin;
Index: oce/src/Font/FILES
===================================================================
--- oce.orig/src/Font/FILES
+++ oce/src/Font/FILES
@@ -1,4 +1,5 @@
 EXTERNLIB
+Font_CMPLRS.edl
 Font_BRepFont.hxx
 Font_BRepFont.cxx
 Font_FTFont.hxx
Index: oce/src/Font/Font_CMPLRS.edl
===================================================================
--- /dev/null
+++ oce/src/Font/Font_CMPLRS.edl
@@ -0,0 +1,19 @@
+-- Created by: Fotios Sioutis
+--
+-- This library is free software; you can redistribute it and / or modify it
+-- under the terms of the GNU Lesser General Public version 2.1 as published
+-- by the Free Software Foundation, with special exception defined in the file
+-- OCCT_LGPL_EXCEPTION.txt. Consult the file LICENSE_LGPL_21.txt included in OCCT
+-- distribution for complete text of the license and disclaimer of any warranty.
+
+
+@ifnotdefined ( %Font_CMPLRS_EDL) then
+
+  @set %Font_CMPLRS_EDL = "";
+
+  @uses "CSF.edl";
+
+  @string %CMPLRS_CXX_Options += %CSF_FREETYPE_INCLUDES " ";
+  @string %CMPLRS_C_Options   += %CSF_FREETYPE_INCLUDES " ";
+
+@endif;
Index: oce/src/Image/Image_Color.hxx
===================================================================
--- oce.orig/src/Image/Image_Color.hxx
+++ oce/src/Image/Image_Color.hxx
@@ -430,9 +430,15 @@ public:
 template<typename ColorType_t>
 inline ColorType_t Image_ColorSumm3 (const ColorType_t& theA, const ColorType_t& theB)
 {
+#ifdef __BORLANDC__
+  ColorType_t aRes = {{ColorType_t::ComponentType_t (theA.v[0] + theB.v[0]),
+                       ColorType_t::ComponentType_t (theA.v[1] + theB.v[1]),
+                       ColorType_t::ComponentType_t (theA.v[2] + theB.v[2])}};
+#else
   ColorType_t aRes = {{typename ColorType_t::ComponentType_t (theA.v[0] + theB.v[0]),
                        typename ColorType_t::ComponentType_t (theA.v[1] + theB.v[1]),
                        typename ColorType_t::ComponentType_t (theA.v[2] + theB.v[2])}};
+#endif
   return aRes;
 }
 
@@ -459,10 +465,17 @@ inline Image_ColorBGRF operator+ (const
 template<typename ColorType_t>
 inline ColorType_t Image_ColorSumm4 (const ColorType_t& theA, const ColorType_t& theB)
 {
+#ifdef __BORLANDC__
+  ColorType_t aRes = {{ColorType_t::ComponentType_t (theA.v[0] + theB.v[0]),
+                       ColorType_t::ComponentType_t (theA.v[1] + theB.v[1]),
+                       ColorType_t::ComponentType_t (theA.v[2] + theB.v[2]),
+                       ColorType_t::ComponentType_t (theA.v[3] + theB.v[3])}};
+#else
   ColorType_t aRes = {{typename ColorType_t::ComponentType_t (theA.v[0] + theB.v[0]),
                        typename ColorType_t::ComponentType_t (theA.v[1] + theB.v[1]),
                        typename ColorType_t::ComponentType_t (theA.v[2] + theB.v[2]),
                        typename ColorType_t::ComponentType_t (theA.v[3] + theB.v[3])}};
+#endif
   return aRes;
 }
 
@@ -500,9 +513,15 @@ inline Image_ColorBGRAF operator+ (const
 template<typename ColorType_t>
 inline ColorType_t Image_ColorSub3 (const ColorType_t& theA, const ColorType_t& theB)
 {
+#ifdef __BORLANDC__
+  ColorType_t aRes = {{ColorType_t::ComponentType_t (theA.v[0] - theB.v[0]),
+                       ColorType_t::ComponentType_t (theA.v[1] - theB.v[1]),
+                       ColorType_t::ComponentType_t (theA.v[2] - theB.v[2])}};
+#else
   ColorType_t aRes = {{typename ColorType_t::ComponentType_t (theA.v[0] - theB.v[0]),
                        typename ColorType_t::ComponentType_t (theA.v[1] - theB.v[1]),
                        typename ColorType_t::ComponentType_t (theA.v[2] - theB.v[2])}};
+#endif
   return aRes;
 }
 
@@ -529,10 +548,17 @@ inline Image_ColorBGRF operator- (const
 template<typename ColorType_t>
 inline ColorType_t Image_ColorSub4 (const ColorType_t& theA, const ColorType_t& theB)
 {
+#ifdef __BORLANDC__
+  ColorType_t aRes = {{ColorType_t::ComponentType_t (theA.v[0] - theB.v[0]),
+                       ColorType_t::ComponentType_t (theA.v[1] - theB.v[1]),
+                       ColorType_t::ComponentType_t (theA.v[2] - theB.v[2]),
+                       ColorType_t::ComponentType_t (theA.v[3] - theB.v[3])}};
+#else
   ColorType_t aRes = {{typename ColorType_t::ComponentType_t (theA.v[0] - theB.v[0]),
                        typename ColorType_t::ComponentType_t (theA.v[1] - theB.v[1]),
                        typename ColorType_t::ComponentType_t (theA.v[2] - theB.v[2]),
                        typename ColorType_t::ComponentType_t (theA.v[3] - theB.v[3])}};
+#endif
   return aRes;
 }
 
Index: oce/src/NCollection/NCollection_StdAllocator.hxx
===================================================================
--- oce.orig/src/NCollection/NCollection_StdAllocator.hxx
+++ oce/src/NCollection/NCollection_StdAllocator.hxx
@@ -102,8 +102,12 @@ public:
 
   //! Destroys the object.
   /*! Uses object destructor.*/
+#if defined(__BORLANDC__)
+  void destroy( pointer p ) { p->~T(); }
+#else
   void destroy( pointer p ) { p->~value_type(); }
-
+#endif
+  
   //! Returns an underlying NCollection_BaseAllocator instance.
   /*! Returns an object specified in the constructor.*/
   const Handle(NCollection_BaseAllocator)& Allocator() const { return myAlloc; }
Index: oce/src/NCollection/NCollection_UtfString.lxx
===================================================================
--- oce.orig/src/NCollection/NCollection_UtfString.lxx
+++ oce/src/NCollection/NCollection_UtfString.lxx
@@ -17,8 +17,8 @@
 // function : strGetAdvance
 // purpose  : Compute advance for specified string.
 // =======================================================================
-template<typename TypeTo> template<typename TypeFrom> inline
-void NCollection_UtfString<TypeTo>::strGetAdvance (const TypeFrom*        theStringUtf,
+template<typename Type> template<typename TypeFrom> inline
+void NCollection_UtfString<Type>::strGetAdvance (const TypeFrom*        theStringUtf,
                                                    const Standard_Integer theLengthMax,
                                                    Standard_Integer&      theSizeBytes,
                                                    Standard_Integer&      theLength)
@@ -27,7 +27,7 @@ void NCollection_UtfString<TypeTo>::strG
   theLength    = 0;
   NCollection_UtfIterator<TypeFrom> anIter (theStringUtf);
   const Standard_Integer aLengthMax = (theLengthMax > 0) ? theLengthMax : IntegerLast();
-  switch (sizeof(TypeTo))
+  switch (sizeof(Type))
   {
     case sizeof(Standard_Utf8Char):
     {
Index: oce/src/OSD/OSD_File.cxx
===================================================================
--- oce.orig/src/OSD/OSD_File.cxx
+++ oce/src/OSD/OSD_File.cxx
@@ -855,7 +855,7 @@ Standard_Boolean OSD_File::IsExecutable(
 #define _int64 int64_t
 #endif
 
-#ifdef _MSC_VER
+#if defined(_MSC_VER) || defined(__BORLANDC__)
 #pragma comment( lib, "WSOCK32.LIB"  )
 #pragma comment( lib, "WINSPOOL.LIB" )
 #endif
Index: oce/src/OSD/OSD_Host.cxx
===================================================================
--- oce.orig/src/OSD/OSD_Host.cxx
+++ oce/src/OSD/OSD_Host.cxx
@@ -228,7 +228,7 @@ Standard_Integer OSD_Host::Error()const{
 
 #include <OSD_Host.hxx>
 
-#ifdef _MSC_VER
+#if defined(_MSC_VER) || defined(__BORLANDC__)
 #pragma comment( lib, "WSOCK32.LIB" )
 #endif
 
Index: oce/src/OpenGl/OpenGl_ShaderObject.cxx
===================================================================
--- oce.orig/src/OpenGl/OpenGl_ShaderObject.cxx
+++ oce/src/OpenGl/OpenGl_ShaderObject.cxx
@@ -20,6 +20,10 @@
 #include <Standard_Assert.hxx>
 #include <TCollection_AsciiString.hxx>
 
+#ifdef __BORLANDC__
+#include <malloc.h>
+#endif
+
 IMPLEMENT_STANDARD_HANDLE (OpenGl_ShaderObject, OpenGl_Resource)
 IMPLEMENT_STANDARD_RTTIEXT(OpenGl_ShaderObject, OpenGl_Resource)
 
Index: oce/src/OpenGl/OpenGl_ShaderProgram.cxx
===================================================================
--- oce.orig/src/OpenGl/OpenGl_ShaderProgram.cxx
+++ oce/src/OpenGl/OpenGl_ShaderProgram.cxx
@@ -24,6 +24,10 @@
 #include <OpenGl_ShaderProgram.hxx>
 #include <OpenGl_ShaderManager.hxx>
 
+#ifdef __BORLANDC__
+#include <malloc.h>
+#endif
+
 IMPLEMENT_STANDARD_HANDLE (OpenGl_ShaderProgram, OpenGl_Resource)
 IMPLEMENT_STANDARD_RTTIEXT(OpenGl_ShaderProgram, OpenGl_Resource)
 
Index: oce/src/Standard/Standard_CLocaleSentry.cxx
===================================================================
--- oce.orig/src/Standard/Standard_CLocaleSentry.cxx
+++ oce/src/Standard/Standard_CLocaleSentry.cxx
@@ -23,6 +23,10 @@
 
 #include <cstring>
 
+#if defined(__BORLANDC__)
+#include <mem.h>
+#endif
+
 namespace
 {
 
@@ -34,7 +38,7 @@ namespace
     CLocalePtr()
     #ifdef HAVE_XLOCALE_H
     : myLocale (newlocale (LC_ALL_MASK, "C", NULL))
-    #elif defined(_WIN32)
+    #elif defined(_WIN32) && !defined(__BORLANDC__)
     : myLocale (_create_locale (LC_ALL, "C"))
     #else
     : myLocale (NULL)
@@ -45,7 +49,7 @@ namespace
     {
     #ifdef HAVE_XLOCALE_H
       freelocale (myLocale);
-    #elif defined(_WIN32)
+    #elif defined(_WIN32) && !defined(__BORLANDC__)
       _free_locale (myLocale);
     #endif
     }
Index: oce/src/Standard/Standard_CLocaleSentry.hxx
===================================================================
--- oce.orig/src/Standard/Standard_CLocaleSentry.hxx
+++ oce/src/Standard/Standard_CLocaleSentry.hxx
@@ -56,7 +56,7 @@ public:
 
 #ifdef HAVE_XLOCALE_H
   typedef  locale_t clocale_t;
-#elif defined(_WIN32)
+#elif defined(_WIN32) && !defined(__BORLANDC__)
   typedef _locale_t clocale_t;
 #else
   typedef void*     clocale_t;
@@ -69,7 +69,7 @@ public:
 private:
 
   void* myPrevLocale;       //!< previous locale, platform-dependent pointer!
-#ifdef _WIN32
+#if defined(_WIN32) && !defined(__BORLANDC__)
   int   myPrevTLocaleState; //!< previous thread-locale state, MSVCRT-specific
 #endif
 
Index: oce/src/Standard/Standard_CString.cxx
===================================================================
--- oce.orig/src/Standard/Standard_CString.cxx
+++ oce/src/Standard/Standard_CString.cxx
@@ -80,7 +80,7 @@ Standard_Integer HashCodes (const Standa
 #ifdef __APPLE__
   // There are a lot of *_l functions availalbe on Mac OS X - we use them
   #define SAVE_TL()
-#elif defined(_WIN32)
+#elif defined(_WIN32) && !defined(__BORLANDC__)
   // MSVCRT has equivalents with slightly different syntax
   #define SAVE_TL()
   #define strtod_l(thePtr, theNextPtr, theLocale)                _strtod_l(thePtr, theNextPtr, theLocale)
@@ -94,7 +94,7 @@ Standard_Integer HashCodes (const Standa
     // strtod, strtol, strtoll functions. For other system with locale-depended
     // implementations problems may appear if "C" locale is not set explicitly.
     #ifndef __ANDROID__
-      #error System does not support xlocale. Import/export could be broken if C locale did not specified by application.
+      #warning System does not support xlocale. Import/export could be broken if C locale did not specified by application.
     #endif
     #define strtod_l(thePtr, theNextPtr, theLocale)              strtod(thePtr, theNextPtr)
   #endif
Index: oce/src/Standard/Standard_Integer.hxx
===================================================================
--- oce.orig/src/Standard/Standard_Integer.hxx
+++ oce/src/Standard/Standard_Integer.hxx
@@ -25,6 +25,10 @@
 
 #include <oce-config.h>
 
+#ifdef __BORLANDC__
+#define OCE_IS_DUPLICATE_UINT32_T
+#endif
+
 // ===============
 // Inline methods
 // ===============
Index: oce/src/Standard/Standard_TypeDef.hxx
===================================================================
--- oce.orig/src/Standard/Standard_TypeDef.hxx
+++ oce/src/Standard/Standard_TypeDef.hxx
@@ -49,6 +49,10 @@
   #include <inttypes.h>
 #endif
 
+#if defined(__BORLANDC__)
+using std::size_t;
+#endif
+
 #define Standard_False false
 #define Standard_True  true
 
Index: oce/src/Standard/Standard_math.cxx
===================================================================
--- oce.orig/src/Standard/Standard_math.cxx
+++ oce/src/Standard/Standard_math.cxx
@@ -15,7 +15,7 @@
 #include <Standard_math.hxx>
 
 // MSVC versions prior to 12 did not provided acosh, asinh, atanh functions in standard library
-#if defined(_MSC_VER) && (_MSC_VER < 1800)
+#if (defined(_MSC_VER) && (_MSC_VER < 1800)) || defined(__BORLANDC__)
 
 Standard_EXPORT double  __cdecl acosh( double X)
 {
Index: oce/src/Standard/Standard_math.hxx
===================================================================
--- oce.orig/src/Standard/Standard_math.hxx
+++ oce/src/Standard/Standard_math.hxx
@@ -16,7 +16,7 @@
 #include <Standard_Macro.hxx>
 #endif
 
-#ifdef _MSC_VER
+#if defined(_MSC_VER) || defined(__BORLANDC__)
 
 #ifndef _USE_MATH_DEFINES
 #define _USE_MATH_DEFINES
@@ -26,7 +26,7 @@
 #include <math.h>
 
 // MSVC versions prior to 12 did not provided acosh, asinh, atanh functions in standard library
-#if _MSC_VER < 1800
+#if (defined(_MSC_VER) && (_MSC_VER < 1800)) || defined(__BORLANDC__)
 __Standard_API double __cdecl acosh ( double );
 __Standard_API double __cdecl asinh ( double );
 __Standard_API double __cdecl atanh ( double );
